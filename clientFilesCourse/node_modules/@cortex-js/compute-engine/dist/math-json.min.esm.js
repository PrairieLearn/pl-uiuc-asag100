/** Compute Engine 0.27.0 */

// src/math-json/utils.ts
function isSymbolObject(expr) {
  return expr !== null && typeof expr === "object" && "sym" in expr;
}
function isStringObject(expr) {
  return expr !== null && typeof expr === "object" && "str" in expr;
}
function isFunctionObject(expr) {
  return expr !== null && typeof expr === "object" && "fn" in expr;
}
function stringValue(expr) {
  if (expr === null || expr === void 0) return null;
  if (typeof expr === "object" && "str" in expr) return expr.str;
  if (typeof expr !== "string") return null;
  if (expr.length < 2) return null;
  if (expr.at(0) !== "'" || expr.at(-1) !== "'") return null;
  return expr.substring(1, expr.length - 1);
}
function operator(expr) {
  if (Array.isArray(expr)) return expr[0];
  if (expr === null || expr === void 0) return "";
  if (isFunctionObject(expr)) return expr.fn[0];
  return "";
}
function operands(expr) {
  if (Array.isArray(expr)) return expr.slice(1);
  if (expr !== void 0 && isFunctionObject(expr)) return expr.fn.slice(1);
  return [];
}
function operand(expr, n) {
  if (Array.isArray(expr)) return expr[n] ?? null;
  if (expr === null || !isFunctionObject(expr)) return null;
  return expr.fn[n] ?? null;
}
function nops(expr) {
  if (expr === null || expr === void 0) return 0;
  if (Array.isArray(expr)) return Math.max(0, expr.length - 1);
  if (isFunctionObject(expr)) return Math.max(0, expr.fn.length - 1);
  return 0;
}
function symbol(expr) {
  if (typeof expr === "string") {
    if (/^[+-]?[0-9\.]/.test(expr)) return null;
    if (expr.length >= 2 && expr[0] === "'" && expr[expr.length - 1] === "'")
      return null;
    return expr;
  }
  if (expr === null || expr === void 0) return null;
  const s = isSymbolObject(expr) ? expr.sym : expr;
  if (typeof s !== "string") return null;
  return s;
}
function keyValuePair(expr) {
  const h = operator(expr);
  if (h === "KeyValuePair" || h === "Tuple" || h === "Pair") {
    const [k, v] = operands(expr);
    const key = stringValue(k);
    if (!key) return null;
    return [key, v ?? "Nothing"];
  }
  return null;
}
function dictionary(expr) {
  if (expr === null) return null;
  const kv = keyValuePair(expr);
  if (kv) return { [kv[0]]: kv[1] };
  const h = operator(expr);
  if (h === "Dictionary") {
    const result = {};
    const ops = operands(expr);
    for (let i = 1; i < nops(expr); i++) {
      const kv2 = keyValuePair(ops[i]);
      if (kv2) result[kv2[0]] = kv2[1];
    }
    return result;
  }
  return null;
}
function mapArgs(expr, fn) {
  let args = null;
  if (Array.isArray(expr)) args = expr;
  if (isFunctionObject(expr)) args = expr.fn;
  if (args === null) return [];
  let i = 1;
  const result = [];
  while (i < args.length) {
    result.push(fn(args[i]));
    i += 1;
  }
  return result;
}

// src/math-json.ts
var version = "0.27.0";
export {
  dictionary as getDictionary,
  stringValue as getStringValue,
  isFunctionObject,
  isStringObject,
  isSymbolObject,
  mapArgs,
  operand,
  operator,
  symbol,
  version
};
