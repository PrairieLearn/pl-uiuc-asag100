/* 0.30.2 */import { Decimal } from 'decimal.js';
import type { Expression, MathJsonSymbol } from '../../math-json/types';
import type { Type, TypeString } from '../../common/type/types';
import { BoxedType } from '../../common/type/boxed-type';
import type { BoxedSubstitution, Metadata, Substitution, CanonicalOptions, BoxedRuleSet, Rule, BoxedBaseDefinition, BoxedValueDefinition, BoxedOperatorDefinition, EvaluateOptions, Sign, BoxedExpression, JsonSerializationOptions, PatternMatchOptions, SimplifyOptions, ComputeEngine, Scope, Tensor } from '../global-types';
import type { NumericValue } from '../numeric-value/types';
import type { SmallInteger } from '../numerics/types';
import type { LatexString, SerializeLatexOptions } from '../latex-syntax/types';
/**
 * _BoxedExpression
 *
 * @internal
 */
export declare abstract class _BoxedExpression implements BoxedExpression {
    abstract readonly hash: number;
    abstract readonly json: Expression;
    abstract isCanonical: boolean;
    abstract match(pattern: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
    readonly engine: ComputeEngine;
    /** Verbatim LaTeX, obtained from a source, i.e. from parsing,
     *  not generated synthetically
     */
    readonly verbatimLatex?: string;
    constructor(ce: ComputeEngine, metadata?: Metadata);
    /**
     *
     * `Object.valueOf()`: return a JavaScript primitive value for the expression
     *
     * Primitive values are: boolean, number, bigint, string, null, undefined
     *
     */
    valueOf(): number | number[] | number[][] | number[][][] | string | boolean;
    [Symbol.toPrimitive](hint: 'number' | 'string' | 'default'): number | string | null;
    /** Object.toString() */
    toString(): string;
    toLatex(options?: Partial<SerializeLatexOptions>): LatexString;
    get latex(): LatexString;
    /** Called by `JSON.stringify()` when serializing to json.
     *
     * Note: this is a standard method of JavaScript objects.
     *
     */
    toJSON(): Expression;
    toMathJson(options?: Readonly<Partial<JsonSerializationOptions>>): Expression;
    print(): void;
    get isStructural(): boolean;
    get canonical(): BoxedExpression;
    get structural(): BoxedExpression;
    get isValid(): boolean;
    get isPure(): boolean;
    get isConstant(): boolean;
    get isNumberLiteral(): boolean;
    get numericValue(): number | NumericValue | null;
    toNumericValue(): [NumericValue, BoxedExpression];
    get isEven(): boolean | undefined;
    get isOdd(): boolean | undefined;
    get re(): number;
    get im(): number;
    get bignumRe(): Decimal | undefined;
    get bignumIm(): Decimal | undefined;
    get sgn(): Sign | undefined;
    get isPositive(): boolean | undefined;
    get isNonNegative(): boolean | undefined;
    get isNegative(): boolean | undefined;
    get isNonPositive(): boolean | undefined;
    neg(): BoxedExpression;
    inv(): BoxedExpression;
    abs(): BoxedExpression;
    add(rhs: number | BoxedExpression): BoxedExpression;
    sub(rhs: BoxedExpression): BoxedExpression;
    mul(rhs: NumericValue | number | BoxedExpression): BoxedExpression;
    div(rhs: number | BoxedExpression): BoxedExpression;
    pow(exp: number | BoxedExpression): BoxedExpression;
    root(exp: number | BoxedExpression): BoxedExpression;
    sqrt(): BoxedExpression;
    ln(base?: number | BoxedExpression): BoxedExpression;
    get numerator(): BoxedExpression;
    get denominator(): BoxedExpression;
    get numeratorDenominator(): [BoxedExpression, BoxedExpression];
    is(other: BoxedExpression | number | bigint | boolean | string): boolean;
    isSame(other: BoxedExpression): boolean;
    isEqual(other: number | BoxedExpression): boolean | undefined;
    isLess(other: number | BoxedExpression): boolean | undefined;
    isLessEqual(other: number | BoxedExpression): boolean | undefined;
    isGreater(other: number | BoxedExpression): boolean | undefined;
    isGreaterEqual(other: number | BoxedExpression): boolean | undefined;
    get symbol(): string | null;
    get tensor(): null | Tensor<any>;
    get string(): string | null;
    getSubexpressions(operator: MathJsonSymbol): ReadonlyArray<BoxedExpression>;
    get subexpressions(): ReadonlyArray<BoxedExpression>;
    get symbols(): ReadonlyArray<string>;
    get unknowns(): ReadonlyArray<string>;
    get errors(): ReadonlyArray<BoxedExpression>;
    get isFunctionExpression(): boolean;
    get ops(): null | ReadonlyArray<BoxedExpression>;
    get isScoped(): boolean;
    get localScope(): Scope | undefined;
    abstract readonly operator: string;
    get nops(): SmallInteger;
    get op1(): BoxedExpression;
    get op2(): BoxedExpression;
    get op3(): BoxedExpression;
    get isNaN(): boolean | undefined;
    get isInfinity(): boolean | undefined;
    get isFinite(): boolean | undefined;
    get shape(): number[];
    get rank(): number;
    subs(_sub: Substitution, options?: {
        canonical?: CanonicalOptions;
    }): BoxedExpression;
    map(fn: (x: BoxedExpression) => BoxedExpression, options?: {
        canonical: CanonicalOptions;
        recursive?: boolean;
    }): BoxedExpression;
    solve(_vars?: Iterable<string> | string | BoxedExpression | Iterable<BoxedExpression>): null | ReadonlyArray<BoxedExpression>;
    replace(_rules: BoxedRuleSet | Rule | Rule[]): null | BoxedExpression;
    has(_v: string | string[]): boolean;
    get description(): string[] | undefined;
    get url(): string | undefined;
    get wikidata(): string | undefined;
    get complexity(): number | undefined;
    get baseDefinition(): BoxedBaseDefinition | undefined;
    get valueDefinition(): BoxedValueDefinition | undefined;
    get operatorDefinition(): BoxedOperatorDefinition | undefined;
    infer(t: Type, inferenceMode?: 'narrow' | 'widen'): boolean;
    bind(): void;
    reset(): void;
    get value(): BoxedExpression | undefined;
    set value(_value: any);
    get type(): BoxedType;
    set type(_type: Type | TypeString | BoxedType);
    get isNumber(): boolean | undefined;
    get isInteger(): boolean | undefined;
    get isRational(): boolean | undefined;
    get isReal(): boolean | undefined;
    simplify(_options?: Partial<SimplifyOptions>): BoxedExpression;
    expand(): BoxedExpression;
    evaluate(_options?: Partial<EvaluateOptions>): BoxedExpression;
    evaluateAsync(_options?: Partial<EvaluateOptions>): Promise<BoxedExpression>;
    N(): BoxedExpression;
    compile(options?: {
        to?: 'javascript';
        functions?: Record<MathJsonSymbol, string | ((...any: any[]) => any)>;
        vars?: Record<MathJsonSymbol, string>;
        imports?: ((...any: any[]) => any)[];
        preamble?: string;
        fallback?: boolean;
    }): ((...args: any[]) => any) & {
        isCompiled?: boolean;
    };
    get isCollection(): boolean;
    get isIndexedCollection(): boolean;
    get isLazyCollection(): boolean;
    xcontains(_rhs: BoxedExpression): boolean | undefined;
    subsetOf(_target: BoxedExpression, _strict: boolean): boolean | undefined;
    get xsize(): number | undefined;
    get isEmptyCollection(): boolean | undefined;
    get isFiniteCollection(): boolean | undefined;
    each(): Generator<BoxedExpression>;
    at(_index: number): BoxedExpression | undefined;
    get(_key: string | BoxedExpression): BoxedExpression | undefined;
    indexWhere(_predicate: (element: BoxedExpression) => boolean): number | undefined;
}
export declare function getSubexpressions(expr: BoxedExpression, name: MathJsonSymbol): ReadonlyArray<BoxedExpression>;
