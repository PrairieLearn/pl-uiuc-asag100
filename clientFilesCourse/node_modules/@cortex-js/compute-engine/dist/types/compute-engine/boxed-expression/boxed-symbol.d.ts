/* 0.30.2 */import type { Expression, MathJsonSymbol } from '../../math-json/types';
import type { Type, TypeString } from '../../common/type/types';
import type { OneOf } from '../../common/one-of';
import { BoxedType } from '../../common/type/boxed-type';
import type { BigNum } from '../numerics/types';
import { NumericValue } from '../numeric-value/types';
import type { BoxedExpression, SimplifyOptions, PatternMatchOptions, ReplaceOptions, BoxedValueDefinition, BoxedOperatorDefinition, ComputeEngine, Metadata, CanonicalOptions, BoxedBaseDefinition, BoxedSubstitution, EvaluateOptions, Rule, BoxedRule, BoxedRuleSet, Substitution, Sign, BoxedDefinition, CollectionHandlers } from '../global-types';
import { _BoxedExpression } from './abstract-boxed-expression';
/**
 * ### BoxedSymbol
 *
 * A boxed symbol is a reference to a `BoxedDefinition`.
 *
 * A `BoxedDefinition` "owns" all the information about a symbol, its
 * type and various attributes (is it a constant?, etc...).
 *
 * Boxed symbols are bound to a definition during construction if they
 * are canonical.
 *
 * If a symbol is not canonical (and thus not bound to a definition),
 * some properties and methods will return `undefined`, for example
 * `isInteger`, `isRational`, `isReal`, etc...
 *
 * There is a single value definition for each symbol but the value of a
 * symbol can be different in different evaluation contexts, for example
 * a local variable during a recursion.
 *
 * The value of a symbol is tracked in the evaluation context and
 * not in the value definition.
 *
 * The `value` property of a boxed symbol is the value of the symbol
 * in the current evaluation context. It is `undefined` if the symbol
 * is not bound to a definition or if the value is not known (a bound
 * symbol may have no value).
 *
 */
export declare class BoxedSymbol extends _BoxedExpression {
    private _hash;
    /** The name of the symbol */
    protected _id: MathJsonSymbol;
    /**
     * The definition of the symbol, if the symbol is bound/canonical.
     */
    private readonly _def;
    /** Note: to indicate that the symbol should be canonical, pass a def. */
    constructor(ce: ComputeEngine, name: MathJsonSymbol, options?: {
        metadata?: Metadata;
        def?: BoxedDefinition;
    });
    get json(): Expression;
    get hash(): number;
    get isPure(): boolean;
    get isConstant(): boolean;
    bind(): void;
    reset(): void;
    get isCanonical(): boolean;
    set isCanonical(val: boolean);
    get canonical(): BoxedExpression;
    is(other: any): boolean;
    toNumericValue(): [NumericValue, BoxedExpression];
    neg(): BoxedExpression;
    inv(): BoxedExpression;
    abs(): BoxedExpression;
    add(rhs: number | BoxedExpression): BoxedExpression;
    mul(rhs: NumericValue | number | BoxedExpression): BoxedExpression;
    div(rhs: number | BoxedExpression): BoxedExpression;
    pow(exp: number | BoxedExpression): BoxedExpression;
    root(n: number | BoxedExpression): BoxedExpression;
    sqrt(): BoxedExpression;
    ln(semiBase?: number | BoxedExpression): BoxedExpression;
    solve(vars?: Iterable<string> | string | BoxedExpression | Iterable<BoxedExpression>): null | ReadonlyArray<BoxedExpression>;
    get complexity(): number;
    get operator(): MathJsonSymbol;
    get symbol(): MathJsonSymbol;
    get baseDefinition(): BoxedBaseDefinition | undefined;
    get valueDefinition(): BoxedValueDefinition | undefined;
    get operatorDefinition(): BoxedOperatorDefinition | undefined;
    /**
     *
     * Assuming the symbol is used as an argument, subsequent inferences will
     * narrow the domain of the symbol:
     *
     * ```
     * f: real -> number, g: integer -> number
     * f(x) => x: inferred to real
     * g(x) => x: narrowed to integer
     * ```
     *
     * If the symbol is used as a return value, its domain should be widened:
     *
     * ```
     * f: number -> integer, g: number -> real
     * x = f(2) => x: inferred to integer
     * x = g(2) => x: widened to real
     * ```
     *
     * Arguments accumulate constraints and narrow.
     * Return values accumulate possibilities and widen.
     *
     * @inheritdoc
     */
    infer(t: Type, inferenceMode?: 'narrow' | 'widen'): boolean;
    /** Return the value of the symbol, undefined if an operator or not bound */
    get _value(): BoxedExpression | undefined;
    get value(): BoxedExpression | undefined;
    set value(value: boolean | string | BigNum | number[] | OneOf<[
        {
            re: number;
            im: number;
        },
        {
            num: number;
            denom: number;
        },
        BoxedExpression
    ]> | number | undefined);
    /**
     * The type of the symbol.
     *
     * Note that the type of the value of the symbol may be more specific.'
     * For example, a symbol could have a type of 'number' but the value
     * could be 'integer'.
     *
     * If the symbol is not canonical (not bound to a definition), the type is
     * 'unknown'
     */
    get type(): BoxedType;
    set type(t: Type | TypeString | BoxedType);
    has(x: MathJsonSymbol | MathJsonSymbol[]): boolean;
    match(pattern: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
    get sgn(): Sign | undefined;
    get isOdd(): boolean | undefined;
    get isEven(): boolean | undefined;
    get isFinite(): boolean | undefined;
    get isInfinity(): boolean | undefined;
    get isNaN(): boolean | undefined;
    get isPositive(): boolean | undefined;
    get isNonPositive(): boolean | undefined;
    get isNegative(): boolean | undefined;
    get isNonNegative(): boolean | undefined;
    get isFunction(): boolean | undefined;
    get isNumber(): boolean | undefined;
    get isInteger(): boolean | undefined;
    get isRational(): boolean | undefined;
    get isReal(): boolean | undefined;
    get re(): number;
    get im(): number;
    get bignumRe(): BigNum | undefined;
    get bignumIm(): BigNum | undefined;
    simplify(options?: Partial<SimplifyOptions>): BoxedExpression;
    evaluate(options?: Partial<EvaluateOptions>): BoxedExpression;
    N(): BoxedExpression;
    replace(rules: Rule | (Rule | BoxedRule)[] | BoxedRuleSet, options?: Partial<ReplaceOptions>): BoxedExpression | null;
    subs(sub: Substitution, options?: {
        canonical?: CanonicalOptions;
    }): BoxedExpression;
    get _asCollection(): CollectionHandlers | undefined;
    get isCollection(): boolean;
    get isIndexedCollection(): boolean;
    get isLazyCollection(): boolean;
    xcontains(rhs: BoxedExpression): boolean | undefined;
    get xsize(): number;
    get isEmptyCollection(): boolean;
    get isFiniteCollection(): boolean | undefined;
    each(): Generator<BoxedExpression>;
    at(index: number): BoxedExpression | undefined;
    get(index: BoxedExpression | string): BoxedExpression | undefined;
    indexWhere(predicate: (element: BoxedExpression) => boolean): number | undefined;
    subsetOf(rhs: BoxedExpression, strict: boolean): boolean;
}
