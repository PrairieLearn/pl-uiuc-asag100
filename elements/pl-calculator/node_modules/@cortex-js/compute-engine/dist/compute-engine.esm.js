/** Compute Engine 0.35.2 */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// node_modules/complex-esm/dist/src/complex.js
function logHypot(a, b) {
  var _a = Math.abs(a);
  var _b = Math.abs(b);
  if (a === 0) {
    return Math.log(_b);
  }
  if (b === 0) {
    return Math.log(_a);
  }
  if (_a < 3e3 && _b < 3e3) {
    return Math.log(a * a + b * b) * 0.5;
  }
  a = a / 2;
  b = b / 2;
  return 0.5 * Math.log(a * a + b * b) + Math.LN2;
}
var cosh, sinh, cosm1, hypot, parser_exit, parse, Complex;
var init_complex = __esm({
  "node_modules/complex-esm/dist/src/complex.js"() {
    cosh = Math.cosh || function(x) {
      return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
    };
    sinh = Math.sinh || function(x) {
      return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
    };
    cosm1 = function(x) {
      var b = Math.PI / 4;
      if (-b > x || x > b) {
        return Math.cos(x) - 1;
      }
      var xx = x * x;
      return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    };
    hypot = function(x, y) {
      var a = Math.abs(x);
      var b = Math.abs(y);
      if (a < 3e3 && b < 3e3) {
        return Math.sqrt(a * a + b * b);
      }
      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };
    parser_exit = function() {
      throw SyntaxError("Invalid Param");
    };
    parse = function(a, b) {
      var z = { "re": 0, "im": 0 };
      if (a === void 0 || a === null) {
        z["re"] = z["im"] = 0;
      } else if (b !== void 0) {
        z["re"] = a;
        z["im"] = b;
      } else
        switch (typeof a) {
          case "object":
            if ("im" in a && "re" in a) {
              z["re"] = a["re"];
              z["im"] = a["im"];
            } else if ("abs" in a && "arg" in a) {
              if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                return Complex["INFINITY"];
              }
              z["re"] = a["abs"] * Math.cos(a["arg"]);
              z["im"] = a["abs"] * Math.sin(a["arg"]);
            } else if ("r" in a && "phi" in a) {
              if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                return Complex["INFINITY"];
              }
              z["re"] = a["r"] * Math.cos(a["phi"]);
              z["im"] = a["r"] * Math.sin(a["phi"]);
            } else if (a.length === 2) {
              z["re"] = a[0];
              z["im"] = a[1];
            } else {
              parser_exit();
            }
            break;
          case "string":
            z["im"] = /* void */
            z["re"] = 0;
            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;
            if (tokens === null) {
              parser_exit();
            }
            for (var i = 0; i < tokens.length; i++) {
              var c = tokens[i];
              if (c === " " || c === "	" || c === "\n") {
              } else if (c === "+") {
                plus++;
              } else if (c === "-") {
                minus++;
              } else if (c === "i" || c === "I") {
                if (plus + minus === 0) {
                  parser_exit();
                }
                if (tokens[i + 1] !== " " && !isNaN(Number(tokens[i + 1]))) {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                  i++;
                } else {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                }
                plus = minus = 0;
              } else {
                if (plus + minus === 0 || isNaN(Number(c))) {
                  parser_exit();
                }
                if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                  i++;
                } else {
                  z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                }
                plus = minus = 0;
              }
            }
            if (plus + minus > 0) {
              parser_exit();
            }
            break;
          case "number":
            z["im"] = 0;
            z["re"] = a;
            break;
          default:
            parser_exit();
        }
      if (isNaN(z["re"]) || isNaN(z["im"])) {
      }
      return z;
    };
    Complex = class _Complex {
      constructor(a, b) {
        this.re = 0;
        this.im = 0;
        var z = parse(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      sign() {
        var abs3 = this["abs"]();
        return new _Complex(this["re"] / abs3, this["im"] / abs3);
      }
      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      add(a, b) {
        var z = new _Complex(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return _Complex["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return _Complex["INFINITY"];
        }
        return new _Complex(this["re"] + z["re"], this["im"] + z["im"]);
      }
      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      sub(a, b) {
        var z = new _Complex(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return _Complex["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return _Complex["INFINITY"];
        }
        return new _Complex(this["re"] - z["re"], this["im"] - z["im"]);
      }
      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      mul(a, b) {
        var z = new _Complex(a, b);
        if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
          return _Complex["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return _Complex["INFINITY"];
        }
        if (z["im"] === 0 && this["im"] === 0) {
          return new _Complex(this["re"] * z["re"], 0);
        }
        return new _Complex(this["re"] * z["re"] - this["im"] * z["im"], this["re"] * z["im"] + this["im"] * z["re"]);
      }
      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      div(a, b) {
        var z = new _Complex(a, b);
        if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
          return _Complex["NAN"];
        }
        if (this["isInfinite"]() || z["isZero"]()) {
          return _Complex["INFINITY"];
        }
        if (this["isZero"]() || z["isInfinite"]()) {
          return _Complex["ZERO"];
        }
        a = this["re"];
        b = this["im"];
        var c = z["re"];
        var d = z["im"];
        var t, x;
        if (0 === d) {
          return new _Complex(a / c, b / c);
        }
        if (Math.abs(c) < Math.abs(d)) {
          x = c / d;
          t = c * x + d;
          return new _Complex((a * x + b) / t, (b * x - a) / t);
        } else {
          x = d / c;
          t = d * x + c;
          return new _Complex((a + b * x) / t, (b - a * x) / t);
        }
      }
      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      pow(a, b) {
        var z = new _Complex(a, b);
        a = this["re"];
        b = this["im"];
        if (z["isZero"]()) {
          return _Complex["ONE"];
        }
        if (z["im"] === 0) {
          if (b === 0 && a > 0) {
            return new _Complex(Math.pow(a, z["re"]), 0);
          } else if (a === 0) {
            switch ((z["re"] % 4 + 4) % 4) {
              case 0:
                return new _Complex(Math.pow(b, z["re"]), 0);
              case 1:
                return new _Complex(0, Math.pow(b, z["re"]));
              case 2:
                return new _Complex(-Math.pow(b, z["re"]), 0);
              case 3:
                return new _Complex(0, -Math.pow(b, z["re"]));
            }
          }
        }
        if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
          return _Complex["ZERO"];
        }
        var arg = Math.atan2(b, a);
        var loh = logHypot(a, b);
        a = Math.exp(z["re"] * loh - z["im"] * arg);
        b = z["im"] * loh + z["re"] * arg;
        return new _Complex(a * Math.cos(b), a * Math.sin(b));
      }
      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      sqrt() {
        var a = this["re"];
        var b = this["im"];
        var r = this["abs"]();
        var re, im;
        if (a >= 0) {
          if (b === 0) {
            return new _Complex(Math.sqrt(a), 0);
          }
          re = 0.5 * Math.sqrt(2 * (r + a));
        } else {
          re = Math.abs(b) / Math.sqrt(2 * (r - a));
        }
        if (a <= 0) {
          im = 0.5 * Math.sqrt(2 * (r - a));
        } else {
          im = Math.abs(b) / Math.sqrt(2 * (r + a));
        }
        return new _Complex(re, b < 0 ? -im : im);
      }
      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      exp() {
        var tmp = Math.exp(this["re"]);
        if (this["im"] === 0) {
        }
        return new _Complex(tmp * Math.cos(this["im"]), tmp * Math.sin(this["im"]));
      }
      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      expm1() {
        var a = this["re"];
        var b = this["im"];
        return new _Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
      }
      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      log() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0 && a > 0) {
        }
        return new _Complex(logHypot(a, b), Math.atan2(b, a));
      }
      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      abs() {
        return hypot(this["re"], this["im"]);
      }
      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      arg() {
        return Math.atan2(this["im"], this["re"]);
      }
      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      sin() {
        var a = this["re"];
        var b = this["im"];
        return new _Complex(Math.sin(a) * cosh(b), Math.cos(a) * sinh(b));
      }
      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      cos() {
        var a = this["re"];
        var b = this["im"];
        return new _Complex(Math.cos(a) * cosh(b), -Math.sin(a) * sinh(b));
      }
      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      tan() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) + cosh(b);
        return new _Complex(Math.sin(a) / d, sinh(b) / d);
      }
      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      cot() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) - cosh(b);
        return new _Complex(-Math.sin(a) / d, sinh(b) / d);
      }
      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      sec() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);
        return new _Complex(Math.cos(a) * cosh(b) / d, Math.sin(a) * sinh(b) / d);
      }
      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      csc() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);
        return new _Complex(Math.sin(a) * cosh(b) / d, -Math.cos(a) * sinh(b) / d);
      }
      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      asin() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new _Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
        var t2 = new _Complex(t1["re"] - b, t1["im"] + a)["log"]();
        return new _Complex(t2["im"], -t2["re"]);
      }
      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      acos() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new _Complex(b * b - a * a + 1, -2 * a * b)["sqrt"]();
        var t2 = new _Complex(t1["re"] - b, t1["im"] + a)["log"]();
        return new _Complex(Math.PI / 2 - t2["im"], t2["re"]);
      }
      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      atan() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0) {
          if (b === 1) {
            return new _Complex(0, Infinity);
          }
          if (b === -1) {
            return new _Complex(0, -Infinity);
          }
        }
        var d = a * a + (1 - b) * (1 - b);
        var t1 = new _Complex((1 - b * b - a * a) / d, -2 * a / d).log();
        return new _Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
      }
      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      acot() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new _Complex(Math.atan2(1, a), 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).atan() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
      }
      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      asec() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new _Complex(0, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).acos() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
      }
      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      acsc() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new _Complex(Math.PI / 2, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).asin() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
      }
      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      sinh() {
        var a = this["re"];
        var b = this["im"];
        return new _Complex(sinh(a) * Math.cos(b), cosh(a) * Math.sin(b));
      }
      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      cosh() {
        var a = this["re"];
        var b = this["im"];
        return new _Complex(cosh(a) * Math.cos(b), sinh(a) * Math.sin(b));
      }
      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      tanh() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh(a) + Math.cos(b);
        return new _Complex(sinh(a) / d, Math.sin(b) / d);
      }
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      coth() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh(a) - Math.cos(b);
        return new _Complex(sinh(a) / d, -Math.sin(b) / d);
      }
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      csch() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) - cosh(2 * a);
        return new _Complex(-2 * sinh(a) * Math.cos(b) / d, 2 * cosh(a) * Math.sin(b) / d);
      }
      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      sech() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) + cosh(2 * a);
        return new _Complex(2 * cosh(a) * Math.cos(b) / d, -2 * sinh(a) * Math.sin(b) / d);
      }
      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      asinh() {
        var tmp = this["im"];
        this["im"] = -this["re"];
        this["re"] = tmp;
        var res = this["asin"]();
        this["re"] = -this["im"];
        this["im"] = tmp;
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
        return res;
      }
      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      acosh() {
        var res = this["acos"]();
        if (res["im"] <= 0) {
          var tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
        } else {
          var tmp = res["im"];
          res["im"] = -res["re"];
          res["re"] = tmp;
        }
        return res;
      }
      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      atanh() {
        var a = this["re"];
        var b = this["im"];
        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;
        var x = d !== 0 ? new _Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new _Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
        var temp = x["re"];
        x["re"] = logHypot(x["re"], x["im"]) / 2;
        x["im"] = Math.atan2(x["im"], temp) / 2;
        if (noIM) {
          x["im"] = -x["im"];
        }
        return x;
      }
      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      acoth() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new _Complex(0, Math.PI / 2);
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).atanh() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
      }
      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      acsch() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new _Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).asinh() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
      }
      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      asech() {
        var a = this["re"];
        var b = this["im"];
        if (this["isZero"]()) {
          return _Complex["INFINITY"];
        }
        var d = a * a + b * b;
        return d !== 0 ? new _Complex(a / d, -b / d).acosh() : new _Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
      }
      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      inverse() {
        if (this["isZero"]()) {
          return _Complex["INFINITY"];
        }
        if (this["isInfinite"]()) {
          return _Complex["ZERO"];
        }
        var a = this["re"];
        var b = this["im"];
        var d = a * a + b * b;
        return new _Complex(a / d, -b / d);
      }
      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      conjugate() {
        return new _Complex(this["re"], -this["im"]);
      }
      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      neg() {
        return new _Complex(-this["re"], -this["im"]);
      }
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      ceil(places) {
        places = Math.pow(10, places || 0);
        return new _Complex(Math.ceil(this["re"] * places) / places, Math.ceil(this["im"] * places) / places);
      }
      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      floor(places) {
        places = Math.pow(10, places || 0);
        return new _Complex(Math.floor(this["re"] * places) / places, Math.floor(this["im"] * places) / places);
      }
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      round(places) {
        places = Math.pow(10, places || 0);
        return new _Complex(Math.round(this["re"] * places) / places, Math.round(this["im"] * places) / places);
      }
      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      equals(a, b) {
        var z = new _Complex(a, b);
        return Math.abs(z["re"] - this["re"]) <= _Complex["EPSILON"] && Math.abs(z["im"] - this["im"]) <= _Complex["EPSILON"];
      }
      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      clone() {
        return new _Complex(this["re"], this["im"]);
      }
      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      toString() {
        var a = this["re"];
        var b = this["im"];
        var ret = "";
        if (this["isNaN"]()) {
          return "NaN";
        }
        if (this["isInfinite"]()) {
          return "Infinity";
        }
        if (Math.abs(a) < _Complex["EPSILON"]) {
          a = 0;
        }
        if (Math.abs(b) < _Complex["EPSILON"]) {
          b = 0;
        }
        if (b === 0) {
          return ret + a;
        }
        if (a !== 0) {
          ret += a;
          ret += " ";
          if (b < 0) {
            b = -b;
            ret += "-";
          } else {
            ret += "+";
          }
          ret += " ";
        } else if (b < 0) {
          b = -b;
          ret += "-";
        }
        if (1 !== b) {
          ret += b;
        }
        return ret + "i";
      }
      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      toVector() {
        return [this["re"], this["im"]];
      }
      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      valueOf() {
        if (this["im"] === 0) {
          return this["re"];
        }
        return null;
      }
      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      isNaN() {
        return isNaN(this["re"]) || isNaN(this["im"]);
      }
      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isZero() {
        return this["im"] === 0 && this["re"] === 0;
      }
      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isFinite() {
        return isFinite(this["re"]) && isFinite(this["im"]);
      }
      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      isInfinite() {
        return !(this["isNaN"]() || this["isFinite"]());
      }
    };
    Complex["ZERO"] = new Complex(0, 0);
    Complex["ONE"] = new Complex(1, 0);
    Complex["I"] = new Complex(0, 1);
    Complex["PI"] = new Complex(Math.PI, 0);
    Complex["E"] = new Complex(Math.E, 0);
    Complex["INFINITY"] = new Complex(Infinity, Infinity);
    Complex["NAN"] = new Complex(NaN, NaN);
    Complex["EPSILON"] = 1e-15;
  }
});

// node_modules/decimal.js/decimal.mjs
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
function checkInt32(i, min3, max3) {
  if (i !== ~~i || i < min3 || i > max3) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero()) return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out: if (sd != null) {
    xd = x.d;
    if (!xd) return x;
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {
          for (; k++ <= xdi; ) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];
        for (digits = 1; k >= 10; k /= 10) digits++;
        i %= LOG_BASE;
        j = i - LOG_BASE + digits;
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x.e + 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {
        xd[0] = x.e = 0;
      }
      return x;
    }
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) len--;
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0) ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow4, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow4 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow4 = finalise(pow4.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow4, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow4 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++) ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str)) return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat) x = divide(x, divisor, len * 4);
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; ) ;
      if (j == -1) break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e) n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len) for (e -= len; e--; ) str += "0";
        else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min3, max3) {
  return new this(x).clamp(min3, max3);
}
function config(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh2(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2)) return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43) v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh2;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot2;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh2;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot2() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh2(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
var EXP_LIMIT, MAX_DIGITS, NUMERALS, LN10, PI, DEFAULTS, inexact, quadrant, external, decimalError, invalidArgument, precisionLimitExceeded, cryptoUnavailable, tag, mathfloor, mathpow, isBinary, isHex, isOctal, isDecimal, BASE, LOG_BASE, MAX_SAFE_INTEGER, LN10_PRECISION, PI_PRECISION, P, divide, Decimal, decimal_default;
var init_decimal = __esm({
  "node_modules/decimal.js/decimal.mjs"() {
    EXP_LIMIT = 9e15;
    MAX_DIGITS = 1e9;
    NUMERALS = "0123456789abcdef";
    LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    DEFAULTS = {
      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.
      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,
      // 1 to MAX_DIGITS
      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,
      // 0 to 8
      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,
      // 0 to 9
      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,
      // 0 to -EXP_LIMIT
      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos: 21,
      // 0 to EXP_LIMIT
      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,
      // -1 to -EXP_LIMIT
      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,
      // 1 to EXP_LIMIT
      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false
      // true/false
    };
    external = true;
    decimalError = "[DecimalError] ";
    invalidArgument = decimalError + "Invalid argument: ";
    precisionLimitExceeded = decimalError + "Precision limit exceeded";
    cryptoUnavailable = decimalError + "crypto unavailable";
    tag = "[object Decimal]";
    mathfloor = Math.floor;
    mathpow = Math.pow;
    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    BASE = 1e7;
    LOG_BASE = 7;
    MAX_SAFE_INTEGER = 9007199254740991;
    LN10_PRECISION = LN10.length - 1;
    PI_PRECISION = PI.length - 1;
    P = { toStringTag: tag };
    P.absoluteValue = P.abs = function() {
      var x = new this.constructor(this);
      if (x.s < 0) x.s = 1;
      return finalise(x);
    };
    P.ceil = function() {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };
    P.clampedTo = P.clamp = function(min3, max3) {
      var k, x = this, Ctor = x.constructor;
      min3 = new Ctor(min3);
      max3 = new Ctor(max3);
      if (!min3.s || !max3.s) return new Ctor(NaN);
      if (min3.gt(max3)) throw Error(invalidArgument + max3);
      k = x.cmp(min3);
      return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
    };
    P.comparedTo = P.cmp = function(y) {
      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }
      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
      if (xs !== ys) return xs;
      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
      xdL = xd.length;
      ydL = yd.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };
    P.cosine = P.cos = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.d) return new Ctor(NaN);
      if (!x.d[0]) return new Ctor(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };
    P.cubeRoot = P.cbrt = function() {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      external = false;
      s = x.s * mathpow(x.s * x, 1 / 3);
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;
        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
        s = mathpow(n, 1 / 3);
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.decimalPlaces = P.dp = function() {
      var w, d = this.d, n = NaN;
      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
        w = d[w];
        if (w) for (; w % 10 == 0; w /= 10) n--;
        if (n < 0) n = 0;
      }
      return n;
    };
    P.dividedBy = P.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P.dividedToIntegerBy = P.divToInt = function(y) {
      var x = this, Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };
    P.equals = P.eq = function(y) {
      return this.cmp(y) === 0;
    };
    P.floor = function() {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };
    P.greaterThan = P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };
    P.hyperbolicCosine = P.cosh = function() {
      var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero()) return one;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = "2.3283064365386962890625e-10";
      }
      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
      var cosh2_x, i = k, d8 = new Ctor(8);
      for (; i--; ) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }
      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.hyperbolicSine = P.sinh = function() {
      var k, pr, rm, len, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);
        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(x, pr, rm, true);
    };
    P.hyperbolicTangent = P.tanh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(x.s);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;
      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };
    P.inverseCosine = P.acos = function() {
      var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
      if (k !== -1) {
        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
      }
      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseHyperbolicCosine = P.acosh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).minus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicSine = P.asinh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).plus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicTangent = P.atanh = function() {
      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();
      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
      Ctor.precision = wpr = xsd - x.e;
      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
      Ctor.precision = pr + 4;
      Ctor.rounding = 1;
      x = x.ln();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(0.5);
    };
    P.inverseSine = P.asin = function() {
      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
      if (x.isZero()) return new Ctor(x);
      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (k !== -1) {
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }
        return new Ctor(NaN);
      }
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseTangent = P.atan = function() {
      var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
      if (!x.isFinite()) {
        if (!x.s) return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }
      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;
      k = Math.min(28, wpr / LOG_BASE + 2 | 0);
      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
      external = false;
      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;
      for (; i !== -1; ) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));
        px = px.times(x2);
        r = t.plus(px.div(n += 2));
        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
      }
      if (k) r = r.times(2 << k - 1);
      external = true;
      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.isFinite = function() {
      return !!this.d;
    };
    P.isInteger = P.isInt = function() {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = P.isNeg = function() {
      return this.s < 0;
    };
    P.isPositive = P.isPos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    P.lessThan = P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.logarithm = P.log = function(base) {
      var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;
        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
        isBase10 = base.eq(10);
      }
      d = arg.d;
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0; ) k /= 10;
          inf = k !== 1;
        }
      }
      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (checkRoundingDigits(r.d, k = pr, rm)) {
        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);
          if (!inf) {
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }
      external = true;
      return finalise(r, pr, rm);
    };
    P.minus = P.sub = function(y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s) y = new Ctor(NaN);
        else if (x.d) y.s = -y.s;
        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (yd[0]) y.s = -y.s;
        else if (xd[0]) y = new Ctor(x);
        else return new Ctor(rm === 3 ? -0 : 0);
        return external ? finalise(y, pr, rm) : y;
      }
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);
      xd = xd.slice();
      k = xe - e;
      if (k) {
        xLTy = k < 0;
        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k > i) {
          k = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k; i--; ) d.push(0);
        d.reverse();
      } else {
        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;
        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }
        k = 0;
      }
      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }
      len = xd.length;
      for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
      for (i = yd.length; i > k; ) {
        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }
        xd[i] -= yd[i];
      }
      for (; xd[--len] === 0; ) xd.pop();
      for (; xd[0] === 0; xd.shift()) --e;
      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.modulo = P.mod = function(y) {
      var q, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }
      external = false;
      if (Ctor.modulo == 9) {
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }
      q = q.times(y);
      external = true;
      return x.minus(q);
    };
    P.naturalExponential = P.exp = function() {
      return naturalExponential(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return naturalLogarithm(this);
    };
    P.negated = P.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };
    P.plus = P.add = function(y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s) y = new Ctor(NaN);
        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (!yd[0]) y = new Ctor(x);
        return external ? finalise(y, pr, rm) : y;
      }
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);
      xd = xd.slice();
      i = k - e;
      if (i) {
        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; ) d.push(0);
        d.reverse();
      }
      len = xd.length;
      i = yd.length;
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }
      for (carry = 0; i; ) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }
      if (carry) {
        xd.unshift(carry);
        ++e;
      }
      for (len = xd.length; xd[--len] == 0; ) xd.pop();
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.precision = P.sd = function(z) {
      var k, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k) k = x.e + 1;
      } else {
        k = NaN;
      }
      return k;
    };
    P.round = function() {
      var x = this, Ctor = x.constructor;
      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };
    P.sine = P.sin = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }
      external = false;
      s = Math.sqrt(+x);
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);
        if ((n.length + e) % 2 == 0) n += "0";
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.tangent = P.tan = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;
      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };
    P.times = P.mul = function(y) {
      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      y.s *= x.s;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
      }
      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--; ) r.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }
        r[k] = (r[k] + carry) % BASE | 0;
      }
      for (; !r[--rL]; ) r.pop();
      if (carry) ++e;
      else r.shift();
      y.d = r;
      y.e = getBase10Exponent(r, e);
      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };
    P.toBinary = function(sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };
    P.toDecimalPlaces = P.toDP = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0) return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
      return finalise(x, dp + x.e + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFraction = function(maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
      if (!xd) return new Ctor(x);
      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);
      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
      if (maxD == null) {
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
        maxD = n.gt(d) ? e > 0 ? d : n1 : n;
      }
      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;
      for (; ; ) {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1) break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }
      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      Ctor.precision = pr;
      external = true;
      return r;
    };
    P.toHexadecimal = P.toHex = function(sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };
    P.toNearest = function(y, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (y == null) {
        if (!x.d) return x;
        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }
        if (!x.d) return y.s ? x : y;
        if (!y.d) {
          if (y.s) y.s = x.s;
          return y;
        }
      }
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);
      } else {
        y.s = x.s;
        x = y;
      }
      return x;
    };
    P.toNumber = function() {
      return +this;
    };
    P.toOctal = function(sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };
    P.toPower = P.pow = function(y) {
      var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
      x = new Ctor(x);
      if (x.eq(1)) return x;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (y.eq(1)) return finalise(x, pr, rm);
      e = mathfloor(y.e / LOG_BASE);
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }
      s = x.s;
      if (s < 0) {
        if (e < y.d.length - 1) return new Ctor(NaN);
        if ((y.d[e] & 1) == 0) s = 1;
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
      external = false;
      Ctor.rounding = x.s = 1;
      k = Math.min(12, (e + "").length);
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
      if (r.d) {
        r = finalise(r, pr + 5, 1);
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }
      r.s = s;
      external = true;
      Ctor.rounding = rm;
      return finalise(r, pr, rm);
    };
    P.toPrecision = function(sd, rm) {
      var str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toSignificantDigits = P.toSD = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }
      return finalise(new Ctor(x), sd, rm);
    };
    P.toString = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.truncated = P.trunc = function() {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };
    P.valueOf = P.toJSON = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() ? "-" + str : str;
    };
    divide = /* @__PURE__ */ (function() {
      function multiplyInteger(x, k, base) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }
        if (carry) x.unshift(carry);
        return x;
      }
      function compare(a, b, aL, bL) {
        var i, r;
        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r;
      }
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; ) a.shift();
      }
      return function(x, y, pr, rm, dp, base) {
        var cmp2, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
              xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
            )
          );
        }
        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign3);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); i++) ;
        if (yd[i] > (xd[i] || 0)) e--;
        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {
          sd = sd / logBase + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
            more = k || i < xL;
          } else {
            k = base / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; ) rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= base / 2) ++yd0;
            do {
              k = 0;
              cmp2 = compare(yd, rem, yL, remL);
              if (cmp2 < 0) {
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= base) k = base - 1;
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp2 = compare(prod, rem, prodL, remL);
                  if (cmp2 == 1) {
                    k--;
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {
                  if (k == 0) cmp2 = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL) prod.unshift(0);
                subtract(rem, prod, remL, base);
                if (cmp2 == -1) {
                  remL = rem.length;
                  cmp2 = compare(yd, rem, yL, remL);
                  if (cmp2 < 1) {
                    k++;
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }
                remL = rem.length;
              } else if (cmp2 === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp2 && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
            more = rem[0] !== void 0;
          }
          if (!qd[0]) qd.shift();
        }
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {
          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
          q.e = i + e * logBase - 1;
          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }
        return q;
      };
    })();
    P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
    P[Symbol.toStringTag] = "Decimal";
    Decimal = P.constructor = clone(DEFAULTS);
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);
    decimal_default = Decimal;
  }
});

// src/math-json/symbols.ts
function isRecommendedScripts(text) {
  if (!recommendedScriptsRegex) {
    const recommendedScripts = [
      "Zyyy",
      "Zinh",
      "Arab",
      "Armn",
      "Beng",
      "Bopo",
      "Cyrl",
      "Deva",
      "Ethi",
      "Geor",
      "Grek",
      "Gujr",
      "Guru",
      "Hang",
      "Hani",
      "Hebr",
      "Hira",
      "Kana",
      "Knda",
      "Khmr",
      "Laoo",
      "Latn",
      "Mlym",
      "Mymr",
      "Orya",
      "Sinh",
      "Taml",
      "Telu",
      "Thaa",
      "Thai",
      "Tibt"
    ];
    const regexPattern = `^[${recommendedScripts.map((x) => `\\p{Script=${x}}`).join("")}]*$`;
    recommendedScriptsRegex = new RegExp(regexPattern, "u");
  }
  return recommendedScriptsRegex.test(text);
}
function isValidSymbol(s) {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s)) return true;
  if (EMOJIS.test(s)) return true;
  if (!isRecommendedScripts(s)) return false;
  return /^[\p{XIDS}_]\p{XIDC}*$/u.test(s);
}
function validateSymbol(s) {
  if (typeof s !== "string") return "not-a-string";
  if (s === "") return "empty-string";
  if (s.normalize() !== s) return "expected-nfc";
  if (/[\u200E\u200F\u2066-\u2069\u202A-\u202E]/.test(s))
    return "unexpected-bidi-marker";
  if (EMOJIS.test(s)) return "valid";
  if (/\p{XIDC}/u.test(s) && SOME_EMOJI.test(s))
    return "unexpected-mixed-emoji";
  if (!isRecommendedScripts(s)) return "unexpected-script";
  if (!isValidSymbol(s)) {
    if (!isValidSymbol(s[0])) return "invalid-first-char";
    return "invalid-char";
  }
  return "valid";
}
var recommendedScriptsRegex, VS16, KEYCAP, ZWJ, FLAG_SEQUENCE, TAG_MOD, EMOJI_MOD, EMOJI_NOT_SYMBOL, ZWJ_ELEMENT, POSSIBLE_EMOJI, SOME_EMOJI, EMOJIS;
var init_symbols = __esm({
  "src/math-json/symbols.ts"() {
    VS16 = "\\u{FE0F}";
    KEYCAP = "\\u{20E3}";
    ZWJ = "\\u{200D}";
    FLAG_SEQUENCE = "\\p{RI}\\p{RI}";
    TAG_MOD = `(?:[\\u{E0020}-\\u{E007E}]+\\u{E007F})`;
    EMOJI_MOD = `(?:\\p{EMod}|${VS16}${KEYCAP}?|${TAG_MOD})`;
    EMOJI_NOT_SYMBOL = `(?:(?=\\P{XIDC})\\p{Emoji})`;
    ZWJ_ELEMENT = `(?:${EMOJI_NOT_SYMBOL}${EMOJI_MOD}*|\\p{Emoji}${EMOJI_MOD}+|${FLAG_SEQUENCE})`;
    POSSIBLE_EMOJI = `(?:${ZWJ_ELEMENT})(${ZWJ}${ZWJ_ELEMENT})*`;
    SOME_EMOJI = new RegExp(`(?:${POSSIBLE_EMOJI})+`, "u");
    EMOJIS = new RegExp(`^(?:${POSSIBLE_EMOJI})+$`, "u");
  }
});

// src/common/type/primitive.ts
function isValidPrimitiveType(s) {
  if (typeof s !== "string") return false;
  return PRIMITIVE_TYPES.includes(s);
}
var NUMERIC_TYPES, INDEXED_COLLECTION_TYPES, COLLECTION_TYPES, SCALAR_TYPES, VALUE_TYPES, EXPRESSION_TYPES, PRIMITIVE_TYPES;
var init_primitive = __esm({
  "src/common/type/primitive.ts"() {
    NUMERIC_TYPES = [
      "number",
      "finite_number",
      "complex",
      "finite_complex",
      "imaginary",
      "real",
      "finite_real",
      "rational",
      "finite_rational",
      "integer",
      "finite_integer",
      "non_finite_number"
    ];
    INDEXED_COLLECTION_TYPES = [
      "indexed_collection",
      "list",
      "tuple"
    ];
    COLLECTION_TYPES = [
      ...INDEXED_COLLECTION_TYPES,
      "collection",
      "set",
      "record",
      "dictionary"
    ];
    SCALAR_TYPES = [
      "scalar",
      ...NUMERIC_TYPES,
      "boolean",
      "string"
    ];
    VALUE_TYPES = [
      "value",
      ...COLLECTION_TYPES,
      ...SCALAR_TYPES
    ];
    EXPRESSION_TYPES = [
      "expression",
      "symbol",
      "function",
      ...VALUE_TYPES
    ];
    PRIMITIVE_TYPES = [
      "any",
      "unknown",
      "nothing",
      "never",
      "error",
      ...EXPRESSION_TYPES
    ];
  }
});

// src/common/type/subtype.ts
function isPrimitiveSubtype(lhs, rhs) {
  if (rhs === "any") return true;
  if (lhs === "never") return true;
  if (lhs === "unknown" || rhs === "unknown") return false;
  if (lhs === rhs) return true;
  return PRIMITIVE_SUBTYPES[rhs].includes(lhs);
}
function isSubtype(lhs, rhs) {
  if (typeof lhs === "string") lhs = parseType(lhs);
  if (typeof rhs === "string") rhs = parseType(rhs);
  if (rhs === "any") return true;
  if (rhs === "never") return false;
  if (rhs === "error") return lhs === "error";
  if (rhs === "nothing") return lhs === "nothing";
  if (lhs === "nothing") return false;
  if (rhs === "unknown") return true;
  if (lhs === "unknown") return false;
  if (typeof rhs === "string") {
    if (typeof lhs === "string")
      return isPrimitiveSubtype(lhs, rhs);
    if (lhs.kind === "value") {
      if (typeof lhs.value === "boolean") return rhs === "boolean";
      if (typeof lhs.value === "number") {
        if (Number.isInteger(lhs.value))
          return isPrimitiveSubtype("integer", rhs);
        return isPrimitiveSubtype("number", rhs);
      }
      if (typeof lhs.value === "boolean")
        return isPrimitiveSubtype("boolean", rhs);
      if (typeof lhs.value === "string")
        return isPrimitiveSubtype("string", rhs);
      return false;
    }
    if (lhs.kind === "union") return lhs.types.every((t) => isSubtype(t, rhs));
    if (lhs.kind === "intersection") {
      return lhs.types.some((t) => isSubtype(t, rhs));
    }
    if (lhs.kind === "negation") {
      return !isSubtype(lhs.type, rhs);
    }
    if (lhs.kind === "numeric") {
      if (!isSubtype(lhs.type, rhs)) return false;
      return true;
    }
    if (rhs === "number") return isNumeric(lhs);
    if (rhs === "symbol") return isSymbol(lhs);
    if (rhs === "expression") return isExpression(lhs);
    if (rhs === "function") return isFunction(lhs);
    if (rhs === "scalar") return isScalar(lhs);
    if (rhs === "value") return isValue(lhs);
    if (rhs === "indexed_collection") return isIndexedCollection(lhs);
    if (rhs === "collection") return isCollection(lhs);
    if (rhs === "tuple") return lhs.kind === "tuple";
    if (rhs === "list") return lhs.kind === "list";
    if (rhs === "set") return lhs.kind === "set";
    if (rhs === "record") return lhs.kind === "record";
    if (rhs === "dictionary") return lhs.kind === "dictionary";
    return false;
  }
  if (rhs.kind === "union") {
    if (typeof lhs !== "string" && lhs.kind === "union") {
      return lhs.types.every(
        (lhsType) => rhs.types.some((rhsType) => isSubtype(lhsType, rhsType))
      );
    }
    return rhs.types.some((t) => isSubtype(lhs, t));
  }
  if (rhs.kind === "expression") {
    if (lhs === "symbol") return true;
    if (typeof lhs === "string") return false;
    if (lhs.kind === "expression") {
      if (rhs.operator === "Symbol") return isSymbol(lhs);
      return lhs.operator === rhs.operator;
    }
    if (lhs.kind === "symbol") return true;
  }
  if (typeof lhs === "string") return false;
  if (rhs.kind === "reference") {
    if (lhs.kind === "reference") return lhs.name === rhs.name;
    if (rhs.alias === true && rhs.def) {
      return isSubtype(lhs, rhs.def);
    }
  }
  if (lhs.kind === "union") return lhs.types.some((t) => isSubtype(t, rhs));
  if (lhs.kind === "intersection" && rhs.kind === "intersection") {
    return rhs.types.every(
      (rhsType) => lhs.types.some((lhsType) => isSubtype(lhsType, rhsType))
    );
  }
  if (lhs.kind === "intersection") {
    return lhs.types.every((lhsType) => isSubtype(lhsType, rhs));
  }
  if (rhs.kind === "intersection") {
    return rhs.types.every((rhsType) => isSubtype(lhs, rhsType));
  }
  if (lhs.kind === "signature" && rhs.kind === "signature") {
    if (!isSubtype(lhs.result, rhs.result)) return false;
    if (lhs.optArgs || lhs.variadicArg) {
      if (rhs.args) {
        if (!lhs.args) return false;
        if (lhs.args.length !== rhs.args.length) return false;
        for (let i = 0; i < rhs.args.length; i++) {
          if (!isSubtype(rhs.args[i].type, lhs.args[i].type)) return false;
        }
      } else if (lhs.args) {
        return false;
      }
      if (rhs.optArgs) {
        if (!lhs.optArgs) return false;
        if (lhs.optArgs.length !== rhs.optArgs.length) return false;
        for (let i = 0; i < lhs.optArgs.length; i++) {
          if (!isSubtype(rhs.optArgs[i].type, lhs.optArgs[i].type))
            return false;
        }
      } else if (lhs.optArgs) {
        return false;
      }
      if (rhs.variadicArg) {
        if (!lhs.variadicArg) return false;
        if (lhs.variadicMin != rhs.variadicMin) return false;
        if (!isSubtype(rhs.variadicArg.type, lhs.variadicArg.type))
          return false;
      } else if (lhs.variadicArg) {
        return false;
      }
    } else {
      if (rhs.args && !lhs.args) {
        return false;
      }
      let i = 0;
      if (rhs.args) {
        if (lhs.args.length < rhs.args.length) return false;
        while (i < rhs.args.length) {
          if (!isSubtype(rhs.args[i].type, lhs.args[i].type)) return false;
          i += 1;
        }
      }
      if (rhs.optArgs) {
        if (i >= lhs.args.length) return true;
        for (let j = 0; j < rhs.optArgs.length; j++) {
          if (!isSubtype(rhs.optArgs[j].type, lhs.args[i].type)) return false;
          i += 1;
          if (i >= lhs.args.length) return true;
        }
      }
      if (rhs.variadicArg) {
        if (i >= lhs.args.length && rhs.variadicMin === 0) return true;
        if (rhs.variadicMin > 0 && i + rhs.variadicMin > lhs.args.length)
          return false;
        while (i < lhs.args.length) {
          if (!isSubtype(rhs.variadicArg.type, lhs.args[i].type)) return false;
          i += 1;
        }
      }
    }
    return true;
  }
  if (lhs.kind === "record" && rhs.kind === "record") {
    for (const key of Object.keys(rhs.elements)) {
      if (!(key in lhs.elements)) return false;
      if (!isSubtype(lhs.elements[key], rhs.elements[key])) return false;
    }
    return true;
  }
  if (lhs.kind === "dictionary" && rhs.kind === "dictionary") {
    return isSubtype(lhs.values, rhs.values);
  }
  if (rhs.kind === "indexed_collection") {
    if (lhs.kind === "indexed_collection")
      return isSubtype(lhs.elements, rhs.elements);
    if (lhs.kind === "list") return isSubtype(lhs.elements, rhs.elements);
    if (lhs.kind === "tuple") {
      return lhs.elements.every((x) => isSubtype(x.type, rhs.elements));
    }
    return false;
  }
  if (rhs.kind === "collection") {
    if (lhs.kind === "collection" || lhs.kind === "indexed_collection")
      return isSubtype(lhs.elements, rhs.elements);
    if (lhs.kind === "list") return isSubtype(lhs.elements, rhs.elements);
    if (lhs.kind === "tuple")
      return lhs.elements.every((x) => isSubtype(x.type, rhs.elements));
    if (lhs.kind === "set") return isSubtype(lhs.elements, rhs.elements);
    if (lhs.kind === "dictionary")
      return isSubtype(
        parseType(`tuple<string, ${typeToString(lhs.values)}>`),
        rhs.elements
      );
    if (lhs.kind === "record")
      return isSubtype(
        parseType(
          `tuple<$string, ${typeToString(widen(...Object.values(lhs.elements)))}>`
        ),
        rhs.elements
      );
  }
  if (lhs.kind === "tuple" && rhs.kind === "tuple") {
    if (lhs.elements.length !== rhs.elements.length) return false;
    for (let i = 0; i < lhs.elements.length; i++) {
      const a = lhs.elements[i];
      const b = rhs.elements[i];
      if (!isSubtype(a.type, b.type) || a.name !== b.name) return false;
    }
    return true;
  }
  if (rhs.kind === "list" && lhs.kind === "list") {
    43;
    if (!isSubtype(lhs.elements, rhs.elements)) return false;
    if (rhs.dimensions) {
      if (!lhs.dimensions) return false;
      if (lhs.dimensions.length !== rhs.dimensions.length) return false;
      for (let i = 0; i < lhs.dimensions.length; i++) {
        if (rhs.dimensions[i] !== -1 && lhs.dimensions[i] !== rhs.dimensions[i])
          return false;
      }
    }
    return true;
  }
  if (lhs.kind === "symbol" && rhs.kind === "symbol") {
    return lhs.name === rhs.name;
  }
  if (lhs.kind === "numeric" && rhs.kind === "numeric") {
    if (!isSubtype(lhs.type, rhs.type)) return false;
    if ((lhs.lower ?? -Infinity) < (rhs.lower ?? -Infinity)) return false;
    if ((lhs.upper ?? Infinity) > (rhs.upper ?? Infinity)) return false;
    return true;
  }
  if (rhs.kind === "set" && lhs.kind === "set") {
    if (!isSubtype(lhs.elements, rhs.elements)) return false;
    return true;
  }
  if (lhs.kind === "negation" && rhs.kind === "negation") {
    return isSubtype(lhs.type, rhs.type);
  }
  if (rhs.kind === "negation") {
    return !isSubtype(lhs, rhs.type);
  }
  if (rhs.kind === "value" && lhs.kind === "value")
    return rhs.value === lhs.value;
  if (lhs.kind === "value") {
    if (typeof lhs.value === "boolean") return isSubtype("boolean", rhs);
    if (typeof lhs.value === "number") {
      if (Number.isInteger(lhs.value)) return isSubtype("integer", rhs);
      return isSubtype("real", rhs);
    }
    if (typeof lhs.value === "string") return isSubtype("string", rhs);
  }
  return false;
}
function isNumeric(type2) {
  if (typeof type2 === "string")
    return NUMERIC_TYPES.includes(type2);
  if (type2.kind === "value") return typeof type2.value === "number";
  if (type2.kind === "numeric") return true;
  return false;
}
function isScalar(type2) {
  if (isNumeric(type2)) return true;
  if (typeof type2 === "string")
    return SCALAR_TYPES.includes(type2);
  if (type2.kind === "value")
    return ["string", "boolean", "number"].includes(typeof type2.value);
  return false;
}
function isCollection(type2) {
  if (isIndexedCollection(type2)) return true;
  if (typeof type2 === "string")
    return COLLECTION_TYPES.includes(type2);
  return ["collection", "set", "record", "dictionary"].includes(type2.kind);
}
function isIndexedCollection(type2) {
  if (typeof type2 === "string") return false;
  return ["indexed_collection", "list", "tuple"].includes(type2.kind);
}
function isValue(type2) {
  return isScalar(type2) || isCollection(type2);
}
function isFunction(type2) {
  return type2 === "function" || typeof type2 !== "string" && type2.kind === "signature";
}
function isExpression(type2) {
  if (typeof type2 === "string" && ["expression", "symbol", "function"].includes(type2))
    return true;
  if (isValue(type2) || isFunction(type2) || isSymbol(type2)) return true;
  if (typeof type2 === "string") return false;
  if (type2.kind === "expression") return true;
  return false;
}
function isSymbol(type2) {
  if (type2 === "symbol") return true;
  if (typeof type2 === "string") return false;
  if (type2.kind === "symbol") return true;
  if (type2.kind === "expression") return type2.operator === "Symbol";
  return false;
}
var PRIMITIVE_SUBTYPES;
var init_subtype = __esm({
  "src/common/type/subtype.ts"() {
    init_parse();
    init_primitive();
    init_serialize();
    init_utils();
    PRIMITIVE_SUBTYPES = {
      number: NUMERIC_TYPES,
      non_finite_number: [],
      //  PositiveInfinity, NegativeInfinity
      finite_number: [
        "finite_complex",
        "finite_real",
        "finite_integer",
        "finite_rational"
      ],
      complex: [
        "finite_complex",
        "imaginary",
        "finite_real",
        "finite_rational",
        "finite_integer",
        "non_finite_number"
      ],
      finite_complex: [
        "imaginary",
        "finite_real",
        "finite_rational",
        "finite_integer"
      ],
      imaginary: [],
      // Pure, finite, imaginary number
      real: [
        "rational",
        "integer",
        "finite_real",
        "finite_rational",
        "finite_integer",
        "non_finite_number"
      ],
      finite_real: ["finite_rational", "finite_integer"],
      rational: [
        "finite_rational",
        "finite_integer",
        "integer",
        "non_finite_number"
      ],
      finite_rational: ["finite_integer"],
      integer: ["finite_integer", "non_finite_number"],
      finite_integer: [],
      any: PRIMITIVE_TYPES,
      unknown: [],
      nothing: [],
      never: [],
      error: [],
      value: VALUE_TYPES,
      scalar: SCALAR_TYPES,
      collection: COLLECTION_TYPES,
      indexed_collection: INDEXED_COLLECTION_TYPES,
      list: [],
      set: [],
      tuple: [],
      record: [],
      dictionary: [],
      function: [],
      symbol: [],
      boolean: [],
      string: [],
      expression: EXPRESSION_TYPES
    };
  }
});

// src/common/type/serialize.ts
function typeToString(type2, precedence = 0) {
  if (typeof type2 === "string") return type2;
  let result = "";
  switch (type2.kind) {
    case "value":
      if (typeof type2.value === "string") result = `"${type2.value}"`;
      else if (typeof type2.value === "boolean")
        result = type2.value ? "true" : "false";
      else result = type2.value.toString();
      break;
    case "reference":
      result = type2.name;
      break;
    case "negation":
      result = `!${typeToString(type2.type, NEGATION_PRECEDENCE)}`;
      break;
    case "union":
      result = type2.types.map((t) => typeToString(t, UNION_PRECEDENCE)).join(" | ");
      break;
    case "intersection":
      result = type2.types.map((t) => typeToString(t, INTERSECTION_PRECEDENCE)).join(" & ");
      break;
    case "expression":
      result = `expression<${symbolName(type2.operator)}>`;
      break;
    case "symbol":
      result = `symbol<${symbolName(type2.name)}>`;
      break;
    case "numeric":
      if (Number.isFinite(type2.lower) && Number.isFinite(type2.upper)) {
        result = `${type2.type}<${type2.lower}..${type2.upper}>`;
      } else if (Number.isFinite(type2.lower)) {
        result = `${type2.type}<${type2.lower}..>`;
      } else if (Number.isFinite(type2.upper)) {
        result = `${type2.type}<..${type2.upper}>`;
      } else {
        result = `${type2.type}`;
      }
      break;
    case "list":
      if (type2.dimensions && isSubtype(type2.elements, "number")) {
        if (type2.dimensions === void 0) {
          if (type2.elements === "number") result = "tensor";
        } else if (type2.dimensions.length === 1) {
          if (type2.elements === "number") {
            if (type2.dimensions[0] < 0) result = "vector";
            else result = `vector<${type2.dimensions[0]}>`;
          } else {
            if (type2.dimensions[0] < 0)
              result = `vector<${typeToString(type2.elements)}>`;
            else
              result = `vector<${typeToString(type2.elements)}^${type2.dimensions[0]}>`;
          }
        } else if (type2.dimensions.length === 2) {
          const dims = type2.dimensions;
          if (type2.elements === "number") {
            if (dims[0] < 0 && dims[1] < 0) result = "matrix";
            else result = `matrix<${dims[0]}x${dims[1]}>`;
          } else {
            if (dims[0] < 0 && dims[1] < 0)
              result = `matrix<${typeToString(type2.elements)}>`;
            else
              result = `matrix<${typeToString(type2.elements)}^(${dims[0]}x${dims[1]})>`;
          }
        }
      }
      if (!result) {
        const dimensions = type2.dimensions ? type2.dimensions.length === 1 ? `^${type2.dimensions[0].toString()}` : `^(${type2.dimensions.join("x")})` : "";
        result = `list<${typeToString(type2.elements)}${dimensions}>`;
      }
      break;
    case "record":
      const elements = Object.entries(type2.elements).map(([key, value]) => `${key}: ${typeToString(value)}`).join(", ");
      result = `record<${elements}>`;
      break;
    case "dictionary":
      result = `dictionary<${typeToString(type2.values)}>`;
      break;
    case "set":
      result = `set<${typeToString(type2.elements)}>`;
      break;
    case "collection":
      result = `collection<${typeToString(type2.elements)}>`;
      break;
    case "indexed_collection":
      result = `indexed_collection<${typeToString(type2.elements)}>`;
      break;
    case "tuple":
      if (type2.elements.length === 0) result = "tuple";
      else if (type2.elements.length === 1) {
        const [el] = type2.elements;
        result = `tuple<${namedElement(el)}>`;
      } else {
        result = "tuple<" + type2.elements.map((el) => namedElement(el)).join(", ") + ">";
      }
      break;
    case "signature":
      const args = type2.args ? type2.args.map((arg) => namedElement(arg)).join(", ") : "";
      const optArgs = type2.optArgs ? type2.optArgs.map((arg) => namedElement(arg) + "?").join(", ") : "";
      const varArg = type2.variadicArg ? type2.variadicMin === 0 ? `${namedElement(type2.variadicArg)}*` : `${namedElement(type2.variadicArg)}+` : "";
      const argsList = [args, optArgs, varArg].filter((s) => s).join(", ");
      result = `(${argsList}) -> ${typeToString(type2.result)}`;
      break;
    default:
      result = "error";
  }
  if (precedence > 0 && precedence > getPrecedence(type2.kind))
    return `(${result})`;
  return result;
}
function namedElement(el) {
  if (el.name) return `${el.name}: ${typeToString(el.type)}`;
  return typeToString(el.type);
}
function symbolName(name) {
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) return name;
  return `\`${name}\``;
}
function getPrecedence(kind) {
  switch (kind) {
    case "negation":
      return NEGATION_PRECEDENCE;
    case "union":
      return UNION_PRECEDENCE;
    case "intersection":
      return INTERSECTION_PRECEDENCE;
    case "list":
      return LIST_PRECEDENCE;
    case "record":
      return RECORD_PRECEDENCE;
    case "dictionary":
      return DICTIONARY_PRECEDENCE;
    case "set":
      return SET_PRECEDENCE;
    case "collection":
    case "indexed_collection":
      return COLLECTION_PRECEDENCE;
    case "tuple":
      return TUPLE_PRECEDENCE;
    case "signature":
      return SIGNATURE_PRECEDENCE;
    case "value":
      return VALUE_PRECEDENCE;
    default:
      return 0;
  }
}
var NEGATION_PRECEDENCE, UNION_PRECEDENCE, INTERSECTION_PRECEDENCE, LIST_PRECEDENCE, RECORD_PRECEDENCE, DICTIONARY_PRECEDENCE, SET_PRECEDENCE, COLLECTION_PRECEDENCE, TUPLE_PRECEDENCE, SIGNATURE_PRECEDENCE, VALUE_PRECEDENCE;
var init_serialize = __esm({
  "src/common/type/serialize.ts"() {
    init_subtype();
    NEGATION_PRECEDENCE = 3;
    UNION_PRECEDENCE = 1;
    INTERSECTION_PRECEDENCE = 2;
    LIST_PRECEDENCE = 4;
    RECORD_PRECEDENCE = 5;
    DICTIONARY_PRECEDENCE = 6;
    SET_PRECEDENCE = 7;
    COLLECTION_PRECEDENCE = 8;
    TUPLE_PRECEDENCE = 9;
    SIGNATURE_PRECEDENCE = 10;
    VALUE_PRECEDENCE = 11;
  }
});

// src/common/fuzzy-string-match.ts
function levenshtein(source, target) {
  if (source === target) return 0;
  if (source.length === 0) return target.length;
  if (target.length === 0) return source.length;
  let prevRow = Array.from(
    { length: source.length + 1 },
    (_, j) => j
  );
  let currRow = new Array(source.length + 1);
  for (let i = 1; i <= target.length; i++) {
    currRow[0] = i;
    for (let j = 1; j <= source.length; j++) {
      const cost = source[j - 1] === target[i - 1] ? 0 : 1;
      currRow[j] = Math.min(
        prevRow[j] + 1,
        // deletion
        currRow[j - 1] + 1,
        // insertion
        prevRow[j - 1] + cost
        // substitution
      );
    }
    [prevRow, currRow] = [currRow, prevRow];
  }
  return prevRow[source.length];
}
function fuzzyStringMatch(invalidWord, validWords) {
  const threshold = 7;
  let bestMatch = null;
  let minDistance = Infinity;
  const invalidLength = invalidWord.length;
  for (const word of validWords) {
    if (Math.abs(invalidLength - word.length) > threshold) continue;
    const distance = levenshtein(invalidWord, word);
    if (distance === 0) return word;
    if (distance <= threshold && distance < minDistance) {
      minDistance = distance;
      bestMatch = word;
    }
  }
  return bestMatch;
}
var init_fuzzy_string_match = __esm({
  "src/common/fuzzy-string-match.ts"() {
  }
});

// src/common/type/lexer.ts
var Lexer;
var init_lexer = __esm({
  "src/common/type/lexer.ts"() {
    Lexer = class {
      input;
      pos = 0;
      line = 1;
      column = 1;
      tokens = [];
      constructor(input) {
        this.input = input;
      }
      // Save current lexer state for backtracking
      saveState() {
        return {
          pos: this.pos,
          line: this.line,
          column: this.column,
          tokens: [...this.tokens]
        };
      }
      // Restore lexer state for backtracking
      restoreState(state) {
        this.pos = state.pos;
        this.line = state.line;
        this.column = state.column;
        this.tokens = state.tokens;
      }
      error(message) {
        throw new Error(
          `Lexer error at line ${this.line}, column ${this.column}: ${message}`
        );
      }
      peek(offset = 0) {
        const index = this.pos + offset;
        return index < this.input.length ? this.input[index] : "";
      }
      advance() {
        const char = this.input[this.pos++];
        if (char === "\n") {
          this.line++;
          this.column = 1;
        } else {
          this.column++;
        }
        return char;
      }
      match(str) {
        if (this.input.slice(this.pos, this.pos + str.length) === str) {
          for (let i = 0; i < str.length; i++) {
            this.advance();
          }
          return true;
        }
        return false;
      }
      isEOF() {
        return this.pos >= this.input.length;
      }
      skipWhitespace() {
        while (!this.isEOF() && /\s/.test(this.peek())) {
          this.advance();
        }
      }
      readIdentifier() {
        let value = "";
        while (!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())) {
          value += this.advance();
        }
        return value;
      }
      readVerbatimString() {
        if (!this.match("`")) return "";
        let value = "";
        while (!this.isEOF() && this.peek() !== "`") {
          if (this.match("\\`")) {
            value += "`";
          } else if (this.match("\\\\")) {
            value += "\\";
          } else {
            value += this.advance();
          }
        }
        if (this.isEOF()) {
          this.error("Unterminated verbatim string");
        }
        this.advance();
        return value;
      }
      readStringLiteral() {
        const quote = this.advance();
        let value = "";
        while (!this.isEOF() && this.peek() !== quote) {
          if (this.match("\\" + quote)) {
            value += quote;
          } else if (this.match("\\\\")) {
            value += "\\";
          } else {
            value += this.advance();
          }
        }
        if (this.isEOF()) {
          this.error("Unterminated string literal");
        }
        this.advance();
        return value;
      }
      readNumber() {
        let value = "";
        if (this.peek() === "-" || this.peek() === "+") {
          value += this.advance();
        }
        if (this.match("0x") || this.match("0X")) {
          value += "x";
          while (!this.isEOF() && /[0-9a-fA-F]/.test(this.peek())) {
            value += this.advance();
          }
          return "0" + value;
        }
        if (this.match("0b") || this.match("0B")) {
          value += "b";
          while (!this.isEOF() && /[01]/.test(this.peek())) {
            value += this.advance();
          }
          return "0" + value;
        }
        while (!this.isEOF() && /[0-9]/.test(this.peek())) {
          value += this.advance();
        }
        if (this.peek() === "." && /[0-9]/.test(this.peek(1))) {
          value += this.advance();
          while (!this.isEOF() && /[0-9]/.test(this.peek())) {
            value += this.advance();
          }
        }
        if (this.peek() === "e" || this.peek() === "E") {
          value += this.advance();
          if (this.peek() === "+" || this.peek() === "-") {
            value += this.advance();
          }
          while (!this.isEOF() && /[0-9]/.test(this.peek())) {
            value += this.advance();
          }
        }
        return value;
      }
      createToken(type2, value) {
        return {
          type: type2,
          value,
          position: this.pos - value.length,
          line: this.line,
          column: this.column - value.length
        };
      }
      nextToken() {
        this.skipWhitespace();
        if (this.isEOF()) {
          return this.createToken("EOF", "");
        }
        const start = this.pos;
        const char = this.peek();
        if (this.match("->")) {
          return this.createToken("->", "->");
        }
        if (this.match("..")) {
          return this.createToken("..", "..");
        }
        if (this.match("+\u221E") || this.match("+oo")) {
          return this.createToken(
            "PLUS_INFINITY",
            this.input.slice(start, this.pos)
          );
        }
        if (this.match("-\u221E") || this.match("-oo")) {
          return this.createToken(
            "MINUS_INFINITY",
            this.input.slice(start, this.pos)
          );
        }
        if (this.match("+infinity")) {
          return this.createToken("PLUS_INFINITY", "+infinity");
        }
        if (this.match("-infinity")) {
          return this.createToken("MINUS_INFINITY", "-infinity");
        }
        if (/[a-zA-Z_]/.test(char)) {
          const value = this.readIdentifier();
          switch (value) {
            case "true":
              return this.createToken("TRUE", value);
            case "false":
              return this.createToken("FALSE", value);
            case "nan":
              return this.createToken("NAN", value);
            case "infinity":
              return this.createToken("INFINITY", value);
            case "oo":
              return this.createToken("INFINITY", value);
            default:
              return this.createToken("IDENTIFIER", value);
          }
        }
        switch (char) {
          case "|":
            this.advance();
            return this.createToken("|", "|");
          case "&":
            this.advance();
            return this.createToken("&", "&");
          case "!":
            this.advance();
            return this.createToken("!", "!");
          case "^":
            this.advance();
            return this.createToken("^", "^");
          case "(":
            this.advance();
            return this.createToken("(", "(");
          case ")":
            this.advance();
            return this.createToken(")", ")");
          case "<":
            this.advance();
            return this.createToken("<", "<");
          case ">":
            this.advance();
            return this.createToken(">", ">");
          case "[":
            this.advance();
            return this.createToken("[", "[");
          case "]":
            this.advance();
            return this.createToken("]", "]");
          case ",":
            this.advance();
            return this.createToken(",", ",");
          case ":":
            this.advance();
            return this.createToken(":", ":");
          case "?":
            this.advance();
            return this.createToken("?", "?");
          case "*":
            this.advance();
            return this.createToken("*", "*");
          case "+":
            if (/[0-9]/.test(this.peek(1))) {
              return this.createToken("NUMBER_LITERAL", this.readNumber());
            }
            this.advance();
            return this.createToken("+", "+");
          case "x":
            if (/[0-9]/.test(this.peek(1))) {
              this.advance();
              return this.createToken("x", "x");
            }
            this.advance();
            return this.createToken("x", "x");
        }
        if (char === '"' || char === "'") {
          return this.createToken("STRING_LITERAL", this.readStringLiteral());
        }
        if (char === "`") {
          return this.createToken("VERBATIM_STRING", this.readVerbatimString());
        }
        if (/[0-9]/.test(char) || char === "-" && /[0-9]/.test(this.peek(1))) {
          const number = this.readNumber();
          if (this.peek() === "x" && /[0-9]/.test(this.peek(1))) {
          }
          return this.createToken("NUMBER_LITERAL", number);
        }
        if (char === "\u221E") {
          this.advance();
          return this.createToken("INFINITY", "\u221E");
        }
        this.error(`Unexpected character: ${char}`);
      }
      tokenize() {
        const tokens = [];
        while (!this.isEOF()) {
          const token = this.nextToken();
          if (token) {
            tokens.push(token);
            if (token.type === "EOF") break;
          }
        }
        return tokens;
      }
      peekToken() {
        if (this.tokens.length === 0) {
          const token = this.nextToken();
          if (token) this.tokens.push(token);
        }
        return this.tokens[0] || this.createToken("EOF", "");
      }
      consumeToken() {
        if (this.tokens.length === 0) {
          const token = this.nextToken();
          if (token) return token;
        }
        return this.tokens.shift() || this.createToken("EOF", "");
      }
      matchToken(type2) {
        const token = this.peekToken();
        if (token.type === type2) {
          this.consumeToken();
          return true;
        }
        return false;
      }
      expectToken(type2) {
        const token = this.consumeToken();
        if (token.type !== type2) {
          this.error(`Expected ${type2}, got ${token.type}`);
        }
        return token;
      }
    };
  }
});

// src/common/type/parser.ts
var Parser;
var init_parser = __esm({
  "src/common/type/parser.ts"() {
    init_lexer();
    init_primitive();
    Parser = class {
      lexer;
      typeResolver;
      current;
      constructor(input, options) {
        this.lexer = new Lexer(input);
        this.typeResolver = options?.typeResolver ?? {
          forward: () => void 0,
          resolve: () => void 0,
          get names() {
            return [];
          }
        };
        this.current = this.lexer.consumeToken();
      }
      error(message, suggestion) {
        this.errorAtToken(this.current, message, suggestion);
      }
      errorAtToken(token, message, suggestion) {
        const input = this.lexer.input;
        const lines = input.split("\n");
        const currentLine = lines[token.line - 1] || input;
        const column = token.column;
        const pointer = " ".repeat(Math.max(0, column - 1)) + "^";
        const formattedMessage = [
          "",
          "Invalid type",
          `|   ${currentLine}`,
          `|   ${pointer}`,
          "|",
          `|   ${message}`
        ];
        if (suggestion) formattedMessage.push(`|   ${suggestion}`);
        formattedMessage.push("");
        throw new Error(formattedMessage.join("\n"));
      }
      advance() {
        const prev = this.current;
        this.current = this.lexer.consumeToken();
        return prev;
      }
      match(type2) {
        if (this.current.type === type2) {
          this.advance();
          return true;
        }
        return false;
      }
      expect(type2) {
        if (this.current.type !== type2) {
          this.error(`Expected ${type2}, got ${this.current.type}`);
        }
        return this.advance();
      }
      createNode(kind, additional = {}) {
        return {
          kind,
          position: this.current.position,
          line: this.current.line,
          column: this.current.column,
          ...additional
        };
      }
      parseType() {
        this.checkForNakedFunctionSignature();
        const type2 = this.parseUnionType();
        if (!type2) {
          this.error("Expected a type");
        }
        if (this.current.type !== "EOF") {
          if (this.current.type === "->" || this.current.type === "+" || this.current.type === "*" || this.current.type === "?") {
            this.error(
              "Function signatures must be enclosed in parentheses",
              "For example `(x: number) -> number`"
            );
          } else if (this.current.type === "(") {
            const input = this.lexer.input;
            if (input.includes("set(") || input.includes("collection(") || input.includes("list(") || input.includes("tuple(")) {
              if (input.includes("set(")) {
                this.error("Use `set<integer>` instead of `set(integer)`.");
              } else if (input.includes("collection(")) {
                this.error(
                  "Use `collection<type>` instead of `collection(type)`.",
                  "For example `collection<number>`"
                );
              } else if (input.includes("list(")) {
                this.error(
                  "Use `list<type>` instead of `list(type)`.",
                  "For example `list<number>`"
                );
              } else if (input.includes("tuple(")) {
                this.error(
                  "Use `tuple<type1, type2>` instead of `tuple(type1, type2)`.",
                  "For example `tuple<string, number>`"
                );
              }
            } else {
              this.error("Unexpected token after type");
            }
          } else {
            this.error("Unexpected token after type");
          }
        }
        return type2;
      }
      checkForNakedFunctionSignature() {
        if (this.current.type === "IDENTIFIER") {
          const savedState = this.lexer.saveState();
          const savedCurrent = this.current;
          try {
            const identifierToken = this.current;
            this.advance();
            if (this.current.type === ":") {
              this.advance();
              let foundSignatureTokens = false;
              let tokenCount = 0;
              const maxLookahead = 10;
              while (this.current.type !== "EOF" && tokenCount < maxLookahead) {
                if (this.current.type === "->") {
                  foundSignatureTokens = true;
                  break;
                }
                if (this.current.type === "+" || this.current.type === "*" || this.current.type === "?") {
                  this.advance();
                  if (this.current.type === "->") {
                    foundSignatureTokens = true;
                    break;
                  }
                  tokenCount++;
                }
                this.advance();
                tokenCount++;
              }
              if (foundSignatureTokens) {
                this.lexer.restoreState(savedState);
                this.current = savedCurrent;
                this.errorAtToken(
                  identifierToken,
                  "Function signatures must be enclosed in parentheses",
                  "For example `(z: string*) -> boolean`"
                );
              }
            }
            this.lexer.restoreState(savedState);
            this.current = savedCurrent;
          } catch (error) {
            this.lexer.restoreState(savedState);
            this.current = savedCurrent;
            if (error instanceof Error && error.message.includes("Function signatures must be enclosed")) {
              throw error;
            }
          }
        }
      }
      parseUnionType() {
        const firstType = this.parseIntersectionType();
        if (!firstType) return void 0;
        const types = [firstType];
        while (this.match("|")) {
          const type2 = this.parseIntersectionType();
          if (!type2) {
            this.error("Expected type after |");
          }
          types.push(type2);
        }
        if (types.length === 1) return types[0];
        return this.createNode("union", { types });
      }
      parseIntersectionType() {
        const firstType = this.parsePrimaryType();
        if (!firstType) return void 0;
        const types = [firstType];
        while (this.match("&")) {
          const type2 = this.parsePrimaryType();
          if (!type2) {
            this.error("Expected type after &");
          }
          types.push(type2);
        }
        if (types.length === 1) return types[0];
        return this.createNode("intersection", { types });
      }
      parsePrimaryType() {
        if (this.match("!")) {
          const type2 = this.parsePrimaryType();
          if (!type2) {
            this.error("Expected type after !");
          }
          return this.createNode("negation", { type: type2 });
        }
        if (this.current.type === "(") {
          const signature = this.parseFunctionSignature();
          if (signature) return signature;
          if (this.match("(")) {
            const type2 = this.parseUnionType();
            if (!type2) {
              this.error("Expected type after (");
            }
            this.expect(")");
            return this.createNode("group", { type: type2 });
          }
        }
        return this.parseListType() || this.parseTupleType() || this.parseRecordType() || this.parseDictionaryType() || this.parseSetType() || this.parseCollectionType() || this.parseExpressionType() || this.parseSymbolType() || this.parseNumericType() || this.parsePrimitiveType() || this.parseValue() || this.parseTypeReference();
      }
      parseFunctionSignature() {
        const savedLexerState = this.lexer.saveState();
        const savedCurrent = this.current;
        const args = [];
        if (!this.match("(")) {
          return void 0;
        }
        try {
          if (!this.match(")")) {
            do {
              const arg = this.parseArgument();
              if (!arg) {
                throw new Error("Expected argument");
              }
              args.push(arg);
            } while (this.match(","));
            this.expect(")");
          }
          if (!this.match("->")) {
            throw new Error("Expected -> for function signature");
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("Invalid type")) {
            throw error;
          }
          this.lexer.restoreState(savedLexerState);
          this.current = savedCurrent;
          return void 0;
        }
        const returnType = this.parseUnionType();
        if (!returnType) {
          this.error("Expected return type after ->");
        }
        const hasOptional = args.some((arg) => arg.modifier === "optional");
        const hasVariadic = args.some(
          (arg) => arg.modifier === "variadic_zero" || arg.modifier === "variadic_one"
        );
        const variadicCount = args.filter(
          (arg) => arg.modifier === "variadic_zero" || arg.modifier === "variadic_one"
        ).length;
        if (hasOptional && hasVariadic) {
          this.error("Variadic arguments cannot be used with optional arguments");
        }
        if (variadicCount > 1) {
          this.error("There can be only one variadic argument");
        }
        return this.createNode("function_signature", {
          arguments: args,
          returnType
        });
      }
      parseArgument() {
        const element = this.parseNamedElement();
        if (!element) return void 0;
        let modifier;
        if (this.match("?")) {
          modifier = "optional";
        } else if (this.match("*")) {
          modifier = "variadic_zero";
        } else if (this.match("+")) {
          modifier = "variadic_one";
        }
        return this.createNode("argument", { element, modifier });
      }
      parseNamedElement() {
        let name;
        if (this.current.type === "IDENTIFIER" || this.current.type === "VERBATIM_STRING") {
          const nameToken = this.current;
          const nextToken = this.lexer.peekToken();
          if (nextToken.type === ":") {
            name = nameToken.value;
            this.advance();
            this.advance();
            const type3 = this.parseUnionType();
            if (!type3) return void 0;
            return this.createNode("named_element", {
              name,
              type: type3
            });
          }
        }
        const type2 = this.parseUnionType();
        if (!type2) return void 0;
        return this.createNode("named_element", {
          name: void 0,
          type: type2
        });
      }
      parseListType() {
        if (this.current.type === "IDENTIFIER") {
          const typeToken = this.current;
          const nextToken = this.lexer.peekToken();
          const isGeneric = nextToken.type === "<";
          switch (typeToken.value) {
            case "list":
              if (isGeneric) {
                this.advance();
                return this.parseListTypeImpl();
              }
              return void 0;
            // Let primitive parser handle bare 'list'
            case "vector":
              if (isGeneric) {
                this.advance();
                return this.parseVectorType();
              }
              this.advance();
              return this.createNode("list", {
                elementType: this.createNode("primitive", {
                  name: "number"
                }),
                dimensions: void 0
              });
            case "matrix":
              if (isGeneric) {
                this.advance();
                return this.parseMatrixType();
              }
              this.advance();
              return this.createNode("matrix", {
                elementType: this.createNode("primitive", {
                  name: "number"
                }),
                dimensions: [
                  this.createNode("dimension", { size: -1 }),
                  this.createNode("dimension", { size: -1 })
                ]
              });
            case "tensor":
              if (isGeneric) {
                this.advance();
                return this.parseTensorType();
              }
              this.advance();
              return this.createNode("list", {
                elementType: this.createNode("primitive", {
                  name: "number"
                }),
                dimensions: void 0
              });
            default:
              return void 0;
          }
        }
        return void 0;
      }
      parseListTypeImpl() {
        let elementType = this.createNode(
          "primitive",
          { name: "any" }
        );
        let dimensions;
        if (this.match("<")) {
          dimensions = this.parseDimensionWithX();
          if (!dimensions) {
            dimensions = this.parseDimensions();
          }
          if (!dimensions) {
            const type2 = this.parseUnionType();
            if (type2) {
              elementType = type2;
              if (this.match("^")) {
                dimensions = this.parseDimensionWithX();
                if (!dimensions) {
                  dimensions = this.parseDimensions();
                }
              }
            }
          }
          this.expect(">");
        }
        return this.createNode("list", { elementType, dimensions });
      }
      parseVectorType() {
        let elementType = this.createNode(
          "primitive",
          { name: "number" }
        );
        let size;
        if (this.match("<")) {
          if (this.current.type === "NUMBER_LITERAL") {
            size = parseInt(this.advance().value);
          } else {
            const type2 = this.parseUnionType();
            if (type2) {
              elementType = type2;
              if (this.match("^")) {
                if (this.current.type === "NUMBER_LITERAL") {
                  size = parseInt(this.advance().value);
                } else {
                  this.error("Expected number after ^");
                }
              }
            }
          }
          this.expect(">");
        }
        return this.createNode("vector", { elementType, size });
      }
      parseMatrixType() {
        let elementType = this.createNode(
          "primitive",
          { name: "number" }
        );
        let dimensions;
        if (this.match("<")) {
          dimensions = this.parseDimensionWithX();
          if (!dimensions) {
            dimensions = this.parseDimensions();
          }
          if (!dimensions) {
            const type2 = this.parseUnionType();
            if (type2) {
              elementType = type2;
              if (this.match("^")) {
                dimensions = this.parseDimensionWithX();
                if (!dimensions) {
                  dimensions = this.parseDimensions();
                }
              }
            }
          }
          this.expect(">");
        } else {
          dimensions = [
            this.createNode("dimension", { size: null }),
            this.createNode("dimension", { size: null })
          ];
        }
        return this.createNode("matrix", {
          elementType,
          dimensions
        });
      }
      parseTensorType() {
        let elementType = this.createNode(
          "primitive",
          { name: "number" }
        );
        if (this.match("<")) {
          const type2 = this.parseUnionType();
          if (type2) {
            elementType = type2;
          }
          this.expect(">");
        }
        return this.createNode("tensor", { elementType });
      }
      parseDimensions() {
        const dimensions = [];
        const firstDim = this.parseDimension();
        if (!firstDim) return void 0;
        dimensions.push(firstDim);
        while (this.match("x")) {
          const dim = this.parseDimension();
          if (!dim) {
            this.error("Expected dimension after x");
          }
          dimensions.push(dim);
        }
        return dimensions;
      }
      parseDimension() {
        if (this.match("?")) {
          return this.createNode("dimension", { size: null });
        }
        if (this.current.type === "NUMBER_LITERAL") {
          const size = parseInt(this.advance().value);
          return this.createNode("dimension", { size });
        }
        return void 0;
      }
      parseDimensionWithX() {
        if (this.current.type === "NUMBER_LITERAL") {
          const dimensions = [];
          const firstDim = parseInt(this.advance().value);
          dimensions.push(
            this.createNode("dimension", { size: firstDim })
          );
          if (this.current.type === "IDENTIFIER" && this.current.value.startsWith("x")) {
            const dimString = this.current.value;
            const matches = dimString.match(/x(\d+)/g);
            if (matches && matches.join("") === dimString) {
              this.advance();
              for (const match2 of matches) {
                const dimValue = parseInt(match2.substring(1));
                dimensions.push(
                  this.createNode("dimension", { size: dimValue })
                );
              }
            } else if (dimString === "x" || dimString.startsWith("x")) {
              this.error(
                "Expected a positive integer literal or `?` after x. For example: `2x3` or `2x?`"
              );
            }
          }
          if (dimensions.length > 1) {
            return dimensions;
          }
        }
        return void 0;
      }
      parseTupleType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "tuple") {
          const nextToken = this.lexer.peekToken();
          if (nextToken.type !== "<") {
            return void 0;
          }
          this.advance();
          this.expect("<");
          const elements = [];
          if (this.current.type !== ">") {
            const firstElement = this.parseNamedElement();
            if (!firstElement) {
              this.error("Expected tuple element");
            }
            elements.push(firstElement);
            const expectNamedElements = firstElement.name !== void 0;
            while (this.match(",")) {
              const element = this.parseNamedElement();
              if (!element) {
                this.error("Expected tuple element");
              }
              if (expectNamedElements && !element.name) {
                this.error(
                  "All tuple elements should be named, or none. Previous elements were named, but this one isn't."
                );
              }
              if (!expectNamedElements && element.name) {
                this.error(
                  "All tuple elements should be named, or none. Previous elements were not named, but this one is."
                );
              }
              elements.push(element);
            }
          }
          this.expect(">");
          return this.createNode("tuple", { elements });
        }
        return void 0;
      }
      parseRecordType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "record") {
          this.advance();
          const entries = [];
          if (this.match("<")) {
            if (this.current.type !== ">") {
              do {
                const entry = this.parseRecordEntry();
                if (!entry) {
                  this.error("Expected record entry");
                }
                entries.push(entry);
              } while (this.match(","));
            }
            this.expect(">");
          }
          return this.createNode("record", { entries });
        }
        return void 0;
      }
      parseRecordEntry() {
        let key;
        if (this.current.type === "IDENTIFIER") {
          key = this.advance().value;
        } else if (this.current.type === "VERBATIM_STRING") {
          key = this.advance().value;
        } else {
          return void 0;
        }
        this.expect(":");
        const valueType = this.parseUnionType();
        if (!valueType) {
          this.error("Expected value type");
        }
        return this.createNode("record_entry", { key, valueType });
      }
      parseDictionaryType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "dictionary") {
          this.advance();
          let valueType = this.createNode(
            "primitive",
            { name: "any" }
          );
          if (this.match("<")) {
            const type2 = this.parseUnionType();
            if (type2) {
              valueType = type2;
            }
            this.expect(">");
          }
          return this.createNode("dictionary", { valueType });
        }
        return void 0;
      }
      parseSetType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "set") {
          this.advance();
          let elementType = this.createNode(
            "primitive",
            { name: "any" }
          );
          if (this.match("<")) {
            const type2 = this.parseUnionType();
            if (type2) {
              elementType = type2;
            }
            this.expect(">");
          }
          return this.createNode("set", { elementType });
        }
        return void 0;
      }
      parseCollectionType() {
        if (this.current.type === "IDENTIFIER") {
          const isIndexed = this.current.value === "indexed_collection";
          const isGeneric = this.current.value === "collection";
          if (isIndexed || isGeneric) {
            this.advance();
            let elementType = this.createNode(
              "primitive",
              { name: "any" }
            );
            if (this.match("<")) {
              const type2 = this.parseUnionType();
              if (type2) {
                elementType = type2;
              }
              this.expect(">");
            }
            return this.createNode("collection", {
              elementType,
              indexed: isIndexed
            });
          }
        }
        return void 0;
      }
      parseExpressionType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "expression") {
          const nextToken = this.lexer.peekToken();
          if (nextToken.type !== "<") {
            return void 0;
          }
          this.advance();
          this.expect("<");
          const operatorToken = this.expect("IDENTIFIER");
          const operator2 = operatorToken.value;
          this.expect(">");
          return this.createNode("expression", { operator: operator2 });
        }
        return void 0;
      }
      parseSymbolType() {
        if (this.current.type === "IDENTIFIER" && this.current.value === "symbol") {
          const nextToken = this.lexer.peekToken();
          if (nextToken.type !== "<") {
            return void 0;
          }
          this.advance();
          this.expect("<");
          const nameToken = this.expect("IDENTIFIER");
          const name = nameToken.value;
          this.expect(">");
          return this.createNode("symbol", { name });
        }
        return void 0;
      }
      parseNumericType() {
        if (this.current.type === "IDENTIFIER") {
          const numericTypes = [
            "real",
            "finite_real",
            "rational",
            "finite_rational",
            "integer",
            "finite_integer"
          ];
          if (numericTypes.includes(this.current.value)) {
            const baseType = this.advance().value;
            if (this.match("<")) {
              const lowerBound = this.parseValue();
              this.expect("..");
              const upperBound = this.parseValue();
              this.expect(">");
              return this.createNode("numeric", {
                baseType,
                lowerBound,
                upperBound
              });
            }
            return this.createNode("numeric", { baseType });
          }
        }
        return void 0;
      }
      parsePrimitiveType() {
        if (this.current.type === "IDENTIFIER") {
          const name = this.current.value;
          if (PRIMITIVE_TYPES.includes(name)) {
            this.advance();
            return this.createNode("primitive", { name });
          }
        }
        return void 0;
      }
      parseValue() {
        let value;
        let valueType;
        switch (this.current.type) {
          case "STRING_LITERAL":
            value = this.advance().value;
            valueType = "string";
            break;
          case "NUMBER_LITERAL":
            value = parseFloat(this.advance().value);
            valueType = "number";
            break;
          case "TRUE":
            this.advance();
            value = true;
            valueType = "boolean";
            break;
          case "FALSE":
            this.advance();
            value = false;
            valueType = "boolean";
            break;
          case "NAN":
            this.advance();
            value = NaN;
            valueType = "nan";
            break;
          case "INFINITY":
          case "PLUS_INFINITY":
            this.advance();
            value = Infinity;
            valueType = "infinity";
            break;
          case "MINUS_INFINITY":
            this.advance();
            value = -Infinity;
            valueType = "infinity";
            break;
          default:
            return void 0;
        }
        return this.createNode("value", { value, valueType });
      }
      parseTypeReference() {
        const isForward = this.current.type === "IDENTIFIER" && this.current.value === "type";
        if (isForward) {
          this.advance();
        }
        if (this.current.type === "IDENTIFIER") {
          const nameToken = this.current;
          const name = this.advance().value;
          const result = this.typeResolver.resolve(name);
          if (result) {
            return this.createNode("type_reference", {
              name,
              isForward
            });
          }
          if (isForward) {
            const forwardResult = this.typeResolver.forward(name);
            if (forwardResult) {
              return this.createNode("type_reference", {
                name,
                isForward: true
              });
            }
          }
          if (!isForward) {
            this.errorAtToken(
              nameToken,
              `Unknown type "${name}"`,
              "Syntax error. The type was not recognized."
            );
          }
          return this.createNode("type_reference", {
            name,
            isForward
          });
        }
        return void 0;
      }
    };
  }
});

// src/common/type/ast-nodes.ts
function visitNode(node, visitor) {
  switch (node.kind) {
    case "function_signature":
      return visitor.visitFunctionSignature(node);
    case "union":
      return visitor.visitUnionType(node);
    case "intersection":
      return visitor.visitIntersectionType(node);
    case "negation":
      return visitor.visitNegationType(node);
    case "group":
      return visitor.visitGroupType(node);
    case "list":
      return visitor.visitListType(node);
    case "vector":
      return visitor.visitVectorType(node);
    case "matrix":
      return visitor.visitMatrixType(node);
    case "tensor":
      return visitor.visitTensorType(node);
    case "tuple":
      return visitor.visitTupleType(node);
    case "record":
      return visitor.visitRecordType(node);
    case "dictionary":
      return visitor.visitDictionaryType(node);
    case "set":
      return visitor.visitSetType(node);
    case "collection":
      return visitor.visitCollectionType(node);
    case "expression":
      return visitor.visitExpressionType(node);
    case "symbol":
      return visitor.visitSymbolType(node);
    case "numeric":
      return visitor.visitNumericType(node);
    case "primitive":
      return visitor.visitPrimitiveType(node);
    case "type_reference":
      return visitor.visitTypeReference(node);
    case "value":
      return visitor.visitValue(node);
    default:
      throw new Error(`Unknown node kind: ${node.kind}`);
  }
}
var init_ast_nodes = __esm({
  "src/common/type/ast-nodes.ts"() {
  }
});

// src/common/type/type-builder.ts
function buildTypeFromAST(node, typeResolver) {
  const builder = new TypeBuilder(typeResolver);
  return builder.buildType(node);
}
var TypeBuilder;
var init_type_builder = __esm({
  "src/common/type/type-builder.ts"() {
    init_ast_nodes();
    TypeBuilder = class {
      typeResolver;
      constructor(typeResolver) {
        this.typeResolver = typeResolver ?? {
          forward: () => void 0,
          resolve: () => void 0,
          get names() {
            return [];
          }
        };
      }
      buildType(node) {
        return visitNode(node, this);
      }
      visitFunctionSignature(node) {
        const args = [];
        const optArgs = [];
        let variadicArg;
        let variadicMin;
        for (const argNode of node.arguments) {
          const element = this.buildNamedElement(argNode.element);
          switch (argNode.modifier) {
            case "optional":
              optArgs.push(element);
              break;
            case "variadic_zero":
              variadicArg = element;
              variadicMin = 0;
              break;
            case "variadic_one":
              variadicArg = element;
              variadicMin = 1;
              break;
            default:
              args.push(element);
              break;
          }
        }
        const result = this.buildType(node.returnType);
        const signature = {
          kind: "signature",
          args: args.length > 0 ? args : void 0,
          result
        };
        if (optArgs.length > 0) signature.optArgs = optArgs;
        if (variadicArg) {
          signature.variadicArg = variadicArg;
          signature.variadicMin = variadicMin;
        }
        return signature;
      }
      visitUnionType(node) {
        const types = node.types.map((t) => this.buildType(t));
        return { kind: "union", types };
      }
      visitIntersectionType(node) {
        const types = node.types.map((t) => this.buildType(t));
        return { kind: "intersection", types };
      }
      visitNegationType(node) {
        const type2 = this.buildType(node.type);
        return { kind: "negation", type: type2 };
      }
      visitGroupType(node) {
        return this.buildType(node.type);
      }
      visitListType(node) {
        const elements = this.buildType(node.elementType);
        const dimensions = node.dimensions?.map((d) => this.buildDimension(d));
        return { kind: "list", elements, dimensions };
      }
      visitVectorType(node) {
        const elements = this.buildType(node.elementType);
        if (node.size !== void 0) {
          return { kind: "list", elements, dimensions: [node.size] };
        }
        return { kind: "list", elements };
      }
      visitMatrixType(node) {
        const elements = this.buildType(node.elementType);
        if (node.dimensions) {
          const dimensions = node.dimensions.map((d) => this.buildDimension(d));
          return { kind: "list", elements, dimensions };
        }
        return { kind: "list", elements, dimensions: [-1, -1] };
      }
      visitTensorType(node) {
        const elements = this.buildType(node.elementType);
        return { kind: "list", elements };
      }
      visitTupleType(node) {
        const elements = node.elements.map((e) => this.buildNamedElement(e));
        return { kind: "tuple", elements };
      }
      visitRecordType(node) {
        if (node.entries.length === 0) {
          return "record";
        }
        const elements = {};
        for (const entry of node.entries) {
          elements[entry.key] = this.buildType(entry.valueType);
        }
        return { kind: "record", elements };
      }
      visitDictionaryType(node) {
        const values = this.buildType(node.valueType);
        if (this.isAnyType(values)) {
          return "dictionary";
        }
        return { kind: "dictionary", values };
      }
      visitSetType(node) {
        const elements = this.buildType(node.elementType);
        if (this.isAnyType(elements)) {
          return "set";
        }
        return { kind: "set", elements };
      }
      visitCollectionType(node) {
        const elements = this.buildType(node.elementType);
        if (node.indexed) {
          if (this.isAnyType(elements)) {
            return "indexed_collection";
          }
          return { kind: "indexed_collection", elements };
        }
        if (this.isAnyType(elements)) {
          return "collection";
        }
        return { kind: "collection", elements };
      }
      visitExpressionType(node) {
        return { kind: "expression", operator: node.operator };
      }
      visitSymbolType(node) {
        return { kind: "symbol", name: node.name };
      }
      visitNumericType(node) {
        if (!node.lowerBound && !node.upperBound) {
          return node.baseType;
        }
        const lower = node.lowerBound ? this.buildValue(node.lowerBound) : -Infinity;
        const upper = node.upperBound ? this.buildValue(node.upperBound) : Infinity;
        if (lower === -Infinity && upper === Infinity) {
          return node.baseType;
        }
        return {
          kind: "numeric",
          type: node.baseType,
          lower,
          upper
        };
      }
      visitPrimitiveType(node) {
        return node.name;
      }
      visitTypeReference(node) {
        const resolved = this.typeResolver.resolve(node.name);
        if (resolved) {
          return resolved;
        }
        if (node.isForward) {
          const forwardResult = this.typeResolver.forward(node.name);
          if (forwardResult) {
            return forwardResult;
          }
        }
        return node.name;
      }
      visitValue(node) {
        return { kind: "value", value: node.value };
      }
      buildNamedElement(node) {
        const type2 = this.buildType(node.type);
        if (node.name) {
          return { name: node.name, type: type2 };
        }
        return { type: type2 };
      }
      buildDimension(node) {
        return node.size ?? -1;
      }
      buildValue(node) {
        return node.value;
      }
      isAnyType(type2) {
        return type2 === "any" || typeof type2 === "object" && "kind" in type2 && type2.kind === "primitive" && "name" in type2 && type2.name === "any";
      }
    };
  }
});

// src/common/type/parse.ts
function parseType(s, typeResolver) {
  if (s === void 0) return void 0;
  if (isValidType(s)) return s;
  if (typeof s !== "string") return void 0;
  try {
    const parser = new Parser(s, { typeResolver });
    const ast = parser.parseType();
    const type2 = buildTypeFromAST(ast, typeResolver);
    return type2;
  } catch (error) {
    throw new Error(
      `Failed to parse type "${s}": ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
var init_parse = __esm({
  "src/common/type/parse.ts"() {
    init_primitive();
    init_serialize();
    init_utils();
    init_fuzzy_string_match();
    init_parser();
    init_type_builder();
  }
});

// src/common/type/utils.ts
function narrow2(a, b) {
  if (a === b) return a;
  if (a === "nothing" || b === "nothing") return "nothing";
  if (a === "any") return b;
  if (b === "any") return a;
  if (a === "never") return b;
  if (b === "never") return a;
  if (a === "unknown") return b;
  if (b === "unknown") return a;
  if (isSubtype(a, b)) return a;
  if (isSubtype(b, a)) return b;
  return superType(a, b);
}
function widen2(a, b) {
  if (a === b) return a;
  if (a === "any" || b === "any") return "any";
  if (a === "never") return b;
  if (b === "never") return a;
  if (a === "unknown") return b;
  if (b === "unknown") return a;
  if (a === "nothing") return b;
  if (b === "nothing") return a;
  if (isSubtype(a, b)) return b;
  if (isSubtype(b, a)) return a;
  return superType(a, b);
}
function narrow(...types) {
  if (types.length === 0) return "nothing";
  if (types.length === 1) return types[0];
  return types.reduce((a, b) => narrow2(a, b));
}
function widen(...types) {
  if (types.length === 0) return "nothing";
  if (types.length === 1) return types[0];
  return types.reduce((a, b) => widen2(a, b));
}
function isSignatureType(type2) {
  type2 = typeof type2 === "string" ? parseType(type2) : type2;
  return typeof type2 !== "string" && type2.kind === "signature";
}
function functionResult(type2) {
  if (!type2) return void 0;
  if (type2 === "function") return "any";
  if (typeof type2 === "string") return void 0;
  if (type2.kind === "signature") return type2.result;
  return void 0;
}
function collectionElementType(type2) {
  if (type2 === "collection") return "any";
  if (type2 === "indexed_collection") return "any";
  if (type2 === "list") return "any";
  if (type2 === "set") return "any";
  if (type2 === "tuple") return "any";
  if (type2 === "dictionary") return "any";
  if (type2 === "record") return "any";
  if (typeof type2 === "string") return void 0;
  if (type2.kind === "collection" || type2.kind === "indexed_collection")
    return type2.elements;
  if (type2.kind === "list") return type2.elements;
  if (type2.kind === "set") return type2.elements;
  if (type2.kind === "tuple") return widen(...type2.elements.map((x) => x.type));
  if (type2.kind === "dictionary")
    return parseType(`tuple<string, ${type2.values}>`);
  if (type2.kind === "record") {
    return parseType(
      `tuple<string, ${typeToString(widen(...Object.values(type2.elements)))}>`
    );
  }
  return void 0;
}
function isValidTypeName(name) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
}
function isValidType(t) {
  if (typeof t === "string")
    return PRIMITIVE_TYPES.includes(t);
  if (typeof t !== "object") return false;
  if (!("kind" in t)) return false;
  return t.kind === "signature" || t.kind === "union" || t.kind === "intersection" || t.kind === "negation" || t.kind === "tuple" || t.kind === "list" || t.kind === "record" || t.kind === "dictionary" || t.kind === "set" || t.kind === "function" || t.kind === "collection" || t.kind === "indexed_collection" || t.kind === "reference";
}
function superType(a, b) {
  if (a === b) return a;
  if (a === "any" || b === "any") return "any";
  if (a === "never") return b;
  if (b === "never") return a;
  if (a === "unknown") return b;
  if (b === "unknown") return a;
  if (a === "nothing") return b;
  if (b === "nothing") return a;
  if (commonSupertype(a, b, "non_finite_number")) return "non_finite_number";
  if (commonSupertype(a, b, "finite_integer")) return "finite_integer";
  if (commonSupertype(a, b, "integer")) return "integer";
  if (commonSupertype(a, b, "finite_rational")) return "finite_rational";
  if (commonSupertype(a, b, "rational")) return "rational";
  if (commonSupertype(a, b, "finite_real")) return "finite_real";
  if (commonSupertype(a, b, "real")) return "real";
  if (commonSupertype(a, b, "imaginary")) return "imaginary";
  if (commonSupertype(a, b, "finite_complex")) return "finite_complex";
  if (commonSupertype(a, b, "complex")) return "complex";
  if (commonSupertype(a, b, "finite_number")) return "finite_number";
  if (commonSupertype(a, b, "number")) return "number";
  if (commonSupertype(a, b, "list")) return "list";
  if (commonSupertype(a, b, "record")) return "record";
  if (commonSupertype(a, b, "dictionary")) return "dictionary";
  if (commonSupertype(a, b, "set")) return "set";
  if (commonSupertype(a, b, "tuple")) return "tuple";
  if (commonSupertype(a, b, "indexed_collection")) return "indexed_collection";
  if (commonSupertype(a, b, "collection")) return "collection";
  if (commonSupertype(a, b, "scalar")) return "scalar";
  if (commonSupertype(a, b, "value")) return "value";
  if (commonSupertype(a, b, "function")) return "function";
  if (commonSupertype(a, b, "expression")) return "expression";
  return "any";
}
function commonSupertype(a, b, ancestor) {
  if (isSubtype(a, ancestor) && isSubtype(b, ancestor)) return true;
  return false;
}
var init_utils = __esm({
  "src/common/type/utils.ts"() {
    init_parse();
    init_primitive();
    init_serialize();
    init_subtype();
  }
});

// src/common/type/boxed-type.ts
var BoxedType;
var init_boxed_type = __esm({
  "src/common/type/boxed-type.ts"() {
    init_subtype();
    init_serialize();
    init_parse();
    init_utils();
    BoxedType = class _BoxedType {
      static unknown = new _BoxedType("unknown");
      static number = new _BoxedType("number");
      static non_finite_number = new _BoxedType("non_finite_number");
      static finite_number = new _BoxedType("finite_number");
      static finite_integer = new _BoxedType("finite_integer");
      static finite_real = new _BoxedType("finite_real");
      static string = new _BoxedType("string");
      static dictionary = new _BoxedType("dictionary");
      static setNumber = new _BoxedType("set<number>");
      static setComplex = new _BoxedType("set<complex>");
      static setImaginary = new _BoxedType("set<imaginary>");
      static setReal = new _BoxedType("set<real>");
      static setRational = new _BoxedType("set<rational>");
      static setFiniteInteger = new _BoxedType("set<finite_integer>");
      static setInteger = new _BoxedType("set<integer>");
      type;
      static widen(...types) {
        return new _BoxedType(
          widen(...types.map((x) => x instanceof _BoxedType ? x.type : x))
        );
      }
      static narrow(...types) {
        return new _BoxedType(
          narrow(...types.map((x) => x instanceof _BoxedType ? x.type : x))
        );
      }
      constructor(type2, typeResolver) {
        if (typeof type2 === "string") this.type = parseType(type2, typeResolver);
        else this.type = type2;
      }
      matches(other) {
        if (other instanceof _BoxedType) return isSubtype(this.type, other.type);
        return isSubtype(this.type, other);
      }
      is(other) {
        return isSubtype(this.type, other) && isSubtype(other, this.type);
      }
      get isUnknown() {
        return this.type === "unknown";
      }
      toString() {
        return typeToString(this.type);
      }
      toJSON() {
        return typeToString(this.type);
      }
      [Symbol.toPrimitive](hint) {
        if (hint === "string") return this.toString();
        return null;
      }
      valueOf() {
        return typeToString(this.type);
      }
    };
  }
});

// src/compute-engine/numerics/richardson.ts
function extrapolate(f, x0, options = {}) {
  const {
    contract = 0.125,
    step = 1,
    power = 2,
    atol = 1e-16,
    rtol = atol > 0 ? 0 : Math.sqrt(Number.EPSILON),
    maxeval = 1e6,
    // Number.MAX_SAFE_INTEGER
    breaktol = 2
  } = options;
  if (!isFinite(x0)) {
    return extrapolate((u) => f(1 / u), 1 / x0, {
      rtol,
      atol,
      maxeval,
      contract: Math.abs(contract) > 1 ? 1 / contract : contract,
      step: 1 / step,
      power
    });
  }
  let h = step;
  const invcontract = Math.pow(1 / contract, power);
  let f0 = f(x0 + h);
  const neville = [f0];
  let err = Infinity;
  let numeval = 1;
  while (numeval < maxeval) {
    numeval += 1;
    h *= contract;
    neville.push(f(x0 + h));
    let c = invcontract;
    let minerr = Infinity;
    for (let i = neville.length - 2; i >= 0; i--) {
      const old = neville[i];
      neville[i] = neville[i + 1] + (neville[i + 1] - neville[i]) / (c - 1);
      const err_ = Math.abs(neville[i] - old);
      minerr = Math.min(minerr, err_);
      if (err_ < err) {
        f0 = neville[i];
        err = err_;
      }
      c *= invcontract;
    }
    if (minerr > breaktol * err || !isFinite(minerr)) break;
    if (err <= Math.max(rtol * Math.abs(f0), atol)) break;
  }
  return [f0, err];
}
var init_richardson = __esm({
  "src/compute-engine/numerics/richardson.ts"() {
  }
});

// src/compute-engine/numerics/bigint.ts
function bigint(a) {
  if (typeof a === "bigint") return a;
  if (typeof a === "number") {
    if (!Number.isInteger(a)) return null;
    if (a >= Number.MAX_SAFE_INTEGER && a <= Number.MAX_SAFE_INTEGER)
      return BigInt(a);
    return bigint(a.toString());
  }
  if (a instanceof Decimal) {
    if (!a.isInteger()) return null;
    return BigInt(a.toFixed(0));
  }
  let s = a.toLowerCase();
  const m = s.match(/^([+-]?[0-9]+)e([+-]?[0-9]+)$/);
  if (m) {
    const exp3 = parseInt(m[2]);
    if (exp3 < 0) return null;
    s = m[1] + "0".repeat(exp3);
  }
  const i = s.indexOf(".");
  if (i >= 0) return null;
  if (!/^[+-]?[0-9]+$/.test(s)) return null;
  try {
    return BigInt(s);
  } catch (e) {
    console.error(e.message);
    return null;
  }
}
var init_bigint = __esm({
  "src/compute-engine/numerics/bigint.ts"() {
    init_decimal();
  }
});

// src/compute-engine/numerics/primes.ts
function primeFactors(n) {
  console.assert(
    Number.isInteger(n) && n >= 0 && n < Number.MAX_SAFE_INTEGER,
    n
  );
  if (n <= 3) return { [n]: 1 };
  const result = {};
  let count = 0;
  while (n % 2 === 0) {
    count += 1;
    n /= 2;
  }
  if (count > 0) result[2] = count;
  count = 0;
  while (n % 3 === 0) {
    count += 1;
    n /= 3;
  }
  if (count > 0) result[3] = count;
  let done = false;
  while (!done) {
    if (n === 1) return result;
    const sr = Math.sqrt(n);
    done = true;
    for (let i = 6; i <= sr + 6; i += 6) {
      if (n % (i - 1) === 0) {
        result[i - 1] = (result[i - 1] ?? 0) + 1;
        n /= i - 1;
        done = false;
        break;
      }
      if (n % (i + 1) === 0) {
        result[i + 1] = (result[i + 1] ?? 0) + 1;
        n /= i + 1;
        done = false;
        break;
      }
    }
  }
  if (result[n] !== void 0) result[n] += 1;
  else result[n] = 1;
  return result;
}
function isPrime(n) {
  if (!Number.isInteger(n) || !Number.isFinite(n) || Number.isNaN(n) || n <= 1) {
    return false;
  }
  if (n <= LARGEST_SMALL_PRIME) return SMALL_PRIMES.has(n);
  for (const smallPrime of SMALL_PRIMES) {
    if (n % smallPrime === 0) return false;
  }
  if (n < LARGE_PRIME) n === leastFactor(n);
  return probablyPrime(n, 30) ? void 0 : false;
}
function leastFactor(n) {
  if (n === 1) return 1;
  if (n % 2 === 0) return 2;
  if (n % 3 === 0) return 3;
  if (n % 5 === 0) return 5;
  const m = Math.floor(Math.sqrt(n));
  let i = 7;
  while (i <= m) {
    if (n % i === 0) return i;
    if (n % (i + 4) === 0) return i + 4;
    if (n % (i + 6) === 0) return i + 6;
    if (n % (i + 10) === 0) return i + 10;
    if (n % (i + 12) === 0) return i + 12;
    if (n % (i + 16) === 0) return i + 16;
    if (n % (i + 22) === 0) return i + 22;
    if (n % (i + 24) === 0) return i + 24;
    i += 30;
  }
  return n;
}
function isPrimeBigint(n) {
  if (n <= 1) return false;
  if (n <= LARGEST_SMALL_PRIME) return isPrime(Number(n));
  for (const smallPrime of SMALL_PRIMES) {
    if (n % BigInt(smallPrime) === BigInt(0)) return false;
  }
  if (n < LARGE_PRIME) n = leastBigFactor(n);
  return probablyPrimeBigint(n, 30) ? void 0 : false;
}
function leastBigFactor(n) {
  if (n === BigInt(1)) return BigInt(1);
  if (n % BigInt(2) === BigInt(0)) return BigInt(2);
  if (n % BigInt(3) === BigInt(0)) return BigInt(3);
  if (n % BigInt(5) === BigInt(0)) return BigInt(5);
  const m = BigInt(Math.floor(Math.sqrt(Number(n))));
  let i = BigInt(7);
  while (i <= m) {
    if (n % i === BigInt(0)) return i;
    if (n % (i + BigInt(4)) === BigInt(0)) return i + BigInt(4);
    if (n % (i + BigInt(6)) === BigInt(0)) return i + BigInt(6);
    if (n % (i + BigInt(10)) === BigInt(0)) return i + BigInt(10);
    if (n % (i + BigInt(12)) === BigInt(0)) return i + BigInt(12);
    if (n % (i + BigInt(16)) === BigInt(0)) return i + BigInt(16);
    if (n % (i + BigInt(22)) === BigInt(0)) return i + BigInt(22);
    if (n % (i + BigInt(24)) === BigInt(0)) return i + BigInt(24);
    i += BigInt(30);
  }
  return n;
}
function probablyPrime(n, k) {
  let s = 0;
  let d = n - 1;
  while (d % 2 === 0) {
    d /= 2;
    ++s;
  }
  WitnessLoop: do {
    let x = Math.pow(2 + Math.floor(Math.random() * (n - 3)), d) % n;
    if (x === 1 || x === n - 1) continue;
    for (let i = s - 1; i--; ) {
      x = x * x % n;
      if (x === 1) return false;
      if (x === n - 1) continue WitnessLoop;
    }
    return false;
  } while (--k);
  return true;
}
function probablyPrimeBigint(n, k) {
  let s = 0;
  let d = n - BigInt(1);
  while (d % BigInt(2) === BigInt(0)) {
    d = d / BigInt(2);
    ++s;
  }
  WitnessLoop: do {
    let x = BigInt(2 + Math.floor(Math.random() * (Number(n) - 3))) ** d % n;
    if (x === BigInt(1) || x === n - BigInt(1)) continue;
    for (let i = s - 1; i--; ) {
      x = x * x % n;
      if (x === BigInt(1)) return false;
      if (x === n - BigInt(1)) continue WitnessLoop;
    }
    return false;
  } while (--k);
  return true;
}
var LARGE_PRIME, SMALL_PRIMES, LARGEST_SMALL_PRIME, PRIME_WHEEL_INC;
var init_primes = __esm({
  "src/compute-engine/numerics/primes.ts"() {
    init_bigint();
    LARGE_PRIME = 1125899906842597;
    SMALL_PRIMES = /* @__PURE__ */ new Set([
      2,
      3,
      5,
      7,
      11,
      13,
      17,
      19,
      23,
      29,
      31,
      37,
      41,
      43,
      47,
      53,
      59,
      61,
      67,
      71,
      73,
      79,
      83,
      89,
      97,
      101,
      103,
      107,
      109,
      113,
      127,
      131,
      137,
      139,
      149,
      151,
      157,
      163,
      167,
      173,
      179,
      181,
      191,
      193,
      197,
      199,
      211,
      223,
      227,
      229,
      233,
      239,
      241,
      251,
      257,
      263,
      269,
      271,
      277,
      281,
      283,
      293,
      307,
      311,
      313,
      317,
      331,
      337,
      347,
      349,
      353,
      359,
      367,
      373,
      379,
      383,
      389,
      397,
      401,
      409,
      419,
      421,
      431,
      433,
      439,
      443,
      449,
      457,
      461,
      463,
      467,
      479,
      487,
      491,
      499,
      503,
      509,
      521,
      523,
      541,
      547,
      557,
      563,
      569,
      571,
      577,
      587,
      593,
      599,
      601,
      607,
      613,
      617,
      619,
      631,
      641,
      643,
      647,
      653,
      659,
      661,
      673,
      677,
      683,
      691,
      701,
      709,
      719,
      727,
      733,
      739,
      743,
      751,
      757,
      761,
      769,
      773,
      787,
      797,
      809,
      811,
      821,
      823,
      827,
      829,
      839,
      853,
      857,
      859,
      863,
      877,
      881,
      883,
      887,
      907,
      911,
      919,
      929,
      937,
      941,
      947,
      953,
      967,
      971,
      977,
      983,
      991,
      997,
      1009,
      1013,
      1019,
      1021,
      1031,
      1033,
      1039,
      1049,
      1051,
      1061,
      1063,
      1069,
      1087,
      1091,
      1093,
      1097,
      1103,
      1109,
      1117,
      1123,
      1129,
      1151,
      1153,
      1163,
      1171,
      1181,
      1187,
      1193,
      1201,
      1213,
      1217,
      1223,
      1229,
      1231,
      1237,
      1249,
      1259,
      1277,
      1279,
      1283,
      1289,
      1291,
      1297,
      1301,
      1303,
      1307,
      1319,
      1321,
      1327,
      1361,
      1367,
      1373,
      1381,
      1399,
      1409,
      1423,
      1427,
      1429,
      1433,
      1439,
      1447,
      1451,
      1453,
      1459,
      1471,
      1481,
      1483,
      1487,
      1489,
      1493,
      1499,
      1511,
      1523,
      1531,
      1543,
      1549,
      1553,
      1559,
      1567,
      1571,
      1579,
      1583,
      1597,
      1601,
      1607,
      1609,
      1613,
      1619,
      1621,
      1627,
      1637,
      1657,
      1663,
      1667,
      1669,
      1693,
      1697,
      1699,
      1709,
      1721,
      1723,
      1733,
      1741,
      1747,
      1753,
      1759,
      1777,
      1783,
      1787,
      1789,
      1801,
      1811,
      1823,
      1831,
      1847,
      1861,
      1867,
      1871,
      1873,
      1877,
      1879,
      1889,
      1901,
      1907,
      1913,
      1931,
      1933,
      1949,
      1951,
      1973,
      1979,
      1987,
      1993,
      1997,
      1999,
      2003,
      2011,
      2017,
      2027,
      2029,
      2039,
      2053,
      2063,
      2069,
      2081,
      2083,
      2087,
      2089,
      2099,
      2111,
      2113,
      2129,
      2131,
      2137,
      2141,
      2143,
      2153,
      2161,
      2179,
      2203,
      2207,
      2213,
      2221,
      2237,
      2239,
      2243,
      2251,
      2267,
      2269,
      2273,
      2281,
      2287,
      2293,
      2297,
      2309,
      2311,
      2333,
      2339,
      2341,
      2347,
      2351,
      2357,
      2371,
      2377,
      2381,
      2383,
      2389,
      2393,
      2399,
      2411,
      2417,
      2423,
      2437,
      2441,
      2447,
      2459,
      2467,
      2473,
      2477,
      2503,
      2521,
      2531,
      2539,
      2543,
      2549,
      2551,
      2557,
      2579,
      2591,
      2593,
      2609,
      2617,
      2621,
      2633,
      2647,
      2657,
      2659,
      2663,
      2671,
      2677,
      2683,
      2687,
      2689,
      2693,
      2699,
      2707,
      2711,
      2713,
      2719,
      2729,
      2731,
      2741,
      2749,
      2753,
      2767,
      2777,
      2789,
      2791,
      2797,
      2801,
      2803,
      2819,
      2833,
      2837,
      2843,
      2851,
      2857,
      2861,
      2879,
      2887,
      2897,
      2903,
      2909,
      2917,
      2927,
      2939,
      2953,
      2957,
      2963,
      2969,
      2971,
      2999,
      3001,
      3011,
      3019,
      3023,
      3037,
      3041,
      3049,
      3061,
      3067,
      3079,
      3083,
      3089,
      3109,
      3119,
      3121,
      3137,
      3163,
      3167,
      3169,
      3181,
      3187,
      3191,
      3203,
      3209,
      3217,
      3221,
      3229,
      3251,
      3253,
      3257,
      3259,
      3271,
      3299,
      3301,
      3307,
      3313,
      3319,
      3323,
      3329,
      3331,
      3343,
      3347,
      3359,
      3361,
      3371,
      3373,
      3389,
      3391,
      3407,
      3413,
      3433,
      3449,
      3457,
      3461,
      3463,
      3467,
      3469,
      3491,
      3499,
      3511,
      3517,
      3527,
      3529,
      3533,
      3539,
      3541,
      3547,
      3557,
      3559,
      3571,
      3581,
      3583,
      3593,
      3607,
      3613,
      3617,
      3623,
      3631,
      3637,
      3643,
      3659,
      3671,
      3673,
      3677,
      3691,
      3697,
      3701,
      3709,
      3719,
      3727,
      3733,
      3739,
      3761,
      3767,
      3769,
      3779,
      3793,
      3797,
      3803,
      3821,
      3823,
      3833,
      3847,
      3851,
      3853,
      3863,
      3877,
      3881,
      3889,
      3907,
      3911,
      3917,
      3919,
      3923,
      3929,
      3931,
      3943,
      3947,
      3967,
      3989,
      4001,
      4003,
      4007,
      4013,
      4019,
      4021,
      4027,
      4049,
      4051,
      4057,
      4073,
      4079,
      4091,
      4093,
      4099,
      4111,
      4127,
      4129,
      4133,
      4139,
      4153,
      4157,
      4159,
      4177,
      4201,
      4211,
      4217,
      4219,
      4229,
      4231,
      4241,
      4243,
      4253,
      4259,
      4261,
      4271,
      4273,
      4283,
      4289,
      4297,
      4327,
      4337,
      4339,
      4349,
      4357,
      4363,
      4373,
      4391,
      4397,
      4409,
      4421,
      4423,
      4441,
      4447,
      4451,
      4457,
      4463,
      4481,
      4483,
      4493,
      4507,
      4513,
      4517,
      4519,
      4523,
      4547,
      4549,
      4561,
      4567,
      4583,
      4591,
      4597,
      4603,
      4621,
      4637,
      4639,
      4643,
      4649,
      4651,
      4657,
      4663,
      4673,
      4679,
      4691,
      4703,
      4721,
      4723,
      4729,
      4733,
      4751,
      4759,
      4783,
      4787,
      4789,
      4793,
      4799,
      4801,
      4813,
      4817,
      4831,
      4861,
      4871,
      4877,
      4889,
      4903,
      4909,
      4919,
      4931,
      4933,
      4937,
      4943,
      4951,
      4957,
      4967,
      4969,
      4973,
      4987,
      4993,
      4999,
      5003,
      5009,
      5011,
      5021,
      5023,
      5039,
      5051,
      5059,
      5077,
      5081,
      5087,
      5099,
      5101,
      5107,
      5113,
      5119,
      5147,
      5153,
      5167,
      5171,
      5179,
      5189,
      5197,
      5209,
      5227,
      5231,
      5233,
      5237,
      5261,
      5273,
      5279,
      5281,
      5297,
      5303,
      5309,
      5323,
      5333,
      5347,
      5351,
      5381,
      5387,
      5393,
      5399,
      5407,
      5413,
      5417,
      5419,
      5431,
      5437,
      5441,
      5443,
      5449,
      5471,
      5477,
      5479,
      5483,
      5501,
      5503,
      5507,
      5519,
      5521,
      5527,
      5531,
      5557,
      5563,
      5569,
      5573,
      5581,
      5591,
      5623,
      5639,
      5641,
      5647,
      5651,
      5653,
      5657,
      5659,
      5669,
      5683,
      5689,
      5693,
      5701,
      5711,
      5717,
      5737,
      5741,
      5743,
      5749,
      5779,
      5783,
      5791,
      5801,
      5807,
      5813,
      5821,
      5827,
      5839,
      5843,
      5849,
      5851,
      5857,
      5861,
      5867,
      5869,
      5879,
      5881,
      5897,
      5903,
      5923,
      5927,
      5939,
      5953,
      5981,
      5987,
      6007,
      6011,
      6029,
      6037,
      6043,
      6047,
      6053,
      6067,
      6073,
      6079,
      6089,
      6091,
      6101,
      6113,
      6121,
      6131,
      6133,
      6143,
      6151,
      6163,
      6173,
      6197,
      6199,
      6203,
      6211,
      6217,
      6221,
      6229,
      6247,
      6257,
      6263,
      6269,
      6271,
      6277,
      6287,
      6299,
      6301,
      6311,
      6317,
      6323,
      6329,
      6337,
      6343,
      6353,
      6359,
      6361,
      6367,
      6373,
      6379,
      6389,
      6397,
      6421,
      6427,
      6449,
      6451,
      6469,
      6473,
      6481,
      6491,
      6521,
      6529,
      6547,
      6551,
      6553,
      6563,
      6569,
      6571,
      6577,
      6581,
      6599,
      6607,
      6619,
      6637,
      6653,
      6659,
      6661,
      6673,
      6679,
      6689,
      6691,
      6701,
      6703,
      6709,
      6719,
      6733,
      6737,
      6761,
      6763,
      6779,
      6781,
      6791,
      6793,
      6803,
      6823,
      6827,
      6829,
      6833,
      6841,
      6857,
      6863,
      6869,
      6871,
      6883,
      6899,
      6907,
      6911,
      6917,
      6947,
      6949,
      6959,
      6961,
      6967,
      6971,
      6977,
      6983,
      6991,
      6997,
      7001,
      7013,
      7019,
      7027,
      7039,
      7043,
      7057,
      7069,
      7079,
      7103,
      7109,
      7121,
      7127,
      7129,
      7151,
      7159,
      7177,
      7187,
      7193,
      7207,
      7211,
      7213,
      7219,
      7229,
      7237,
      7243,
      7247,
      7253,
      7283,
      7297,
      7307,
      7309,
      7321,
      7331,
      7333,
      7349,
      7351,
      7369,
      7393,
      7411,
      7417,
      7433,
      7451,
      7457,
      7459,
      7477,
      7481,
      7487,
      7489,
      7499,
      7507,
      7517,
      7523,
      7529,
      7537,
      7541,
      7547,
      7549,
      7559,
      7561,
      7573,
      7577,
      7583,
      7589,
      7591,
      7603,
      7607,
      7621,
      7639,
      7643,
      7649,
      7669,
      7673,
      7681,
      7687,
      7691,
      7699,
      7703,
      7717,
      7723,
      7727,
      7741,
      7753,
      7757,
      7759,
      7789,
      7793,
      7817,
      7823,
      7829,
      7841,
      7853,
      7867,
      7873,
      7877,
      7879,
      7883,
      7901,
      7907,
      7919
    ]);
    LARGEST_SMALL_PRIME = 7919;
    PRIME_WHEEL_INC = [
      BigInt(4),
      BigInt(2),
      BigInt(4),
      BigInt(2),
      BigInt(4),
      BigInt(6),
      BigInt(2),
      BigInt(6)
    ];
  }
});

// src/compute-engine/numerics/numeric.ts
function canonicalInteger(n, exponent) {
  if (n >= Number.MAX_SAFE_INTEGER) return [1, n];
  if (n === 0) return [0, 0];
  if (n === 1) return [1, 1];
  console.assert(Number.isInteger(n) && n > 0 && n < Number.MAX_SAFE_INTEGER);
  if (exponent === 2) {
    const result = [
      [0, 0],
      [1, 1],
      [1, 2],
      [1, 3],
      [2, 1],
      [1, 5],
      [1, 6],
      [1, 7],
      [1, 8],
      [3, 1],
      [1, 10],
      [1, 11],
      [2, 3],
      [1, 13],
      [1, 14],
      [1, 15],
      [4, 1],
      [1, 17],
      [3, 2],
      [1, 19],
      [1, 20]
    ][n];
    if (result) return result;
  }
  const factors = primeFactors(n);
  let f = 1;
  let r = 1;
  for (const k of Object.keys(factors)) {
    const v = parseInt(k);
    f = f * Math.pow(v, Math.floor(factors[k] / exponent));
    r = r * Math.pow(v, factors[k] % exponent);
  }
  return [f, r];
}
function gcd(a, b) {
  if (a === 0) return b;
  if (b === 0) return a;
  if (a === b) return a;
  if (!Number.isInteger(a) || !Number.isInteger(b)) return NaN;
  while (b !== 0) [a, b] = [b, a % b];
  return a < 0 ? -a : a;
}
function lcm(a, b) {
  return a * b / gcd(a, b);
}
function factorial2(n) {
  if (!Number.isInteger(n) || n < 0) return NaN;
  if (n >= 170) return Infinity;
  let val = 1;
  for (let i = 2; i <= n; i++) val = val * i;
  return val;
}
function factorial22(n) {
  if (!Number.isInteger(n) || n < 0) return NaN;
  if (n < 0) return NaN;
  if (n <= 1) return 1;
  let result = n;
  while (n > 2) {
    n -= 2;
    result *= n;
  }
  return result;
}
function chop(n, tolerance = DEFAULT_TOLERANCE) {
  if (typeof n === "number" && Math.abs(n) <= tolerance) return 0;
  return n;
}
function centeredDiff8thOrder(f, x, h = 0.1) {
  return (f(x - 4 * h) / 280 - 4 * f(x - 3 * h) / 105 + f(x - 2 * h) / 5 - 4 * f(x - h) / 5 + 4 * f(x + h) / 5 - f(x + 2 * h) / 5 + 4 * f(x + 3 * h) / 105 - f(x + 4 * h) / 280) / h;
}
function limit(f, x, dir = 1) {
  if (dir === 0) {
    const left = limit(f, x, -1);
    const right = limit(f, x, 1);
    if (left === void 0 || right === void 0) return NaN;
    if (Math.abs(left - right) > 1e-5) return NaN;
    return (left + right) / 2;
  }
  const [val, _err] = extrapolate(f, x, { step: dir > 0 ? 1 : -1 });
  return val;
}
function* cantorEnumerateRationals() {
  yield [0, 1];
  for (let s = 1; ; s++) {
    for (let n = 0; n <= s; n++) {
      const d = s - n;
      if (d === 0) continue;
      if (gcd(n, d) !== 1) continue;
      yield [n, d];
      yield [-n, d];
    }
  }
}
function* cantorEnumeratePositiveRationals() {
  yield [0, 1];
  for (let s = 1; ; s++) {
    for (let n = 0; n <= s; n++) {
      const d = s - n;
      if (d === 0) continue;
      if (gcd(n, d) !== 1) continue;
      yield [n, d];
    }
  }
}
function* cantorEnumerateComplexNumbers() {
  yield [0, 0];
  for (let s = 1; ; s++) {
    for (let na = 0; na <= s; na++) {
      const da = s - na;
      if (da === 0 || gcd(na, da) !== 1) continue;
      const a = na / da;
      for (let nb = 0; nb <= s; nb++) {
        const db = s - nb;
        if (db === 0 || gcd(nb, db) !== 1) continue;
        const b = nb / db;
        yield [a, b];
        yield [-a, b];
        yield [a, -b];
        yield [-a, -b];
      }
    }
  }
}
function* cantorEnumerateIntegers() {
  yield 0;
  for (let n = 1; ; n++) {
    yield n;
    yield -n;
  }
}
var DEFAULT_PRECISION, MACHINE_PRECISION_BITS, MACHINE_PRECISION, DEFAULT_TOLERANCE, SMALL_INTEGER, MAX_BIGINT_DIGITS, MAX_ITERATION;
var init_numeric = __esm({
  "src/compute-engine/numerics/numeric.ts"() {
    init_richardson();
    init_primes();
    DEFAULT_PRECISION = 21;
    MACHINE_PRECISION_BITS = 53;
    MACHINE_PRECISION = Math.floor(
      Math.log10(Math.pow(2, MACHINE_PRECISION_BITS))
    );
    DEFAULT_TOLERANCE = 1e-10;
    SMALL_INTEGER = 1e6;
    MAX_BIGINT_DIGITS = 1024;
    MAX_ITERATION = 1e4;
  }
});

// src/math-json/utils.ts
function isNumberExpression(expr) {
  if (typeof expr === "number" || isNumberObject(expr)) return true;
  if (typeof expr === "string" && matchesNumber(expr)) return true;
  return false;
}
function isNumberObject(expr) {
  return expr !== null && typeof expr === "object" && "num" in expr;
}
function isSymbolObject(expr) {
  return expr !== null && typeof expr === "object" && "sym" in expr;
}
function isStringObject(expr) {
  return expr !== null && typeof expr === "object" && "str" in expr;
}
function isDictionaryObject(expr) {
  return expr !== null && typeof expr === "object" && "dict" in expr && typeof expr.dict === "object" && !Array.isArray(expr.dict) && expr.dict !== null;
}
function isFunctionObject(expr) {
  return expr !== null && typeof expr === "object" && "fn" in expr && Array.isArray(expr.fn) && expr.fn.length > 0 && typeof expr.fn[0] === "string";
}
function isExpressionObject(expr) {
  return expr !== null && typeof expr === "object" && ("fn" in expr || "num" in expr || "sym" in expr || "str" in expr);
}
function hasMetaData(expr) {
  return isExpressionObject(expr) && (expr.latex !== void 0 || expr.wikidata !== void 0);
}
function stringValue(expr) {
  if (expr === null || expr === void 0) return null;
  if (typeof expr === "object" && "str" in expr) return expr.str;
  if (typeof expr !== "string") return null;
  if (expr.length >= 2 && expr.at(0) === "'" && expr.at(-1) === "'")
    return expr.substring(1, expr.length - 1);
  if (matchesNumber(expr) || matchesSymbol(expr)) return null;
  return expr;
}
function stripText(expr) {
  if (expr === null || expr === void 0 || stringValue(expr) !== null)
    return null;
  const h = operator(expr);
  if (!h) return expr;
  return [
    h,
    ...operands(expr).map((x) => stripText(x)).filter((x) => x !== null)
  ];
}
function operator(expr) {
  if (Array.isArray(expr)) return expr[0];
  if (expr === null || expr === void 0) return "";
  if (isFunctionObject(expr)) return expr.fn[0];
  return "";
}
function operands(expr) {
  if (Array.isArray(expr)) return expr.slice(1);
  if (expr !== void 0 && isFunctionObject(expr)) return expr.fn.slice(1);
  return [];
}
function operand(expr, n) {
  if (Array.isArray(expr)) return expr[n] ?? null;
  if (expr === null || !isFunctionObject(expr)) return null;
  return expr.fn[n] ?? null;
}
function nops(expr) {
  if (expr === null || expr === void 0) return 0;
  if (Array.isArray(expr)) return Math.max(0, expr.length - 1);
  if (isFunctionObject(expr)) return Math.max(0, expr.fn.length - 1);
  return 0;
}
function unhold(expr) {
  if (expr === null || expr === void 0) return null;
  if (operator(expr) === "Hold") return operand(expr, 1);
  return expr;
}
function symbol(expr) {
  if (typeof expr === "string" && matchesSymbol(expr)) {
    if (expr.length >= 2 && expr.at(0) === "`" && expr.at(-1) === "`")
      return expr.slice(1, -1);
    return expr;
  }
  if (expr === null || expr === void 0) return null;
  if (isSymbolObject(expr)) return expr.sym;
  return null;
}
function keyValuePair(expr) {
  const h = operator(expr);
  if (h === "KeyValuePair" || h === "Tuple" || h === "Pair") {
    const [k, v] = operands(expr);
    const key = stringValue(k);
    if (!key) return null;
    return [key, v ?? "Nothing"];
  }
  return null;
}
function dictionaryFromExpression(expr) {
  if (expr === null) return null;
  if (isDictionaryObject(expr)) return expr;
  const kv = keyValuePair(expr);
  if (kv) return { [kv[0]]: kv[1] };
  if (operator(expr) === "Dictionary") {
    const dict = {};
    const ops = operands(expr);
    for (let i = 1; i < nops(expr); i++) {
      const kv2 = keyValuePair(ops[i]);
      if (kv2) {
        dict[kv2[0]] = expressionToDictionaryValue(kv2[1]) ?? "Nothing";
      }
    }
    return { dict };
  }
  return null;
}
function dictionaryFromEntries(dict) {
  const entries = Object.fromEntries(
    Object.entries(dict).map(([k, v]) => [
      k,
      jsValueToExpression(v) ?? "Nothing"
    ])
  );
  return { dict: entries };
}
function machineValueOfString(s) {
  s = s.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
  if (s === "nan") return NaN;
  if (/^(infinity|\+infinity|oo|\+oo)$/i.test(s)) return Infinity;
  if (/^(-infinity|-oo)$/.test(s)) return -Infinity;
  if (/\([0-9]+\)/.test(s)) {
    const [_, body, repeat2, trail] = s.match(/(.+)\(([0-9]+)\)(.*)$/) ?? [];
    s = body + repeat2.repeat(Math.ceil(16 / repeat2.length)) + (trail ?? "");
  }
  return parseFloat(s);
}
function machineValue(expr) {
  if (typeof expr === "number") return expr;
  if (typeof expr === "string" && matchesNumber(expr))
    return machineValueOfString(expr);
  if (expr !== void 0 && isNumberObject(expr)) return machineValue(expr.num);
  return null;
}
function rationalValue(expr) {
  if (expr === void 0 || expr === null) return null;
  if (symbol(expr) === "Half") return [1, 2];
  const h = operator(expr);
  if (!h) return null;
  let numer = null;
  let denom = null;
  if (h === "Negate") {
    const r = rationalValue(operands(expr)[0]);
    if (r) return [-r[0], r[1]];
  }
  if (h === "Rational" || h === "Divide") {
    const [n, d] = operands(expr);
    numer = machineValue(n) ?? NaN;
    denom = machineValue(d) ?? NaN;
  }
  if (h === "Power") {
    const [base, exp3] = operands(expr);
    const exponent = machineValue(exp3);
    if (exponent === 1) {
      numer = machineValue(base);
      denom = 1;
    } else if (exponent === -1) {
      numer = 1;
      denom = machineValue(base);
    }
  }
  if (h === "Multiply") {
    const [op1, op2] = operands(expr);
    if (operator(op2) === "Power") {
      const [op21, op22] = operands(op2);
      if (machineValue(op22) === -1) {
        numer = machineValue(op1);
        denom = machineValue(op21);
      }
    }
  }
  if (numer === null || denom === null) return null;
  if (Number.isInteger(numer) && Number.isInteger(denom)) return [numer, denom];
  return null;
}
function mapArgs(expr, fn) {
  let args = null;
  if (Array.isArray(expr)) args = expr;
  if (isFunctionObject(expr)) args = expr.fn;
  if (args === null) return [];
  let i = 1;
  const result = [];
  while (i < args.length) {
    result.push(fn(args[i]));
    i += 1;
  }
  return result;
}
function foldAssociativeOperator(op, lhs, rhs) {
  const lhsName = operator(lhs);
  const rhsName = operator(rhs);
  if (lhsName === op && rhsName === op)
    return [op, ...operands(lhs), ...operands(rhs)];
  if (lhsName === op) return [op, ...operands(lhs), rhs];
  if (rhsName === op) return [op, lhs, ...operands(rhs)];
  return [op, lhs, rhs];
}
function getSequence(expr) {
  if (expr === null || expr === void 0) return null;
  let h = operator(expr);
  if (h === "Delimiter") {
    expr = operand(expr, 1);
    if (expr === null) return [];
    h = operator(expr);
    if (h !== "Sequence") return [expr];
  }
  if (h !== "Sequence") return null;
  return operands(expr);
}
function isEmptySequence(expr) {
  if (expr === null || expr === void 0) return true;
  if (expr === "Nothing") return true;
  return operator(expr) === "Sequence" && nops(expr) === 0;
}
function missingIfEmpty(expr) {
  return isEmptySequence(expr) ? MISSING : expr;
}
function countFunctionLeaves(xs) {
  if (xs[0] === "Square") {
    return countFunctionLeaves(xs.slice(1)) + 2;
  }
  return xs.reduce((acc, x) => acc + countLeaves(x), 0);
}
function countLeaves(expr) {
  if (expr === null) return 0;
  if (typeof expr === "number" || typeof expr === "string") return 1;
  if (isNumberExpression(expr) || isSymbolObject(expr) || isStringObject(expr))
    return 1;
  if (Array.isArray(expr)) return countFunctionLeaves(expr);
  if ("fn" in expr) return countFunctionLeaves(expr.fn);
  const dict = dictionaryFromExpression(expr);
  if (dict) {
    const keys = Object.keys(dict);
    return 1 + keys.length + keys.reduce((acc, x) => acc + countLeaves(dict[x]), 0);
  }
  return 0;
}
function matchesNumber(s) {
  return /^(nan|oo|\+oo|-oo|infinity|\+infinity|-infinity)$/i.test(s) || /^[+-]?(0|[1-9][0-9]*)(\.[0-9]+)?(\([0-9]+\))?([eE][+-]?[0-9]+)?$/.test(s);
}
function matchesSymbol(s) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s) || s.length >= 2 && s[0] === "`" && s[s.length - 1] === "`";
}
function matchesString(s) {
  if (s.length >= 2 && s[0] === "'" && s[s.length - 1] === "'") {
    return true;
  }
  return !matchesNumber(s) && !matchesSymbol(s);
}
function jsValueToExpression(v) {
  if (typeof v === "string") {
    return { str: v };
  } else if (typeof v === "number") {
    return { num: v.toString() };
  } else if (typeof v === "boolean") {
    return v ? "True" : "False";
  } else if (Array.isArray(v)) {
    return ["List", ...v.map((x) => jsValueToExpression(x) ?? "Nothing")];
  } else if (v === null) {
    return null;
  } else if (typeof v === "object") {
    const dict = {};
    for (const key in v) {
      dict[key] = jsValueToExpression(v[key]) ?? "Nothing";
    }
    return { dict };
  }
  if (isFunctionObject(v) || isSymbolObject(v) || isNumberObject(v) || isStringObject(v) || isDictionaryObject(v)) {
    return v;
  }
  return null;
}
function expressionToDictionaryValue(expr) {
  if (expr === null || expr === void 0) return null;
  if (isStringObject(expr)) return expr.str;
  if (isNumberObject(expr)) return parseFloat(expr.num);
  if (isSymbolObject(expr)) return expr.sym;
  if (typeof expr === "string" || typeof expr === "number") return expr;
  if (Array.isArray(expr)) return { fn: expr };
  return expr;
}
var MISSING;
var init_utils2 = __esm({
  "src/math-json/utils.ts"() {
    MISSING = ["Error", "'missing'"];
  }
});

// src/common/grapheme-splitter.ts
function stringToCodepoints(string) {
  const result = [];
  for (let i = 0; i < string.length; i++) {
    let code = string.charCodeAt(i);
    if (code >= 55296 && code <= 56319) {
      const nextCode = string.charCodeAt(i + 1);
      if (nextCode >= 56320 && nextCode <= 57343) {
        const lead = code - 55296;
        const trail = nextCode - 56320;
        code = 2 ** 16 + lead * 2 ** 10 + trail;
        i++;
      }
    }
    result.push(code);
  }
  return result;
}
function isEmojiCombinator(code) {
  if (code === ZWJ2) return true;
  if (code === 65038 || code === 65039) return true;
  if (code >= 127995 && code <= 127995 + 5) return true;
  if (code >= 129456 && code <= 129456 + 4) return true;
  if (code >= 917536 && code <= 917536 + 96) return true;
  return false;
}
function isRegionalIndicator(code) {
  return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
}
function splitGraphemes(string) {
  if (/^[\u0020-\u00FF]*$/.test(string)) return string;
  const result = [];
  const codePoints = stringToCodepoints(string);
  let index = 0;
  while (index < codePoints.length) {
    const code = codePoints[index++];
    const next = codePoints[index];
    if (next === ZWJ2) {
      const baseIndex = index - 1;
      index += 2;
      while (codePoints[index] === ZWJ2) {
        index += 2;
      }
      result.push(
        String.fromCodePoint(
          ...codePoints.slice(baseIndex, 2 * index - baseIndex + 1)
        )
      );
    } else if (isEmojiCombinator(next)) {
      const baseIndex = index - 1;
      while (isEmojiCombinator(codePoints[index])) {
        index += codePoints[index] === ZWJ2 ? 2 : 1;
      }
      result.push(
        String.fromCodePoint(
          ...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)
        )
      );
    } else if (isRegionalIndicator(code)) {
      index += 1;
      result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
    } else {
      result.push(String.fromCodePoint(code));
    }
  }
  return result;
}
var ZWJ2, REGIONAL_INDICATOR;
var init_grapheme_splitter = __esm({
  "src/common/grapheme-splitter.ts"() {
    ZWJ2 = 8205;
    REGIONAL_INDICATOR = [127462, 127487];
  }
});

// src/compute-engine/latex-syntax/tokenizer.ts
function expand(lex2, args) {
  let token = lex2.next();
  if (!token) return [];
  let result = [];
  if (token === "\\relax") {
  } else if (token === "\\noexpand") {
    token = lex2.next();
    if (token) {
      result.push(token);
    }
  } else if (token === "\\obeyspaces") {
    lex2.obeyspaces = true;
  } else if (token === "\\space" || token === "~") {
    result.push("<space>");
  } else if (token === "\\bgroup") {
    result.push("<{>");
  } else if (token === "\\egroup") {
    result.push("<}>");
  } else if (token === "\\string") {
    token = lex2.next();
    if (token) {
      if (token[0] === "\\") {
        Array.from(token).forEach(
          (x) => result.push(x === "\\" ? "\\backslash" : x)
        );
      } else if (token === "<{>") {
        result.push("\\{");
      } else if (token === "<space>") {
        result.push("~");
      } else if (token === "<}>") {
        result.push("\\}");
      }
    }
  } else if (token === "\\csname") {
    while (lex2.peek() === "<space>") {
      lex2.next();
    }
    let command = "";
    let done = false;
    let tokens = [];
    do {
      if (tokens.length === 0) {
        if (/^#[0-9?]$/.test(lex2.peek())) {
          const param = lex2.get().slice(1);
          tokens = tokenize(
            args?.[param] ?? args?.["?"] ?? "\\placeholder{}",
            args
          );
          token = tokens[0];
        } else {
          token = lex2.next();
          tokens = token ? [token] : [];
        }
      }
      done = tokens.length === 0;
      if (!done && token === "\\endcsname") {
        done = true;
        tokens.shift();
      }
      if (!done) {
        done = token === "<$>" || token === "<$$>" || token === "<{>" || token === "<}>" || !!token && token.length > 1 && token[0] === "\\";
      }
      if (!done) {
        command += tokens.shift();
      }
    } while (!done);
    if (command) {
      result.push("\\" + command);
    }
    result = result.concat(tokens);
  } else if (token === "\\endcsname") {
  } else if (token.length > 1 && token[0] === "#") {
    const param = token.slice(1);
    result = result.concat(
      tokenize(args?.[param] ?? args?.["?"] ?? "\\placeholder{}", args)
    );
  } else {
    result.push(token);
  }
  return result;
}
function tokenize(s, args = []) {
  const lines = s.toString().split(/\r?\n/);
  let stream = "";
  let sep = "";
  for (const line of lines) {
    stream += sep;
    sep = " ";
    const m = line.match(/((?:\\%)|[^%])*/);
    if (m !== null) stream += m[0];
  }
  const tokenizer = new Tokenizer(stream);
  const result = [];
  do
    result.push(...expand(tokenizer, args));
  while (!tokenizer.end());
  return result;
}
function countTokens(s) {
  return tokenize(s).length;
}
function joinLatex(segments) {
  let sep = "";
  let result = "";
  for (const segment of segments) {
    if (segment === void 0 || segment === null) continue;
    if (typeof segment === "string") {
      if (/[a-zA-Z]/.test(segment[0])) result += sep;
      if (/\\[a-zA-Z]+\*?$/.test(segment)) sep = " ";
      else sep = "";
    }
    result += segment.toString();
  }
  return result;
}
function supsub(c, body, x) {
  if (body.includes(c)) body = `{${body}}`;
  if (/^[0-9]$/.test(x)) return `${body}${c}${x}`;
  return `${body}${c}{${x}}`;
}
function tokensToString(tokens) {
  let flat = [];
  if (Array.isArray(tokens)) {
    for (const item of tokens) {
      if (Array.isArray(item)) {
        flat = [...flat, ...item];
      } else {
        flat.push(item);
      }
    }
  } else {
    flat = [tokens];
  }
  const result = joinLatex(
    flat.map((token) => {
      return {
        "<space>": " ",
        "<$$>": "$$",
        "<$>": "$",
        "<{>": "{",
        "<}>": "}"
      }[token] ?? token;
    })
  );
  return result;
}
var Tokenizer;
var init_tokenizer = __esm({
  "src/compute-engine/latex-syntax/tokenizer.ts"() {
    init_grapheme_splitter();
    Tokenizer = class {
      s;
      pos;
      obeyspaces = false;
      constructor(s) {
        s = s.replace(/[\u200E\u200F\u2066-\u2069\u202A-\u202E]/g, "");
        s = s.replace(/\u2212/g, "-");
        this.s = splitGraphemes(s);
        this.pos = 0;
      }
      /**
       * @return True if we reached the end of the stream
       */
      end() {
        return this.pos >= this.s.length;
      }
      /**
       * Return the next char and advance
       */
      get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
      }
      /**
       * Return the next char, but do not advance
       */
      peek() {
        return this.s[this.pos];
      }
      /**
       * Return the next substring matching regEx and advance.
       */
      match(regEx) {
        let execResult;
        if (typeof this.s === "string") {
          execResult = regEx.exec(this.s.slice(this.pos));
        } else {
          execResult = regEx.exec(this.s.slice(this.pos).join(""));
        }
        if (execResult?.[0]) {
          this.pos += execResult[0].length;
          return execResult[0];
        }
        return null;
      }
      /**
       * Return the next token, or null.
       */
      next() {
        if (this.end()) return null;
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) {
          return "<space>";
        } else if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) {
          return "<space>";
        }
        const next = this.get();
        if (next === "\\") {
          if (!this.end()) {
            let command = this.match(/^[a-zA-Z]+/);
            if (command) {
              this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
            } else {
              command = this.get();
              if (command === " ") {
                return "<space>";
              }
            }
            return "\\" + command;
          }
        } else if (next === "{") {
          return "<{>";
        } else if (next === "}") {
          return "<}>";
        } else if (next === "^") {
          if (this.peek() === "^") {
            this.get();
            const hex = this.match(
              /^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/
            );
            if (hex) {
              return String.fromCodePoint(
                parseInt(hex.slice(hex.lastIndexOf("^") + 1), 16)
              );
            }
          }
          return next;
        } else if (next === "#") {
          if (!this.end()) {
            let isParam = false;
            if (/[0-9?]/.test(this.peek())) {
              isParam = true;
              if (this.pos + 1 < this.s.length) {
                const after = this.s[this.pos + 1];
                isParam = /[^0-9A-Za-z]/.test(after);
              }
            }
            if (isParam) {
              return "#" + this.get();
            }
            return "#";
          }
        } else if (next === "$") {
          if (this.peek() === "$") {
            this.get();
            return "<$$>";
          }
          return "<$>";
        }
        return next;
      }
    };
  }
});

// src/compute-engine/latex-syntax/types.ts
function isExpressionEntry(entry) {
  return !("kind" in entry) || entry.kind === "expression";
}
function isSymbolEntry(entry) {
  return "kind" in entry && entry.kind === "symbol";
}
function isMatchfixEntry(entry) {
  return "kind" in entry && entry.kind === "matchfix";
}
function isInfixEntry(entry) {
  return "kind" in entry && entry.kind === "infix";
}
function isPrefixEntry(entry) {
  return "kind" in entry && entry.kind === "prefix";
}
function isPostfixEntry(entry) {
  return "kind" in entry && entry.kind === "postfix";
}
function isEnvironmentEntry(entry) {
  return "kind" in entry && entry.kind === "environment";
}
var COMPARISON_PRECEDENCE, ASSIGNMENT_PRECEDENCE, ARROW_PRECEDENCE, ADDITION_PRECEDENCE, MULTIPLICATION_PRECEDENCE, DIVISION_PRECEDENCE, INVISIBLE_OP_PRECEDENCE, EXPONENTIATION_PRECEDENCE, POSTFIX_PRECEDENCE;
var init_types = __esm({
  "src/compute-engine/latex-syntax/types.ts"() {
    COMPARISON_PRECEDENCE = 245;
    ASSIGNMENT_PRECEDENCE = 260;
    ARROW_PRECEDENCE = 270;
    ADDITION_PRECEDENCE = 275;
    MULTIPLICATION_PRECEDENCE = 390;
    DIVISION_PRECEDENCE = 600;
    INVISIBLE_OP_PRECEDENCE = 650;
    EXPONENTIATION_PRECEDENCE = 700;
    POSTFIX_PRECEDENCE = 810;
  }
});

// src/compute-engine/latex-syntax/serializer-style.ts
function getApplyFunctionStyle(_expr, _level) {
  return "normal";
}
function getGroupStyle(_expr, _level) {
  return "normal";
}
function getRootStyle(_expr, level) {
  return level > 2 ? "solidus" : "radical";
}
function getFractionStyle(expr, level) {
  if (level > 3) return "inline-solidus";
  if (operator(expr) === "Divide") {
    const [op1, op2] = operands(expr);
    const [n, d] = [countLeaves(op1), countLeaves(op2)];
    if (d <= 2 && n > 5) return "factor";
    const denomOp = operator(op2);
    if (n <= 2 && d > 5 && denomOp !== "Sqrt" && denomOp !== "Root")
      return "reciprocal";
  }
  return "quotient";
}
function getLogicStyle(_expr, _level) {
  return "boolean";
}
function getPowerStyle(_expr, _level) {
  return "solidus";
}
function getNumericSetStyle(_expr, _level) {
  return "compact";
}
function latexTemplate(s, lhs, rhs) {
  if (s.indexOf("#1") < 0 && s.indexOf("#2") < 0) s = `#1 ${s} #2`;
  const parts = s.split(/(#\d+)/).filter((x) => x.trim() !== "").map((x) => x.trim());
  return joinLatex(
    parts.map((x) => {
      switch (x) {
        case "#1":
          return lhs;
        case "#2":
          return rhs;
        default:
          return x;
      }
    })
  );
}
var init_serializer_style = __esm({
  "src/compute-engine/latex-syntax/serializer-style.ts"() {
    init_utils2();
    init_tokenizer();
  }
});

// src/compute-engine/latex-syntax/dictionary/definitions-relational-operators.ts
var DEFINITIONS_INEQUALITIES;
var init_definitions_relational_operators = __esm({
  "src/compute-engine/latex-syntax/dictionary/definitions-relational-operators.ts"() {
    init_types();
    DEFINITIONS_INEQUALITIES = [
      {
        latexTrigger: ["\\not", "<"],
        kind: "infix",
        associativity: "any",
        precedence: 246,
        parse: "NotLess"
      },
      {
        name: "NotLess",
        latexTrigger: ["\\nless"],
        kind: "infix",
        associativity: "any",
        precedence: 246
      },
      {
        latexTrigger: ["<"],
        kind: "infix",
        associativity: "any",
        precedence: 245,
        parse: "Less"
      },
      {
        name: "Less",
        latexTrigger: ["\\lt"],
        kind: "infix",
        associativity: "any",
        precedence: 245
      },
      {
        latexTrigger: ["<", "="],
        kind: "infix",
        associativity: "any",
        precedence: 241,
        parse: "LessEqual"
      },
      {
        name: "LessEqual",
        latexTrigger: ["\\le"],
        kind: "infix",
        associativity: "any",
        precedence: 241
      },
      {
        latexTrigger: ["\\leq"],
        kind: "infix",
        associativity: "any",
        precedence: 241,
        parse: "LessEqual"
      },
      {
        latexTrigger: ["\\leqslant"],
        kind: "infix",
        associativity: "any",
        precedence: COMPARISON_PRECEDENCE + 5,
        // Note different precedence than `<=` as per MathML
        parse: "LessEqual"
      },
      {
        name: "LessNotEqual",
        latexTrigger: ["\\lneqq"],
        kind: "infix",
        associativity: "any",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotLessNotEqual",
        latexTrigger: ["\\nleqq"],
        kind: "infix",
        associativity: "any",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "LessOverEqual",
        latexTrigger: ["\\leqq"],
        kind: "infix",
        associativity: "any",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "GreaterOverEqual",
        latexTrigger: ["\\geqq"],
        kind: "infix",
        associativity: "any",
        precedence: COMPARISON_PRECEDENCE + 5,
        parse: "GreaterEqual"
      },
      {
        name: "Equal",
        latexTrigger: ["="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        latexTrigger: ["*", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE,
        parse: "StarEqual"
      },
      {
        name: "StarEqual",
        latexTrigger: ["\\star", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "PlusEqual",
        latexTrigger: ["+", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "MinusEqual",
        latexTrigger: ["-", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "SlashEqual",
        latexTrigger: ["/", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "EqualEqual",
        latexTrigger: ["=", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "EqualEqualEqual",
        latexTrigger: ["=", "=", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "TildeFullEqual",
        // MathML: approximately equal to
        latexTrigger: ["\\cong"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotTildeFullEqual",
        // MathML: approximately but not actually equal to
        latexTrigger: ["\\ncong"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "Approx",
        // Note: Mathematica TildeTilde
        latexTrigger: ["\\approx"],
        kind: "infix",
        associativity: "right",
        precedence: 247
      },
      {
        name: "NotApprox",
        // Note: Mathematica TildeTilde
        latexTrigger: ["\\not", "\\approx"],
        kind: "infix",
        associativity: "right",
        precedence: 247
      },
      {
        name: "ApproxEqual",
        // Note: Mathematica TildeEqual, MathML: `asymptotically equal to`
        latexTrigger: ["\\approxeq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotApproxEqual",
        // Note: Mathematica NotTildeEqual
        latexTrigger: ["\\not", "\\approxeq"],
        kind: "infix",
        // Note: no LaTeX symbol for char U+2249
        associativity: "right",
        precedence: 250
      },
      {
        name: "NotEqual",
        latexTrigger: ["\\ne"],
        kind: "infix",
        associativity: "right",
        precedence: 255
      },
      {
        name: "Unequal",
        latexTrigger: ["!", "="],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
        // Note different precedence than \\ne per MathML
      },
      {
        name: "GreaterEqual",
        latexTrigger: ["\\ge"],
        kind: "infix",
        associativity: "right",
        precedence: 242
        // Note: different precedence than `>=` as per MathML
      },
      {
        latexTrigger: ["\\geq"],
        kind: "infix",
        associativity: "right",
        precedence: 242,
        // Note: different precedence than `>=` as per MathML
        parse: "GreaterEqual"
      },
      {
        latexTrigger: [">", "="],
        kind: "infix",
        associativity: "right",
        precedence: 243,
        parse: "GreaterEqual"
      },
      {
        latexTrigger: ["\\geqslant"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5,
        // Note: different precedence than `>=` as per MathML
        parse: "GreaterEqual"
      },
      {
        name: "GreaterNotEqual",
        latexTrigger: ["\\gneqq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotGreaterNotEqual",
        latexTrigger: ["\\ngeqq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        latexTrigger: [">"],
        kind: "infix",
        associativity: "right",
        precedence: 245,
        parse: "Greater"
      },
      {
        name: "Greater",
        latexTrigger: ["\\gt"],
        kind: "infix",
        associativity: "right",
        precedence: 245
      },
      {
        name: "NotGreater",
        latexTrigger: ["\\ngtr"],
        kind: "infix",
        associativity: "right",
        precedence: 244
      },
      {
        latexTrigger: ["\\not", ">"],
        kind: "infix",
        associativity: "right",
        precedence: 244,
        parse: "NotGreater"
      },
      {
        name: "RingEqual",
        latexTrigger: ["\\circeq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "TriangleEqual",
        // MathML: delta equal to
        latexTrigger: ["\\triangleq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "DotEqual",
        // MathML: approaches the limit
        latexTrigger: ["\\doteq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "DotEqualDot",
        // MathML: Geometrically equal
        latexTrigger: ["\\doteqdot"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "FallingDotEqual",
        // MathML: approximately equal to or the image of
        latexTrigger: ["\\fallingdotseq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "RisingDotEqual",
        // MathML: image of or approximately equal to
        latexTrigger: ["\\fallingdotseq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      },
      {
        name: "QuestionEqual",
        latexTrigger: ["\\questeq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "MuchLess",
        latexTrigger: ["\\ll"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "MuchGreater",
        latexTrigger: ["\\gg"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "Precedes",
        latexTrigger: ["\\prec"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "Succeeds",
        latexTrigger: ["\\succ"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "PrecedesEqual",
        latexTrigger: ["\\preccurlyeq"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "SucceedsEqual",
        latexTrigger: ["\\curlyeqprec"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotPrecedes",
        latexTrigger: ["\\nprec"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "NotSucceeds",
        latexTrigger: ["\\nsucc"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE
      },
      {
        name: "Between",
        latexTrigger: ["\\between"],
        kind: "infix",
        associativity: "right",
        precedence: COMPARISON_PRECEDENCE + 5
      }
    ];
  }
});

// src/compute-engine/latex-syntax/utils.ts
function isLatexString(s) {
  if (typeof s === "string") return s.startsWith("$") && s.endsWith("$");
  return false;
}
function asLatexString(s) {
  if (typeof s === "number") return s.toString();
  if (typeof s === "string") {
    const str = s.trim();
    if (str.startsWith("$$") && str.endsWith("$$")) return str.slice(2, -2);
    if (str.startsWith("$") && str.endsWith("$")) return str.slice(1, -1);
  }
  if (Array.isArray(s)) {
    return asLatexString(joinLatex(s));
  }
  return null;
}
function isRelationalOperator(name) {
  if (typeof name !== "string") return false;
  return DEFINITIONS_INEQUALITIES.some((x) => x.name === name);
}
function isInequalityOperator(operator2) {
  if (typeof operator2 !== "string") return false;
  return ["Less", "LessEqual", "Greater", "GreaterEqual"].includes(operator2);
}
function isEquationOperator(operator2) {
  if (typeof operator2 !== "string") return false;
  return ["Equal", "NotEqual"].includes(operator2);
}
var init_utils3 = __esm({
  "src/compute-engine/latex-syntax/utils.ts"() {
    init_tokenizer();
    init_definitions_relational_operators();
  }
});

// src/compute-engine/latex-syntax/dictionary/definitions-core.ts
function parseSequence(parser, terminator, lhs, prec, sep) {
  if (terminator && terminator.minPrec >= prec) return null;
  const result = lhs ? [lhs] : ["Nothing"];
  let done = false;
  while (!done) {
    done = true;
    parser.skipSpace();
    while (parser.match(sep)) {
      result.push("Nothing");
      parser.skipSpace();
    }
    if (parser.atTerminator(terminator)) {
      result.push("Nothing");
    } else {
      const rhs = parser.parseExpression({ ...terminator, minPrec: prec });
      result.push(rhs ?? "Nothing");
      done = rhs === null;
    }
    if (!done) {
      parser.skipSpace();
      done = !parser.match(sep);
    }
  }
  return result;
}
function serializeOps(sep = "") {
  return (serializer, expr) => {
    if (!expr) return "";
    const xs = operands(expr);
    if (xs.length === 0) return "";
    if (xs.length === 1) return serializer.serialize(xs[0]);
    sep = {
      "&": "\\&",
      ":": "\\colon",
      "|": "\\mvert",
      "-": "-",
      "\xB7": "\\cdot",
      // U+00B7 MIDDLE DOT
      "\u2012": "-",
      // U+2012 FIGURE DASH
      "\u2013": "--",
      // U+2013 EN DASH
      "\u2014": "---",
      // U+2014 EM DASH
      "\u2015": "-",
      // U+2015 HORIZONTAL BAR
      "\u2022": "\\bullet",
      // U+2022 BULLET
      "\u2026": "\\ldots"
    }[sep] ?? sep;
    const ys = xs.reduce((acc, item) => {
      acc.push(serializer.serialize(item), sep);
      return acc;
    }, []);
    ys.pop();
    return joinLatex(ys);
  };
}
function parseTextRun(parser, style) {
  if (!parser.match("<{>")) return "''";
  const runs = [];
  let text = "";
  let runinStyle = null;
  const flush = () => {
    if (runinStyle !== null && text) {
      runs.push(["Annotated", `'${text}'`, dictionaryFromEntries(runinStyle)]);
    } else if (text) {
      runs.push(`'${text}'`);
    }
    text = "";
    runinStyle = null;
  };
  while (!parser.atEnd && !parser.match("<}>")) {
    if (parser.peek === "<{>") {
      flush();
      runs.push(parseTextRun(parser));
    } else if (parser.match("\\textbf")) {
      flush();
      runs.push(parseTextRun(parser, { fontWeight: "bold" }));
    } else if (parser.match("\\textmd")) {
      flush();
      runs.push(parseTextRun(parser, { fontStyle: "normal" }));
    } else if (parser.match("\\textup")) {
      flush();
      runs.push(parseTextRun(parser, { fontStyle: "normal" }));
    } else if (parser.match("\\textsl")) {
      flush();
      runs.push(parseTextRun(parser, { fontStyle: "italic" }));
    } else if (parser.match("\\textit")) {
      flush();
      runs.push(parseTextRun(parser, { fontStyle: "italic" }));
    } else if (parser.match("\\texttt")) {
      flush();
      runs.push(parseTextRun(parser, { fontFamily: "monospace" }));
    } else if (parser.match("\\textsf")) {
      flush();
      runs.push(parseTextRun(parser, { fontFamily: "sans-serif" }));
    } else if (parser.match("\\textcolor")) {
      const pos = parser.index;
      const color = parser.parseStringGroup();
      const body2 = parser.parseExpression();
      if (color !== null && body2 !== null) {
        runs.push(["Annotated", body2, { dict: { color } }]);
      } else {
        parser.index = pos;
        text += "\\textcolor";
      }
    } else if (parser.match("\\color")) {
      const color = parser.parseStringGroup();
      if (color !== null) {
        flush();
        runinStyle = { color };
      }
    } else if (parser.match("<space>")) {
      text += " ";
    } else if (parser.match("<$>")) {
      const index = parser.index;
      const expr = parser.parseExpression() ?? "Nothing";
      parser.skipSpace();
      if (parser.match("<$>")) {
        runs.push(expr);
      } else {
        text += "$";
        parser.index = index;
      }
    } else if (parser.match("<$$>")) {
      const index = parser.index;
      const expr = parser.parseExpression() ?? "Nothing";
      parser.skipSpace();
      if (parser.match("<$$>")) {
        runs.push(expr);
      } else {
        text += "$$";
        parser.index = index;
      }
    } else {
      const c = parser.parseChar() ?? parser.nextToken();
      text += {
        "\\enskip": "\u2002",
        //  en space
        "\\enspace": "\u2002",
        //  en space
        "\\quad": "\u2003",
        //  em space
        "\\qquad": "\u2003\u2003",
        //  2 em space
        "\\space": "\u2003",
        //  em space
        "\\ ": "\u2003",
        //  em space
        "\\;": "\u2004",
        //  three per em space
        "\\,": "\u2009",
        //  thin space
        "\\:": "\u205F",
        //  medium mathematical space
        "\\!": "",
        //  negative thin space
        "\\{": "{",
        "\\}": "}",
        "\\$": "$",
        "\\&": "&",
        "\\#": "#",
        "\\%": "%",
        "\\_": "_",
        "\\textbackslash": "\\",
        "\\textasciitilde": "~",
        "\\textasciicircum": "^",
        "\\textless": "<",
        "\\textgreater": ">",
        "\\textbar": "|",
        "\\textunderscore": "_",
        "\\textbraceleft": "{",
        "\\textbraceright": "}",
        "\\textasciigrave": "`",
        "\\textquotesingle": "'",
        "\\textquotedblleft": "\u201C",
        "\\textquotedblright": "\u201D",
        "\\textquotedbl": '"',
        "\\textquoteleft": "\u2018",
        "\\textquoteright": "\u2019",
        "\\textbullet": "\u2022",
        "\\textdagger": "\u2020",
        "\\textdaggerdbl": "\u2021",
        "\\textsection": "\xA7",
        "\\textparagraph": "\xB6",
        "\\textperiodcentered": "\xB7",
        "\\textellipsis": "\u2026",
        "\\textemdash": "\u2014",
        "\\textendash": "\u2013",
        "\\textregistered": "\xAE",
        "\\texttrademark": "\u2122",
        "\\textdegree": "\xB0"
      }[c] ?? c;
    }
  }
  flush();
  let body;
  if (runs.length === 1) body = runs[0];
  else {
    if (runs.every((x) => stringValue(x) !== null))
      body = "'" + runs.map((x) => stringValue(x)).join() + "'";
    else body = ["Text", ...runs];
  }
  return style ? ["Annotated", body, dictionaryFromEntries(style)] : body;
}
function serializeLatexTokens(serializer, expr) {
  if (expr === null) return "";
  return joinLatex(
    mapArgs(expr, (x) => {
      const s = stringValue(x);
      if (s === null) return serializer.serialize(x);
      if (s === "<{>") return "{";
      if (s === "<}>") return "}";
      if (s === "<$>") return "$";
      if (s === "<$$>") return "$$";
      if (s === "<space>") return " ";
      return s;
    })
  );
}
function sanitizeLatex(s) {
  if (s === null) return "";
  return s.replace(
    /[{}\[\]\\:\-\$%]/g,
    (c) => ({
      "{": "\\lbrace ",
      "}": "\\rbrace ",
      "[": "\\lbrack ",
      "]": "\\rbrack ",
      ":": "\\colon ",
      "\\": "\\backslash "
    })[c] ?? "\\" + c
  );
}
function errorContextAsLatex(serializer, error) {
  const arg = operand(error, 2);
  if (!arg) return "";
  if (operator(arg) === "LatexString")
    return stringValue(operand(arg, 1)) ?? "";
  if (operator(arg) === "Hold") return serializer.serialize(operand(arg, 1));
  return serializer.serialize(arg);
}
function parsePrime(parser, lhs, order3) {
  while (!parser.atEnd) {
    if (parser.match("'") || parser.match("\\prime")) order3++;
    else if (parser.match("\\doubleprime")) order3 += 2;
    else if (parser.match("\\tripleprime")) order3 += 3;
    else break;
  }
  const lhsh = operator(lhs);
  if (lhsh === "Derivative" || lhsh === "Prime") {
    const n = machineValue(operand(lhs, 2)) ?? 1;
    return [lhsh, missingIfEmpty(operand(lhs, 1)), n + order3];
  }
  const sym = symbol(lhs);
  const isKnownFunction = sym && parser.getSymbolType(sym).matches("function") || operator(lhs);
  parser.skipSpace();
  const args = parser.parseArguments("enclosure");
  if (args && args.length > 0) {
    const firstArg = args[0];
    const variable = symbol(firstArg) ?? "x";
    const fnCall = typeof lhs === "string" ? [lhs, ...args] : ["Apply", lhs, ...args];
    let result = fnCall;
    for (let i = 0; i < order3; i++) {
      result = ["D", result, variable];
    }
    return result;
  }
  if (isKnownFunction) {
    if (order3 === 1) return ["Derivative", lhs];
    return ["Derivative", lhs, order3];
  }
  if (order3 === 1) return ["Prime", missingIfEmpty(lhs)];
  return ["Prime", missingIfEmpty(lhs), order3];
}
function parseParenDelimiter(_parser, body) {
  if (isEmptySequence(body)) return ["Delimiter"];
  const h = operator(body);
  if (h === "Delimiter" && operand(body, 2) !== null) {
    const delims = stringValue(operand(body, 2));
    if (delims?.length === 1) {
      return [
        "Delimiter",
        operand(body, 1) ?? "Nothing",
        { str: `(${delims})` }
      ];
    }
  }
  if (h === "Matrix") {
    const delims = stringValue(operand(body, 2)) ?? "..";
    if (delims === "..") return ["Matrix", operand(body, 1)];
  }
  return ["Delimiter", body];
}
function parseBrackets(parser, body) {
  if (isEmptySequence(body)) return ["List"];
  const h = operator(body);
  if (h === "Range" || h === "Linspace") return body;
  if (h === "Sequence") return ["List", ...operands(body)];
  if (h === "Delimiter") {
    const delim = stringValue(operand(body, 2)) ?? "...";
    if (delim === ";" || delim === ".;.") {
      return [
        "List",
        ...(operands(operand(body, 1)) ?? []).map(
          (x) => parseBrackets(parser, x)
        )
      ];
    }
    if (delim === "," || delim === ".,.") {
      body = operand(body, 1);
      if (operator(body) === "Sequence") return ["List", ...operands(body)];
      return ["List", body ?? "Nothing"];
    }
  }
  return ["List", body];
}
function serializeList(serializer, expr) {
  if (nops(expr) > 1 && operands(expr).every((x) => {
    const op = operator(x);
    return isEquationOperator(op) || isInequalityOperator(op);
  })) {
    return joinLatex([
      "\\begin{cases}",
      serializeOps("\\\\")(serializer, expr),
      "\\end{cases}"
    ]);
  }
  return joinLatex([
    "\\bigl\\lbrack",
    serializeOps(", ")(serializer, expr),
    "\\bigr\\rbrack"
  ]);
}
function parseRange(parser, lhs) {
  if (lhs === null) return null;
  const second = parser.parseExpression({ minPrec: 270 });
  if (second === null) return null;
  if (operator(second) === "Range") {
    const step = operand(second, 1);
    const end = operand(second, 2);
    if (step && end) return ["Range", lhs, end, ["Subtract", step, lhs]];
    return null;
  }
  return ["Range", lhs, second];
}
function parseAssign(parser, lhs) {
  const lhsSymbol = symbol(lhs);
  if (lhsSymbol && lhsSymbol.includes("_")) {
    const underscoreIndex = lhsSymbol.indexOf("_");
    const baseName = lhsSymbol.substring(0, underscoreIndex);
    const subscriptStr = lhsSymbol.substring(underscoreIndex + 1);
    const subscriptNum = parseInt(subscriptStr, 10);
    const subscript = !isNaN(subscriptNum) && String(subscriptNum) === subscriptStr ? subscriptNum : subscriptStr;
    lhs = ["Subscript", baseName, subscript];
  }
  if (operator(lhs) === "InvisibleOperator" && nops(lhs) === 2 && operator(operand(lhs, 2)) === "Delimiter") {
    const fn2 = symbol(operand(lhs, 1));
    if (!fn2) return null;
    const rhs2 = parser.parseExpression({ minPrec: 0 });
    if (rhs2 === null) return null;
    const delimBody = operand(operand(lhs, 2), 1);
    let args = [];
    if (operator(delimBody) === "Sequence") args = [...operands(delimBody)];
    else if (delimBody) args = [delimBody];
    return ["Assign", fn2, ["Function", rhs2, ...args ?? []]];
  }
  if (operator(lhs) === "Subscript" && symbol(operand(lhs, 1))) {
    const fn2 = symbol(operand(lhs, 1));
    if (!fn2) return null;
    const rhs2 = parser.parseExpression({ minPrec: 0 });
    if (rhs2 === null) return null;
    const sub3 = operand(lhs, 2);
    if (stringValue(sub3) !== null) {
      return ["Assign", lhs, rhs2];
    }
    if (symbol(sub3)) {
      return ["Assign", lhs, rhs2];
    }
    return ["Assign", lhs, rhs2];
  }
  const fn = operator(lhs);
  if (fn) {
    if (fn === "Subscript" || fn === "Superscript") {
    }
    const args = operands(lhs);
    const rhs2 = parser.parseExpression({ minPrec: 0 });
    if (rhs2 === null) return null;
    return ["Assign", fn, ["Function", rhs2, ...args]];
  }
  if (!symbol(lhs)) return null;
  const rhs = parser.parseExpression({ minPrec: 0 });
  if (rhs === null) return null;
  return ["Assign", lhs, rhs];
}
function parseCasesEnvironment(parser) {
  const rows = parser.parseTabular();
  if (!rows) return ["List"];
  if (rows.every((row) => {
    if (row.length !== 1) return false;
    const op = operator(row[0]);
    return isInequalityOperator(op) || isEquationOperator(op);
  })) {
    return ["List", ...rows.map((row) => row[0])];
  }
  const result = [];
  for (const row of rows) {
    if (row.length === 1) {
      result.push("True");
      result.push(row[0]);
    } else if (row.length === 2) {
      const s = stringValue(row[1]);
      result.push(s ? "True" : stripText(row[1]) ?? "True");
      result.push(row[0]);
    }
  }
  return ["Which", ...result];
}
function parseAt(...close) {
  return (parser, lhs) => {
    if (!symbol(lhs) && operator(lhs) !== "List") return null;
    let rhs = null;
    if (close.length === 0) rhs = parser.parseGroup();
    rhs ??= parser.parseExpression({ minPrec: 0 });
    if (rhs === null) return null;
    if (close.length > 0 && !parser.matchAll(close)) return null;
    if (stringValue(rhs) !== null) return null;
    if (operator(rhs) === "Delimiter") rhs = operand(rhs, 1) ?? "Nothing";
    if (operator(rhs) === "Sequence") return ["At", lhs, ...operands(rhs)];
    return ["At", lhs, rhs];
  };
}
var DEFINITIONS_CORE, DELIMITERS_SHORTHAND;
var init_definitions_core = __esm({
  "src/compute-engine/latex-syntax/dictionary/definitions-core.ts"() {
    init_utils2();
    init_types();
    init_tokenizer();
    init_utils3();
    DEFINITIONS_CORE = [
      //
      // Constants
      //
      {
        latexTrigger: ["\\placeholder"],
        kind: "symbol",
        parse: (parser) => {
          while (parser.match("<space>")) {
          }
          if (parser.match("["))
            while (!parser.match("]") && !parser.atBoundary) parser.nextToken();
          while (parser.match("<space>")) {
          }
          if (parser.match("<{>"))
            while (!parser.match("<}>") && !parser.atBoundary) parser.nextToken();
          return "Nothing";
        }
      },
      { name: "ContinuationPlaceholder", latexTrigger: ["\\dots"] },
      { latexTrigger: ["\\ldots"], parse: "ContinuationPlaceholder" },
      { latexTrigger: [".", ".", "."], parse: "ContinuationPlaceholder" },
      //
      // Functions
      //
      // Anonymous function, i.e. `(x) \mapsto x^2`
      {
        name: "Function",
        latexTrigger: ["\\mapsto"],
        kind: "infix",
        precedence: ARROW_PRECEDENCE,
        // MathML rightwards arrow
        parse: (parser, lhs, _until) => {
          let params = [];
          if (operator(lhs) === "Delimiter") lhs = operand(lhs, 1) ?? "Nothing";
          if (operator(lhs) === "Sequence") {
            for (const x of operands(lhs)) {
              if (!symbol(x)) return null;
              params.push(symbol(x));
            }
          } else {
            if (!symbol(lhs)) return null;
            params = [symbol(lhs)];
          }
          let rhs = parser.parseExpression({ minPrec: ARROW_PRECEDENCE }) ?? "Nothing";
          if (operator(rhs) === "Delimiter") rhs = operand(rhs, 1) ?? "Nothing";
          if (operator(rhs) === "Sequence") rhs = ["Block", ...operands(rhs)];
          return ["Function", rhs, ...params];
        },
        serialize: (serializer, expr) => {
          const args = operands(expr);
          if (args.length < 1) return "()\\mapsto()";
          if (args.length === 1)
            return joinLatex([
              "()",
              "\\mapsto",
              serializer.serialize(operand(expr, 1))
            ]);
          if (args.length === 2) {
            return joinLatex([
              serializer.serialize(operand(expr, 2)),
              "\\mapsto",
              serializer.serialize(operand(expr, 1))
            ]);
          }
          return joinLatex([
            serializer.wrapString(
              operands(expr)?.slice(1).map((x) => serializer.serialize(x)).join(", "),
              "normal"
            ),
            "\\mapsto",
            serializer.serialize(operand(expr, 1))
          ]);
        }
      },
      {
        name: "Apply",
        kind: "function",
        symbolTrigger: "apply",
        serialize: (serializer, expr) => {
          const lhs = operand(expr, 1);
          const h = operator(lhs);
          if (h === "InverseFunction" || h === "Derivative") {
            const style2 = serializer.options.applyFunctionStyle(
              expr,
              serializer.level
            );
            const args = operands(expr).slice(1);
            return serializer.serializeFunction(
              lhs,
              serializer.dictionary.ids.get(h)
            ) + serializer.wrapString(
              args.map((x) => serializer.serialize(x)).join(", "),
              style2
            );
          }
          const rhs = operand(expr, 2);
          if (typeof lhs === "string" || !rhs) {
            const fn = operands(expr).slice(1);
            return serializer.serialize(fn);
          }
          if (nops(expr) === 2) {
            return joinLatex([
              serializer.wrap(lhs, 20),
              "\\lhd",
              serializer.wrap(rhs, 20)
            ]);
          }
          const style = serializer.options.applyFunctionStyle(
            expr,
            serializer.level
          );
          return joinLatex([
            "\\operatorname{apply}",
            serializer.wrapString(
              serializer.serialize(h) + ", " + serializer.serialize(["List", ...operands(expr)]),
              style
            )
          ]);
        }
      },
      {
        latexTrigger: "\\lhd",
        kind: "infix",
        precedence: 20,
        parse: "Apply"
      },
      {
        latexTrigger: "\\rhd",
        kind: "infix",
        precedence: 20,
        parse: (parser, lhs, _until) => {
          const rhs = parser.parseExpression({ minPrec: 21 }) ?? "Nothing";
          return ["Apply", rhs, lhs];
        }
      },
      {
        name: "EvaluateAt",
        openTrigger: ".",
        closeTrigger: "|",
        kind: "matchfix",
        serialize: (serializer, expr) => {
          const fn = operand(expr, 1);
          if (!fn) return "";
          const args = operands(expr).slice(1);
          if (operator(fn) === "Function") {
            const parameters = operands(fn).slice(1);
            let body = operand(fn, 1);
            if (operator(body) === "Block" && nops(body) === 1)
              body = operand(body, 1);
            if (parameters.length > 0) {
              return `\\left.\\left(${serializer.serialize(body)}\\right)\\right|_{${parameters.map(
                (x, i) => `${serializer.serialize(x)}=${serializer.serialize(args[i])}`
              ).join(", ")}}`;
            }
          }
          return `\\left.\\left(${serializer.serialize(fn)}\\right)\\right|_{${args.map((x) => serializer.serialize(x)).join(", ")}}`;
        }
      },
      // The mathtools package includes several synonmyms for \colonequals. The
      // preferred one as of summer 2022 is `\coloneq` (see  3.7.3 https://ctan.math.illinois.edu/macros/latex/contrib/mathtools/mathtools.pdf)
      {
        name: "Assign",
        latexTrigger: "\\coloneq",
        kind: "infix",
        associativity: "right",
        precedence: ASSIGNMENT_PRECEDENCE,
        serialize: (serializer, expr) => {
          const id = unhold(operand(expr, 1));
          if (operator(operand(expr, 2)) === "Function") {
            const op_2 = operand(expr, 2);
            const body = unhold(operand(op_2, 1));
            const args = operands(op_2).slice(1);
            return joinLatex([
              serializer.serialize(id),
              serializer.wrapString(
                args.map((x) => serializer.serialize(x)).join(", "),
                serializer.options.applyFunctionStyle(expr, serializer.level)
              ),
              "\\coloneq",
              serializer.serialize(body)
            ]);
          }
          return joinLatex([
            serializer.serialize(id),
            "\\coloneq",
            serializer.serialize(operand(expr, 2))
          ]);
        },
        parse: parseAssign
      },
      {
        latexTrigger: "\\coloneqq",
        kind: "infix",
        associativity: "right",
        precedence: ASSIGNMENT_PRECEDENCE,
        parse: parseAssign
      },
      // From the colonequals package:
      {
        latexTrigger: "\\colonequals",
        kind: "infix",
        associativity: "right",
        precedence: ASSIGNMENT_PRECEDENCE,
        parse: parseAssign
      },
      {
        latexTrigger: [":", "="],
        kind: "infix",
        associativity: "right",
        precedence: ASSIGNMENT_PRECEDENCE,
        parse: parseAssign
      },
      {
        name: "BaseForm",
        serialize: (serializer, expr) => {
          const radix = machineValue(operand(expr, 2)) ?? NaN;
          if (isFinite(radix) && radix >= 2 && radix <= 36) {
            const num = machineValue(operand(expr, 1)) ?? NaN;
            if (isFinite(num) && Number.isInteger(num)) {
              let digits = Number(num).toString(radix);
              let groupLength = 0;
              if (radix === 2) {
                groupLength = 4;
              } else if (radix === 10) {
                groupLength = 4;
              } else if (radix === 16) {
                groupLength = 2;
              } else if (radix > 16) {
                groupLength = 4;
              }
              if (groupLength > 0) {
                const oldDigits = digits;
                digits = "";
                for (let i = 0; i < oldDigits.length; i++) {
                  if (i > 0 && i % groupLength === 0) digits = "\\, " + digits;
                  digits = oldDigits[oldDigits.length - i - 1] + digits;
                }
              }
              return `(\\text{${digits}}_{${radix}}`;
            }
          }
          return "\\operatorname{BaseForm}(" + serializer.serialize(operand(expr, 1)) + ", " + serializer.serialize(operand(expr, 2)) + ")";
        }
      },
      {
        name: "Sequence",
        // Use a space as a separator, otherwise a sequence of numbers
        // could be interpreted as a single number.
        serialize: serializeOps(" ")
      },
      {
        name: "InvisibleOperator",
        serialize: serializeOps("")
      },
      {
        // The first argument is a function expression.
        // The second (optional) argument is a string specifying the
        // delimiters and separator.
        name: "Delimiter",
        serialize: (serializer, expr) => {
          const style = serializer.options.groupStyle(expr, serializer.level + 1);
          const arg1 = operand(expr, 1);
          let delims = {
            Set: "{,}",
            List: "[,]",
            Tuple: "(,)",
            Single: "(,)",
            Pair: "(,)",
            Triple: "(,)",
            Sequence: "(,)",
            String: '""'
          }[operator(arg1)];
          const items = delims ? arg1 : ["Sequence", arg1];
          delims ??= "(,)";
          if (nops(expr) > 1) {
            const op2 = stringValue(operand(expr, 2));
            if (typeof op2 === "string" && op2.length <= 3) delims = op2;
          }
          let [open, sep, close] = ["", "", ""];
          if (delims.length === 3) [open, sep, close] = delims;
          else if (delims.length === 2) [open, close] = delims;
          else if (delims.length === 1) sep = delims;
          const body = arg1 ? items ? serializeOps(sep)(serializer, items) : serializer.serialize(arg1) : "";
          return serializer.wrapString(body, style, open + close);
        }
      },
      {
        name: "Tuple",
        serialize: (serializer, expr) => joinLatex(["(", serializeOps(",")(serializer, expr), ")"])
      },
      {
        name: "Pair",
        serialize: (serializer, expr) => joinLatex(["(", serializeOps(",")(serializer, expr), ")"])
      },
      {
        name: "Triple",
        serialize: (serializer, expr) => joinLatex(["(", serializeOps(",")(serializer, expr), ")"])
      },
      {
        name: "Single",
        serialize: (serializer, expr) => joinLatex(["(", serializeOps(",")(serializer, expr), ")"])
      },
      {
        name: "Domain",
        serialize: (serializer, expr) => {
          if (operator(expr) === "Error") return serializer.serialize(expr);
          return `\\mathbf{${serializer.serialize(operand(expr, 1))}}`;
        }
      },
      {
        latexTrigger: ["\\mathtip"],
        parse: (parser) => {
          const op1 = parser.parseGroup();
          parser.parseGroup();
          return op1;
        }
      },
      {
        latexTrigger: ["\\texttip"],
        parse: (parser) => {
          const op1 = parser.parseGroup();
          parser.parseGroup();
          return op1;
        }
      },
      {
        latexTrigger: ["\\error"],
        parse: (parser) => ["Error", parser.parseGroup()]
      },
      {
        name: "Error",
        serialize: (serializer, expr) => {
          const op1 = operand(expr, 1);
          if (stringValue(op1) === "missing")
            return `\\error{${serializer.options.missingSymbol ?? "\\placeholder{}"}}`;
          const where = errorContextAsLatex(serializer, expr) || "\\blacksquare";
          const code = operator(op1) === "ErrorCode" ? stringValue(operand(op1, 1)) : stringValue(op1);
          if (code === "incompatible-type") {
            if (symbol(operand(op1, 3)) === "Undefined") {
              return `\\mathtip{\\error{${where}}}{\\notin ${serializer.serialize(
                operand(op1, 2)
              )}}`;
            }
            return `\\mathtip{\\error{${where}}}{\\in ${serializer.serialize(
              operand(op1, 3)
            )}\\notin ${serializer.serialize(operand(op1, 2))}}`;
          }
          if (typeof code === "string") return `\\error{${where}}`;
          return `\\error{${where}}`;
        }
      },
      {
        name: "ErrorCode",
        serialize: (serializer, expr) => {
          const code = stringValue(operand(expr, 1));
          if (code === "missing")
            return serializer.options.missingSymbol ?? "\\placeholder{}";
          if (code === "unexpected-command" || code === "unexpected-operator" || code === "unexpected-token" || code === "invalid-symbol" || code === "unknown-environment" || code === "unexpected-base" || code === "incompatible-type") {
            return "";
          }
          return `\\texttip{\\error{\\blacksquare}}{\\mathtt{${code}}}`;
        }
      },
      {
        name: "FromLatex",
        serialize: (_serializer, expr) => {
          return `\\texttt{${sanitizeLatex(stringValue(operand(expr, 1)))}}`;
        }
      },
      {
        name: "Latex",
        serialize: (serializer, expr) => {
          if (expr === null) return "";
          return joinLatex(
            mapArgs(expr, (x) => stringValue(x) ?? serializer.serialize(x))
          );
        }
      },
      {
        name: "LatexString",
        serialize: (serializer, expr) => {
          if (expr === null) return "";
          return joinLatex(mapArgs(expr, (x) => serializer.serialize(x)));
        }
      },
      { name: "LatexTokens", serialize: serializeLatexTokens },
      {
        name: "At",
        kind: "postfix",
        precedence: 810,
        latexTrigger: ["["],
        parse: parseAt("]"),
        serialize: (serializer, expr) => joinLatex(["\\lbrack", serializeOps(", ")(serializer, expr), "\\rbrack"])
      },
      {
        kind: "postfix",
        precedence: 810,
        latexTrigger: ["\\lbrack"],
        parse: parseAt("\\rbrack")
      },
      {
        kind: "postfix",
        precedence: 810,
        latexTrigger: ["\\left", "\\lbrack"],
        parse: parseAt("\\right", "\\rbrack")
      },
      {
        kind: "postfix",
        latexTrigger: ["_"],
        parse: (parser, lhs, until) => {
          let rhs = parser.parseGroup() ?? parser.parseToken();
          if (rhs === null && parser.options.strict === false && parser.peek === "(")
            rhs = parser.parseEnclosure();
          return ["Subscript", lhs, rhs];
        }
      },
      {
        name: "List",
        kind: "matchfix",
        openTrigger: "[",
        closeTrigger: "]",
        parse: parseBrackets,
        serialize: serializeList
      },
      {
        kind: "matchfix",
        openTrigger: "(",
        closeTrigger: ")",
        parse: parseParenDelimiter
      },
      {
        latexTrigger: [","],
        kind: "infix",
        precedence: 20,
        // Unlike the matchfix version of List,
        // when the comma operator is used, the lhs and rhs are flattened,
        // i.e. `1,2,3` -> `["Delimiter", ["List", 1, 2, 3],  ","]`,
        // and `1, (2, 3)` -> `["Delimiter",
        // ["Sequence", 1, ["Delimiter", ["List", 2, 3],  "()", ","]]],
        parse: (parser, lhs, terminator) => {
          const seq = parseSequence(parser, terminator, lhs, 20, ",");
          if (seq === null) return null;
          return ["Delimiter", ["Sequence", ...seq], { str: "," }];
        }
      },
      // Entry to handle the case of a single comma
      // with a missing lhs.
      {
        latexTrigger: [","],
        kind: "prefix",
        precedence: 20,
        parse: (parser, terminator) => {
          const seq = parseSequence(parser, terminator, null, 20, ",");
          if (seq === null) return null;
          return ["Delimiter", ["Sequence", ...seq], { str: "," }];
        }
      },
      {
        name: "Range",
        latexTrigger: [".", "."],
        kind: "infix",
        // associativity: 'left',
        precedence: 800,
        parse: parseRange,
        serialize: (serializer, expr) => {
          const args = operands(expr);
          if (args.length === 0) return "";
          if (args.length === 1)
            return "1.." + serializer.serialize(operand(expr, 1));
          if (args.length === 2)
            return serializer.wrap(operand(expr, 1), 10) + ".." + serializer.wrap(operand(expr, 2), 10);
          if (args.length === 3) {
            const step = machineValue(operand(expr, 3));
            const start = machineValue(operand(expr, 1));
            if (step !== null && start !== null) {
              return serializer.wrap(operand(expr, 1), 10) + ".." + serializer.wrap(start + step, 10) + ".." + serializer.wrap(operand(expr, 2), 10);
            }
            return serializer.wrap(operand(expr, 1), 10) + "..(" + (serializer.wrap(operand(expr, 1), ADDITION_PRECEDENCE) + "+" + serializer.wrap(operand(expr, 3), ADDITION_PRECEDENCE)) + ").." + serializer.wrap(operand(expr, 2), 10);
          }
          return "";
        }
      },
      {
        latexTrigger: [";"],
        kind: "infix",
        precedence: 19,
        parse: (parser, lhs, terminator) => {
          const seq = parseSequence(parser, terminator, lhs, 19, ";");
          if (seq === null) return null;
          return ["Delimiter", ["Sequence", ...seq], "';'"];
        }
      },
      {
        name: "String",
        latexTrigger: ["\\text"],
        parse: (scanner) => parseTextRun(scanner),
        serialize: (serializer, expr) => {
          const args = operands(expr);
          if (args.length === 0) return "\\text{}";
          return joinLatex([
            "\\text{",
            args.map((x) => serializer.serialize(x)).join(""),
            "}"
          ]);
        }
      },
      {
        name: "Subscript",
        latexTrigger: ["_"],
        kind: "infix",
        serialize: (serializer, expr) => {
          if (nops(expr) === 2) {
            return serializer.serialize(operand(expr, 1)) + "_{" + serializer.serialize(operand(expr, 2)) + "}";
          }
          return "_{" + serializer.serialize(operand(expr, 1)) + "}";
        }
      },
      { name: "Superplus", latexTrigger: ["^", "+"], kind: "postfix" },
      { name: "Subplus", latexTrigger: ["_", "+"], kind: "postfix" },
      { name: "Superminus", latexTrigger: ["^", "-"], kind: "postfix" },
      { name: "Subminus", latexTrigger: ["_", "-"], kind: "postfix" },
      {
        latexTrigger: ["^", "*"],
        kind: "postfix",
        parse: (_parser, lhs) => ["Superstar", lhs]
      },
      // { name: 'Superstar', latexTrigger: ['^', '\\star'], kind: 'postfix' },
      {
        latexTrigger: ["_", "*"],
        kind: "postfix",
        parse: (_parser, lhs) => ["Substar", lhs]
      },
      { name: "Substar", latexTrigger: ["_", "\\star"], kind: "postfix" },
      { name: "Superdagger", latexTrigger: ["^", "\\dagger"], kind: "postfix" },
      {
        latexTrigger: ["^", "\\dag"],
        kind: "postfix",
        parse: (_parser, lhs) => ["Superdagger", lhs]
      },
      {
        name: "Prime",
        latexTrigger: ["^", "\\prime"],
        // Note: we don't need a precedence because the trigger is '^'
        // and '^' (and '_') are treated specially by the parser.
        kind: "postfix",
        parse: (parser, lhs) => parsePrime(parser, lhs, 1),
        serialize: (serializer, expr) => {
          const n2 = machineValue(operand(expr, 2)) ?? 1;
          const base = serializer.serialize(operand(expr, 1));
          if (n2 === 1) return base + "^\\prime";
          if (n2 === 2) return base + "^\\doubleprime";
          if (n2 === 3) return base + "^\\tripleprime";
          return base + "^{(" + serializer.serialize(operand(expr, 2)) + ")}";
        }
      },
      {
        latexTrigger: "^{\\prime\\prime}",
        kind: "postfix",
        parse: (parser, lhs) => parsePrime(parser, lhs, 2)
      },
      {
        latexTrigger: "^{\\prime\\prime\\prime}",
        kind: "postfix",
        parse: (parser, lhs) => parsePrime(parser, lhs, 3)
      },
      {
        latexTrigger: ["^", "\\doubleprime"],
        kind: "postfix",
        parse: (parser, lhs) => parsePrime(parser, lhs, 2)
      },
      {
        latexTrigger: ["^", "\\tripleprime"],
        kind: "postfix",
        parse: (parser, lhs) => parsePrime(parser, lhs, 3)
      },
      {
        latexTrigger: "'",
        kind: "postfix",
        precedence: 810,
        parse: (parser, lhs) => parsePrime(parser, lhs, 1)
      },
      {
        latexTrigger: "\\prime",
        kind: "postfix",
        precedence: 810,
        parse: (parser, lhs) => parsePrime(parser, lhs, 1)
      },
      {
        latexTrigger: "\\doubleprime",
        kind: "postfix",
        precedence: 810,
        parse: (parser, lhs) => parsePrime(parser, lhs, 2)
      },
      {
        latexTrigger: "\\tripleprime",
        kind: "postfix",
        precedence: 810,
        parse: (parser, lhs) => parsePrime(parser, lhs, 3)
      },
      // Lagrange Notation for n-th order derivatives,
      // i.e. f^{(n)} -> Derivative(f, n)
      {
        latexTrigger: ["^", "<{>", "("],
        kind: "postfix",
        parse: (parser, lhs, until) => {
          const sym = symbol(lhs);
          if (!sym || !parser.getSymbolType(sym).matches("function")) return null;
          parser.addBoundary([")"]);
          const expr = parser.parseExpression(until);
          if (!parser.matchBoundary()) return null;
          if (!parser.match("<}>")) return null;
          return ["Derivative", lhs, expr];
        }
      },
      {
        name: "InverseFunction",
        latexTrigger: "^{-1",
        // Note: the closing brace is not included
        kind: "postfix",
        parse: (parser, lhs) => {
          const sym = symbol(lhs);
          if (!sym || !parser.getSymbolType(sym).matches("function")) return null;
          let primeCount = 0;
          while (!parser.atEnd && !parser.match("<}>")) {
            if (parser.match("'")) primeCount++;
            else if (parser.match("\\prime")) primeCount++;
            else if (parser.match("\\doubleprime")) primeCount += 2;
            else if (parser.match("\\tripleprime")) primeCount += 3;
            else return null;
          }
          if (primeCount === 1)
            return ["Derivative", ["InverseFunction", lhs]];
          if (primeCount > 0)
            return [
              "Derivative",
              ["InverseFunction", lhs],
              primeCount
            ];
          return ["InverseFunction", lhs];
        },
        serialize: (serializer, expr) => serializer.serialize(operand(expr, 1)) + "^{-1}"
      },
      // Lagrange notation
      {
        name: "Derivative",
        // @todo: Leibniz notation: {% latex " \\frac{d^n}{dx^n} f(x)" %}
        // @todo: Euler modified notation: This notation is used by Mathematica. The Euler notation uses `D` instead of
        // `\partial`: `\partial_{x} f`,  `\partial_{x,y} f`
        // Newton notation (\dot{v}, \ddot{v}) is implemented below
        serialize: (serializer, expr) => {
          const degree = machineValue(operand(expr, 2)) ?? 1;
          const base = serializer.serialize(operand(expr, 1));
          if (degree === 1) return base + "^{\\prime}";
          if (degree === 2) return base + "^{\\doubleprime}";
          if (degree === 3) return base + "^{\\tripleprime}";
          return base + "^{(" + serializer.serialize(operand(expr, 2)) + ")}";
        }
      },
      // Serializer for D (partial derivative) - outputs Leibniz notation
      {
        name: "D",
        serialize: (serializer, expr) => {
          if (operator(expr) !== "D") return "D";
          const fn = operand(expr, 1);
          const variable = operand(expr, 2);
          if (!fn || !variable) return "D";
          let order3 = 1;
          let innerFn = fn;
          while (operator(innerFn) === "D") {
            const innerVar = operand(innerFn, 2);
            if (symbol(innerVar) === symbol(variable)) {
              order3++;
              innerFn = operand(innerFn, 1);
            } else {
              break;
            }
          }
          let bodyToSerialize = innerFn;
          if (operator(innerFn) === "Function") {
            bodyToSerialize = operand(innerFn, 1) ?? innerFn;
          }
          const fnLatex = serializer.serialize(bodyToSerialize);
          const varLatex = serializer.serialize(variable);
          if (order3 === 1) {
            return `\\frac{\\mathrm{d}}{\\mathrm{d}${varLatex}}${fnLatex}`;
          }
          return `\\frac{\\mathrm{d}^{${order3}}}{\\mathrm{d}${varLatex}^{${order3}}}${fnLatex}`;
        }
      },
      // Newton notation for time derivatives: \dot{x}, \ddot{x}, etc.
      {
        name: "NewtonDerivative1",
        latexTrigger: ["\\dot"],
        kind: "prefix",
        precedence: 740,
        parse: (parser) => {
          const body = parser.parseGroup();
          if (body === null) return null;
          const t = parser.options.timeDerivativeVariable;
          return ["D", body, t];
        }
      },
      {
        name: "NewtonDerivative2",
        latexTrigger: ["\\ddot"],
        kind: "prefix",
        precedence: 740,
        parse: (parser) => {
          const body = parser.parseGroup();
          if (body === null) return null;
          const t = parser.options.timeDerivativeVariable;
          return ["D", ["D", body, t], t];
        }
      },
      {
        name: "NewtonDerivative3",
        latexTrigger: ["\\dddot"],
        kind: "prefix",
        precedence: 740,
        parse: (parser) => {
          const body = parser.parseGroup();
          if (body === null) return null;
          const t = parser.options.timeDerivativeVariable;
          return ["D", ["D", ["D", body, t], t], t];
        }
      },
      {
        name: "NewtonDerivative4",
        latexTrigger: ["\\ddddot"],
        kind: "prefix",
        precedence: 740,
        parse: (parser) => {
          const body = parser.parseGroup();
          if (body === null) return null;
          const t = parser.options.timeDerivativeVariable;
          return ["D", ["D", ["D", ["D", body, t], t], t], t];
        }
      },
      // Euler notation for derivatives: D_x f, D^2_x f, D_x^2 f
      // Uses latexTrigger to intercept before symbol parsing combines D with subscript
      {
        name: "EulerDerivative",
        latexTrigger: ["D"],
        kind: "expression",
        parse: (parser) => {
          let degree = 1;
          let variable = null;
          let done = false;
          while (!done) {
            if (parser.match("_")) {
              variable = parser.parseGroup() ?? parser.parseToken();
              if (!variable) return null;
            } else if (parser.match("^")) {
              const degExpr = parser.parseGroup() ?? parser.parseToken();
              degree = machineValue(degExpr) ?? 1;
            } else {
              done = true;
            }
          }
          if (!variable) return null;
          parser.skipSpace();
          const fn = parser.parseExpression({ minPrec: 740 });
          if (!fn) return null;
          let result = fn;
          for (let i = 0; i < degree; i++) {
            result = ["D", result, variable];
          }
          return result;
        }
      },
      {
        kind: "environment",
        name: "Which",
        symbolTrigger: "cases",
        parse: parseCasesEnvironment,
        serialize: (serialize, expr) => {
          const rows = [];
          const args = operands(expr);
          if (args.length > 0) {
            for (let i = 0; i <= args.length - 2; i += 2) {
              const row = [];
              row.push(serialize.serialize(args[i + 1]));
              row.push(serialize.serialize(args[i]));
              rows.push(row.join("&"));
            }
          }
          return joinLatex(["\\begin{cases}", rows.join("\\\\"), "\\end{cases}"]);
        }
      },
      {
        kind: "environment",
        symbolTrigger: "dcases",
        parse: parseCasesEnvironment
      },
      {
        kind: "environment",
        symbolTrigger: "rcases",
        parse: parseCasesEnvironment
      }
    ];
    DELIMITERS_SHORTHAND = {
      "(": "(",
      ")": ")",
      "[": "\\lbrack",
      "]": "\\rbrack",
      "\u27E6": "\\llbrack",
      // U+27E6 MATHEMATICAL LEFT WHITE SQUARE BRACKET
      "\u27E7": "\\rrbrack",
      // U+27E7 MATHEMATICAL RIGHT WHITE SQUARE BRACKET
      "{": "\\lbrace",
      "}": "\\rbrace",
      "<": "\\langle",
      ">": "\\rangle",
      // '|': '\\vert',
      "\u2016": "\\Vert",
      // U+2016 DOUBLE VERTICAL LINE
      "\\": "\\backslash",
      "\u2308": "\\lceil",
      //  U+2308 LEFT CEILING
      "\u2309": "\\rceil",
      // U+2309 RIGHT CEILING
      "\u230A": "\\lfloor",
      //  U+230A LEFT FLOOR
      "\u230B": "\\rfloor",
      //  U+230B RIGHT FLOOR
      "\u231C": "\\ulcorner",
      //  U+231C TOP LEFT CORNER
      "\u231D": "\\urcorner",
      //  U+231D TOP RIGHT CORNER
      "\u231E": "\\llcorner",
      //  U+231E BOTTOM LEFT CORNER
      "\u231F": "\\lrcorner",
      //  U+231F BOTTOM RIGHT CORNER
      "\u23B0": "\\lmoustache",
      // U+23B0 UPPER LEFT OR LOWER RIGHT CURLY BRACKET SECTION
      "\u23B1": "\\rmoustache"
      // U+23B1 UPPER RIGHT OR LOWER LEFT CURLY BRACKET SECTION
      // '': '', // U+23B9 DIVIDES
      // '': '', // U+23BE RIGHT PARENTHESIS UPPER HOOK
      // '': '', // U+23BF RIGHT PARENTHESIS LOWER HOOK
    };
  }
});

// src/compute-engine/latex-syntax/dictionary/definitions-symbols.ts
var SYMBOLS, DEFINITIONS_SYMBOLS;
var init_definitions_symbols = __esm({
  "src/compute-engine/latex-syntax/dictionary/definitions-symbols.ts"() {
    SYMBOLS = [
      // Greek
      ["alpha", "\\alpha", 945],
      ["beta", "\\beta", 946],
      ["gamma", "\\gamma", 947],
      ["delta", "\\delta", 948],
      ["epsilon", "\\epsilon", 949],
      ["epsilonSymbol", "\\varepsilon", 1013],
      // GREEK LUNATE EPSILON SYMBOL
      ["zeta", "\\zeta", 950],
      ["eta", "\\eta", 951],
      ["theta", "\\theta", 952],
      ["thetaSymbol", "\\vartheta", 977],
      // Unicode GREEK THETA SYMBOL
      ["iota", "\\iota", 953],
      ["kappa", "\\kappa", 954],
      ["kappaSymbol", "\\varkappa", 1008],
      // GREEK KAPPA SYMBOL
      ["lambda", "\\lambda", 955],
      ["mu", "\\mu", 956],
      ["nu", "\\nu", 957],
      ["xi", "\\xi", 958],
      ["omicron", "\\omicron", 959],
      ["pi", "\\pi", 960],
      ["piSymbol", "\\varpi", 982],
      // GREEK PI SYMBOL
      ["rho", "\\rho", 961],
      ["rhoSymbol", "\\varrho", 1009],
      // GREEK RHO SYMBOL
      ["sigma", "\\sigma", 963],
      ["finalSigma", "\\varsigma", 962],
      //GREEK SMALL LETTER FINAL SIGMA
      ["tau", "\\tau", 964],
      ["phi", "\\phi", 981],
      // Note GREEK PHI SYMBOL, but common usage in math
      ["phiLetter", "\\varphi", 966],
      ["upsilon", "\\upsilon", 965],
      ["chi", "\\chi", 967],
      ["psi", "\\psi", 968],
      ["omega", "\\omega", 969],
      ["Alpha", "\\Alpha", 913],
      ["Beta", "\\Beta", 914],
      ["Gamma", "\\Gamma", 915],
      ["Delta", "\\Delta", 916],
      ["Epsilon", "\\Epsilon", 917],
      ["Zeta", "\\Zeta", 918],
      ["Eta", "\\Eta", 919],
      ["Theta", "\\Theta", 920],
      ["Iota", "\\Iota", 921],
      ["Kappa", "\\Kappa", 922],
      ["Lambda", "\\Lambda", 923],
      ["Mu", "\\Mu", 924],
      ["Nu", "\\Nu", 925],
      ["Xi", "\\Xi", 926],
      ["Omicron", "\\Omicron", 927],
      // ['Pi', '\\Pi', 0x03a0],
      ["Rho", "\\Rho", 929],
      ["Sigma", "\\Sigma", 931],
      ["Tau", "\\Tau", 932],
      ["Phi", "\\Phi", 934],
      ["Upsilon", "\\Upsilon", 933],
      ["Chi", "\\Chi", 935],
      ["Psi", "\\Psi", 936],
      ["Omega", "\\Omega", 937],
      ["digamma", "\\digamma", 989],
      // Hebrew
      ["aleph", "\\aleph", 8501],
      // Unicode ALEF SYMBOL
      ["bet", "\\beth", 8502],
      ["gimel", "\\gimel", 8503],
      ["dalet", "\\daleth", 8504],
      // Letter-like
      ["ell", "\\ell", 8499],
      // Unicode SCRIPT SMALL L
      ["turnedCapitalF", "\\Finv", 8498],
      // Unicode TURNED CAPITAL F'
      ["turnedCapitalG", "\\Game", 8513],
      // TURNED SANS-SERIF CAPITAL G
      ["weierstrass", "\\wp", 8472],
      // Unicode SCRIPT CAPITAL P
      ["eth", "\\eth", 240],
      ["invertedOhm", "\\mho", 8487],
      // Unicode INVERTED OHM SIGN
      ["hBar", "\\hbar", 295],
      // Unicode LATIN SMALL LETTER H WITH STROKE
      ["hSlash", "\\hslash", 8463],
      // Unicode PLANCK CONSTANT OVER TWO PI
      // Symbols
      ["blackClubSuit", "\\clubsuit", 9827],
      ["whiteHeartSuit", "\\heartsuit", 9825],
      ["blackSpadeSuit", "\\spadesuit", 9824],
      ["whiteDiamondSuit", "\\diamondsuit", 9826],
      ["sharp", "\\sharp", 9839],
      ["flat", "\\flat", 9837],
      ["natural", "\\natural", 9838]
    ];
    DEFINITIONS_SYMBOLS = [
      ...SYMBOLS.map(([symbol2, latex, _codepoint]) => {
        return {
          kind: "symbol",
          name: symbol2,
          latexTrigger: [latex],
          parse: symbol2
        };
      }),
      ...SYMBOLS.map(([symbol2, _latex, codepoint]) => {
        return {
          kind: "symbol",
          latexTrigger: [String.fromCodePoint(codepoint)],
          parse: symbol2
        };
      })
    ];
  }
});

// src/compute-engine/collection-utils.ts
function isFiniteIndexedCollection(col) {
  return (col.isFiniteCollection ?? false) && col.isIndexedCollection;
}
function repeat(value, count) {
  if (typeof count === "number") {
    if (count < 0) count = 0;
    return {
      next() {
        if (count === 0) return { done: true, value: void 0 };
        count--;
        return { done: false, value };
      }
    };
  }
  return {
    next() {
      return { done: false, value };
    }
  };
}
function zip(items) {
  if (items.length === 0) {
    return {
      next() {
        return { done: true, value: void 0 };
      }
    };
  }
  if (items.length === 1) {
    const item = items[0];
    const iter = item.each();
    if (!iter) {
      let done = false;
      return {
        next() {
          if (done) return { done, value: void 0 };
          done = true;
          return { done: false, value: [item] };
        }
      };
    }
    return {
      next() {
        const next = iter.next();
        if (next.done) return { done: true, value: void 0 };
        return { done: false, value: [next.value] };
      }
    };
  }
  const shortest = Math.min(
    ...items.map((x) => x.isCollection ? x.count ?? 1 : Infinity)
  );
  if (shortest === 0) {
    return {
      next() {
        return { done: true, value: void 0 };
      }
    };
  }
  const iterators = items.map((x) => x.isCollection ? x.each() : repeat(x));
  let count = 0;
  return {
    next() {
      if (count >= shortest) {
        return { done: true, value: void 0 };
      }
      const values = iterators.map((x) => x.next());
      count += 1;
      return { done: false, value: values.map((x) => x.value) };
    }
  };
}
function collectionSubset(a, b, strict) {
  if (a.isFiniteCollection !== true || b.isFiniteCollection !== true)
    return void 0;
  for (const x of a.each()) if (b.contains(x) !== true) return false;
  if (strict) {
    const aSize = a.count;
    if (aSize === void 0) return false;
    const bSize = b.count;
    if (bSize === void 0) return false;
    if (aSize === bSize) return false;
  }
  return true;
}
function basicCollectionIndexWhere(expr, predicate2) {
  for (let i = 0; i !== expr.nops; i += 1)
    if (predicate2(expr.ops[i])) return i + 1;
  return void 0;
}
function collectionIndexWhere(expr, predicate2) {
  if (expr.isIndexedCollection !== true) return void 0;
  let i = 1;
  let op = expr.at(i);
  while (op !== void 0) {
    if (predicate2(op)) return i;
    i += 1;
    op = expr.at(i);
  }
  return void 0;
}
function collectionContains(expr, target) {
  if (expr.isFiniteCollection !== true) return void 0;
  if (expr.isIndexedCollection)
    return expr.indexWhere((x) => x.isSame(target)) !== void 0;
  for (const x of expr.each()) if (x.isSame(target)) return true;
  return false;
}
function basicIndexedCollectionHandlers() {
  return {
    isLazy: (_expr) => false,
    count: (expr) => expr.nops,
    isEmpty: (expr) => expr.nops === 0,
    isFinite: (_expr) => true,
    contains: (expr, target) => expr.ops.some((x) => x.isSame(target)),
    iterator: (expr) => {
      let index = 1;
      const last = expr.nops;
      return {
        next: () => {
          if (index === last + 1) return { value: void 0, done: true };
          index += 1;
          return { value: expr.ops[index - 1 - 1], done: false };
        }
      };
    },
    subsetOf: collectionSubset,
    at: (expr, index) => {
      if (typeof index !== "number") return void 0;
      if (index < 0) index = expr.nops + index + 1;
      if (index < 1 || index > expr.nops) return void 0;
      return expr.ops[index - 1];
    },
    indexWhere: basicCollectionIndexWhere,
    eltsgn: (_expr) => void 0,
    elttype: (expr) => {
      if (expr.nops === 0) return "unknown";
      if (expr.nops === 1) return expr.ops[0].type.type;
      return widen(...expr.ops.map((op) => op.type.type));
    }
  };
}
function defaultCollectionHandlers(def) {
  if (!def) return void 0;
  if (!def.count || !def.iterator)
    throw new Error(
      'A collection must have at least an "iterator" and a "count" handler'
    );
  if (def.indexWhere && def.at === void 0) {
    throw new Error(
      'A collection with an "indexWhere" handler must also have an "at" handler'
    );
  }
  const result = {
    iterator: def.iterator,
    count: def.count,
    contains: def.contains ?? collectionContains,
    isEmpty: def.isEmpty ?? ((expr) => {
      const count = def.count(expr);
      if (count === void 0) return void 0;
      return def.count(expr) === 0;
    }),
    isFinite: def.isFinite ?? ((expr) => {
      const count = def.count(expr);
      if (count === void 0) return void 0;
      return Number.isFinite(count);
    }),
    subsetOf: def.subsetOf ?? collectionSubset
  };
  if (def.isLazy) result.isLazy = def.isLazy;
  if (def.eltsgn) result.eltsgn = def.eltsgn;
  if (def.elttype) result.elttype = def.elttype;
  if (def.at) {
    result.at = def.at;
    result.indexWhere = def.indexWhere ?? collectionIndexWhere;
  }
  return result;
}
var MAX_SIZE_EAGER_COLLECTION;
var init_collection_utils = __esm({
  "src/compute-engine/collection-utils.ts"() {
    init_utils();
    MAX_SIZE_EAGER_COLLECTION = 100;
  }
});

// src/compute-engine/boxed-expression/flatten.ts
function flatten(ops, operator2) {
  const xs = ops.every((x) => x.isCanonical) ? ops : ops.map((x) => x.canonical);
  if (operator2) {
    const shouldFlatten = (x) => x.symbol === "Nothing" || x.operator === operator2 || x.operator === "Sequence";
    if (xs.every((x) => !shouldFlatten(x))) return xs;
    const ys2 = [];
    for (const x of xs) {
      if (x.symbol === "Nothing") continue;
      if (x.ops && (x.operator === operator2 || x.operator === "Sequence"))
        ys2.push(...flatten(x.ops, operator2));
      else ys2.push(x);
    }
    return ys2;
  }
  if (xs.every((x) => !(x.symbol === "Nothing" || x.operator === "Sequence")))
    return xs;
  const ys = [];
  for (const x of xs) {
    if (x.symbol === "Nothing") continue;
    if (x.ops && x.operator === "Sequence")
      ys.push(...flatten(x.ops, operator2));
    else ys.push(x);
  }
  return ys;
}
function flattenOps(ops, operator2) {
  if (!operator2) return ops;
  if (ops.every((x) => !x.ops || x.operator !== operator2)) return ops;
  const result = [];
  for (const arg of ops) {
    if (!arg.ops || arg.operator !== operator2) result.push(arg);
    else {
      result.push(...flattenOps(arg.ops, operator2));
    }
  }
  console.assert(result.length !== ops.length);
  if (result.length === ops.length) return ops;
  return result;
}
function flattenSequence(xs) {
  if (xs.every((x) => x.operator !== "Sequence" && x.operator !== "Delimiter"))
    return xs;
  const ys = [];
  for (const x of xs) {
    if (!x.isValid) ys.push(x);
    else if (x.operator === "Delimiter") {
      if (x.op1.operator === "Sequence") {
        const seq = x.op1.ops ?? [];
        if (seq.length === 0) ys.push(x.engine.box(["Tuple"]));
        else ys.push(...flattenSequence(seq));
      } else ys.push(x.op1);
    } else if (x.operator === "Sequence") {
      if (x.ops) ys.push(...x.ops);
    } else ys.push(x);
  }
  return ys;
}
var init_flatten = __esm({
  "src/compute-engine/boxed-expression/flatten.ts"() {
  }
});

// src/compute-engine/latex-syntax/serialize-number.ts
function formatFractionalPart(digits, wholeDigitsCount, options) {
  if (options.repeatingDecimal && options.repeatingDecimal !== "none") {
    const truncatedDigits = digits.slice(0, -1);
    for (let i = 0; i < digits.length - 16; i++) {
      const offset = truncatedDigits.substring(0, i);
      for (let j = 0; j < 17; j++) {
        const cycle = truncatedDigits.substring(i, i + j + 1);
        const times = Math.floor(
          (truncatedDigits.length - offset.length) / cycle.length
        );
        if (times <= 3) break;
        if ((offset + cycle.repeat(times + 1)).startsWith(truncatedDigits)) {
          if (cycle === "0") {
            return insertFractionalGroupSeparator(offset, options);
          }
          let pattern = {
            vinculum: "\\overline{#}",
            parentheses: "(#)",
            dots: "\\overset{\\cdots}{#1}#2\\overset{\\cdots}{#3}",
            arc: "\\wideparen{#}"
          }[options.repeatingDecimal] ?? "\\overline{#}";
          pattern = pattern.replace(/#1/g, cycle[0]).replace(/#2/g, cycle.slice(1)).replace(/#3/g, cycle.slice(-1)).replace(/#/, cycle);
          return insertFractionalGroupSeparator(offset, options) + pattern;
        }
      }
    }
  }
  let maxFractionalDigits = typeof options.fractionalDigits === "number" ? options.fractionalDigits : Infinity;
  if (maxFractionalDigits < 0)
    maxFractionalDigits = maxFractionalDigits - wholeDigitsCount;
  if (maxFractionalDigits < 0) maxFractionalDigits = 0;
  const extraDigits = digits.length > maxFractionalDigits;
  if (extraDigits) digits = digits.substring(0, maxFractionalDigits);
  digits = insertFractionalGroupSeparator(digits, options);
  if (extraDigits) digits += options.truncationMarker;
  return digits;
}
function formatExponent(exp3, options) {
  if (!exp3 || exp3 === "0") return "";
  if (options.beginExponentMarker) {
    return options.beginExponentMarker + exp3 + (options.endExponentMarker ?? "");
  }
  return `10^{${exp3}}`;
}
function serializeNumber(expr, options) {
  if (expr === null) return "";
  let num;
  if (typeof expr === "number" || typeof expr === "string") {
    num = expr;
  } else if (typeof expr === "object" && "num" in expr) {
    num = expr.num;
  } else return "";
  if (typeof num === "number") {
    if (num === Infinity) return options.positiveInfinity;
    else if (num === -Infinity) return options.negativeInfinity;
    else if (Number.isNaN(num)) return options.notANumber;
    let result2 = void 0;
    if (options.notation === "engineering") {
      result2 = serializeScientificNotationNumber(
        num.toExponential(),
        options,
        3
      );
    } else if (options.notation === "scientific") {
      result2 = serializeScientificNotationNumber(num.toExponential(), {
        ...options,
        avoidExponentsInRange: null
        // Scientific notation should always use exponents
      });
    } else if (options.notation === "adaptiveScientific") {
      result2 = serializeScientificNotationNumber(num.toExponential(), options);
    }
    return result2 ?? serializeAutoNotationNumber(num.toString(), options);
  }
  num = num.toLowerCase().replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
  if (num === "infinity" || num === "+infinity" || num === "oo" || num === "+oo")
    return options.positiveInfinity;
  else if (num === "-infinity" || num === "-oo")
    return options.negativeInfinity;
  else if (num === "nan") return options.notANumber;
  if (!/^[-+\.]?[0-9]/.test(num)) return "";
  num = num.replace(/[nd]$/, "");
  if (/\([0-9]+\)/.test(num)) {
    const [_, body, repeat2, trail] = num.match(/(.+)\(([0-9]+)\)(.*)$/) ?? [];
    num = body + repeat2.repeat(6) + trail;
  }
  let sign3 = "";
  if (num[0] === "-") {
    sign3 = "-";
    num = num.substring(1);
  } else if (num[0] === "+") {
    num = num.substring(1);
  }
  while (num[0] === "0") num = num.substring(1);
  if (num.length === 0) num = "0";
  else if (num[0] === ".") num = "0" + num;
  let result = void 0;
  if (options.notation === "engineering") {
    result = serializeScientificNotationNumber(num, options, 3);
  } else if (options.notation === "scientific") {
    result = serializeScientificNotationNumber(num, options);
  } else if (options.notation === "adaptiveScientific") {
    result = serializeScientificNotationNumber(num, options);
  }
  return sign3 + (result ?? serializeAutoNotationNumber(num, {
    ...options
  }));
}
function serializeScientificNotationNumber(valString, options, expMultiple = 1) {
  let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
  if (!m) {
    let sign3 = "";
    if (valString[0] === "-") {
      sign3 = "-";
      valString = valString.substring(1);
    } else if (valString[0] === "+") {
      valString = valString.substring(1);
    }
    if (valString.indexOf(".") < 0) {
      if (valString.length === 1) {
        valString = sign3 + valString + "e+0";
      } else {
        valString = sign3 + valString[0] + "." + valString.slice(1) + "e+" + (valString.length - 1).toString();
      }
    } else {
      let [_, whole, fraction] = valString.match(/^(.*)\.(.*)$/);
      if (!fraction) fraction = "";
      while (whole.startsWith("0")) whole = whole.substring(1);
      if (!whole) {
        let leadingZeros = 0;
        while (fraction[leadingZeros] === "0") leadingZeros++;
        if (leadingZeros === fraction.length) {
          valString = sign3 + "0e+0";
        } else {
          const significand = fraction.slice(leadingZeros);
          const firstDigit = significand[0];
          const restDigits = significand.slice(1);
          const exponent2 = -(leadingZeros + 1);
          if (restDigits) {
            valString = sign3 + firstDigit + "." + restDigits + "e" + exponent2;
          } else {
            valString = sign3 + firstDigit + "e" + exponent2;
          }
        }
      } else {
        valString = sign3 + whole[0] + "." + whole.slice(1) + fraction + "e+" + (whole.length - 1).toString();
      }
    }
    m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
  }
  console.assert(m);
  if (!m) return serializeAutoNotationNumber(valString, options);
  let exponent = parseInt(m[2]);
  let mantissa = m[1];
  {
    const signMatch = mantissa.match(/^(-?)/);
    const sign3 = signMatch ? signMatch[1] : "";
    const unsigned = sign3 ? mantissa.substring(1) : mantissa;
    const parts = unsigned.match(/^(\d+)(?:\.(\d*))?$/);
    if (parts) {
      let whole = parts[1];
      let fraction = parts[2] ?? "";
      if (whole.length > 1) {
        fraction = whole.slice(1) + fraction;
        exponent += whole.length - 1;
        whole = whole[0];
      }
      mantissa = sign3 + whole;
      if (fraction) mantissa += "." + fraction;
    }
  }
  if (Math.abs(exponent) % expMultiple !== 0) {
    const adjust = exponent > 0 ? exponent % expMultiple : -((expMultiple + exponent) % expMultiple);
    exponent = exponent >= 0 ? exponent - adjust : exponent + adjust;
    let [_, whole, fraction] = mantissa.match(/^(.*)\.(.*)$/) ?? [
      "",
      mantissa,
      ""
    ];
    mantissa = whole + (fraction + "00000000000000000").slice(0, Math.abs(adjust)) + "." + fraction.slice(Math.abs(adjust));
  }
  const avoid = options.avoidExponentsInRange;
  if (avoid && exponent >= avoid[0] && exponent <= avoid[1]) return void 0;
  let fractionalPart = "";
  let wholePart = mantissa;
  m = wholePart.match(/^(.*)\.(.*)$/);
  if (m) {
    wholePart = m[1];
    fractionalPart = m[2];
  }
  const expString = formatExponent(Number(exponent).toString(), options);
  fractionalPart = formatFractionalPart(
    fractionalPart,
    wholePart.length,
    options
  );
  if (fractionalPart)
    fractionalPart = options.decimalSeparator + fractionalPart;
  wholePart = insertWholeGroupSeparator(wholePart, options);
  if (!expString) return wholePart + fractionalPart;
  return wholePart + fractionalPart + options.exponentProduct + expString;
}
function serializeAutoNotationNumber(valString, options) {
  let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
  let exp3 = 0;
  let originalExp = 0;
  if (m?.[1] && m[2]) {
    exp3 = parseInt(m[2]);
    originalExp = exp3;
    valString = m[1];
  }
  let wholePart = m?.[1] ?? valString;
  let fractionalPart = "";
  m = valString.match(/^(.*)\.(.*)$/);
  if (m?.[1] && m[2]) {
    wholePart = m[1];
    fractionalPart = m[2];
  }
  if (exp3 !== 0 && fractionalPart) {
    wholePart += fractionalPart;
    exp3 -= fractionalPart.length;
    fractionalPart = "";
  }
  const avoid = options.avoidExponentsInRange;
  if (exp3 !== 0 && avoid) {
    if (originalExp >= avoid[0] && originalExp <= avoid[1]) {
      [wholePart, fractionalPart] = toDecimalNumber(
        wholePart,
        fractionalPart,
        exp3
      );
      exp3 = 0;
    }
  }
  const exponent = formatExponent(exp3.toString(), options);
  if (fractionalPart)
    fractionalPart = options.decimalSeparator + formatFractionalPart(fractionalPart, wholePart.length, options);
  wholePart = insertWholeGroupSeparator(wholePart, options);
  if (!exponent) return wholePart + fractionalPart;
  if (!fractionalPart) {
    if (wholePart === "1") return exponent;
    if (wholePart === "-1") return "-" + exponent;
  }
  return wholePart + fractionalPart + options.exponentProduct + exponent;
}
function insertSeparatorEveryNDigitsFromLeft(numberString, n, separator) {
  const regex = new RegExp(`(\\d{${n}})(?=\\d)`, "g");
  return numberString.replace(regex, `$1${separator}`);
}
function insertSeparatorEveryNDigitsFromRight(numberString, n, separator) {
  const regex = new RegExp(`(\\d{${n}})(?=\\d)`, "g");
  const reversedSeparator = separator.split("").reverse().join("");
  return numberString.split("").reverse().join("").replace(regex, `$1${reversedSeparator}`).split("").reverse().join("");
}
function insertIndianNumberingSystem(numberString, separator) {
  const reverseString = numberString.split("").reverse().join("");
  const reversedSeparator = separator.split("").reverse().join("");
  let formattedString = reverseString.replace(
    /(\d{3})(?=\d)/,
    `$1${reversedSeparator}`
  );
  formattedString = formattedString.replace(
    /(\d{2})(?=(\d{2})+,)/g,
    `$1${reversedSeparator}`
  );
  return formattedString.split("").reverse().join("");
}
function insertGroupSeparator(numberString, options, part) {
  let group = options.digitGroup;
  if (typeof group !== "string" && Array.isArray(group)) group = group[part];
  const separator = typeof options.digitGroupSeparator === "string" ? options.digitGroupSeparator : options.digitGroupSeparator[part];
  if (!separator) return numberString;
  if (group === "lakh") {
    if (part === 0) return insertIndianNumberingSystem(numberString, separator);
    return insertSeparatorEveryNDigitsFromLeft(numberString, 3, separator);
  }
  if (group === false || group <= 0) return numberString;
  if (part === 1)
    return insertSeparatorEveryNDigitsFromLeft(numberString, group, separator);
  return insertSeparatorEveryNDigitsFromRight(numberString, group, separator);
}
function insertFractionalGroupSeparator(numberString, options) {
  return insertGroupSeparator(numberString, options, 1);
}
function insertWholeGroupSeparator(numberString, options) {
  return insertGroupSeparator(numberString, options, 0);
}
function toDecimalNumber(wholePart, fractionalPart, exp3) {
  let combinedNumber = wholePart + fractionalPart;
  const wholeLength = wholePart.length;
  const newDecimalPosition = wholeLength + exp3;
  let newWholePart;
  let newFractionalPart;
  if (newDecimalPosition > 0) {
    if (newDecimalPosition >= combinedNumber.length) {
      combinedNumber = combinedNumber + "0".repeat(newDecimalPosition - combinedNumber.length);
      newWholePart = combinedNumber;
      newFractionalPart = "";
    } else {
      newWholePart = combinedNumber.slice(0, newDecimalPosition);
      newFractionalPart = combinedNumber.slice(newDecimalPosition);
    }
  } else {
    newWholePart = "0";
    newFractionalPart = "0".repeat(-newDecimalPosition) + combinedNumber;
  }
  return [newWholePart, newFractionalPart];
}
var init_serialize_number = __esm({
  "src/compute-engine/latex-syntax/serialize-number.ts"() {
  }
});

// src/compute-engine/latex-syntax/serializer.ts
function specialName(s) {
  const prefix = s.match(/^([^_]+)/)?.[1] ?? "";
  let i = SYMBOLS.findIndex((x) => prefix === x[0]);
  if (i >= 0) return [SYMBOLS[i][1], s.substring(SYMBOLS[i][0].length)];
  const DIGITS = {
    zero: "0",
    one: "1",
    two: "2",
    three: "3",
    four: "4",
    five: "5",
    six: "6",
    seven: "7",
    eight: "8",
    nine: "9",
    ten: "10"
  };
  i = Object.keys(DIGITS).findIndex((x) => s.startsWith(x));
  if (i >= 0) {
    const key = Object.keys(DIGITS)[i];
    return [DIGITS[key], s.substring(key.length)];
  }
  const code = s.codePointAt(0);
  i = SYMBOLS.findIndex((x) => x[2] === code);
  if (i >= 0) return [SYMBOLS[i][1], s.substring(1)];
  const EXTRA_SYMBOLS = {
    plus: "+",
    minus: "-",
    pm: "\\pm",
    ast: "\\ast",
    dag: "\\dag",
    ddag: "\\ddag",
    hash: "\\#",
    bottom: "\\bot",
    top: "\\top",
    bullet: "\\bullet",
    circle: "\\circ",
    diamond: "\\diamond",
    times: "\\times",
    square: "\\square",
    star: "\\star"
  };
  i = Object.keys(EXTRA_SYMBOLS).findIndex((x) => prefix === x);
  if (i >= 0) {
    const key = Object.keys(EXTRA_SYMBOLS)[i];
    return [EXTRA_SYMBOLS[key], s.substring(key.length)];
  }
  return [prefix, s.substring(prefix.length)];
}
function parseModifiers(s) {
  let [body, rest] = specialName(s);
  const accent = [];
  while (rest.length > 0) {
    const m = rest.match(/^_([a-zA-Z]+)(.*)/);
    if (!m) break;
    if (!ACCENT_MODIFIERS[m[1]]) break;
    accent.push(m[1]);
    rest = m[2];
  }
  const styles = [];
  while (rest.length > 0) {
    const m = rest.match(/^_([a-zA-Z]+)(.*)/);
    if (!m) break;
    if (!STYLE_MODIFIERS[m[1]]) break;
    styles.push(m[1]);
    rest = m[2];
  }
  return [body, accent, styles, rest];
}
function parseSymbolBody2(s, topLevel = true, style = "auto") {
  let [body, accents, styles, rest] = parseModifiers(s);
  for (const accent of accents) {
    if (ACCENT_MODIFIERS[accent]) body = ACCENT_MODIFIERS[accent](body);
  }
  if (topLevel) {
    const sups = [];
    const subs = [];
    const m = body.match(/^([^\d].*?)(\d+)$/);
    if (m) {
      subs.push(m[2]);
      body = m[1];
    }
    while (rest.length > 0) {
      if (rest.startsWith("__")) {
        const [sup, rest2] = parseSymbolBody2(rest.substring(2), false, "none");
        sups.push(sup);
        rest = rest2;
      } else if (rest.startsWith("_")) {
        const [sub3, rest2] = parseSymbolBody2(rest.substring(1), false, "none");
        subs.push(sub3);
        rest = rest2;
      } else {
        break;
      }
    }
    if (sups.length > 0) body = supsub("^", body, sups.join(","));
    if (subs.length > 0) body = supsub("_", body, subs.join(","));
  }
  for (const style2 of styles) {
    if (STYLE_MODIFIERS[style2]) body = STYLE_MODIFIERS[style2](body);
  }
  if (styles.length === 0 && style !== "none") {
    switch (style) {
      case "auto":
        if (countTokens(body) > 1) body = `\\mathrm{${body}}`;
        break;
      case "operator":
        body = `\\operatorname{${body}}`;
        break;
      case "italic":
        body = `\\mathit{${body}}`;
        break;
      case "upright":
        body = `\\mathrm{${body}}`;
        break;
    }
  }
  return [body, rest];
}
function serializeSymbol(s, style = "auto") {
  if (s === null) return null;
  if (EMOJIS.test(s)) return s;
  const m = s.match(/^(_+)(.*)/);
  if (m) {
    const [body2, rest2] = parseSymbolBody2(m[2], true, "none");
    return `\\operatorname{${"\\_".repeat(m[1].length) + body2 + rest2}}`;
  }
  const [body, rest] = parseSymbolBody2(s, true, style);
  if (rest.length > 0) return `\\operatorname{${s}}`;
  return body;
}
function serializeLatex(expr, dict, options) {
  const serializer = new Serializer4(dict, options);
  return serializer.serialize(expr);
}
var ACCENT_MODIFIERS, STYLE_MODIFIERS, Serializer4;
var init_serializer = __esm({
  "src/compute-engine/latex-syntax/serializer.ts"() {
    init_utils2();
    init_types();
    init_tokenizer();
    init_serialize_number();
    init_definitions_symbols();
    init_definitions_core();
    init_symbols();
    ACCENT_MODIFIERS = {
      deg: (s) => `${s}\\degree`,
      prime: (s) => `${s}^{\\prime}`,
      dprime: (s) => `${s}^{\\doubleprime}`,
      ring: (s) => `\\mathring{${s}}`,
      hat: (s) => `\\hat{${s}}`,
      tilde: (s) => `\\tilde{${s}}`,
      vec: (s) => `\\vec{${s}}`,
      bar: (s) => `\\overline{${s}}`,
      underbar: (s) => `\\underline{${s}}`,
      dot: (s) => `\\dot{${s}}`,
      ddot: (s) => `\\ddot{${s}}`,
      tdot: (s) => `\\dddot{${s}}`,
      qdot: (s) => `\\ddddot{${s}}`,
      // Supplemental
      acute: (s) => `\\acute{${s}}`,
      grave: (s) => `\\grave{${s}}`,
      breve: (s) => `\\breve{${s}}`,
      check: (s) => `\\check{${s}}`
    };
    STYLE_MODIFIERS = {
      upright: (s) => `\\mathrm{${s}}`,
      italic: (s) => `\\mathit{${s}}`,
      bold: (s) => `\\mathbf{${s}}`,
      script: (s) => `\\mathscr{${s}}`,
      fraktur: (s) => `\\mathfrak{${s}}`,
      // Note Unicode uses 'fraktur' for 'gothic'
      doublestruck: (s) => `\\mathbb{${s}}`,
      // Unicode uses 'double-struck' for 'blackboard'
      // Supplemental
      blackboard: (s) => `\\mathbb{${s}}`,
      calligraphic: (s) => `\\mathcal{${s}}`,
      gothic: (s) => `\\mathfrak{${s}}`,
      sansserif: (s) => `\\mathsf{${s}}`,
      monospace: (s) => `\\mathtt{${s}}`
    };
    Serializer4 = class {
      options;
      dictionary;
      level = -1;
      constructor(dictionary, options) {
        this.dictionary = dictionary;
        this.options = options;
      }
      /**
       * Serialize the expression, and if the expression is an operator
       * of precedence less than or equal to prec, wrap it in some parens.
       * @todo: don't wrap Abs, Floor, Ceil, Delimiter
       */
      wrap(expr, prec) {
        if (expr === null || expr === void 0) return "";
        if (prec === void 0) {
          return this.wrapString(
            this.serialize(expr),
            this.options.groupStyle(expr, this.level + 1)
          );
        }
        if (typeof expr === "number" || isNumberObject(expr)) {
          const val = machineValue(expr);
          if (val !== null && val < 0 && prec > ADDITION_PRECEDENCE)
            return this.wrap(expr);
          return this.serialize(expr);
        }
        const name = operator(expr);
        if (name && name !== "Delimiter" && name !== "Subscript") {
          const def = this.dictionary.ids.get(name);
          if (def && (def.kind === "symbol" || def.kind === "expression" || def.kind === "prefix" || def.kind === "infix" || def.kind === "postfix") && def.precedence < prec)
            return this.wrapString(
              this.serialize(expr),
              this.options.applyFunctionStyle(expr, this.level)
            );
        }
        return this.serialize(expr);
      }
      /**
       * If this is a "short" expression, wrap it.
       * Do not wrap symbols, positive numbers or functions.
       *
       * This is called by the serializer for power and division (i.e. "(a+1)/b")
       *
       */
      wrapShort(expr) {
        if (expr === null || expr === void 0) return "";
        const exprStr = this.serialize(expr);
        if (symbol(expr) !== null) return exprStr;
        const isNum = isNumberExpression(expr);
        if (isNum && !/^(-|\.)/.test(exprStr)) return exprStr;
        const h = operator(expr);
        if (h === "Delimiter" && nops(expr) === 1) return exprStr;
        if (h !== "Add" && h !== "Negate" && h !== "Subtract" && h !== "PlusMinus" && h !== "Multiply")
          return exprStr;
        return this.wrapString(
          exprStr,
          this.options.groupStyle(expr, this.level + 1)
        );
      }
      wrapString(s, style, fence) {
        if (style === "none") return s;
        fence ??= "()";
        let openFence = fence?.[0] ?? ".";
        let closeFence = fence?.[1] ?? ".";
        if (openFence === '"') openFence = "``";
        else if (openFence === "|") openFence = "\\lvert";
        else openFence = DELIMITERS_SHORTHAND[openFence] ?? openFence;
        if (closeFence === '"') closeFence = "''";
        else if (closeFence === "|") closeFence = "\\rvert";
        else closeFence = DELIMITERS_SHORTHAND[closeFence] ?? closeFence;
        if (openFence === "." && closeFence === ".") return s;
        if ((openFence === "." || closeFence === ".") && style === "normal")
          style = "scaled";
        if (style === "scaled")
          return `\\left${openFence}${s}\\right${closeFence}}`;
        if (style === "big")
          return `${`\\Bigl${openFence}`}${s}${`\\Bigr${closeFence}`})`;
        return openFence + s + closeFence;
      }
      wrapArguments(expr) {
        return this.wrapString(
          operands(expr).map((x) => this.serialize(x)).join(", "),
          this.options.applyFunctionStyle(expr, this.level)
        );
      }
      serializeSymbol(expr, def) {
        console.assert(typeof expr === "string" || isSymbolObject(expr));
        if (def?.kind === "function") {
          return serializeSymbol(symbol(expr) ?? "") ?? "";
        }
        return def?.serialize?.(this, expr) ?? serializeSymbol(symbol(expr)) ?? "";
      }
      serializeFunction(expr, def) {
        if (def?.serialize) return def.serialize(this, expr);
        const h = operator(expr);
        return serializeSymbol(h, "auto") + this.wrapArguments(expr);
      }
      serialize(expr) {
        if (expr === null || expr === void 0) return "";
        this.level += 1;
        try {
          const result = (() => {
            const numericValue = serializeNumber(expr, this.options);
            if (numericValue) return numericValue;
            const s = stringValue(expr);
            if (s !== null) return `\\text{${s}}`;
            const symbolName2 = symbol(expr);
            if (symbolName2 !== null) {
              return this.serializeSymbol(
                expr,
                this.dictionary.ids.get(symbolName2)
              );
            }
            const fnName = operator(expr);
            if (fnName) {
              const def = this.dictionary.ids.get(fnName);
              return this.serializeFunction(expr, def);
            }
            throw Error(
              `Syntax error ${expr ? JSON.stringify(expr, void 0, 4) : ""}`
            );
          })();
          this.level -= 1;
          return result ?? "";
        } catch (e) {
        }
        this.level -= 1;
        return "";
      }
      applyFunctionStyle(expr, level) {
        return this.options.applyFunctionStyle(expr, level);
      }
      groupStyle(expr, level) {
        return this.options.groupStyle(expr, level);
      }
      rootStyle(expr, level) {
        return this.options.rootStyle(expr, level);
      }
      fractionStyle(expr, level) {
        return this.options.fractionStyle(expr, level);
      }
      logicStyle(expr, level) {
        return this.options.logicStyle(expr, level);
      }
      powerStyle(expr, level) {
        return this.options.powerStyle(expr, level);
      }
      numericSetStyle(expr, level) {
        return this.options.numericSetStyle(expr, level);
      }
    };
  }
});

// src/compute-engine/numerics/numeric-bigint.ts
function gcd2(a, b) {
  while (b !== BigInt(0)) [a, b] = [b, a % b];
  return a < 0 ? -a : a;
}
function lcm2(a, b) {
  return a * b / gcd2(a, b);
}
function* factorial3(n) {
  if (n < 0) return BigInt(0);
  if (n < 10)
    return BigInt([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880][Number(n)]);
  if (n % BigInt(2) === BigInt(1)) return n * (yield* factorial3(n - BigInt(1)));
  let loop = n;
  let sum2 = n;
  let val = n;
  let counter = 0;
  while (loop > 2) {
    loop -= BigInt(2);
    sum2 += loop;
    val *= sum2;
    counter += 1;
    if (counter % 5e4 === 0 || counter > 1e4 && counter % 500 === 0)
      yield val;
  }
  return val;
}
var init_numeric_bigint = __esm({
  "src/compute-engine/numerics/numeric-bigint.ts"() {
    init_bigint();
    init_primes();
  }
});

// src/compute-engine/numerics/rationals.ts
function isRational(x) {
  return x !== null && Array.isArray(x);
}
function isMachineRational(x) {
  return x !== null && Array.isArray(x) && typeof x[0] === "number";
}
function isBigRational(x) {
  return x !== null && Array.isArray(x) && typeof x[0] === "bigint";
}
function isZero(x) {
  return x[0] == 0;
}
function isPositive(x) {
  return x[0] > 0;
}
function isOne(x) {
  return x[0] == x[1];
}
function isNegativeOne(x) {
  return x[0] === -x[1];
}
function isInteger(x) {
  return x[1] == 1;
}
function machineNumerator(x) {
  return Number(x[0]);
}
function machineDenominator(x) {
  return Number(x[1]);
}
function rationalAsFloat(x) {
  return Number(x[0]) / Number(x[1]);
}
function add2(lhs, rhs) {
  if (typeof lhs[0] === "number" && !Number.isFinite(lhs[0])) return lhs;
  const rhsNum = rhs;
  if (rhsNum === null) return lhs;
  if (isBigRational(rhsNum)) {
    lhs = [BigInt(lhs[0]), BigInt(lhs[1])];
    return [rhsNum[1] * lhs[0] + rhsNum[0] * lhs[1], rhsNum[1] * lhs[1]];
  }
  if (!Number.isFinite(rhsNum[0])) return rhsNum;
  if (isBigRational(lhs)) {
    const bigRhs = [BigInt(rhsNum[0]), BigInt(rhsNum[1])];
    return [bigRhs[1] * lhs[0] + bigRhs[0] * lhs[1], bigRhs[1] * lhs[1]];
  }
  return [rhsNum[1] * lhs[0] + rhsNum[0] * lhs[1], rhsNum[1] * lhs[1]];
}
function mul2(lhs, rhs) {
  if (isMachineRational(lhs) && isMachineRational(rhs))
    return [lhs[0] * rhs[0], lhs[1] * rhs[1]];
  if (isMachineRational(lhs))
    return [
      BigInt(lhs[0]) * rhs[0],
      BigInt(lhs[1]) * rhs[1]
    ];
  if (isMachineRational(rhs))
    return [
      BigInt(rhs[0]) * lhs[0],
      BigInt(rhs[1]) * lhs[1]
    ];
  return [lhs[0] * rhs[0], lhs[1] * rhs[1]];
}
function neg(x) {
  return [-x[0], x[1]];
}
function inverse(x) {
  return x[0] < 0 ? [-x[1], -x[0]] : [x[1], x[0]];
}
function asMachineRational(r) {
  return [Number(r[0]), Number(r[1])];
}
function rationalGcd(lhs, rhs) {
  if (isMachineRational(lhs) && isMachineRational(rhs)) {
    if (lhs[1] === 1 && rhs[1] === 1) return [gcd(lhs[0], rhs[0]), 1];
    return [gcd(lhs[0], rhs[0]), lcm(lhs[1], rhs[1])];
  }
  if (lhs[1] === 1 && rhs[1] === 1)
    return [gcd2(BigInt(lhs[0]), BigInt(rhs[0])), BigInt(1)];
  return [
    gcd2(BigInt(lhs[0]), BigInt(rhs[0])),
    lcm2(BigInt(lhs[1]), BigInt(rhs[1]))
  ];
}
function reducedRational(r) {
  if (isMachineRational(r)) {
    if (r[1] < 0) r = [-r[0], -r[1]];
    if (r[0] === 1 || r[1] === 1) return r;
    if (!Number.isFinite(r[1])) return [0, 1];
    const g2 = gcd(r[0], r[1]);
    return g2 <= 1 ? r : [r[0] / g2, r[1] / g2];
  }
  if (r[1] < 0) r = [-r[0], -r[1]];
  const g = gcd2(r[0], r[1]);
  const [n, d] = g <= 1 ? r : [r[0] / g, r[1] / g];
  if (n <= Number.MAX_SAFE_INTEGER && n >= Number.MIN_SAFE_INTEGER && d <= Number.MAX_SAFE_INTEGER)
    return [Number(n), Number(d)];
  return [n, d];
}
function rationalize(x) {
  if (!Number.isFinite(x)) return x;
  const fractional = x % 1;
  if (fractional === 0) return x;
  const eps = 1e-15;
  let a = Math.floor(x);
  let h1 = 1;
  let k1 = 0;
  let h = a;
  let k = 1;
  while (x - a > eps * k * k) {
    x = 1 / (x - a);
    a = Math.floor(x);
    const h2 = h1;
    h1 = h;
    const k2 = k1;
    k1 = k;
    h = h2 + a * h1;
    k = k2 + a * k1;
  }
  return [h, k];
}
var init_rationals = __esm({
  "src/compute-engine/numerics/rationals.ts"() {
    init_numeric();
    init_numeric_bigint();
  }
});

// src/compute-engine/boxed-expression/ascii-math.ts
function bigOp(expr, op, serialize) {
  const [fn, ...limits] = expr.ops ?? [];
  const indexes = [];
  let body;
  let args = [];
  if (fn?.operator === "Function") {
    args = fn.ops.slice(1) ?? [];
    const b = fn.op1 ?? fn;
    if (b.operator === "Block") body = serialize(b.op1 ?? b);
    else body = serialize(b);
  } else if (fn) {
    args = [];
    body = serialize(fn);
  } else {
    return `${op}()`;
  }
  let result = op;
  for (const limit2 of limits) {
    if (!["Range", "Tuple", "Pair", "Single", "Limits"].includes(limit2.operator))
      continue;
    if (limit2.nops === 0) continue;
    if (limit2.nops === 2) {
      if (limit2.op1.symbol) {
        if (limit2.op1.symbol !== "Nothing") indexes.push(limit2.op1);
        if (limit2.op2.symbol !== "Nothing") {
          if (op === "int") result += `_${wrap(serialize(limit2.op2))}`;
          else
            result += "_" + wrap(`${limit2.op1.symbol}=${serialize(limit2.op2)}`);
        }
      } else {
        if (limit2.op1.symbol !== "Nothing")
          result += `_${wrap(serialize(limit2.op1))}`;
        if (limit2.op2.symbol !== "Nothing")
          result += `^${wrap(serialize(limit2.op2))}`;
      }
    } else if (limit2.nops === 3) {
      let index = "";
      if (limit2.op1.symbol !== "Nothing") {
        indexes.push(limit2.op1);
        index = limit2.op1.symbol ?? "";
      }
      const start = limit2.op2.symbol !== "Nothing" ? limit2.op2 : null;
      const end = limit2.op3.symbol !== "Nothing" ? limit2.op3 : null;
      if (start) {
        if (op === "int" || !index) result += `_${wrap(serialize(start))}`;
        else result += "_" + wrap(`${index}=${serialize(start)}`);
      } else if (op !== "int") {
        result += `_${wrap(serialize(limit2.op1))}`;
      }
      if (end) result += `^${wrap(serialize(end))}`;
    }
  }
  if (op === "int") {
    result += wrap(body + args.map((x) => ` d${serialize(x)}`).join(" "));
  } else {
    result += wrap(body);
  }
  return result;
}
function delimiter(expr, delimiter2, serialize) {
  if (!delimiter2) delimiter2 = "(,)";
  let separator = "";
  let open = "";
  let close = "";
  if (delimiter2.length === 1) separator = delimiter2;
  if (delimiter2.length === 2) {
    open = delimiter2[0];
    close = delimiter2[1];
  }
  if (delimiter2.length === 3) {
    open = delimiter2[0];
    separator = delimiter2[1];
    close = delimiter2[2];
  }
  if (!expr) return `${open}${close}`;
  let items = [expr];
  if (expr.operator === "Sequence") items = expr.ops;
  return `${open}${items.map((x) => serialize(x)).join(separator)}${close}`;
}
function wrap(s, precedence = 0, target = -1) {
  if (precedence > target && !/^\(.+\)$/.test(s)) return `(${s})`;
  return s;
}
function serializeSymbol2(symbol2, options = {}) {
  if (options.symbols?.[symbol2]) return options.symbols[symbol2];
  if (SYMBOLS2[symbol2]) return SYMBOLS2[symbol2];
  if (symbol2.startsWith("_")) return symbol2;
  if (FUNCTIONS[symbol2] && typeof FUNCTIONS[symbol2] === "string")
    return FUNCTIONS[symbol2];
  return symbol2.length === 1 ? symbol2 : `"${symbol2}"`;
}
function toAsciiMath(expr, options = {}, precedence = 0) {
  if (expr === void 0) return "[undefined]";
  if (expr === null) return "[null]";
  if (expr.symbol) return serializeSymbol2(expr.symbol, options);
  const serialize = (expr2, precedence2 = 0) => toAsciiMath(expr2, options, precedence2);
  if (expr.string) {
    return `"${expr.string.replace(/"/g, '\\"')}"`;
  }
  const num = expr.numericValue;
  if (num !== null) {
    if (expr.isNaN) return serializeSymbol2("NaN", options);
    if (expr.isFinite === false) {
      if (expr.isNegative !== true && expr.isPositive !== true)
        return serializeSymbol2("ComplexInfinity", options);
      return serializeSymbol2(
        expr.isNegative ? "NegativeInfinity" : "PositiveInfinity",
        options
      );
    }
    return num.toString();
  }
  if (expr.operator) {
    const operators = options.operators ? { ...OPERATORS, ...options.operators } : OPERATORS;
    const [operator2, precedence_] = operators[expr.operator] ?? [];
    if (operator2) {
      let result = "";
      if (typeof operator2 === "function") {
        result = operator2(expr, serialize);
      } else {
        if (expr.nops === 1)
          return `${operator2}${serialize(expr.op1, precedence_ + 1)}`;
        result = expr.ops?.map((x) => serialize(x, precedence_ + 1)).join(` ${operator2} `) ?? "";
      }
      return wrap(result, precedence, precedence_);
    }
    const functions = options.functions ? { ...FUNCTIONS, ...options.functions } : FUNCTIONS;
    const func = functions[expr.operator];
    if (typeof func === "function") return func(expr, serialize);
    if (typeof func === "string")
      return `${func}(${expr.ops?.map((x) => serialize(x)).join(", ") ?? ""})`;
    return `${expr.operator}(${expr.ops?.map((x) => serialize(x)).join(", ") ?? ""})`;
  }
  return JSON.stringify(expr.json);
}
function joinMul(lhs, rhs) {
  if (!lhs) return rhs;
  if (!rhs) return lhs;
  if (rhs.startsWith("-") || rhs.startsWith("+")) rhs = `(${rhs})`;
  if (lhs.match(/^[-+]?\d+$/) && rhs.match(/^[a-zA-Z\(]/)) return lhs + rhs;
  return `${lhs} * ${rhs}`;
}
function joinAdd(lhs, rhs) {
  if (!lhs) return rhs;
  if (!rhs) return lhs;
  if (rhs.startsWith("-")) return `${lhs} - ${rhs.substring(1)}`;
  if (rhs.startsWith("+")) return `${lhs} + ${rhs.substring(1)}`;
  return `${lhs} + ${rhs}`;
}
var SYMBOLS2, OPERATORS, FUNCTIONS;
var init_ascii_math = __esm({
  "src/compute-engine/boxed-expression/ascii-math.ts"() {
    init_rationals();
    SYMBOLS2 = {
      PositiveInfinity: "+oo",
      NegativeInfinity: "-oo",
      ComplexInfinity: "~oo",
      NaN: "NaN",
      Pi: "pi",
      ExponentialE: "e",
      ImaginaryUnit: "i",
      ContinuationPlaceholder: "...",
      // Greek letters are valid symbols (i.e. don't need to be quoted)
      alpha: "alpha",
      beta: "beta",
      gamma: "gamma",
      delta: "delta",
      epsilon: "epsilon",
      epsilonSymbol: "varepsilon",
      zeta: "zeta",
      eta: "eta",
      theta: "theta",
      thetaSymbol: "vartheta",
      iota: "iota",
      kappa: "kappa",
      lambda: "lambda",
      mu: "mu",
      nu: "nu",
      xi: "xi",
      omicron: "omicron",
      pi: "pi",
      rho: "rho",
      sigma: "sigma",
      tau: "tau",
      upsilon: "upsilon",
      phi: "phi",
      phiSymbol: "varphi",
      chi: "chi",
      psi: "psi",
      omega: "omega",
      Gamma: "Gamma",
      Delta: "Delta",
      Theta: "Theta",
      Lambda: "Lambda",
      Xi: "Xi",
      Sigma: "Sigma",
      Upsilon: "Upsilon",
      Phi: "Phi",
      Psi: "Psi",
      Omega: "Omega"
    };
    OPERATORS = {
      Add: [
        (expr, serialize) => {
          let ops = expr.ops ?? [];
          if (ops.length === 2 && ops[0].operator === "Negate" && ops[1].operator !== "Negate" && ops[1].isNumberLiteral) {
            ops = [ops[1], ops[0]];
          }
          return ops.reduce((acc, x) => {
            if (x.operator === "Negate") {
              const rhs = serialize(x.op1, 10);
              if (acc === "") return `-${rhs}`;
              if (rhs.startsWith("+")) return `${acc} - ${rhs.substring(1)}`;
              if (rhs.startsWith("-")) return `${acc} + ${rhs.substring(1)}`;
              return `${acc} - ${rhs}`;
            }
            return joinAdd(acc, serialize(x, 10));
          }, "") ?? "";
        },
        11
      ],
      Negate: [
        (expr, serialize) => {
          const base = serialize(expr.op1, 14);
          const op = expr.op1?.operator;
          if (op === "Power" || op === "Square") return `-(${base})`;
          return `-${base}`;
        },
        14
      ],
      Subtract: [
        (expr, serialize) => {
          return expr.ops?.reduce((acc, x) => {
            const rhs = serialize(x, 10);
            if (acc === "") return rhs;
            if (rhs.startsWith("-")) return `${acc} - (${rhs})`;
            return `${acc} - ${rhs}`;
          }, "") ?? "";
        },
        11
      ],
      Multiply: [
        (expr, serialize) => {
          if (!expr.ops) return "";
          if (expr.nops === 2) {
            const lhs = expr.op1.numericValue;
            if (lhs !== null) {
              if (typeof lhs !== "number" && lhs.im !== 0) {
                joinMul(
                  serialize(expr.op2, 12),
                  joinAdd(lhs.re.toString(), `${lhs.im}i`)
                );
              }
              const rhs = expr.op2;
              if (rhs.symbol || rhs.operator === "Power" || rhs.operator === "Square" || typeof FUNCTIONS[rhs.operator] === "string") {
                if (isRational(lhs) && lhs[0] === 1) {
                  const den = lhs[1];
                  return `${serialize(rhs, 12)}/${den}`;
                }
              }
              return joinMul(serialize(expr.op1, 12), serialize(expr.op2, 12));
            }
          }
          return expr.ops.reduce((acc, x) => joinMul(acc, serialize(x, 12)), "");
        },
        12
      ],
      Divide: ["/", 13],
      Power: [
        (expr, serialize) => {
          const exponent = serialize(expr.op2, 14);
          if (exponent === "1") return serialize(expr.op1);
          if (exponent === "(1/2)" || exponent === "1/2" || exponent === "0.5")
            return `sqrt(${serialize(expr.op1)})`;
          if (exponent === "-0.5" || exponent === "-1/2" || exponent === "(-1/2)")
            return `1 / sqrt(${serialize(expr.op1)})`;
          let base = serialize(expr.op1, 14);
          if (base.startsWith("-")) base = `(${base})`;
          if (exponent.length === 1) return `${base}^${exponent}`;
          return `${base}^${wrap(exponent)}`;
        },
        15
      ],
      Equal: ["===", 8],
      NotEqual: ["!==", 8],
      LessEqual: ["<=", 9],
      GreaterEqual: [">=", 9],
      Less: ["<", 9],
      Greater: [">", 9],
      And: ["&&", 4],
      Or: ["||", 3],
      Not: ["!", 14]
      // Unary operator
    };
    FUNCTIONS = {
      Abs: (expr, serialize) => `|${serialize(expr.op1)}|`,
      Norm: (expr, serialize) => `||${serialize(expr.op1)}||`,
      // Trigonometric functions
      Sin: "sin",
      Cos: "cos",
      Tan: "tan",
      Sec: "sec",
      Csc: "csc",
      Cot: "cot",
      // Inverse trigonometric functions
      Arcsin: "arcsin",
      Arccos: "arccos",
      Arctan: "arctan",
      Arcsec: "arcsec",
      Arccsc: "arccsc",
      Arccot: "arccot",
      // Hyperbolic functions
      Sinh: "sinh",
      Cosh: "cosh",
      Tanh: "tanh",
      Sech: "sech",
      Csch: "csch",
      Coth: "coth",
      // Inverse hyperbolic functions (ISO 80000-2 standard names)
      Arsinh: "arsinh",
      Arcosh: "arcosh",
      Artanh: "artanh",
      Arsech: "arsech",
      Arcsch: "arcsch",
      Arcoth: "arcoth",
      Ceil: "ceil",
      // also: (expr, serialize) => `|~${serialize(expr.op1)}~|`,
      Exp: "exp",
      Factorial: (expr, serialize) => `${serialize(expr.op1, 12)}!`,
      Floor: "floor",
      // also: (expr, serialize) => `|__${serialize(expr.op1)}__|`,
      Log: "log",
      Ln: "ln",
      Log10: "log10",
      Sqrt: "sqrt",
      Root: (expr, serialize) => {
        const x = expr.op1;
        const n = expr.op2;
        if (n.is(2)) return `sqrt${wrap(serialize(x))}`;
        return `root${wrap(serialize(n))}${wrap(serialize(x))}`;
      },
      Square: (expr, serialize) => `${serialize(expr.op1, 12)}^2`,
      Det: "det",
      Dim: "dim",
      Mod: "mod",
      GCD: "gcd",
      LCM: "lcm",
      Lub: "lub",
      Glb: "glb",
      Max: "max",
      Min: "min",
      PlusMinus: (expr, serialize) => {
        const [lhs, rhs] = expr.ops ?? [];
        if (!rhs) return serialize(lhs);
        if (lhs && rhs) {
          const lhs_ = serialize(lhs);
          const rhs_ = serialize(rhs);
          return `${lhs_} \xB1 ${rhs_}`;
        }
        if (lhs) return `\xB1 ${serialize(lhs)}`;
        if (rhs) return `\xB1 ${serialize(rhs)}`;
        return "0";
      },
      Sum: (expr, serialize) => bigOp(expr, "sum", serialize),
      Product: (expr, serialize) => bigOp(expr, "prod", serialize),
      Integrate: (expr, serialize) => bigOp(expr, "int", serialize),
      Limit: (expr, serialize) => {
        const [fn, val] = expr.ops ?? [];
        if (fn?.operator === "Function") {
          const args = fn.ops?.slice(2) ?? [];
          const body = fn.op1 ?? fn;
          let arg = null;
          if (args.length === 1) arg = args[0];
          return arg ? `lim_(${serialize(arg)} -> ${serialize(val)}) ${serialize(body)}` : `lim_(${serialize(val)}) ${serialize(body)}`;
        } else if (fn?.symbol) {
          return `lim_(x -> ${serialize(val)}) ${serialize(fn)}(x)`;
        }
        return `lim`;
      },
      // Note: use ops[0], not op1 because op1 is "Nothing" when empty, and
      // we need to correctly handle `["Delimiter"]`
      Delimiter: (expr, serialize) => delimiter(expr.ops[0], expr.ops[1]?.string, serialize),
      Sequence: (expr, serialize) => {
        if (expr.nops === 0) return "";
        return expr.ops.map((x) => serialize(x)).join(" ");
      },
      List: (expr, serialize) => `[${expr.ops?.map((x) => serialize(x)) ?? ""}]`,
      Single: (expr, serialize) => `(${expr.ops.map((x) => serialize(x)).join(", ")})`,
      Pair: (expr, serialize) => `(${expr.ops.map((x) => serialize(x)).join(", ")})`,
      Triple: (expr, serialize) => `(${expr.ops.map((x) => serialize(x)).join(", ")})`,
      Tuple: (expr, serialize) => `(${expr.ops.map((x) => serialize(x)).join(", ")})`,
      Block: (expr, serialize) => {
        if (expr.nops === 0) return "{}";
        if (expr.nops === 1) return `{${serialize(expr.op1)}}`;
        return `{    ${expr.ops.map((x) => serialize(x)).join(";\n     ")}
    }`;
      },
      EvaluateAt: (expr, serialize) => {
        const f = expr.op1;
        const args = expr.ops.slice(1);
        if (args.length === 0) return serialize(f);
        if (args.length === 1) return `(${serialize(f)})|_(${serialize(args[0])})`;
        if (args.length === 2)
          return `(${serialize(f)})|_(${serialize(args[0])})^(${serialize(args[1])})`;
        return `(${serialize(f)})|_(${args.map((x) => serialize(x)).join(", ")})`;
      },
      Function: (expr, serialize) => {
        const args = expr.ops.slice(1);
        const serializedArgs = () => args.map((x) => serialize(x)).join(", ");
        if (expr.op1.operator === "Block") {
          if (expr.op1.nops === 0) return `(${serializedArgs()}) |-> {}`;
          if (expr.op1.nops === 1) {
            if (args.length === 1 && args[0].symbol === "_1") {
              return `(_) |-> ${serialize(expr.op1.op1.subs({ _1: "_" }))}`;
            }
            return `(${serializedArgs()}) |-> ${serialize(expr.op1.op1)}`;
          }
          return `(${serializedArgs()}) |-> {
    ${expr.op1.ops.map((x) => serialize(x)).join(";\n     ")}
}`;
        }
        return `(${serializedArgs()}) |-> ${serialize(expr.op1)}`;
      },
      Domain: (expr) => JSON.stringify(expr.json),
      Error: (expr, serialize) => {
        if (expr.nops === 1) return `Error(${serialize(expr.op1)})`;
        if (expr.nops === 2) {
          if (expr.op1.string)
            return `Error("${expr.op1.string}", ${serialize(expr.op2)})`;
          return `Error(${serialize(expr.op1)}, ${serialize(expr.op2)})`;
        }
        return `Error(${expr.ops.map((x) => serialize(x)).join(", ")})`;
      },
      LatexString: (expr) => {
        return `"${expr.op1.string ?? ""}"`;
      }
    };
  }
});

// src/common/interruptible.ts
async function runAsync(gen, timeLimitMs, signal) {
  const startTime = performance.now();
  while (true) {
    const chunkStart = performance.now();
    const chunkDurationMs = 16;
    while (performance.now() - chunkStart < chunkDurationMs) {
      const { done, value } = gen.next();
      if (done) return value;
      if (signal?.aborted)
        throw new CancellationError({ value, cause: signal.reason });
      if (performance.now() - startTime >= timeLimitMs)
        throw new CancellationError({
          value,
          cause: "timeout",
          message: `Timeout exceeded (${timeLimitMs}ms)`
        });
    }
    await new Promise((resolve) => setTimeout(resolve, 0));
  }
}
function run(gen, timeLimitMs) {
  const startTime = Date.now();
  while (true) {
    const { done, value } = gen.next();
    if (done) return value;
    const elapsedTime = Date.now() - startTime;
    if (elapsedTime >= timeLimitMs) {
      throw new CancellationError({
        value,
        cause: "timeout",
        message: `Timeout exceeded (${timeLimitMs}ms)`
      });
    }
  }
}
var CancellationError;
var init_interruptible = __esm({
  "src/common/interruptible.ts"() {
    CancellationError = class extends Error {
      cause;
      value;
      constructor({
        message,
        value,
        cause
      } = {}) {
        super(message ?? "Operation canceled");
        if (value) this.value = value;
        this.cause = cause;
        this.name = "CancellationError";
      }
    };
  }
});

// src/compute-engine/numerics/numeric-bignum.ts
function gcd3(a, b) {
  console.assert(a.isInteger() && b.isInteger());
  while (!b.isZero()) [a, b] = [b, a.modulo(b)];
  return a.abs();
}
function lcm3(a, b) {
  return a.mul(b).div(gcd3(a, b));
}
function factorial23(ce, n) {
  if (!n.isInteger() || n.isNegative()) return ce._BIGNUM_NAN;
  if (n.lessThan(1)) return ce._BIGNUM_ONE;
  let result = n;
  while (n.greaterThan(2)) {
    n = n.minus(2);
    result = result.mul(n);
  }
  return result;
}
function isInMachineRange(d) {
  if (!d.isFinite()) return true;
  if (d.d.length > 3 || d.d.length === 3 && d.d[0] >= 90) return false;
  console.assert(d.precision() <= 16);
  return d.e < 308 && d.e > -306;
}
var init_numeric_bignum = __esm({
  "src/compute-engine/numerics/numeric-bignum.ts"() {
  }
});

// src/compute-engine/numerics/strings.ts
function fromRoman(roman) {
  if (roman === "N") return [0, ""];
  const romanMap = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1e3
  };
  let total = 0;
  let prevValue = 0;
  roman = roman.toUpperCase();
  for (let i = roman.length - 1; i >= 0; i--) {
    const currentValue = romanMap[roman[i]];
    if (currentValue === void 0) return [total, roman.slice(i)];
    if (currentValue < prevValue) total -= currentValue;
    else total += currentValue;
    prevValue = currentValue;
  }
  return [total, ""];
}
function fromDigits(s, baseInput) {
  s = s.trim();
  if (s.length === 0) return [NaN, ""];
  if (s.startsWith("+")) return fromDigits(s.slice(1), baseInput);
  if (s.startsWith("-")) {
    const [v, r] = fromDigits(s.slice(1), baseInput);
    return [-v, r];
  }
  let base = 10;
  if (typeof baseInput === "string") baseInput = baseInput.toLowerCase();
  if (s.startsWith("0x")) {
    base = 16;
    s = s.slice(2);
  } else if (s.startsWith("0b")) {
    base = 2;
    s = s.slice(2);
  } else if (baseInput === "roman") {
    return fromRoman(s);
  } else if (baseInput === "base64" || baseInput === "base-64") {
    try {
      return [parseInt(btoa(s)), ""];
    } catch (e) {
      return [NaN, ""];
    }
  } else if (typeof baseInput === "number") {
    base = baseInput;
  } else if (typeof baseInput === "string") {
    base = parseInt(baseInput);
  }
  let value = 0;
  for (let i = 0; i < s.length; i++) {
    const k = {
      " ": -1,
      "\xA0": -1,
      // NBS
      "\u2000": -1,
      // EN QUAD
      "\u2001": -1,
      // EM QUAD
      "\u2002": -1,
      // EN SPACE
      "\u2003": -1,
      // EM SPACE
      "\u2004": -1,
      // THREE-PER-EM SPACE
      "\u2005": -1,
      // FOUR-PER-EM SPACE
      "\u2006": -1,
      // SIX-PER-EM SPACE
      "\u2007": -1,
      // FIGURE SPACE
      "\u2008": -1,
      // PUNCTUATION SPACE
      "\u2009": -1,
      // THIN SPACE
      "\u200A": -1,
      // HAIR SPACE
      "\u200B": -1,
      // ZWS
      "\u202F": -1,
      // NARROW NBS
      "\u205F": -1,
      // MEDIUM MATHEMATICAL SPACE
      "_": -1,
      ",": -1,
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "b": 11,
      "c": 12,
      "d": 13,
      "e": 14,
      "f": 15,
      "g": 16,
      "h": 17,
      "i": 18,
      "j": 19,
      "k": 20,
      "l": 21,
      "m": 22,
      "n": 23,
      "o": 24,
      "p": 25,
      "q": 26,
      "r": 27,
      "s": 28,
      "t": 29,
      "u": 30,
      "v": 31,
      "w": 32,
      "x": 33,
      "y": 34,
      "z": 35
    }[s[i]];
    if (k !== -1) {
      if (k === void 0) return [value, s.substring(i)];
      if (k >= base) return [value, s.substring(i)];
      value = value * base + k;
    }
  }
  return [value, ""];
}
function numberToString(num, fractionalDigits) {
  if (typeof fractionalDigits === "number" && typeof num === "number")
    return num.toFixed(fractionalDigits);
  const numStr = num.toString();
  if (typeof num === "number" && Number.isInteger(num) && numStr.includes("e")) {
    const fixedStr = BigInt(num).toString();
    const trailingZeros = fixedStr.match(/0+$/);
    const trailingZerosCount = trailingZeros ? trailingZeros[0].length : 0;
    if (trailingZerosCount <= 5) return fixedStr;
  } else if (typeof num === "bigint") {
    const trailingZeros = numStr.match(/0+$/);
    const trailingZerosCount = trailingZeros ? trailingZeros[0].length : 0;
    if (trailingZerosCount > 5)
      return `${numStr.slice(0, -trailingZerosCount)}e+${trailingZerosCount}`;
  }
  return numStr;
}
var init_strings = __esm({
  "src/compute-engine/numerics/strings.ts"() {
  }
});

// src/compute-engine/numerics/expression.ts
function bigintValue(expr) {
  if (typeof expr === "number")
    return Number.isInteger(expr) ? BigInt(expr) : null;
  if (expr === null || expr === void 0) return null;
  if (!isNumberExpression(expr)) return null;
  const num = isNumberObject(expr) ? expr.num : expr;
  if (typeof num === "number")
    return Number.isInteger(num) ? BigInt(num) : null;
  if (typeof num !== "string") return null;
  const s = num.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
  if (s === "nan") return null;
  if (/^(infinity|\+infinity|oo|\+oo|-infinity|-oo)$/.test(s)) return null;
  return bigint(s);
}
function numberToExpression(num, fractionalDigits) {
  if (typeof num === "number") {
    if (isNaN(num)) return "NaN";
    if (!Number.isFinite(num))
      return num < 0 ? "NegativeInfinity" : "PositiveInfinity";
    if (typeof fractionalDigits === "number")
      return { num: num.toFixed(fractionalDigits) };
    return num;
  }
  if (num >= Number.MIN_SAFE_INTEGER && num <= Number.MAX_SAFE_INTEGER)
    return Number(num);
  const numStr = numberToString(num);
  if (Number(num).toString() === numStr) return Number(num);
  return { num: numStr };
}
var init_expression = __esm({
  "src/compute-engine/numerics/expression.ts"() {
    init_utils2();
    init_bigint();
    init_strings();
  }
});

// src/compute-engine/numeric-value/types.ts
var NumericValue;
var init_types2 = __esm({
  "src/compute-engine/numeric-value/types.ts"() {
    NumericValue = class {
      /**  bignum version of .re, if available */
      get bignumRe() {
        return void 0;
      }
      /** The imaginary part of this numeric value.
       *
       * Can be negative, zero or positive.
       */
      im;
      get bignumIm() {
        return void 0;
      }
      isZeroWithTolerance(_tolerance) {
        return this.isZero;
      }
      //
      // JavaScript Object methods
      //
      /** Object.valueOf(): returns a primitive value, preferably a JavaScript
       *  number over a string, even if at the expense of precision */
      valueOf() {
        if (this.im === 0)
          return this.bignumRe ? this.bignumRe.toNumber() : this.re;
        return this.toString();
      }
      /** Object.toPrimitive() */
      [Symbol.toPrimitive](hint) {
        return hint === "string" ? this.toString() : this.valueOf();
      }
      /** Object.toJSON */
      toJSON() {
        if (this.im === 0) {
          const r = this.re;
          if (Number.isFinite(r)) return r;
        }
        return this.N().toString();
      }
      print() {
        const log3 = console["log"];
        log3?.(this.toString());
      }
    };
  }
});

// src/compute-engine/numeric-value/exact-numeric-value.ts
var ExactNumericValue;
var init_exact_numeric_value = __esm({
  "src/compute-engine/numeric-value/exact-numeric-value.ts"() {
    init_decimal();
    init_numeric();
    init_rationals();
    init_types2();
    init_expression();
    init_strings();
    init_subtype();
    ExactNumericValue = class _ExactNumericValue extends NumericValue {
      __brand;
      rational;
      radical;
      // An integer > 0
      // For exact numeric values, the imaginary part is always 0
      im = 0;
      factory;
      bignum;
      /** The caller is responsible to make sure the input is valid, i.e.
       * - rational is a fraction of integers (but it may not be reduced)
       * - radical is an integer
       */
      constructor(value, factory, bignum) {
        super();
        this.factory = factory;
        this.bignum = bignum;
        if (typeof value === "number") {
          console.assert(!Number.isFinite(value) || Number.isInteger(value));
          this.rational = [value, 1];
          this.radical = 1;
          return;
        }
        if (typeof value === "bigint") {
          this.rational = [value, BigInt(1)];
          this.radical = 1;
          return;
        }
        console.assert(typeof value !== "object" || !("im" in value));
        const decimal = 1;
        console.assert(typeof decimal !== "number" || Number.isInteger(decimal));
        if (decimal == 0) {
          this.rational = [0, 1];
          this.radical = 1;
          return;
        }
        let rational = value.rational ? [...value.rational] : [1, 1];
        if (decimal != 1) {
          if (typeof decimal === "bigint")
            rational = mul2(rational, [decimal, BigInt(1)]);
          else rational = mul2(rational, [decimal, 1]);
        }
        this.rational = rational;
        this.radical = value.radical ?? 1;
        console.assert(this.radical <= SMALL_INTEGER && this.radical >= 1);
        this.normalize();
      }
      get type() {
        if (this.isNaN) return "number";
        if (this.isPositiveInfinity || this.isNegativeInfinity)
          return "non_finite_number";
        if (this.radical !== 1) {
          console.assert(!isZero(this.rational));
          return "finite_real";
        }
        return isInteger(this.rational) ? "finite_integer" : "finite_rational";
      }
      get isExact() {
        return true;
      }
      get asExact() {
        return this;
      }
      toJSON() {
        if (this.isNaN) return "NaN";
        if (this.isPositiveInfinity) return "PositiveInfinity";
        if (this.isNegativeInfinity) return "NegativeInfinity";
        if (this.isZero) return 0;
        if (this.isOne) return 1;
        if (this.isNegativeOne) return -1;
        const rationalExpr = (r) => {
          if (isInteger(r)) return numberToExpression(r[0]);
          return [
            "Rational",
            numberToExpression(r[0]),
            numberToExpression(r[1])
          ];
        };
        if (this.radical === 1) return rationalExpr(this.rational);
        if (isOne(this.rational)) return ["Sqrt", this.radical];
        if (isNegativeOne(this.rational)) return ["Negate", ["Sqrt", this.radical]];
        if (this.rational[0] == 1)
          return [
            "Divide",
            ["Sqrt", this.radical],
            numberToExpression(this.rational[1])
          ];
        if (this.rational[0] == -1)
          return [
            "Negate",
            [
              "Divide",
              ["Sqrt", this.radical],
              numberToExpression(this.rational[1])
            ]
          ];
        return ["Multiply", rationalExpr(this.rational), ["Sqrt", this.radical]];
      }
      clone(value) {
        return new _ExactNumericValue(value, this.factory, this.bignum);
      }
      /** Object.toString() */
      toString() {
        if (this.isZero) return "0";
        if (this.isOne) return "1";
        if (this.isNegativeOne) return "-1";
        const rationalStr = (r) => {
          if (isInteger(r)) return numberToString(r[0]);
          return `${numberToString(r[0])}/${numberToString(r[1])}`;
        };
        if (this.radical === 1) return rationalStr(this.rational);
        const radicalStr = (r) => `sqrt(${numberToString(r)})`;
        if (isOne(this.rational)) return radicalStr(this.radical);
        if (isNegativeOne(this.rational)) return `-${radicalStr(this.radical)}`;
        if (this.rational[0] == 1)
          return `${radicalStr(this.radical)}/${numberToString(this.rational[1])}`;
        if (this.rational[0] == -1)
          return `-${radicalStr(this.radical)}/${numberToString(this.rational[1])}`;
        return `${rationalStr(this.rational)}${radicalStr(this.radical)}`;
      }
      get sign() {
        if (isZero(this.rational)) return 0;
        if (isPositive(this.rational)) return 1;
        return -1;
      }
      get re() {
        return rationalAsFloat(this.rational) * Math.sqrt(this.radical);
      }
      get bignumRe() {
        let result;
        const r = this.rational;
        if (isMachineRational(r)) result = this.bignum(r[0]).div(r[1]);
        else
          result = this.bignum(r[0].toString()).div(this.bignum(r[1].toString()));
        if (this.radical === 1) return result;
        return result.mul(this.bignum(this.radical).sqrt());
      }
      get numerator() {
        if (this.rational[1] == 1) return this;
        return this.clone({
          rational: isMachineRational(this.rational) ? [this.rational[0], 1] : [this.rational[0], BigInt(1)],
          radical: this.radical
        });
      }
      get denominator() {
        if (isMachineRational(this.rational)) return this.clone(this.rational[1]);
        return this.clone({ rational: [this.rational[1], BigInt(1)] });
      }
      normalize() {
        console.assert(
          Number.isInteger(this.radical) && this.radical > 0 && Number.isFinite(this.radical)
        );
        if (isNaN(this.radical)) {
          this.rational = [NaN, 1];
          this.radical = 1;
          return;
        }
        const [n, d] = this.rational;
        if (d == 0) {
          this.rational = [NaN, 1];
          this.radical = 1;
          return;
        }
        if (this.radical === 0 || n === 0) {
          this.rational = [0, 1];
          this.radical = 1;
          return;
        }
        if (this.radical >= 4) {
          const [factor3, root2] = canonicalInteger(this.radical, 2);
          if (typeof this.rational[0] === "number") this.rational[0] *= factor3;
          else this.rational = mul2(this.rational, [factor3, 1]);
          this.radical = root2;
        }
        this.rational = reducedRational(this.rational);
      }
      get isNaN() {
        return Number.isNaN(this.rational[0]);
      }
      get isPositiveInfinity() {
        return this.rational[0] == Infinity;
      }
      get isNegativeInfinity() {
        return this.rational[0] == -Infinity;
      }
      get isComplexInfinity() {
        return false;
      }
      get isZero() {
        return isZero(this.rational);
      }
      get isOne() {
        if (this.rational[0] !== this.rational[1]) return false;
        if (this.radical !== 1) return false;
        return true;
      }
      get isNegativeOne() {
        if (this.rational[0] !== -this.rational[1]) return false;
        if (this.radical !== 1) return false;
        return true;
      }
      sgn() {
        if (Number.isNaN(this.rational[0])) return void 0;
        if (isZero(this.rational)) return 0;
        return isPositive(this.rational) ? 1 : -1;
      }
      N() {
        if (this.isZero || this.isOne || this.isNegativeOne) return this;
        if (this.rational[1] == 1 && this.radical === 1) return this;
        return this.factory(this.bignumRe);
      }
      neg() {
        if (this.isZero) return this;
        return this.clone({
          rational: neg(this.rational),
          radical: this.radical
        });
      }
      inv() {
        if (this.isOne) return this;
        if (this.isNegativeOne) return this;
        return this.clone({
          rational: isMachineRational(this.rational) ? [this.rational[1], this.rational[0] * this.radical] : [this.rational[1], this.rational[0] * BigInt(this.radical)],
          radical: this.radical
        });
      }
      add(other) {
        if (typeof other === "number") {
          if (other === 0) return this;
          if (Number.isInteger(other) && this.radical === 1)
            return this.clone({
              rational: isMachineRational(this.rational) ? [this.rational[0] + other * this.rational[1], this.rational[1]] : [
                this.rational[0] + BigInt(other) * this.rational[1],
                this.rational[1]
              ]
            });
          return this.factory(this.bignumRe).add(other);
        }
        if (other.isZero) return this;
        if (this.isZero) return other;
        if (!(other instanceof _ExactNumericValue)) return other.add(this);
        if (this.radical === other.radical) {
          return this.clone({
            rational: add2(this.rational, other.rational),
            radical: this.radical
          });
        }
        return this.factory(this.bignumRe).add(other);
      }
      sub(other) {
        return this.add(other.neg());
      }
      mul(other) {
        if (other === 0) return this.clone(0);
        if (other === 1) return this;
        if (other === -1) return this.neg();
        if (typeof other === "number") {
          if (Number.isInteger(other))
            return this.clone({
              rational: isMachineRational(this.rational) ? [this.rational[0] * other, this.rational[1]] : [this.rational[0] * BigInt(other), this.rational[1]],
              radical: this.radical
            });
          return this.factory(this.bignumRe).mul(other);
        }
        if (other instanceof Decimal) return this.factory(other).mul(this);
        if (other.im !== 0) return other.mul(this);
        if (other.isZero) return other;
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (other.isNaN) return other;
        if (this.isZero) return this;
        if (this.isOne) return other;
        if (this.isNegativeOne) return other.neg();
        if (!(other instanceof _ExactNumericValue)) return other.mul(this);
        return this.clone({
          rational: mul2(this.rational, other.rational),
          radical: this.radical * other.radical
        });
      }
      div(other) {
        if (typeof other === "number") {
          if (other === 1) return this;
          if (other === -1) return this.neg();
          if (other === 0) return this.clone(NaN);
          return this.clone({
            rational: isMachineRational(this.rational) ? [this.rational[0], this.rational[1] * other] : [this.rational[0], this.rational[1] * BigInt(other)],
            radical: this.radical
          });
        }
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (this.isZero) {
          if (other.isZero) return this.clone(NaN);
          return other.isNaN ? other : this;
        }
        if (other.isNaN) return other;
        if (other.isZero) return this.clone(this.sign * Infinity);
        if (!(other instanceof _ExactNumericValue))
          return this.factory(this.bignumRe).div(other);
        if (other.im !== 0) return this.factory(this.bignumRe).div(other);
        let rational;
        if (isMachineRational(this.rational) && isMachineRational(other.rational)) {
          const [a, b] = this.rational;
          const [d, e] = other.rational;
          rational = [a * e, b * d * other.radical];
        } else {
          rational = mul2(this.rational, [
            BigInt(other.rational[1]),
            BigInt(other.rational[0]) * BigInt(other.radical)
          ]);
        }
        return this.clone({ rational, radical: this.radical * other.radical });
      }
      pow(exponent) {
        console.assert(!Array.isArray(exponent));
        if (this.isNaN) return this;
        if (typeof exponent === "number" && isNaN(exponent)) return this.clone(NaN);
        if (exponent instanceof NumericValue) {
          if (exponent.isNaN) return this.clone(NaN);
          if (exponent.isZero) return this.clone(1);
          if (exponent.isOne) return this;
          if (exponent.im) {
            exponent = { re: exponent.re, im: exponent.im };
          } else {
            if (exponent instanceof _ExactNumericValue) {
              if (exponent.radical === 1 && exponent.rational[0] == 1)
                return this.root(exponent.rational[0]);
            }
            exponent = exponent.re;
          }
        }
        if (exponent === 0.5) return this.sqrt();
        if (typeof exponent === "object" && ("re" in exponent || "im" in exponent))
          return this.factory(this.bignumRe).pow(exponent);
        if (this.isPositiveInfinity) {
          if (exponent === -1) return this.clone(0);
          if (exponent === Infinity) return this.clone(Infinity);
          if (exponent === -Infinity) return this.clone(0);
        } else if (this.isNegativeInfinity && exponent === Infinity)
          return this.clone(NaN);
        if ((exponent === Infinity || exponent === -Infinity) && (this.isOne || this.isNegativeOne))
          return this.clone(NaN);
        if (exponent === 1) return this;
        if (exponent === -1) return this.inv();
        if (exponent === 0) return this.clone(1);
        if (this.isZero) {
          if (exponent > 0) return this;
          if (exponent < 0) return this.factory({ im: Infinity });
        }
        if (exponent < 0) return this.pow(-exponent).inv();
        if (exponent % 1 === 0.5)
          return this.pow(Math.floor(exponent)).mul(this.sqrt());
        if (this.radical > SMALL_INTEGER || this.rational[0] > SMALL_INTEGER || this.rational[0] < -SMALL_INTEGER || this.rational[1] > SMALL_INTEGER)
          return this.factory(this.bignumRe).pow(exponent);
        if (this.sign < 0) {
          if (Number.isInteger(exponent)) {
            const sign3 = exponent % 2 === 0 ? 1 : -1;
            return this.clone({
              rational: isMachineRational(this.rational) ? [
                sign3 * (-this.rational[0]) ** exponent,
                this.rational[1] ** exponent
              ] : [
                BigInt(sign3) * (-this.rational[0]) ** BigInt(exponent),
                this.rational[1] ** BigInt(exponent)
              ],
              radical: this.radical ** exponent
            });
          }
          return this.factory({ im: (-this.re) ** exponent });
        } else {
          if (Number.isInteger(exponent)) {
            return this.clone({
              rational: isMachineRational(this.rational) ? [this.rational[0] ** exponent, this.rational[1] ** exponent] : [
                BigInt(this.rational[0]) ** BigInt(exponent),
                this.rational[1] ** BigInt(exponent)
              ],
              radical: this.radical ** exponent
            });
          }
        }
        return this.factory(this.bignumRe).pow(exponent);
      }
      root(exponent) {
        if (exponent === 0) return this.clone(NaN);
        if (this.isNaN) return this;
        if (this.isZero) return this;
        if (exponent === 1) return this;
        if (exponent === -1) return this.inv();
        if (exponent < 0) return this.root(-exponent).inv();
        if (exponent % 1 === 0.5) return this.root(Math.floor(exponent)).sqrt();
        if (this.radical === 1) {
          if (this.sign > 0) {
            const re = this.re;
            if (Number.isInteger(re)) {
              if (re > 0) {
                const root2 = Math.pow(re, 1 / exponent);
                if (Number.isInteger(root2)) return this.clone(root2);
              }
              return this.factory(this.bignumRe).root(exponent);
            }
          }
          return this.factory(this.bignumRe).root(exponent);
        }
        if (this.sign < 0)
          return this.factory({ im: Math.pow(-this.re, 1 / exponent) });
        if (this.radical > SMALL_INTEGER || this.rational[0] > SMALL_INTEGER || this.rational[0] < -SMALL_INTEGER || this.rational[1] > SMALL_INTEGER)
          return this.factory(this.bignumRe).root(exponent);
        if (this.rational[1] == 1) {
          const root2 = Math.pow(this.rational[0], 1 / exponent);
          if (Number.isInteger(root2)) return this.clone(root2);
        }
        return this.factory(this.bignumRe).root(exponent);
      }
      sqrt() {
        if (this.isZero || this.isOne) return this;
        if (this.radical === 1) {
          if (isMachineRational(this.rational)) {
            const [n, d] = this.rational;
            if (n * d > SMALL_INTEGER) return this.factory(this.bignumRe).sqrt();
            if (n > 0) return this.clone({ radical: n * d, rational: [1, d] });
            return this.factory({ im: Math.sqrt(-n * d) / d });
          } else {
            return this.factory(this.bignumRe).sqrt();
          }
        }
        if (this.sign > 0) {
          const re = Math.sqrt(this.re);
          if (Number.isInteger(re)) return this.clone(re);
        }
        return this.factory(this.bignumRe).sqrt();
      }
      gcd(other) {
        if (!(other instanceof _ExactNumericValue)) return other.gcd(this);
        if (this.isOne || other.im !== 0 || other.isOne) return this.clone(1);
        const rational = rationalGcd(this.rational, other.rational);
        const radical = gcd(this.radical, other.radical);
        return this.clone({ rational, radical });
      }
      abs() {
        return this.sign === -1 ? this.neg() : this;
      }
      ln(base) {
        if (this.isZero) return this.clone(NaN);
        if (this.isPositiveInfinity) return this.clone(Infinity);
        if (this.sign < 0) return this.clone(NaN);
        if (this.isOne) return this.clone(0);
        if (this.isNegativeOne) return this.factory({ im: Math.PI });
        return this.factory(this.bignumRe).ln(base);
      }
      exp() {
        if (this.isNaN) return this.clone(NaN);
        if (this.isZero) return this.clone(1);
        if (this.isNegativeInfinity) return this.clone(0);
        if (this.isPositiveInfinity) return this.clone(Infinity);
        return this.factory(this.bignumRe).exp();
      }
      floor() {
        if (this.isNaN) return this.clone(NaN);
        if (this.type === "integer") return this;
        return this.clone(Math.floor(this.re));
      }
      ceil() {
        if (this.isNaN) return this.clone(NaN);
        if (this.type === "integer") return this;
        return this.clone(Math.ceil(this.re));
      }
      round() {
        if (this.isNaN) return this.clone(NaN);
        if (this.type === "integer") return this;
        return this.clone(Math.round(this.re));
      }
      eq(other) {
        if (typeof other === "number")
          return this.radical === 1 && isInteger(this.rational) && this.rational[0] == other;
        if (other instanceof _ExactNumericValue) {
          return this.radical === other.radical && this.rational[0] == other.rational[0] && this.rational[1] == other.rational[1];
        }
        return other.im === 0 && other.re === this.re;
      }
      lt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.re < other;
        return this.re < other.re;
      }
      lte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.re <= other;
        return this.re <= other.re;
      }
      gt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.re > other;
        return this.re > other.re;
      }
      gte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.re >= other;
        return this.re >= other.re;
      }
      // When using add(), inexact values propagate, i.e. '1.2 + 1/4' -> '1.45'
      // This may not be desirable when adding many values, i.e. '1.2 - 1.2 + 1/4' -> '1/4'
      // Furthermore we may want to keep track of rational and square rational parts
      // i.e. '1.2 + 1/4 + 5 + 7' -> '3/4 + 5 + 7'
      // '1.2 + 1/4 + 5 + 5' -> '3/4 + 25'
      static sum(values, factory, bignumFactory) {
        if (values.length === 1) return values;
        if (values.some((x) => !x.isExact)) {
          if (values.length === 2) return [values[0].add(values[1])];
          let sum2 = factory(0);
          for (const value of values) sum2 = sum2.add(value);
          return [sum2];
        }
        let imSum = 0;
        let rationalSum = [0, 1];
        const radicals = [];
        for (const value of values) {
          if (value.isNaN)
            return [new _ExactNumericValue(NaN, factory, bignumFactory)];
          if (value.isZero) continue;
          imSum += value.im;
          if (value instanceof _ExactNumericValue) {
            const rational = value.rational;
            if (value.radical === 1) {
              rationalSum = add2(rationalSum, rational);
            } else {
              const index = radicals.findIndex((x) => x.radical === value.radical);
              if (index === -1) {
                radicals.push({ multiple: rational, radical: value.radical });
              } else {
                radicals[index].multiple = add2(radicals[index].multiple, rational);
              }
            }
          } else {
            console.assert(isSubtype(value.type, "integer"));
            const intValue = BigInt(value.bignumRe.toFixed(0));
            rationalSum = add2(rationalSum, [intValue, BigInt(1)]);
          }
        }
        if (isZero(rationalSum) && radicals.length === 0) {
          if (imSum === 0)
            return [new _ExactNumericValue(0, factory, bignumFactory)];
          return [factory({ im: imSum })];
        }
        const result = [];
        if (imSum !== 0) result.push(factory({ im: imSum }));
        if (radicals.length === 0)
          result.push(
            new _ExactNumericValue({ rational: rationalSum }, factory, bignumFactory)
          );
        else {
          radicals.push({ multiple: rationalSum, radical: 1 });
          result.push(
            ...radicals.map(
              (x) => new _ExactNumericValue(
                { rational: x.multiple, radical: x.radical },
                factory,
                bignumFactory
              )
            )
          );
        }
        return result;
      }
    };
  }
});

// src/compute-engine/boxed-expression/numerics.ts
function asRational(expr) {
  const num = expr.numericValue;
  if (num === null) return void 0;
  if (typeof num === "number" && !Number.isFinite(num)) return void 0;
  if (num instanceof NumericValue && (num.isNaN || num.isPositiveInfinity || num.isNegativeInfinity))
    return void 0;
  if (typeof num === "number") {
    if (!Number.isInteger(num)) return void 0;
    return [num, 1];
  }
  const type2 = num.type;
  if (type2 !== "finite_integer" && type2 !== "finite_rational") return void 0;
  if (num.im !== 0) return void 0;
  if (num instanceof ExactNumericValue) {
    if (num.radical !== 1) return void 0;
    return num.rational;
  }
  const bignumRe = num.bignumRe;
  if (bignumRe !== void 0 && Number.isInteger(bignumRe))
    return [bigint(bignumRe), BigInt(1)];
  const re = num.re;
  if (Number.isInteger(re)) return [re, 1];
  return void 0;
}
function asBigint(x) {
  if (x === void 0 || x === null) return null;
  if (typeof x === "bigint") return x;
  if (typeof x === "number" && Number.isInteger(x)) return BigInt(x);
  if (isBoxedExpression(x)) {
    const num = x.numericValue;
    if (num === null) return null;
    if (typeof num === "number") {
      if (Number.isInteger(num)) return BigInt(num);
      return null;
    }
    if (num.im !== 0) return null;
    const n = num.bignumRe;
    if (n?.isInteger()) return bigint(n);
    if (!Number.isInteger(num.re)) return null;
    return BigInt(num.re);
  }
  if (x instanceof Decimal || typeof x === "string") return bigint(x);
  if (x instanceof Complex) {
    if (x.im === 0) return bigint(x.re);
    return null;
  }
  return bigintValue(x);
}
function asBignum(expr) {
  if (expr === void 0 || expr === null) return null;
  const num = typeof expr === "number" ? expr : expr.numericValue;
  if (num === null) return null;
  if (typeof num === "number") return expr.engine.bignum(num);
  if (num.im !== 0) return null;
  const re = num.bignumRe ?? num.re;
  if (typeof re === "number" && isNaN(re)) return null;
  return expr.engine.bignum(re);
}
function asSmallInteger(expr) {
  if (expr === void 0 || expr === null) return null;
  if (typeof expr === "number") {
    if (Number.isInteger(expr) && expr >= -SMALL_INTEGER && expr <= SMALL_INTEGER)
      return expr;
    return null;
  }
  const num = expr.numericValue;
  if (num === null) return null;
  if (typeof num === "number") {
    if (Number.isInteger(num) && num >= -SMALL_INTEGER && num <= SMALL_INTEGER)
      return num;
    return null;
  }
  if (num.im !== 0) return null;
  const n = num.re;
  if (Number.isInteger(n) && n >= -SMALL_INTEGER && n <= SMALL_INTEGER)
    return Number(n);
  return null;
}
function toInteger(expr) {
  const num = expr?.numericValue ?? void 0;
  if (num === void 0) return null;
  return Math.round(typeof num === "number" ? num : num.re);
}
function toBigint(expr) {
  if (expr === void 0 || expr === null) return null;
  const num = expr.numericValue;
  if (num === null) return null;
  if (typeof num === "number") return BigInt(Math.round(num));
  const n = num.bignumRe ?? num.re;
  if (typeof n === "number") return BigInt(Math.round(n));
  return bigint(n.round());
}
var init_numerics = __esm({
  "src/compute-engine/boxed-expression/numerics.ts"() {
    init_complex();
    init_decimal();
    init_utils5();
    init_numeric();
    init_bigint();
    init_exact_numeric_value();
    init_types2();
    init_expression();
  }
});

// src/compute-engine/boxed-expression/expand.ts
var expand_exports = {};
__export(expand_exports, {
  choose: () => choose,
  expand: () => expand2,
  expandAll: () => expandAll,
  expandFunction: () => expandFunction,
  expandProducts: () => expandProducts
});
function expandProduct(lhs, rhs) {
  if (lhs.operator === "Negate" && rhs.operator === "Negate")
    return expandProduct(lhs.op1, rhs.op1);
  const ce = lhs.engine;
  if (lhs.operator === "Negate") return expandProduct(lhs.op1, rhs).neg();
  if (rhs.operator === "Negate") return expandProduct(lhs, rhs.op1).neg();
  if (lhs.operator === "Divide" && rhs.operator === "Divide") {
    const denom = lhs.op2.mul(rhs.op2);
    return expandProduct(lhs.op1, rhs.op1).div(denom);
  }
  if (lhs.operator === "Divide")
    return expandProduct(lhs.op1, rhs).div(lhs.op2);
  if (rhs.operator === "Divide")
    return expandProduct(lhs, rhs.op1).div(rhs.op2);
  if (lhs.operator === "Add")
    return add3(...lhs.ops.map((x) => expandProduct(x, rhs)));
  if (rhs.operator === "Add")
    return add3(...rhs.ops.map((x) => expandProduct(lhs, x)));
  return new Product(ce, [lhs, rhs]).asExpression();
}
function expandProducts(ce, ops) {
  if (ops.length === 0) return null;
  if (ops.length === 1) return ops[0];
  if (ops.length === 2) return expandProduct(ops[0], ops[1]);
  const rhs = expandProducts(ce, ops.slice(1));
  return rhs === null ? null : expandProduct(ops[0], rhs);
}
function choose(n, k) {
  while (n >= binomials.length) {
    const s = binomials.length;
    const nextRow = [1];
    const prev = binomials[s - 1];
    for (let i = 1; i < s; i++) nextRow[i] = prev[i - 1] + prev[i];
    nextRow[s] = 1;
    binomials.push(nextRow);
  }
  return binomials[n][k];
}
function multinomialCoefficient(k) {
  let n = k.reduce((acc, v) => acc + v, 0);
  let prod = 1;
  for (let i = 0; i < k.length; i += 1) {
    prod *= choose(n, k[i]);
    n -= k[i];
  }
  return prod;
}
function* powers(n, exp3) {
  if (n === 1) {
    yield [exp3];
    return;
  }
  for (let i = 0; i <= exp3; i += 1)
    for (const p of powers(n - 1, exp3 - i)) yield [i, ...p];
}
function expandPower(base, exp3) {
  const ce = base.engine;
  if (exp3 < 0) {
    const expr = expandPower(base, -exp3);
    return expr ? expr.inv() : null;
  }
  if (exp3 === 0) return ce.One;
  if (exp3 === 1) return expand2(base);
  if (base.operator === "Negate") {
    if (Number.isInteger(exp3)) {
      const sign3 = exp3 % 2 === 0 ? 1 : -1;
      const result2 = expandPower(base.op1, exp3);
      if (result2 === null) return null;
      return sign3 > 0 ? result2 : result2.neg();
    }
  }
  console.assert(base.operator !== "Subtract");
  if (base.operator !== "Add") return null;
  const terms = base.ops;
  const it = powers(terms.length, exp3);
  const result = [];
  for (const val of it) {
    const product = [ce.number(multinomialCoefficient(val))];
    for (let i = 0; i < val.length; i += 1) {
      if (val[i] !== 0) {
        if (val[i] === 1) product.push(terms[i]);
        else product.push(terms[i].pow(val[i]));
      }
    }
    result.push(mul3(...product));
  }
  return add3(...result);
}
function expandFunction(ce, h, ops) {
  let result = null;
  if (h === "Divide") {
    const num = expand2(ops[0]);
    if (num === null) return null;
    if (num.operator === "Add")
      return add3(...num.ops.map((x) => x.div(ops[1])));
    return ce._fn("Divide", [num, ops[1]]);
  }
  if (h === "Multiply") return expandProducts(ce, ops);
  if (h === "Negate") return expand2(ops[0])?.neg() ?? null;
  if (h === "Add") return add3(...ops.map((x) => expand2(x) ?? x));
  if (h === "Power") {
    const exp3 = asSmallInteger(ops[1]);
    result = exp3 !== null ? expandPower(ops[0], exp3) : null;
  }
  return result;
}
function expand2(expr) {
  expr = expr?.canonical;
  if (!expr || typeof expr.operator !== "string") return null;
  if (isRelationalOperator(expr.operator)) {
    return expr.engine._fn(
      expr.operator,
      expr.ops.map((x) => expand2(x) ?? x)
    );
  }
  return expandFunction(expr.engine, expr.operator, expr.ops ?? []);
}
function expandAll(expr) {
  if (!expr.operator || !expr.ops) return null;
  const ops = expr.ops.map((x) => expandAll(x) ?? x);
  const result = expr.engine.function(expr.operator, ops);
  return expand2(result) ?? result;
}
var binomials;
var init_expand = __esm({
  "src/compute-engine/boxed-expression/expand.ts"() {
    init_utils3();
    init_numerics();
    init_arithmetic_mul_div();
    init_arithmetic_add();
    init_product();
    binomials = [
      [1],
      [1, 1],
      [1, 2, 1],
      [1, 3, 3, 1],
      [1, 4, 6, 4, 1],
      [1, 5, 10, 10, 5, 1],
      [1, 6, 15, 20, 15, 6, 1],
      [1, 7, 21, 35, 35, 21, 7, 1],
      [1, 8, 28, 56, 70, 56, 28, 8, 1]
    ];
  }
});

// src/compute-engine/boxed-expression/negate.ts
function canonicalNegate(expr) {
  let sign3 = -1;
  while (expr.operator === "Negate") {
    expr = expr.op1;
    sign3 = -sign3;
  }
  if (sign3 === 1) return expr;
  if (expr.isNumberLiteral) return expr.neg();
  return expr.engine._fn("Negate", [expr]);
}
function negate(expr) {
  let sign3 = -1;
  while (expr.operator === "Negate") {
    expr = expr.op1;
    sign3 = -sign3;
  }
  if (sign3 === 1) return expr;
  if (expr.numericValue !== null) return expr.neg();
  const ce = expr.engine;
  if (expr.operator === "Subtract") return expr.op2.sub(expr.op1);
  if (expr.operator === "Add") return add3(...expr.ops.map((x) => negate(x)));
  if (expr.operator === "Multiply") return negateProduct(ce, expr.ops);
  if (expr.operator === "Divide") return negate(expr.op1).div(expr.op2);
  return ce._fn("Negate", [expr]);
}
function negateProduct(ce, args) {
  if (args.length === 0) return ce.NegativeOne;
  if (args.length === 1) return negate(args[0]);
  let result = [];
  let done = false;
  for (const arg of args) {
    if (!done && arg.operator === "Negate") {
      done = true;
      if (!arg.op1.is(1)) result.push(arg.op1);
    } else result.push(arg);
  }
  if (!done) {
    result = [];
    for (const arg of args) {
      if (done || arg.numericValue === null && !arg.isInteger)
        result.push(arg);
      else {
        done = true;
        if (!arg.is(-1)) result.push(arg.neg());
      }
    }
  }
  if (done) return ce._fn("Multiply", result.sort(order));
  if (!done) {
    result = [];
    for (const arg of args) {
      if (done || arg.numericValue === null || !arg.isNumber) result.push(arg);
      else {
        done = true;
        if (!arg.is(-1)) result.push(arg.neg());
      }
    }
  }
  if (done) return ce._fn("Multiply", result.sort(order));
  return ce._fn("Negate", [ce._fn("Multiply", [...args].sort(order))]);
}
var init_negate = __esm({
  "src/compute-engine/boxed-expression/negate.ts"() {
    init_arithmetic_add();
    init_order();
  }
});

// src/compute-engine/boxed-expression/arithmetic-mul-div.ts
function canonicalDivide(op1, op2) {
  const ce = op1.engine;
  if (!op1.isValid || !op2.isValid) return ce._fn("Divide", [op1, op2]);
  if (op1.isNaN || op2.isNaN) return ce.NaN;
  const op2IsConstantExpression = op2.unknowns.length === 0 && !op2.isNumberLiteral;
  if (op2.is(0)) return op1.is(0) ? ce.NaN : ce.ComplexInfinity;
  if (op1.is(0) && op2.isFinite !== false) {
    if (op2IsConstantExpression)
      return ce.function("Divide", [op1, op2], {
        canonical: false,
        structural: true
      });
    return ce.Zero;
  }
  if (op2.isInfinity) return op1.isInfinity ? ce.NaN : ce.Zero;
  if (op2.is(0) === false && op2.isFinite !== false) {
    if (op1.symbol !== null && op1.symbol === op2.symbol && op1.isConstant)
      return ce.One;
    if (op1.isSame(op2)) {
      if (op2IsConstantExpression)
        return ce.function("Divide", [op1, op2], {
          canonical: false,
          structural: true
        });
      return ce.One;
    }
  }
  if (op1.operator === "Negate" && op2.operator === "Negate") {
    op1 = op1.op1;
    op2 = op2.op1;
  }
  if (op1.operator === "Divide" && op2.operator === "Divide") {
    return canonicalDivide(
      canonicalMultiply(ce, [op1.op1, op2.op2]),
      canonicalMultiply(ce, [op1.op2, op2.op1])
    );
  }
  if (op1.operator === "Divide")
    return canonicalDivide(op1.op1, canonicalMultiply(ce, [op1.op2, op2]));
  if (op2.operator === "Divide")
    return canonicalDivide(canonicalMultiply(ce, [op1, op2.op2]), op2.op1);
  if (op2.is(1)) return op1;
  if (op2.is(-1)) return op1.neg();
  if (op1.is(1)) return op2.inv();
  if (op1.operator === "Sqrt" && op2.operator === "Sqrt") {
    const a = asSmallInteger(op1.op1);
    const b = asSmallInteger(op2.op1);
    if (a !== null && b !== null)
      return ce.number(ce._numericValue({ radical: a * b, rational: [1, b] }));
  } else if (op1.operator === "Sqrt") {
    const a = asSmallInteger(op1.op1);
    const b = asSmallInteger(op2);
    if (a !== null && b !== null)
      return ce.number(ce._numericValue({ radical: a, rational: [1, b] }));
  } else if (op2.operator === "Sqrt") {
    const a = asSmallInteger(op1);
    const b = asSmallInteger(op2.op1);
    if (a !== null && b !== null)
      return ce.number(ce._numericValue({ radical: b, rational: [a, b] }));
  }
  const v1 = op1.numericValue;
  const v2 = op2.numericValue;
  if (v1 !== null && v2 !== null) {
    if (typeof v1 !== "number" && v1.im !== 0 || typeof v2 !== "number" && v2.im !== 0) {
      return ce._fn("Divide", [op1, op2]);
    }
    if (typeof v1 === "number" && Number.isInteger(v1) && typeof v2 === "number" && Number.isInteger(v2)) {
      if (v2 === 0) return v1 === 0 ? ce.NaN : ce.ComplexInfinity;
      return ce.number([v1, v2]);
    }
    if (typeof v1 === "number" && Number.isInteger(v1)) {
      if (v1 === 0) return ce.Zero;
      if (typeof v2 !== "number" && isSubtype(v2.type, "integer")) {
        const b = v2.bignumRe;
        if (b !== void 0) {
          if (b.isInteger()) return ce.number([bigint(v1), bigint(b)]);
        } else {
          const d = v2.re;
          if (Number.isInteger(d)) return ce.number([v1, d]);
        }
      }
    }
    return ce._fn("Divide", [op1, op2]);
  }
  const [c1, t1] = op1.toNumericValue();
  if (c1.isZero) return ce.Zero;
  const [c2, t2] = op2.toNumericValue();
  if (c2.isZero) return ce.NaN;
  const c = c1.div(c2);
  if (c.isOne) return t2.is(1) ? t1 : ce._fn("Divide", [t1, t2]);
  if (c.isNegativeOne)
    return t2.is(1) ? t1.neg() : ce._fn("Divide", [t1.neg(), t2]);
  if (c.isExact) {
    if (t1.is(1) && t2.is(1)) return ce.number(c);
    if (t2.is(1)) return canonicalMultiply(ce, [ce.number(c), t1]);
    return ce._fn("Divide", [
      canonicalMultiply(ce, [ce.number(c.numerator), t1]),
      canonicalMultiply(ce, [ce.number(c.denominator), t2])
    ]);
  }
  return ce._fn("Divide", [op1, op2]);
}
function div2(num, denom) {
  const ce = num.engine;
  num = num.canonical;
  if (typeof denom !== "number") denom = denom.canonical;
  if (num.isNaN) return ce.NaN;
  if (typeof denom === "number") {
    if (isNaN(denom)) return ce.NaN;
    if (num.is(0)) {
      if (denom === 0 || !isFinite(denom)) return ce.NaN;
      return num;
    }
    if (denom === 1) return num;
    if (denom === -1) return num.neg();
    if (denom === 0) return ce.ComplexInfinity;
    if (num.isNumberLiteral) {
      const n = num.numericValue;
      if (typeof n === "number") {
        if (Number.isInteger(n) && Number.isInteger(denom))
          return ce.number(ce._numericValue({ rational: [n, denom] }));
      } else if (n.isExact && Number.isInteger(denom)) {
        return ce.number(n.asExact.div(denom));
      }
    }
  } else {
    if (denom.isNaN) return ce.NaN;
    if (num.is(0)) {
      if (denom.is(0) || denom.isFinite === false) return ce.NaN;
      return ce.Zero;
    }
    if (denom.is(1)) return num;
    if (denom.is(-1)) return num.neg();
    if (denom.is(0)) return ce.NaN;
    if (num.isNumberLiteral && denom.isNumberLiteral) {
      const numV = num.numericValue;
      const denomV = denom.numericValue;
      if (typeof numV === "number" && typeof denomV === "number" && Number.isInteger(numV) && Number.isInteger(denomV)) {
        return ce.number(ce._numericValue({ rational: [numV, denomV] }));
      } else if (typeof numV === "number" && Number.isInteger(numV) && typeof denomV !== "number") {
        if (denomV.isExact) {
          return ce.number(ce._numericValue(numV).div(denomV.asExact));
        }
      } else if (typeof denomV === "number" && Number.isInteger(denomV) && typeof numV !== "number") {
        if (numV.isExact) {
          return ce.number(numV.asExact.div(denomV));
        }
      } else if (typeof numV !== "number" && typeof denomV !== "number") {
        if (numV.isExact && denomV.isExact) {
          return ce.number(numV.asExact.div(denomV.asExact));
        }
      }
    }
  }
  const result = new Product(ce, [num]);
  result.div(typeof denom === "number" ? ce._numericValue(denom) : denom);
  return result.asRationalExpression();
}
function canonicalMultiply(ce, ops) {
  let sign3 = 1;
  let xs = [];
  for (const op of ops) {
    const [o, s] = unnegate(op);
    sign3 *= s;
    xs.push(o);
  }
  xs = xs.filter((x) => !x.is(1));
  const ys = [];
  for (let i = 0; i < xs.length; i++) {
    const x = xs[i];
    if (i + 1 >= xs.length) {
      ys.push(x);
      continue;
    }
    const next = xs[i + 1];
    if (x.isNumberLiteral) {
      if (next.operator === "Sqrt" && next.op1.isNumberLiteral && next.op1.type.matches("finite_integer")) {
        let radical = next.op1.numericValue;
        if (typeof radical !== "number") radical = radical.re;
        if (radical >= SMALL_INTEGER) {
          ys.push(x);
          continue;
        }
        if (x.type.matches("finite_rational")) {
          const rational = x.numericValue;
          const [num, den] = typeof rational === "number" ? [rational, 1] : [rational.numerator.re, rational.denominator.re];
          ys.push(
            ce.number(ce._numericValue({ rational: [num, den], radical }))
          );
          i++;
          continue;
        }
      } else if (next.isNumberLiteral && next.numericValue instanceof NumericValue) {
        const nextNv = next.numericValue;
        if (nextNv instanceof ExactNumericValue && isOne(nextNv.rational) && nextNv.radical !== 1) {
          const r = asRational(x);
          if (r) {
            ys.push(
              ce.number(
                ce._numericValue({ rational: r, radical: nextNv.radical })
              )
            );
            i++;
            continue;
          }
        } else if (nextNv.im === 1) {
          const nv = x.numericValue;
          if (typeof nv === "number") {
            ys.push(ce.number(ce.complex(0, nv)));
            i++;
            continue;
          } else if (nv.im === 0) {
            if (Number.isInteger(nv.re)) {
              ys.push(ce.number(ce.complex(0, nv.re)));
              i++;
              continue;
            } else if (!nv.isExact) {
              ys.push(ce.number(ce.complex(0, nv.re)));
              i++;
              continue;
            }
          }
        }
      }
    }
    ys.push(x);
  }
  if (sign3 < 0) {
    if (ys.length === 0) return ce.number(-1);
    if (ys.length === 1) return ys[0].neg();
    return negateProduct(ce, ys);
  }
  if (ys.length === 0) return ce.number(1);
  if (ys.length === 1) return ys[0];
  return ce._fn("Multiply", [...ys].sort(order));
}
function unnegate(op) {
  let sign3 = 1;
  while (op.operator === "Negate") {
    sign3 = -sign3;
    op = op.op1;
  }
  if (op.isNumberLiteral && op.isNegative) {
    sign3 = -sign3;
    op = op.neg();
  }
  return [op, sign3];
}
function mul3(...xs) {
  console.assert(xs.length > 0);
  if (xs.length === 1) return xs[0];
  const ce = xs[0].engine;
  const exp3 = expandProducts(ce, xs);
  if (exp3) {
    if (exp3.operator !== "Multiply") return exp3;
    xs = exp3.ops;
  }
  return new Product(ce, xs).asRationalExpression();
}
function mulN(...xs) {
  console.assert(xs.length > 0);
  const ce = xs[0].engine;
  xs = xs.map((x) => x.N());
  const exp3 = expandProducts(ce, xs);
  if (exp3) {
    if (exp3.operator !== "Multiply") return exp3;
    xs = exp3.ops;
  }
  return new Product(ce, xs).asExpression({ numericApproximation: true });
}
var init_arithmetic_mul_div = __esm({
  "src/compute-engine/boxed-expression/arithmetic-mul-div.ts"() {
    init_subtype();
    init_exact_numeric_value();
    init_numeric();
    init_rationals();
    init_bigint();
    init_numerics();
    init_product();
    init_expand();
    init_negate();
    init_order();
    init_types2();
  }
});

// src/compute-engine/numeric-value/big-numeric-value.ts
function decimalToString(num) {
  const numStr = num.toString();
  if (num.isInteger() && numStr.includes("e")) {
    const fixedStr = num.toFixed();
    const trailingZeros = fixedStr.match(/0+$/);
    const trailingZerosCount = trailingZeros ? trailingZeros[0].length : 0;
    if (trailingZerosCount <= 5) {
      return fixedStr;
    }
  }
  return numStr;
}
function chop2(n) {
  return Math.abs(n) <= 1e-14 ? 0 : n;
}
var BigNumericValue;
var init_big_numeric_value = __esm({
  "src/compute-engine/numeric-value/big-numeric-value.ts"() {
    init_decimal();
    init_types2();
    init_exact_numeric_value();
    init_numeric_bignum();
    init_expression();
    init_strings();
    init_bigint();
    BigNumericValue = class _BigNumericValue extends NumericValue {
      __brand;
      decimal;
      bignum;
      constructor(value, bignum) {
        super();
        this.bignum = bignum;
        if (typeof value === "number") {
          this.decimal = bignum(value);
          this.im = 0;
        } else if (value instanceof Decimal) {
          this.decimal = value;
          this.im = 0;
        } else {
          const decimal = bignum(value.re ?? 0);
          this.decimal = decimal;
          this.im = value.im ?? 0;
        }
        if (this.decimal.isNaN()) this.im = NaN;
        console.assert(this.decimal.isNaN() === isNaN(this.im));
      }
      get type() {
        if (this.isNaN) return "number";
        if (this.isComplexInfinity) return "complex";
        if (this.im !== 0) {
          if (this.decimal.isZero()) return "imaginary";
          return "finite_complex";
        }
        if (!this.decimal.isFinite()) return "non_finite_number";
        if (this.decimal.isInteger()) return "finite_integer";
        return "finite_real";
      }
      get isExact() {
        return this.im === 0 && this.decimal.isInteger();
      }
      get asExact() {
        if (!this.isExact) return void 0;
        return this._makeExact(bigint(this.decimal));
      }
      toJSON() {
        if (this.isNaN) return "NaN";
        if (this.isPositiveInfinity) return "PositiveInfinity";
        if (this.isNegativeInfinity) return "NegativeInfinity";
        if (this.isComplexInfinity) return "ComplexInfinity";
        if (this.im === 0) {
          if (isInMachineRange(this.decimal)) return this.decimal.toNumber();
          return { num: decimalToString(this.decimal) };
        }
        if (isInMachineRange(this.decimal))
          return [
            "Complex",
            numberToExpression(this.decimal.toNumber()),
            numberToExpression(this.im)
          ];
        return [
          "Complex",
          { num: decimalToString(this.decimal) },
          numberToExpression(this.im)
        ];
      }
      toString() {
        if (this.isZero) return "0";
        if (this.isOne) return "1";
        if (this.isNegativeOne) return "-1";
        if (this.im === 0) return decimalToString(this.decimal);
        if (this.decimal.isZero()) {
          if (this.im === 1) return "i";
          if (this.im === -1) return "-i";
          return `${numberToString(this.im)}i`;
        }
        if (this.isComplexInfinity) return "~oo";
        let im = "";
        if (this.im === 1) im = "+ i";
        else if (this.im === -1) im = "- i";
        else if (this.im > 0) im = `+ ${this.im}i`;
        else im = `- ${-this.im}i`;
        return `(${decimalToString(this.decimal)} ${im})`;
      }
      clone(value) {
        return new _BigNumericValue(value, this.bignum);
      }
      _makeExact(value) {
        return new ExactNumericValue(value, (x) => this.clone(x), this.bignum);
      }
      get re() {
        return this.decimal.toNumber();
      }
      get bignumRe() {
        return this.decimal;
      }
      get numerator() {
        return this;
      }
      get denominator() {
        return this._makeExact(1);
      }
      get isNaN() {
        return this.decimal.isNaN();
      }
      get isPositiveInfinity() {
        return this.im === 0 && !this.decimal.isFinite() && !this.decimal.isNaN() && this.decimal.isPositive();
      }
      get isNegativeInfinity() {
        return this.im === 0 && !this.decimal.isFinite() && !this.decimal.isNaN() && this.decimal.isNegative();
      }
      get isComplexInfinity() {
        return !Number.isFinite(this.im) && !Number.isNaN(this.im);
      }
      get isZero() {
        return this.im === 0 && this.decimal.isZero();
      }
      isZeroWithTolerance(tolerance) {
        if (this.im !== 0) return false;
        const tol = typeof tolerance === "number" ? this.bignum(tolerance) : tolerance;
        return this.decimal.abs().lte(tol);
      }
      get isOne() {
        return this.im === 0 && this.decimal.eq(1);
      }
      get isNegativeOne() {
        return this.im === 0 && this.decimal.eq(-1);
      }
      sgn() {
        if (this.im !== 0) return void 0;
        if (this.decimal.isZero()) return 0;
        if (this.decimal.isPositive()) return 1;
        if (this.decimal.isNegative()) return -1;
        return void 0;
      }
      N() {
        return this;
      }
      neg() {
        if (this.isZero) return this;
        return this.clone({ re: this.decimal.neg(), im: -this.im });
      }
      inv() {
        if (this.isOne) return this;
        if (this.isNegativeOne) return this;
        if (this.im === 0) return this.clone(this.decimal.pow(-1));
        const d = Math.hypot(this.re, this.im);
        const bigD = this.decimal.mul(this.decimal).add(this.im * this.im).sqrt();
        return this.clone({ re: this.decimal.div(bigD), im: -this.im / d });
      }
      add(other) {
        if (typeof other === "number") {
          if (other === 0) return this;
          return this.clone({ re: this.decimal.add(other), im: this.im });
        }
        if (other.isZero) return this;
        if (this.isZero) return this.clone(other);
        return this.clone({
          re: this.decimal.add(other.bignumRe ?? other.re),
          im: this.im + other.im
        });
      }
      sub(other) {
        return this.add(other.neg());
      }
      mul(other) {
        if (this.isZero) return this;
        if (other === 1) return this;
        if (other === -1) return this.neg();
        if (other === 0) return this.clone(0);
        if (this.isOne) {
          if (typeof other === "number" || other instanceof Decimal)
            return this.clone(other);
          return this.clone({ re: other.bignumRe ?? other.re, im: other.im });
        }
        if (typeof other === "number") {
          if (this.im === 0) return this.clone(this.decimal.mul(other));
          return this.clone({
            re: this.decimal.mul(other),
            im: this.im * other
          });
        }
        if (other instanceof Decimal) {
          if (this.im === 0) return this.clone(this.decimal.mul(other));
          return this.clone({
            re: this.decimal.mul(other),
            im: this.im * other.toNumber()
          });
        }
        if (this.isNegativeOne) {
          const n = other.neg();
          return this.clone({ re: n.bignumRe ?? n.re, im: n.im });
        }
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (other.isZero) return this.clone(0);
        if (this.im === 0 && other.im === 0)
          return this.clone(this.decimal.mul(other.bignumRe ?? other.re));
        return this.clone({
          re: this.decimal.mul(other.bignumRe ?? other.re).sub(this.im * other.im),
          im: this.re * other.im + this.im * other.re
        });
      }
      div(other) {
        if (typeof other === "number") {
          if (other === 1) return this;
          if (other === -1) return this.neg();
          if (other === 0) return this.clone(NaN);
          return this.clone({
            re: this.decimal.div(other),
            im: this.im / other
          });
        }
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (other.isZero) return this.clone(this.isZero ? NaN : Infinity);
        if (this.im === 0 && other.im === 0)
          return this.clone(this.decimal.div(other.bignumRe ?? other.re));
        const [a, b] = [this.re, this.im];
        const [c, d] = [other.re, other.im];
        const denominator = c * c + d * d;
        const bigC = other.bignumRe ?? this.bignum(other.re);
        const bigDenominator = bigC.mul(bigC).add(d * d);
        return this.clone({
          re: this.decimal.mul(bigC).add(b * d).div(bigDenominator),
          im: (b * c - a * d) / denominator
        });
      }
      pow(exponent) {
        console.assert(!Array.isArray(exponent));
        if (this.isNaN) return this;
        if (typeof exponent === "number" && isNaN(exponent)) return this.clone(NaN);
        if (exponent instanceof NumericValue) {
          if (exponent.isNaN) return this.clone(NaN);
          if (exponent.isZero) return this.clone(1);
          if (exponent.isOne) return this;
          if (exponent.im) {
            exponent = { re: exponent.re, im: exponent.im };
          } else exponent = exponent.re;
        }
        if (typeof exponent === "object" && ("re" in exponent || "im" in exponent)) {
          const [re, im] = [exponent?.re ?? 0, exponent?.im ?? 0];
          if (Number.isNaN(im) || Number.isNaN(re)) return this.clone(NaN);
          if (im === 0) {
            exponent = re;
          } else {
            if (this.im === Infinity) return this.clone(NaN);
            if (this.isNegativeInfinity) return this.clone(0);
            if (this.isPositiveInfinity) return this.clone({ im: Infinity });
            const zRe = this.pow(re);
            const zArg = this.decimal.ln().mul(im);
            const zIm = this.clone({
              re: zArg.cos(),
              im: chop2(zArg.sin().toNumber())
            });
            return zRe.mul(zIm);
          }
        }
        if (this.isPositiveInfinity) {
          if (exponent === -1) return this.clone(0);
          if (exponent === Infinity) return this.clone(Infinity);
          if (exponent === -Infinity) return this.clone(0);
        } else if (this.isNegativeInfinity && exponent === Infinity)
          return this.clone(NaN);
        if ((exponent === Infinity || exponent === -Infinity) && (this.isOne || this.isNegativeOne))
          return this.clone(NaN);
        if (exponent === 1) return this;
        if (exponent === -1) return this.inv();
        if (exponent === 0) return this.clone(1);
        if (this.isZero) {
          if (exponent > 0) return this;
          if (exponent < 0) return this.clone({ im: Infinity });
        }
        if (exponent < 0) return this.pow(-exponent).inv();
        if (this.im === 0) {
          return this.clone(this.decimal.pow(exponent));
        }
        const a = this.decimal;
        const b = this.im;
        const modulus = a.mul(a).add(b * b).sqrt();
        const argument = Decimal.atan2(b, a);
        const newModulus = modulus.pow(exponent);
        const newArgument = argument.mul(exponent);
        return this.clone({
          re: newModulus.mul(newArgument.cos()),
          im: chop2(newModulus.mul(newArgument.sin()).toNumber())
        });
      }
      root(exp3) {
        if (!Number.isInteger(exp3)) return this._makeExact(NaN);
        if (exp3 === 0) return this._makeExact(NaN);
        if (exp3 === 1) return this;
        if (this.isZero) return this;
        if (this.isOne) return this;
        if (this.isNegativeOne) return this;
        if (this.im === 0) {
          if (this.decimal.isNegative()) return this._makeExact(NaN);
          if (exp3 === 2) return this.clone(this.decimal.sqrt());
          if (exp3 === 3) return this.clone(this.decimal.cbrt());
          return this.clone(this.decimal.pow(1 / exp3));
        }
        const a = this.decimal;
        const b = this.im;
        const modulus = a.mul(a).add(b * b).sqrt();
        const argument = Decimal.atan2(b, a);
        const newModulus = modulus.pow(1 / exp3);
        const newArgument = argument.div(exp3);
        return this.clone({
          re: newModulus.mul(newArgument.cos()),
          im: chop2(newModulus.mul(newArgument.sin()).toNumber())
        });
      }
      sqrt() {
        if (this.isZero || this.isOne) return this;
        if (this.im !== 0) {
          const a = this.decimal;
          const b = this.im;
          const modulus = a.mul(a).add(b * b).sqrt();
          const realPart = a.add(modulus).div(2).sqrt();
          const imaginaryPart = chop2(
            Math.sign(b) * modulus.sub(a).div(2).sqrt().toNumber()
          );
          return this.clone({ re: realPart, im: imaginaryPart });
        }
        if (this.decimal.isPositive()) return this.clone(this.decimal.sqrt());
        return this.clone({ im: Math.sqrt(-this.re) });
      }
      gcd(other) {
        if (this.isZero) return other;
        if (other.isZero) return this;
        if (this.im !== 0 || other.im !== 0) return this._makeExact(NaN);
        if (!this.decimal.isInteger()) return this._makeExact(1);
        let b = this.bignum(other.bignumRe ?? other.re);
        if (!b.isInteger()) return this._makeExact(1);
        let a = this.decimal;
        while (!b.isZero()) {
          const t = b;
          b = a.mod(b);
          a = t;
        }
        return this.clone(a.abs());
      }
      abs() {
        if (this.im === 0)
          return this.decimal.isPositive() ? this : this.clone(this.decimal.neg());
        return this.clone(
          this.decimal.pow(2).add(this.im ** 2).sqrt()
        );
      }
      ln(base) {
        if (this.isZero) return this._makeExact(NaN);
        if (this.isNegativeInfinity) return this._makeExact(NaN);
        if (this.isPositiveInfinity) return this._makeExact(Infinity);
        if (this.im === 0) {
          if (this.decimal.isNegative()) return this._makeExact(NaN);
          if (this.isOne) return this._makeExact(0);
          if (this.isNegativeOne) return this.clone({ im: Math.PI });
          if (base === void 0) return this.clone(this.decimal.ln());
          return this.clone(this.decimal.log(base));
        }
        const a = this.decimal;
        const b = this.im;
        const modulus = a.mul(a).add(b * b).sqrt();
        const argument = Decimal.atan2(b, a).toNumber();
        if (base === void 0)
          return this.clone({ re: modulus.ln(), im: argument });
        return this.clone({ re: modulus.log(base), im: argument });
      }
      exp() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return this._makeExact(1);
        if (this.isNegativeInfinity) return this._makeExact(0);
        if (this.isPositiveInfinity) return this._makeExact(Infinity);
        if (this.im !== 0) {
          const e = this.decimal.exp();
          return this.clone({
            re: e.mul(chop2(Math.cos(this.im))),
            im: chop2(e.mul(Math.sin(this.im)).toNumber())
          });
        }
        return this.clone(this.decimal.exp());
      }
      floor() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (this.decimal.isInteger()) return this;
        return this._makeExact(bigint(this.decimal.floor()));
      }
      ceil() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (this.decimal.isInteger()) return this;
        return this._makeExact(bigint(this.decimal.ceil()));
      }
      round() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (this.decimal.isInteger()) return this;
        return this._makeExact(bigint(this.decimal.round()));
      }
      eq(other) {
        if (this.isNaN) return false;
        if (typeof other === "number")
          return this.im === 0 && this.decimal.eq(other);
        if (other.isNaN) return false;
        if (!Number.isFinite(this.im)) return !Number.isFinite(other.im);
        return this.decimal.eq(other.bignumRe ?? other.re) && this.im - other.im === 0;
      }
      lt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal.lt(other);
        return this.decimal.lt(other.bignumRe ?? other.re);
      }
      lte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal.lte(other);
        return this.decimal.lte(other.bignumRe ?? other.re);
      }
      gt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal.gt(other);
        return this.decimal.gt(other.bignumRe ?? other.re);
      }
      gte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal.gte(other);
        return this.decimal.gte(other.bignumRe ?? other.re);
      }
    };
  }
});

// src/compute-engine/numeric-value/machine-numeric-value.ts
function chop3(n) {
  return Math.abs(n) <= 1e-14 ? 0 : n;
}
var MachineNumericValue;
var init_machine_numeric_value = __esm({
  "src/compute-engine/numeric-value/machine-numeric-value.ts"() {
    init_decimal();
    init_types2();
    init_strings();
    init_expression();
    init_exact_numeric_value();
    MachineNumericValue = class _MachineNumericValue extends NumericValue {
      __brand;
      // synonymous with 're'; the JavasScript number representation of the 'real' part.
      decimal;
      bignum;
      constructor(value, bignum) {
        super();
        this.bignum = bignum;
        if (typeof value === "number") {
          this.decimal = value;
          this.im = 0;
        } else if (value instanceof Decimal) {
          this.decimal = value.toNumber();
          this.im = 0;
        } else {
          const decimal = value.re === void 0 ? 0 : value.re instanceof Decimal ? value.re.toNumber() : value.re;
          this.decimal = decimal;
          this.im = value.im ?? 0;
          if (!isFinite(this.im)) this.decimal = this.im;
        }
        console.assert(!isNaN(this.im));
      }
      _makeExact(value) {
        return new ExactNumericValue(value, (x) => this.clone(x), this.bignum);
      }
      get type() {
        if (this.isNaN) return "number";
        if (this.isComplexInfinity) return "complex";
        if (this.im !== 0) {
          if (this.decimal === 0) return "imaginary";
          return "finite_complex";
        }
        if (!Number.isFinite(this.decimal)) return "non_finite_number";
        if (Number.isInteger(this.decimal)) return "finite_integer";
        return "finite_real";
      }
      get isExact() {
        return this.im === 0 && Number.isInteger(this.decimal);
      }
      get asExact() {
        if (!this.isExact) return void 0;
        return this._makeExact(this.decimal);
      }
      toJSON() {
        if (this.isNaN) return "NaN";
        if (this.isPositiveInfinity) return "PositiveInfinity";
        if (this.isNegativeInfinity) return "NegativeInfinity";
        if (this.im === 0) return numberToExpression(this.decimal);
        return [
          "Complex",
          numberToExpression(this.decimal),
          numberToExpression(this.im)
        ];
      }
      toString() {
        if (this.isZero) return "0";
        if (this.isOne) return "1";
        if (this.isNegativeOne) return "-1";
        if (this.im === 0) return numberToString(this.decimal);
        if (this.decimal === 0) {
          if (this.im === 1) return "i";
          if (this.im === -1) return "-i";
          return `${numberToString(this.im)}i`;
        }
        if (this.isComplexInfinity) return "~oo";
        let im = "";
        if (this.im === 1) im = "+ i";
        else if (this.im === -1) im = "- i";
        else if (this.im > 0) im = `+ ${numberToString(this.im)}i`;
        else im = `- ${numberToString(-this.im)}i`;
        return `(${numberToString(this.decimal)} ${im})`;
      }
      clone(value) {
        return new _MachineNumericValue(value, this.bignum);
      }
      get re() {
        return this.decimal;
      }
      get bignumRe() {
        return void 0;
      }
      get numerator() {
        return this;
      }
      get denominator() {
        return this._makeExact(1);
      }
      get isNaN() {
        return Number.isNaN(this.decimal);
      }
      get isPositiveInfinity() {
        return !Number.isFinite(this.decimal) && this.decimal > 0 && this.im === 0;
      }
      get isNegativeInfinity() {
        return !Number.isFinite(this.decimal) && this.decimal < 0 && this.im === 0;
      }
      get isComplexInfinity() {
        return !Number.isFinite(this.im) && !Number.isNaN(this.im);
      }
      get isZero() {
        return this.im === 0 && this.decimal === 0;
      }
      isZeroWithTolerance(tolerance) {
        if (this.im !== 0) return false;
        const tol = tolerance instanceof Decimal ? tolerance.toNumber() : tolerance;
        return Math.abs(this.decimal) < tol;
      }
      get isOne() {
        return this.im === 0 && this.decimal === 1;
      }
      get isNegativeOne() {
        return this.im === 0 && this.decimal === -1;
      }
      sgn() {
        if (this.im !== 0 || !Number.isFinite(this.decimal)) return void 0;
        return Math.sign(this.decimal);
      }
      N() {
        return this;
      }
      neg() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return this;
        return this.clone({ re: -this.decimal, im: -this.im });
      }
      inv() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isOne) return this;
        if (this.isNegativeOne) return this;
        if (this.im === 0) return this.clone(1 / this.decimal);
        const d = Math.hypot(this.re, this.im);
        return this.clone({ re: this.decimal / d, im: -this.im / d });
      }
      add(other) {
        if (this.isNaN) return this._makeExact(NaN);
        if (typeof other === "number") {
          if (other === 0) return this;
          return this.clone({ re: this.decimal + other, im: this.im });
        }
        if (other.isZero) return this;
        if (this.isZero)
          return this.clone({ re: other.bignumRe ?? other.re, im: other.im });
        return this.clone({
          re: this.decimal + other.re,
          im: this.im + other.im
        });
      }
      sub(other) {
        return this.add(other.neg());
      }
      mul(other) {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return this;
        if (other instanceof Decimal) other = other.toNumber();
        if (other === 1) return this;
        if (other === -1) return this.neg();
        if (other === 0) return this.clone(0);
        if (this.isOne) {
          if (typeof other === "number" || other instanceof Decimal)
            return this.clone(other);
          return this.clone({ re: other.bignumRe ?? other.re, im: other.im });
        }
        if (typeof other === "number") {
          if (this.im === 0) return this.clone(this.decimal * other);
          return this.clone({
            re: this.decimal * other,
            im: this.im * other
          });
        }
        if (this.isNegativeOne) {
          const n = other.neg();
          return this.clone({ re: n.bignumRe ?? n.re, im: n.im });
        }
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (other.isZero) return this.clone(0);
        if (this.im === 0 && other.im === 0)
          return this.clone(this.decimal * other.re);
        return this.clone({
          re: this.decimal * other.re - this.im * other.im,
          im: this.re * other.im + this.im * other.re
        });
      }
      div(other) {
        if (this.isNaN) return this._makeExact(NaN);
        if (typeof other === "number") {
          if (other === 1) return this;
          if (other === -1) return this.neg();
          if (other === 0) return this.clone(NaN);
          return this.clone({
            re: this.decimal / other,
            im: this.im / other
          });
        }
        if (other.isOne) return this;
        if (other.isNegativeOne) return this.neg();
        if (other.isZero) return this.clone(this.isZero ? NaN : Infinity);
        if (this.im === 0 && other.im === 0)
          return this.clone(this.decimal / other.re);
        const [a, b] = [this.decimal, this.im];
        const [c, d] = [other.re, other.im];
        const denominator = c * c + d * d;
        return this.clone({
          re: (a * c + b * d) / denominator,
          im: (b * c - a * d) / denominator
        });
      }
      pow(exponent) {
        console.assert(!Array.isArray(exponent));
        if (this.isNaN) return this._makeExact(NaN);
        if (typeof exponent === "number" && isNaN(exponent)) return this.clone(NaN);
        if (exponent instanceof NumericValue) {
          if (exponent.isNaN) return this.clone(NaN);
          if (exponent.isZero) return this.clone(1);
          if (exponent.isOne) return this;
          if (exponent.im) {
            exponent = { re: exponent.re, im: exponent.im };
          } else exponent = exponent.re;
        }
        if (typeof exponent === "object" && ("re" in exponent || "im" in exponent)) {
          const [re, im] = [exponent?.re ?? 0, exponent?.im ?? 0];
          if (Number.isNaN(im) || Number.isNaN(re)) return this.clone(NaN);
          if (im === 0) {
            exponent = re;
          } else {
            if (this.im === Infinity) return this.clone(NaN);
            if (this.isNegativeInfinity) return this.clone(0);
            if (this.isPositiveInfinity) return this.clone({ im: Infinity });
            const zRe = this.pow(re).re;
            const zArg = Math.log(this.decimal) * im;
            return this.clone({
              re: chop3(zRe * Math.cos(zArg)),
              im: chop3(zRe * Math.sin(zArg))
            });
          }
        }
        if (this.isPositiveInfinity) {
          if (exponent === -1) return this.clone(0);
          if (exponent === Infinity) return this.clone(Infinity);
          if (exponent === -Infinity) return this.clone(0);
        } else if (this.isNegativeInfinity && exponent === Infinity)
          return this.clone(NaN);
        if ((exponent === Infinity || exponent === -Infinity) && (this.isOne || this.isNegativeOne))
          return this.clone(NaN);
        if (exponent === 1) return this;
        if (exponent === -1) return this.inv();
        if (exponent === 0) return this.clone(1);
        if (this.isZero) {
          if (exponent > 0) return this;
          if (exponent < 0) return this.clone({ im: Infinity });
        }
        if (exponent < 0) return this.clone(1 / this.decimal ** -exponent);
        if (this.im === 0) return this.clone(this.decimal ** exponent);
        const a = this.decimal;
        const b = this.im;
        const modulus = Math.sqrt(a * a + b * b);
        const argument = Math.atan2(b, a);
        const newModulus = modulus ** exponent;
        const newArgument = argument ** exponent;
        return this.clone({
          re: newModulus * Math.cos(newArgument),
          im: newModulus * Math.sin(newArgument)
        });
      }
      root(exponent) {
        if (this.isNaN) return this._makeExact(NaN);
        if (exponent === 0) return this.clone(NaN);
        if (this.isNaN) return this;
        if (this.isZero) return this;
        if (this.isOne) return this;
        if (this.isNegativeOne) return this;
        if (exponent === 1) return this;
        if (exponent === 2) return this.sqrt();
        if (exponent === 3) return this.clone(Math.cbrt(this.decimal));
        if (this.im === 0) {
          if (this.decimal < 0) {
            if (exponent % 2 === 0) return this.clone(NaN);
            return this.clone(-Math.pow(-this.decimal, 1 / exponent));
          }
          return this.clone(Math.pow(this.decimal, 1 / exponent));
        }
        const a = this.decimal;
        const b = this.im;
        const modulus = Math.hypot(a, b);
        const argument = Math.atan2(b, a);
        const newModulus = Math.pow(modulus, 1 / exponent);
        const newArgument = argument / exponent;
        return this.clone({
          re: newModulus * Math.cos(newArgument),
          im: newModulus * Math.sin(newArgument)
        });
      }
      sqrt() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero || this.isOne) return this;
        if (this.im !== 0) {
          const a = this.decimal;
          const b = this.im;
          const modulus = Math.sqrt(a * a + b * b);
          const realPart = Math.sqrt((a + modulus) / 2);
          const imaginaryPart = Math.sign(b) * Math.sqrt((modulus - a) / 2);
          return this.clone({ re: realPart, im: imaginaryPart });
        }
        if (this.decimal > 0) return this.clone(Math.sqrt(this.decimal));
        return this.clone({ im: Math.sqrt(-this.decimal) });
      }
      gcd(other) {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return other;
        if (other.isZero) return this;
        if (this.im !== 0 || other.im !== 0) return this._makeExact(NaN);
        if (!Number.isInteger(this.decimal)) return this._makeExact(1);
        let b = other.re;
        if (!Number.isInteger(b)) return this._makeExact(1);
        let a = this.decimal;
        while (b !== 0) {
          const t = b;
          b = a % b;
          a = t;
        }
        return this.clone(Math.abs(a));
      }
      abs() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.im === 0)
          return this.decimal > 0 ? this : this.clone(-this.decimal);
        return this.clone(Math.sqrt(this.decimal ** 2 + this.im ** 2));
      }
      ln(base) {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return this._makeExact(NaN);
        if (this.isNegativeInfinity) return this._makeExact(NaN);
        if (this.isPositiveInfinity) return this._makeExact(Infinity);
        if (this.im === 0) {
          if (this.decimal < 0) return this._makeExact(NaN);
          if (this.isOne) return this._makeExact(0);
          if (this.isNegativeOne) return this.clone({ im: Math.PI });
          if (base === void 0) return this.clone(Math.log(this.decimal));
          return this.clone(Math.log(this.decimal) / Math.log(base));
        }
        const a = this.decimal;
        const b = this.im;
        const modulus = Math.hypot(a, b);
        const argument = Math.atan2(b, a);
        const decimal = base === void 0 ? Math.log(modulus) : Math.log(modulus) / Math.log(base);
        return this.clone({ re: decimal, im: argument });
      }
      exp() {
        if (this.isNaN) return this._makeExact(NaN);
        if (this.isZero) return this._makeExact(1);
        if (this.isNegativeInfinity) return this._makeExact(0);
        if (this.isPositiveInfinity) return this._makeExact(Infinity);
        if (this.im !== 0) {
          const e = Math.exp(this.decimal);
          return this.clone({
            re: e * Math.cos(this.im),
            im: e * Math.sin(this.im)
          });
        }
        return this.clone(Math.exp(this.decimal));
      }
      floor() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (Number.isInteger(this.decimal)) return this;
        return this._makeExact(Math.floor(this.decimal));
      }
      ceil() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (Number.isInteger(this.decimal)) return this;
        return this._makeExact(Math.ceil(this.decimal));
      }
      round() {
        if (this.isNaN || this.im !== 0) return this._makeExact(NaN);
        if (Number.isInteger(this.decimal)) return this;
        return this._makeExact(Math.round(this.decimal));
      }
      eq(other) {
        if (this.isNaN) return false;
        if (typeof other === "number")
          return this.im === 0 && this.decimal - other === 0;
        if (other.isNaN) return false;
        if (!Number.isFinite(this.im)) return !Number.isFinite(other.im);
        return this.decimal - other.re === 0 && this.im - other.im === 0;
      }
      lt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal < other;
        return this.decimal < other.re;
      }
      lte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal <= other;
        return this.decimal <= other.re;
      }
      gt(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal > other;
        return this.decimal > other.re;
      }
      gte(other) {
        if (this.im !== 0) ;
        if (typeof other === "number") return this.decimal >= other;
        return this.decimal >= other.re;
      }
    };
  }
});

// src/compute-engine/boxed-expression/terms.ts
function nvSum(ce, numericValues) {
  const bignum = (x) => ce.bignum(x);
  const makeExact = (x) => new ExactNumericValue(x, factory, bignum);
  const factory = ce.precision > MACHINE_PRECISION ? (x) => new BigNumericValue(x, bignum) : (x) => new MachineNumericValue(x, makeExact);
  return ExactNumericValue.sum(numericValues, factory, bignum);
}
function nvSumN(ce, numericValues) {
  const bignum = (x) => ce.bignum(x);
  const makeExact = (x) => new ExactNumericValue(x, factory, bignum);
  const factory = ce.precision > MACHINE_PRECISION ? (x) => new BigNumericValue(x, bignum) : (x) => new MachineNumericValue(x, makeExact);
  const result = ExactNumericValue.sum(numericValues, factory, bignum);
  if (result.length === 0) return makeExact(0);
  if (result.length === 1) return result[0].N();
  return result.reduce((acc, x) => acc.add(x).N());
}
var Terms;
var init_terms = __esm({
  "src/compute-engine/boxed-expression/terms.ts"() {
    init_arithmetic_add();
    init_arithmetic_mul_div();
    init_numeric();
    init_exact_numeric_value();
    init_big_numeric_value();
    init_machine_numeric_value();
    Terms = class {
      engine;
      terms = [];
      constructor(ce, terms) {
        this.engine = ce;
        let posInfinityCount = 0;
        let negInfinityCount = 0;
        const numericValues = [];
        for (const term of terms) {
          if (term.type.is("complex") && term.isInfinity) {
            this.terms = [{ term: ce.ComplexInfinity, coef: [] }];
            return;
          }
          if (term.isNaN || term.symbol === "Undefined") {
            this.terms = [{ term: ce.NaN, coef: [] }];
            return;
          }
          const [coef, rest] = term.toNumericValue();
          if (coef.isPositiveInfinity) posInfinityCount += 1;
          else if (coef.isNegativeInfinity) negInfinityCount += 1;
          if (rest.is(1)) {
            if (!coef.isZero) numericValues.push(coef);
          } else this.add(coef, rest);
        }
        if (posInfinityCount > 0 && negInfinityCount > 0) {
          this.terms = [{ term: ce.NaN, coef: [] }];
          return;
        }
        if (posInfinityCount > 0) {
          this.terms = [{ term: ce.PositiveInfinity, coef: [] }];
          return;
        }
        if (negInfinityCount > 0) {
          this.terms = [{ term: ce.NegativeInfinity, coef: [] }];
          return;
        }
        if (numericValues.length === 1) {
          this.add(numericValues[0], ce.One);
        } else if (numericValues.length > 0) {
          nvSum(ce, numericValues).forEach((x) => this.add(x, ce.One));
        }
      }
      add(coef, term) {
        if (term.is(0) || coef.isZero) return;
        if (term.is(1)) {
          const ce = this.engine;
          this.terms.push({ coef: [], term: ce.number(coef) });
          return;
        }
        if (term.operator === "Add") {
          for (const x of term.ops) {
            const [c, t] = x.toNumericValue();
            this.add(coef.mul(c), t);
          }
          return;
        }
        if (term.operator === "Negate") {
          this.add(coef.neg(), term.op1);
          return;
        }
        const i = this.find(term);
        if (i >= 0) {
          this.terms[i].coef.push(coef);
          return;
        }
        console.assert(term.numericValue === null || term.is(1));
        this.terms.push({ coef: [coef], term });
      }
      find(term) {
        return this.terms.findIndex((x) => x.term.isSame(term));
      }
      N() {
        const ce = this.engine;
        const terms = this.terms;
        if (terms.length === 0) return ce.Zero;
        const rest = [];
        const numericValues = [];
        for (const { coef, term } of terms) {
          if (coef.length === 0) {
            if (term.isNumberLiteral) {
              if (typeof term.numericValue === "number")
                numericValues.push(ce._numericValue(term.numericValue));
              else numericValues.push(term.numericValue);
            } else rest.push(term);
          } else {
            const sum3 = coef.reduce((acc, x) => acc.add(x)).N();
            if (sum3.isZero) continue;
            if (sum3.eq(1)) rest.push(term.N());
            else if (sum3.eq(-1)) rest.push(term.N().neg());
            else rest.push(term.N().mul(ce.box(sum3)));
          }
        }
        const sum2 = nvSumN(ce, numericValues);
        if (!sum2.isZero) {
          if (rest.length === 0) return ce.box(sum2);
          rest.push(ce.box(sum2));
        }
        return canonicalAdd(ce, rest);
      }
      asExpression() {
        const ce = this.engine;
        const terms = this.terms;
        if (terms.length === 0) return ce.Zero;
        return canonicalAdd(
          ce,
          terms.map(({ coef, term }) => {
            if (coef.length === 0) return term;
            const coefs = nvSum(ce, coef);
            if (coefs.length === 0) return term;
            if (coefs.length > 1) {
              return canonicalMultiply(ce, [
                canonicalAdd(
                  ce,
                  coefs.map((x) => ce.box(x))
                ),
                term
              ]);
            }
            const sum2 = coefs[0];
            if (sum2.isNaN) return ce.NaN;
            if (sum2.isZero) return ce.Zero;
            if (sum2.eq(1)) return term;
            if (sum2.eq(-1)) return term.neg();
            if (term.is(1)) return ce.box(sum2);
            return term.mul(ce.box(sum2));
          })
        );
      }
    };
  }
});

// src/compute-engine/tensor/tensor-fields.ts
function makeTensorField(ce, dtype) {
  switch (dtype) {
    case "float64":
    case "float32":
    case "int32":
    case "uint8":
      return new TensorFieldNumber(ce);
    case "complex128":
    case "complex64":
      return new TensorFieldComplex(ce);
    case "bool":
    // case 'string':
    case "expression":
      return new TensorFieldExpression(ce);
    case void 0:
      return new TensorFieldNumber(ce);
  }
  throw new Error(`Unknown dtype ${dtype}`);
}
function getSupertype(t1, t2) {
  if (t1 === void 0) return t2;
  if (t1 === t2) return t1;
  if (t1 === "expression" || t2 === "expression") return "expression";
  if (t1 === "complex128" || t2 === "complex128") return "complex128";
  if (t1 === "complex64" || t2 === "complex64") return "complex64";
  if (t1 === "float64" || t2 === "float64") return "float64";
  if (t1 === "float32" || t2 === "float32") return "float32";
  if (t1 === "int32" || t2 === "int32") return "int32";
  if (t1 === "uint8" || t2 === "uint8") return "uint8";
  if (t1 === "bool" || t2 === "bool") return "bool";
  return "expression";
}
function getExpressionDatatype(expr) {
  if (expr.symbol === "True" || expr.symbol === "False") return "bool";
  if (expr.symbol === "NaN") return "float64";
  if (expr.symbol === "PositiveInfinity") return "float64";
  if (expr.symbol === "NegativeInfinity") return "float64";
  if (expr.symbol === "ComplexInfinity") return "complex128";
  if (expr.symbol === "ImaginaryUnit") return "complex128";
  if (expr.isNumberLiteral)
    switch (expr.type.type) {
      case "real":
      case "rational":
      case "finite_real":
      case "finite_rational":
      case "integer":
        return "float64";
      case "complex":
      case "finite_complex":
      case "imaginary":
        return "complex128";
      case "finite_integer": {
        const val = expr.re;
        if (val >= 0 && val <= 255) return "uint8";
        return "int32";
      }
      default:
        return "expression";
    }
  return "expression";
}
var TensorFieldNumber, TensorFieldExpression, TensorFieldComplex;
var init_tensor_fields = __esm({
  "src/compute-engine/tensor/tensor-fields.ts"() {
    init_arithmetic_mul_div();
    init_arithmetic_add();
    TensorFieldNumber = class {
      constructor(ce) {
        this.ce = ce;
      }
      one = 1;
      zero = 0;
      nan = NaN;
      cast(x, dtype) {
        const ce = this.ce;
        switch (dtype) {
          case "float64":
          case "float32":
          case "int32":
          case "uint8":
            return x;
          case "complex128":
          case "complex64":
            return Array.isArray(x) ? x.map((x2) => ce.complex(x2)) : this.ce.complex(x);
          case "bool":
            return Array.isArray(x) ? x.map((x2) => x2 === 0 ? false : true) : x === 0 ? false : true;
          // case 'string':
          //   return Array.isArray(x)
          //     ? x.map((x) => Number(x).toString())
          //     : Number(x).toString();
          case "expression":
            return Array.isArray(x) ? x.map((x2) => ce.number(x2)) : ce.number(x);
        }
        throw new Error(`Cannot cast ${x} to ${dtype}`);
      }
      expression(x) {
        return this.ce.number(x);
      }
      isZero(x) {
        return x === 0;
      }
      isOne(x) {
        return x === 1;
      }
      equals(lhs, rhs) {
        return lhs === rhs;
      }
      add(lhs, rhs) {
        return lhs + rhs;
      }
      addn(...xs) {
        return xs.reduce((a, b) => a + b, 0);
      }
      neg(x) {
        return -x;
      }
      sub(lhs, rhs) {
        return lhs - rhs;
      }
      mul(lhs, rhs) {
        return lhs * rhs;
      }
      muln(...xs) {
        return xs.reduce((a, b) => a * b, 1);
      }
      div(lhs, rhs) {
        return lhs / rhs;
      }
      pow(lhs, rhs) {
        return lhs ** rhs;
      }
      conjugate(x) {
        return x;
      }
    };
    TensorFieldExpression = class {
      one;
      zero;
      nan;
      ce;
      constructor(ce) {
        this.zero = ce.Zero;
        this.nan = ce.NaN;
        this.ce = ce;
      }
      cast(x, dtype) {
        if (Array.isArray(x)) return x.map((x2) => this.cast(x2, dtype));
        switch (dtype) {
          case "float64":
          case "float32":
            return x.im === 0 ? x.re : void 0;
          case "int32":
            return typeof x.re === "number" ? Math.round(x.re) : void 0;
          case "uint8":
            if (typeof x.re !== "number") return void 0;
            const i = Math.round(x.re);
            return i >= 0 && i <= 255 ? i : void 0;
          case "complex128":
          case "complex64":
            const [re, im] = [x.re, x.im];
            if (typeof re === "number" && typeof im === "number")
              return this.ce.complex(re, im);
            if (typeof re === "number") return this.ce.complex(re);
            return void 0;
          case "bool":
            const bool = x.valueOf();
            return typeof bool === "boolean" ? bool : void 0;
          // case 'string':
          //   const str = x.valueOf();
          //   if (typeof str === 'string') return str;
          //   if (typeof str === 'number') return str.toString();
          //   if (typeof str === 'boolean') return str.toString();
          //   return undefined;
          case "expression":
            return x;
        }
        throw new Error(`Cannot cast ${x} to ${dtype}`);
      }
      expression(x) {
        return x;
      }
      isZero(x) {
        return x.is(0);
      }
      isOne(x) {
        return x.is(1);
      }
      equals(lhs, rhs) {
        return lhs.isSame(rhs) === true;
      }
      add(lhs, rhs) {
        return lhs.add(rhs);
      }
      addn(...xs) {
        return add3(...xs);
      }
      neg(x) {
        return x.neg();
      }
      sub(lhs, rhs) {
        return lhs.sub(rhs);
      }
      mul(lhs, rhs) {
        return lhs.mul(rhs);
      }
      muln(...xs) {
        return mul3(...xs);
      }
      div(lhs, rhs) {
        return lhs.div(rhs);
      }
      pow(lhs, rhs) {
        return lhs.pow(rhs);
      }
      conjugate(x) {
        return this.ce.function("Conjugate", [x]).evaluate();
      }
    };
    TensorFieldComplex = class {
      one;
      zero;
      nan;
      ce;
      constructor(ce) {
        this.ce = ce;
        this.one = ce.complex(1);
        this.zero = ce.complex(0);
        this.nan = ce.complex(NaN);
      }
      cast(x, dtype) {
        if (Array.isArray(x)) {
          return x.map((x2) => this.cast(x2, dtype));
        }
        switch (dtype) {
          case "float64":
            return x.im === 0 ? x.re : void 0;
          case "float32":
            return x.im === 0 ? x.re : void 0;
          case "int32":
            return x.im === 0 ? Math.round(x.re) : void 0;
          case "uint8":
            if (x.im !== 0) return void 0;
            const i = Math.round(x.re);
            return i >= 0 && i <= 255 ? i : void 0;
          case "complex128":
            return x;
          case "complex64":
            return x;
          case "bool":
            return x.im === 0 && x.re === 0 ? false : true;
          // case 'string':
          //   return x.toString();
          case "expression":
            return this.ce.number(x);
        }
        throw new Error(`Cannot cast ${x} to ${dtype}`);
      }
      expression(z) {
        return this.ce.number(z);
      }
      isZero(z) {
        return z.isZero();
      }
      isOne(z) {
        return z.re === 1 && z.im === 0;
      }
      equals(lhs, rhs) {
        return lhs.equals(rhs);
      }
      add(lhs, rhs) {
        return lhs.add(rhs);
      }
      addn(...xs) {
        return xs.reduce((a, b) => a.add(b), this.zero);
      }
      neg(z) {
        return z.neg();
      }
      sub(lhs, rhs) {
        return lhs.sub(rhs);
      }
      mul(lhs, rhs) {
        return lhs.mul(rhs);
      }
      muln(...xs) {
        return xs.reduce((a, b) => a.mul(b), this.one);
      }
      div(lhs, rhs) {
        return lhs.div(rhs);
      }
      pow(lhs, rhs) {
        return lhs.pow(rhs);
      }
      conjugate(z) {
        return z.conjugate();
      }
    };
  }
});

// src/compute-engine/tensor/tensors.ts
function getStrides(shape) {
  const strides = new Array(shape.length);
  for (let i = shape.length - 1, stride = 1; i >= 0; i--) {
    strides[i] = stride;
    stride *= shape[i];
  }
  return strides;
}
function makeTensor(ce, data) {
  const dtype = data.dtype;
  if (dtype === "float64" || dtype === "float32" || dtype === "uint8" || dtype === "int32")
    return new NumberTensor(
      ce,
      data
    );
  if (dtype === "bool")
    return new BooleanTensor(
      ce,
      data
    );
  if (dtype === "complex64" || dtype === "complex128")
    return new ComplexTensor(
      ce,
      data
    );
  return new GenericTensor(
    ce,
    data
  );
}
var AbstractTensor, NumberTensor, ComplexTensor, BooleanTensor, GenericTensor;
var init_tensors = __esm({
  "src/compute-engine/tensor/tensors.ts"() {
    init_tensor_fields();
    AbstractTensor = class _AbstractTensor {
      constructor(ce, tensorData) {
        this.ce = ce;
        this.shape = tensorData.shape;
        this.rank = this.shape.length;
        this._strides = getStrides(this.shape);
        this.field = makeTensorField(ce, tensorData.dtype);
      }
      static align(lhs, rhs) {
        if (lhs.dtype === rhs.dtype)
          return [lhs, rhs];
        const dtype = getSupertype(lhs.dtype, rhs.dtype);
        if (lhs.dtype === dtype)
          return [lhs, rhs.upcast(dtype)];
        return [lhs.upcast(dtype), rhs];
      }
      /**
       * Apply a function to the elements of two tensors, or to a tensor
       * and a scalar.
       *
       * The tensors are aligned and broadcasted if necessary.
       *
       * @param fn
       * @param lhs
       * @param rhs
       * @returns
       */
      static broadcast(fn, lhs, rhs) {
        if (!(rhs instanceof _AbstractTensor)) return lhs.map1(fn, rhs);
        const [lhs_, rhs_] = _AbstractTensor.align(lhs, rhs);
        const data = lhs_.data.map((v, i) => fn(v, rhs_.data[i]));
        return makeTensor(lhs_.ce, {
          dtype: lhs_.dtype,
          shape: lhs_.shape,
          data
        });
      }
      // The arithmetic operations that can be performed on the
      // elements of the tensor, based on the datatype
      field;
      shape;
      rank;
      _strides;
      // A Boxed Expression that represents the tensor
      get expression() {
        const shape = this.shape;
        const rank2 = this.rank;
        const data = this.data;
        const index = this._index.bind(this);
        const expression = this.field.expression.bind(this.field);
        const fill = (indices) => {
          if (indices.length === rank2 - 1) {
            const idx = index(indices);
            return this.ce._fn(
              "List",
              data.slice(idx, idx + shape[rank2 - 1]).map((x) => expression(x))
            );
          } else {
            const list = [];
            for (let i = 1; i <= shape[indices.length]; i++)
              list.push(fill([...indices, i]));
            return this.ce._fn("List", list);
          }
        };
        return fill([]);
      }
      /**
       * Like expression(), but return a nested JS array instead
       * of a BoxedExpression
       */
      get array() {
        const shape = this.shape;
        const rank2 = this.rank;
        const data = this.data;
        if (rank2 === 1) return data;
        if (rank2 === 2) {
          const [m, n] = shape;
          const array = new Array(m);
          for (let i = 0; i < m; i++) array[i] = data.slice(i * n, (i + 1) * n);
          return array;
        }
        const index = this._index.bind(this);
        const fill = (indices) => {
          if (indices.length === rank2 - 1) {
            const idx = index(indices);
            return data.slice(idx, idx + shape[rank2 - 1]);
          } else {
            const list = [];
            for (let i = 0; i < shape[indices.length]; i++)
              list.push(fill([...indices, i + 1]));
            return list;
          }
        };
        return fill([]);
      }
      /** Indices are 1-based, return a 0-based index in the data */
      _index(indices) {
        const strides = this._strides;
        return indices.reduce((acc, val, dim) => acc + (val - 1) * strides[dim], 0);
      }
      get isSquare() {
        const shape = this.shape;
        return shape.length === 2 && shape[0] === shape[1];
      }
      // A square matrix that is equal to its transpose. A^T = A
      get isSymmetric() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const eq2 = this.field.equals.bind(this.field);
        for (let i = 0; i < n; i++)
          for (let j = i + 1; j < n; j++)
            if (!eq2(data[i * n + j], data[j * n + i])) return false;
        return true;
      }
      // Aka antisymmetric matrix, skew-symmetric matrix, or antimetric matrix
      // A square matrix whose transpose is also its negative. A^T = -A
      get isSkewSymmetric() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const eq2 = this.field.equals.bind(this.field);
        const neg2 = this.field.neg.bind(this.field);
        for (let i = 0; i < n; i++)
          for (let j = i + 1; j < n; j++)
            if (!eq2(data[i * n + j], neg2(data[j * n + i]))) return false;
        return true;
      }
      // All entries below the diagonal are zero.
      get isUpperTriangular() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const isZero2 = this.field.isZero.bind(this.field);
        for (let i = 1; i < n; i++)
          for (let j = 0; j < i; j++) if (isZero2(data[i * n + j])) return false;
        return true;
      }
      // All entries above the diagonal are zero.
      get isLowerTriangular() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const isZero2 = this.field.isZero.bind(this.field);
        for (let i = 0; i < n - 1; i++)
          for (let j = i + 1; j < n; j++)
            if (!isZero2(data[i * n + j])) return false;
        return true;
      }
      get isTriangular() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const isZero2 = this.field.isZero.bind(this.field);
        for (let i = 0; i < n; i++)
          for (let j = 0; j < n; j++)
            if (i < j && !isZero2(data[i * n + j]) || i > j && !isZero2(data[i * n + j]))
              return false;
        return true;
      }
      get isDiagonal() {
        if (!this.isSquare) return false;
        const n = this.shape[0];
        const data = this.data;
        const isZero2 = this.field.isZero.bind(this.field);
        for (let i = 0; i < n; i++)
          for (let j = 0; j < n; j++)
            if (i === j && !isZero2(data[i * n + j]) || i !== j && !isZero2(data[i * n + j]))
              return false;
        return true;
      }
      get isIdentity() {
        if (!this.isSquare) return false;
        const [m, n] = this.shape;
        const data = this.data;
        const isOne2 = this.field.isOne.bind(this.field);
        const isZero2 = this.field.isZero.bind(this.field);
        for (let i = 0; i < n; i++)
          for (let j = 0; j < n; j++)
            if (i === j && !isOne2(data[i * n + j]) || i !== j && !isZero2(data[i * n + j]))
              return false;
        return true;
      }
      get isZero() {
        const isZero2 = this.field.isZero.bind(this.field);
        return this.data.every((e) => isZero2(e));
      }
      /**
       *  The number of indices should match the rank of the tensor.
       *
       * Note: the indices are 1-based
       * Note: the data is broadcast (wraps around) if the indices are out of bounds
       *
       * LaTeX notation `A\lbracki, j\rbrack` or `A_{i, j}`
       */
      at(...indices) {
        const l = this.data.length;
        return this.data[this._index(indices) % l];
      }
      diagonal(axis1, axis2) {
        axis1 ??= 1;
        axis2 ??= 2;
        if (axis1 === axis2) return void 0;
        if (axis1 <= 0 || axis1 > this.shape.length) return void 0;
        if (this.shape[axis1 - 1] !== this.shape[axis2 - 1]) return void 0;
        const diag = new Array(this.shape[axis1 - 1]);
        const data = this.data;
        const n = this.shape[axis1 - 1];
        for (let i = 0; i < n; i++) diag[i] = data[i * n + i];
        return diag;
      }
      // Trace is the sum of the diagonal entries of a square matrix.
      // `\operatorname{tr}(A) = \sum_{i=1}^n a_{ii}`
      // For rank > 2, returns a tensor of traces over the last two axes (batch trace)
      trace(axis1, axis2) {
        const rank2 = this.rank;
        if (rank2 < 2) return void 0;
        axis1 ??= rank2 - 1;
        axis2 ??= rank2;
        const ax1 = axis1 - 1;
        const ax2 = axis2 - 1;
        if (this.shape[ax1] !== this.shape[ax2]) return void 0;
        const traceSize = this.shape[ax1];
        if (rank2 === 2) {
          const data = this.data;
          const n = traceSize;
          const traceElements = new Array(n);
          for (let i = 0; i < n; i++) traceElements[i] = data[i * n + i];
          return this.field.addn(...traceElements);
        }
        const resultShape = this.shape.filter((_, i) => i !== ax1 && i !== ax2);
        const srcStrides = getStrides(this.shape);
        const resultSize = resultShape.reduce((a, b) => a * b, 1);
        const resultData = new Array(resultSize);
        const resultStrides = getStrides(resultShape);
        for (let resultIdx = 0; resultIdx < resultSize; resultIdx++) {
          const resultIndices = new Array(resultShape.length);
          let remaining = resultIdx;
          for (let d = 0; d < resultShape.length; d++) {
            resultIndices[d] = Math.floor(remaining / resultStrides[d]);
            remaining = remaining % resultStrides[d];
          }
          const srcIndices = new Array(rank2);
          let rIdx = 0;
          for (let d = 0; d < rank2; d++) {
            if (d === ax1 || d === ax2) {
              srcIndices[d] = 0;
            } else {
              srcIndices[d] = resultIndices[rIdx++];
            }
          }
          const traceElements = new Array(traceSize);
          for (let i = 0; i < traceSize; i++) {
            srcIndices[ax1] = i;
            srcIndices[ax2] = i;
            let srcIdx = 0;
            for (let d = 0; d < rank2; d++) {
              srcIdx += srcIndices[d] * srcStrides[d];
            }
            traceElements[i] = this.data[srcIdx];
          }
          resultData[resultIdx] = this.field.addn(...traceElements);
        }
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: resultShape,
          data: resultData
        });
      }
      /**
       * Change the shape of the tensor
       *
       * The data is reused (and shared) between the two tensors.
       */
      reshape(...shape) {
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape,
          data: this.data
        });
      }
      slice(index) {
        if (index < 0) index = this.shape[0] + index + 1;
        if (this.rank === 0) return this;
        if (this.rank === 1) {
          const value = this.data[index - 1];
          return makeTensor(this.ce, {
            dtype: this.dtype,
            shape: [],
            data: [value]
          });
        }
        const size = this.shape[1];
        const stride = this._strides[0];
        const start = index * stride;
        const end = start + stride;
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: this.shape.slice(1),
          data: this.data.slice(start, end)
        });
      }
      flatten() {
        return this.data;
      }
      upcast(dtype) {
        const data = this.field.cast(this.data, dtype);
        if (data === void 0) throw Error(`Cannot cast tensor to ${dtype}`);
        return makeTensor(this.ce, {
          dtype,
          shape: this.shape,
          data
        });
      }
      transpose(axis1, axis2, fn) {
        const rank2 = this.rank;
        if (rank2 === 1) return this;
        axis1 ??= rank2 - 1;
        axis2 ??= rank2;
        if (axis1 === axis2) return this;
        if (axis1 <= 0 || axis1 > rank2) return void 0;
        if (axis2 <= 0 || axis2 > rank2) return void 0;
        const ax1 = axis1 - 1;
        const ax2 = axis2 - 1;
        const newShape = [...this.shape];
        [newShape[ax1], newShape[ax2]] = [newShape[ax2], newShape[ax1]];
        let data = this.data;
        if (fn) data = data.map((x) => fn(x));
        if (rank2 === 2) {
          const [m, n] = this.shape;
          let index = 0;
          const result2 = new Array(m * n);
          for (let i = 0; i < n; i++) {
            for (let j = 0; j < m; j++) result2[index++] = data[j * n + i];
          }
          return makeTensor(this.ce, {
            dtype: this.dtype,
            shape: newShape,
            data: result2
          });
        }
        const totalSize = data.length;
        const result = new Array(totalSize);
        const srcStrides = getStrides(this.shape);
        const dstStrides = getStrides(newShape);
        for (let dstIdx = 0; dstIdx < totalSize; dstIdx++) {
          const dstIndices = new Array(rank2);
          let remaining = dstIdx;
          for (let d = 0; d < rank2; d++) {
            dstIndices[d] = Math.floor(remaining / dstStrides[d]);
            remaining = remaining % dstStrides[d];
          }
          const srcIndices = [...dstIndices];
          [srcIndices[ax1], srcIndices[ax2]] = [srcIndices[ax2], srcIndices[ax1]];
          let srcIdx = 0;
          for (let d = 0; d < rank2; d++) {
            srcIdx += srcIndices[d] * srcStrides[d];
          }
          result[dstIdx] = data[srcIdx];
        }
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: newShape,
          data: result
        });
      }
      // a^H or A^*, or A^\dagger : conjugate transpose, aka Hermitian transpose, aka adjoint
      // https://en.wikipedia.org/wiki/Conjugate_transpose
      // transpose, then apply the complex conjugate to each entry
      // (same as transpose if all entries are real)
      conjugateTranspose(axis1, axis2) {
        const conjugate = this.field.conjugate.bind(this.field);
        return this.transpose(axis1, axis2, conjugate);
      }
      determinant() {
        if (this.rank !== 2) return void 0;
        const [m, n] = this.shape;
        if (m !== n) return void 0;
        if (m === 1) return this.data[0];
        const add5 = this.field.add.bind(this.field);
        const mul5 = this.field.mul.bind(this.field);
        const neg2 = this.field.neg.bind(this.field);
        if (m === 2) {
          const [a, b, c, d] = this.data;
          return add5(mul5(a, d), neg2(mul5(b, c)));
        }
        const addn = this.field.addn.bind(this.field);
        const muln = this.field.muln.bind(this.field);
        if (m === 3) {
          const [a, b, c, d, e, f, g, h, i] = this.data;
          return addn([
            muln(a, e, i),
            muln(b, f, g),
            muln(c, d, h),
            neg2(muln(c, e, g)),
            neg2(muln(b, d, i)),
            neg2(muln(a, f, h))
          ]);
        }
        const rows = this.shape[0];
        let negated = false;
        const div4 = this.field.div.bind(this.field);
        const sub3 = this.field.sub.bind(this.field);
        const rowIndices = new Array(rows).fill(0).map((_, i) => i);
        const matrix = [...this.data];
        for (let k = 0; k < rows; k++) {
          let k_ = rowIndices[k - 1];
          if (this.at(k_, k) === 0) {
            let _k;
            for (_k = k + 1; _k < rows; _k++) {
              if (this.at(rowIndices[_k], k) !== 0) {
                k_ = rowIndices[_k];
                rowIndices[_k - 1] = rowIndices[k - 1];
                rowIndices[k - 1] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows) return this.at(k_, k);
          }
          const piv = this.at(k_, k);
          const piv_ = k === 0 ? 1 : this.at(rowIndices[k - 2], k - 2);
          for (let i = k + 1; i < rows; i++) {
            const i_ = rowIndices[i - 1];
            for (let j = k + 1; j < rows; j++) {
              matrix[i_][j] = div4(
                sub3(mul5(matrix[i_][j], piv), mul5(matrix[i_][k], matrix[k_][j])),
                piv_
              );
            }
          }
        }
        const det = matrix[rowIndices[rows - 1]][rows - 1];
        return negated ? this.field.neg(det) : det;
      }
      inverse() {
        if (this.rank !== 2) return void 0;
        const [m, n] = this.shape;
        if (m !== n) return void 0;
        if (m === 2) {
          const [a, b, c, d] = this.data;
          const det = this.determinant();
          if (det === void 0 || this.field.isZero(det)) return void 0;
          const div5 = this.field.div.bind(this.field);
          const neg2 = this.field.neg.bind(this.field);
          const inverseData2 = [
            div5(d, det),
            neg2(div5(b, det)),
            neg2(div5(c, det)),
            div5(a, det)
          ];
          return makeTensor(this.ce, {
            dtype: this.dtype,
            shape: [n, n],
            data: inverseData2
          });
        }
        const rows = this.shape[0];
        const div4 = this.field.div.bind(this.field);
        const sub3 = this.field.sub.bind(this.field);
        const mul5 = this.field.mul.bind(this.field);
        const matrix = this.array;
        const identity = new Array(rows).fill(0).map((_, i) => {
          const row = new Array(rows).fill(0);
          row[i] = 1;
          return row;
        });
        const augmented = matrix.map((row, i) => [...row, ...identity[i]]);
        const rowIndices = new Array(rows).fill(0).map((_, i) => i);
        for (let k = 0; k < rows; k++) {
          let k_ = rowIndices[k - 1];
          if (this.at(k_, k) === 0) {
            let _k;
            for (_k = k + 1; _k < rows; _k++) {
              if (this.at(rowIndices[_k], k) !== 0) {
                k_ = rowIndices[_k];
                rowIndices[_k - 1] = rowIndices[k - 1];
                rowIndices[k - 1] = k_;
                break;
              }
            }
            if (_k === rows) return void 0;
          }
          const piv = this.at(k_, k);
          const piv_ = k === 0 ? 1 : this.at(rowIndices[k - 2], k - 2);
          for (let i = k + 1; i < rows; i++) {
            const i_ = rowIndices[i - 1];
            for (let j = k + 1; j < rows * 2; j++) {
              augmented[i_][j] = sub3(
                augmented[i_][j],
                mul5(div4(mul5(augmented[i_][k], augmented[k_][j]), piv), piv_)
              );
            }
          }
        }
        for (let k = rows - 1; k >= 0; k--) {
          const piv = augmented[rowIndices[k], k];
          for (let i = 0; i < k; i++) {
            const i_ = rowIndices[i];
            for (let j = rows; j < rows * 2; j++) {
              augmented[i_][j] = sub3(
                augmented[i_][j],
                mul5(div4(mul5(augmented[i_][k], augmented[k][j]), piv), piv)
              );
            }
          }
          for (let j = rows; j < rows * 2; j++) {
            augmented[k][j] = div4(augmented[k][j], piv);
          }
        }
        const inverseData = augmented.map(
          (row) => row.slice(rows)
        );
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: [n, n],
          data: inverseData
        });
      }
      // A^+ is the Moore-Penrose pseudoinverse of A. https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse
      // Pseudoinverse can also be defined for scalars: the pseudoinverse of a scalar is its reciprocal if it is non-zero, and zero otherwise.
      pseudoInverse() {
        return void 0;
      }
      // The adjugate, classical adjoint, or adjunct of a square matrix is the transpose of its cofactor matrix. https://en.wikipedia.org/wiki/Adjugate_matrix
      adjugateMatrix() {
        return void 0;
      }
      // The determinant of the matrix obtained by deleting row i and column j from this matrix. https://en.wikipedia.org/wiki/Minor_(linear_algebra)
      minor(i, j) {
        return void 0;
      }
      map1(fn, scalar) {
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: this.shape,
          data: this.data.map((v) => fn(v, scalar))
        });
      }
      map2(fn, rhs) {
        const rhsData = rhs.data;
        return makeTensor(this.ce, {
          dtype: this.dtype,
          shape: this.shape,
          data: this.data.map((v, i) => fn(v, rhsData[i]))
        });
      }
      add(rhs) {
        return _AbstractTensor.broadcast(this.field.add.bind(this.field), this, rhs);
      }
      subtract(rhs) {
        return _AbstractTensor.broadcast(this.field.sub.bind(this.field), this, rhs);
      }
      // Hadamard product: \odot or \circ
      multiply(rhs) {
        return _AbstractTensor.broadcast(this.field.mul.bind(this.field), this, rhs);
      }
      divide(rhs) {
        return _AbstractTensor.broadcast(this.field.div.bind(this.field), this, rhs);
      }
      power(rhs) {
        return _AbstractTensor.broadcast(this.field.pow.bind(this.field), this, rhs);
      }
      // // aka inner product
      // dot(rhs: AbstractTensor<DT>): undefined | AbstractTensor<DT> {
      //   return undefined;
      // }
      // // aka matmul, \otimes or invisibleoperator
      // // generalization of the outer product
      // tensorProduct(rhs: AbstractTensor<DT>): AbstractTensor<DT>;
      // // generalization of kroneckerProduct
      // outerProduct(rhs: AbstractTensor<DT>): AbstractTensor<DT>;
      // // for 2d
      // kroneckerProduct(rhs: AbstractTensor<DT>): AbstractTensor<DT>;
      // // https://en.wikipedia.org/wiki/Frobenius_inner_product
      // // \langle A, B \rangle_F, Frobenius norm: \lVert A \rVert_F =
      // // \sqrt{\sum_{i,j} |a_{ij}|^2}
      // frobeniusProduct(rhs: AbstractTensor<DT>): DataTypeMap[DT];
      // crossProduct(rhs: AbstractTensor<DT>): AbstractTensor<DT>;
      // innerProduct(rhs: AbstractTensor<DT>): AbstractTensor<DT>;
      equals(rhs) {
        if (this.rank !== rhs.rank) return false;
        if (!this.shape.every((x, i) => x === rhs.shape[i])) return false;
        const eq2 = this.field.equals.bind(this.field);
        const cast = this.field.cast.bind(this.field);
        const dtype = this.dtype;
        if (this.dtype !== rhs.dtype) {
          if (!this.data.every((x, i) => eq2(x, cast(rhs.data[i], dtype))))
            return false;
          return true;
        }
        return this.data.every((x, i) => eq2(x, rhs.data[i]));
      }
    };
    NumberTensor = class extends AbstractTensor {
      dtype = "float64";
      data;
      constructor(ce, data) {
        super(ce, data);
        this.data = data.data;
      }
      get isZero() {
        return this.data.every((x) => x === 0);
      }
    };
    ComplexTensor = class extends AbstractTensor {
      dtype = "complex128";
      data;
      constructor(ce, data) {
        super(ce, data);
        this.data = data.data;
      }
    };
    BooleanTensor = class extends AbstractTensor {
      dtype = "bool";
      data;
      constructor(ce, data) {
        super(ce, data);
        this.data = data.data;
      }
    };
    GenericTensor = class extends AbstractTensor {
      dtype = "expression";
      data;
      constructor(ce, data) {
        super(ce, data);
        this.data = data.data;
      }
    };
  }
});

// src/compute-engine/boxed-expression/boxed-patterns.ts
function isWildcard(expr) {
  return expr.symbol?.startsWith("_") ?? (expr.operator === "Wildcard" || expr.operator === "WildcardSequence" || expr.operator === "WildcardOptionalSequence");
}
function wildcardName(expr) {
  if (expr.symbol?.startsWith("_")) return expr.symbol;
  if (expr.nops === 1) {
    const arg = expr.op1;
    if (expr.operator === "Wildcard") return `_${arg}`;
    if (expr.operator === "WildcardSequence") return `__${arg}`;
    if (expr.operator === "WildcardOptionalSequence") return `___${arg}`;
  }
  if (expr.operator === "Wildcard") return "_";
  if (expr.operator === "WildcardSequence") return "__";
  if (expr.operator === "WildcardOptionalSequence") return "___";
  return null;
}
function wildcardType(expr) {
  if (typeof expr === "string") {
    if (expr.startsWith("_")) {
      if (expr.startsWith("__")) {
        if (expr.startsWith("___")) return "OptionalSequence";
        return "Sequence";
      }
      return "Wildcard";
    }
    return null;
  }
  if (expr.symbol !== null) {
    const symbol2 = expr.symbol;
    if (!symbol2.startsWith("_")) return null;
    if (!symbol2.startsWith("__")) return "Wildcard";
    return symbol2.startsWith("___") ? "OptionalSequence" : "Sequence";
  }
  if (expr.isFunctionExpression) {
    if (expr.operator === "Wildcard") return "Wildcard";
    if (expr.operator === "WildcardSequence") return "Sequence";
    if (expr.operator === "WildcardOptionalSequence") return "OptionalSequence";
  }
  return null;
}
var init_boxed_patterns = __esm({
  "src/compute-engine/boxed-expression/boxed-patterns.ts"() {
  }
});

// src/compute-engine/boxed-expression/boxed-tensor.ts
function isBoxedTensor(val) {
  return val instanceof BoxedTensor;
}
function expressionTensorInfo(operator2, rows) {
  let dtype = void 0;
  const shape = [];
  let valid = true;
  const visit = (t, axis = 0) => {
    if (!valid) return;
    const len = t.length;
    if (len === 0) return;
    if (shape[axis] === void 0) {
      shape[axis] = len;
    } else if (shape[axis] !== len) {
      valid = false;
      return;
    }
    let nestedCount = 0;
    for (const item of t) {
      if (item.operator === operator2) nestedCount++;
    }
    const leafCount = len - nestedCount;
    if (nestedCount > 0 && leafCount > 0) {
      valid = false;
      return;
    }
    if (nestedCount === len) {
      for (const item of t) {
        visit(item.ops, axis + 1);
        if (!valid) return;
      }
    } else {
      for (const item of t) {
        dtype = getSupertype(dtype, getExpressionDatatype(item));
      }
    }
  };
  visit(rows);
  return valid ? { shape, dtype } : void 0;
}
function expressionAsTensor(ce, operator2, rows, shape, dtype) {
  let isValid = true;
  const data = [];
  const f = makeTensorField(ce, "expression");
  const cast = f.cast.bind(f);
  const visit = (t, axis = 0) => {
    if (t.length === 0) return;
    if (shape[axis] === void 0) {
      shape[axis] = t.length;
    } else if (shape[axis] !== t.length) {
      isValid = false;
      return;
    }
    for (const item of t) {
      if (!isValid) return;
      if (item.operator === operator2) visit(item.ops, axis + 1);
      else {
        const v = cast(item, dtype);
        if (v === void 0) {
          isValid = false;
          return;
        }
        data.push(v);
      }
    }
  };
  visit(rows);
  if (!isValid) return void 0;
  return { shape, rank: shape.length, data, dtype };
}
var BoxedTensor;
var init_boxed_tensor = __esm({
  "src/compute-engine/boxed-expression/boxed-tensor.ts"() {
    init_boxed_type();
    init_tensor_fields();
    init_tensors();
    init_abstract_boxed_expression();
    init_boxed_patterns();
    init_utils5();
    BoxedTensor = class _BoxedTensor extends _BoxedExpression {
      constructor(ce, input, options) {
        super(ce, options?.metadata);
        this.input = input;
        this.options = options;
        const tensorData = expressionAsTensor(
          ce,
          "List",
          input.ops,
          input.shape,
          input.dtype
        );
        if (!tensorData) throw new Error("Invalid tensor");
        this._tensor = makeTensor(ce, tensorData);
      }
      _tensor;
      _expression;
      get structural() {
        this._expression ??= this._tensor.expression;
        return this._expression;
      }
      /** Create the tensor on demand */
      get tensor() {
        return this._tensor;
      }
      get baseDefinition() {
        return this.structural.baseDefinition;
      }
      get operatorDefinition() {
        return this.structural.operatorDefinition;
      }
      get hash() {
        const h = hashCode("BoxedTensor");
        return h;
      }
      get canonical() {
        return this;
      }
      get isCanonical() {
        if (this._tensor) return true;
        return this._expression.isCanonical;
      }
      // set isCanonical(val: boolean) {
      //   if (!this._tensor) this.structural.isCanonical = val;
      // }
      get isPure() {
        if (this._tensor) return true;
        return this.structural.isPure;
      }
      get isValid() {
        if (this._tensor) return true;
        return this.structural.isValid;
      }
      get complexity() {
        return 97;
      }
      get operator() {
        return "List";
      }
      get nops() {
        if (this._tensor) return this._tensor.shape[0];
        return this.structural.nops;
      }
      get ops() {
        return this.structural.ops;
      }
      get op1() {
        if (this._tensor) {
          const data = this._tensor.data;
          if (data.length === 0) return this.engine.Nothing;
          return this.engine.box(data[0]);
        }
        return this.structural.op1;
      }
      get op2() {
        if (this._tensor) {
          const data = this._tensor.data;
          if (data.length < 2) return this.engine.Nothing;
          return this.engine.box(data[1]);
        }
        return this.structural.op2;
      }
      get op3() {
        if (this._tensor) {
          const data = this._tensor.data;
          if (data.length < 3) return this.engine.Nothing;
          return this.engine.box(data[2]);
        }
        return this.structural.op3;
      }
      //
      //
      // ALGEBRAIC OPERATIONS
      //
      neg() {
        return this.structural.neg();
      }
      inv() {
        return this.engine.One.div(this.structural);
      }
      abs() {
        return this.structural.abs();
      }
      add(rhs) {
        return this.structural.add(rhs);
      }
      sub(rhs) {
        return this.structural.sub(rhs);
      }
      mul(rhs) {
        return this.structural.mul(rhs);
      }
      div(rhs) {
        return this.structural.div(rhs);
      }
      pow(exp3) {
        return this.structural.pow(exp3);
      }
      root(exp3) {
        return this.structural.root(exp3);
      }
      sqrt() {
        return this.structural.sqrt();
      }
      get shape() {
        return this.tensor.shape;
      }
      get rank() {
        try {
          return this.tensor.rank;
        } catch (e) {
        }
        return 0;
      }
      get type() {
        if (!this.isValid) return new BoxedType("error");
        const shape = this.shape;
        if (shape.length === 0) {
          return new BoxedType("number");
        }
        const dims = shape.join("x");
        return new BoxedType(`list<number^${dims}>`);
      }
      get json() {
        return this.structural.json;
      }
      /** Mathematical equality */
      isEqual(rhs) {
        if (this === rhs) return true;
        if (rhs instanceof _BoxedTensor) return this.tensor.equals(rhs.tensor);
        return this.structural.isEqual(rhs);
      }
      get isCollection() {
        return true;
      }
      get isIndexedCollection() {
        return true;
      }
      contains(other) {
        if (["float64", "float32", "int32", "uint8"].includes(this.tensor.dtype)) {
          const data = this.tensor.data;
          return data.includes(other.re);
        }
        return this.tensor.data.some(
          (x) => other.isSame(
            this.tensor.field.cast(x, "expression") ?? other.engine.Nothing
          )
        );
      }
      get count() {
        return this.tensor.shape.reduce((a, b) => a * b, 1);
      }
      each() {
        const shape = this.tensor.shape;
        const rank2 = this.tensor.rank;
        if (rank2 === 0) {
          return (function* (self) {
            yield self;
          })(this);
        }
        const count = shape[0];
        if (rank2 === 1) {
          return (function* (self) {
            for (let i = 1; i <= count; i += 1) {
              const data = self.tensor.data;
              const idx = i - 1;
              if (idx >= 0 && idx < data.length) {
                yield self.engine.box(data[idx]);
              }
            }
          })(this);
        }
        return (function* (self) {
          for (let i = 1; i <= count; i += 1) {
            const row = self.tensor.slice(i - 1);
            yield new _BoxedTensor(self.engine, {
              ops: row.expression.ops,
              shape: row.shape,
              dtype: row.dtype
            });
          }
        })(this);
      }
      at(index) {
        const row = this.tensor.slice(index);
        if (row.rank === 0) {
          return this.engine.box(row.data[0]);
        } else if (row.rank === 1) {
          return this.engine.box(row.data[0]);
        } else if (row.rank > 1) {
          return new _BoxedTensor(this.engine, {
            ops: row.expression.ops,
            shape: row.shape,
            dtype: row.dtype
          });
        }
        return void 0;
      }
      match(pattern, options) {
        if (!isBoxedExpression(pattern))
          pattern = this.engine.box(pattern, { canonical: false });
        if (isWildcard(pattern)) return { [wildcardName(pattern)]: this };
        return this.structural.match(pattern, options);
      }
      evaluate(options) {
        if (this._tensor && this._tensor.dtype !== "expression") return this;
        return this.structural.evaluate(options);
      }
      simplify(options) {
        if (this._tensor && this._tensor.dtype !== "expression") return this;
        return this.structural.simplify(options);
      }
      N() {
        if (this._tensor && this._tensor.dtype !== "expression") return this;
        return this.structural.N();
      }
      solve(vars) {
        return this.structural.solve(vars);
      }
    };
  }
});

// src/compute-engine/boxed-expression/arithmetic-add.ts
function canonicalAdd(ce, ops) {
  ops = flatten(ops, "Add");
  ops = ops.filter((x) => x.numericValue === null || !x.is(0));
  if (ops.length === 0) return ce.Zero;
  if (ops.length === 1 && !ops[0].isIndexedCollection) return ops[0];
  const xs = [];
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.isNumberLiteral) {
      const nv = op.numericValue;
      if (typeof nv === "number" || isSubtype(nv.type, "real") && !nv.isExact || isSubtype(nv.type, "integer")) {
        const next = ops[i + 1];
        if (next) {
          const fac = getImaginaryFactor(next)?.numericValue;
          if (fac !== void 0) {
            const im = typeof fac === "number" ? fac : fac?.re;
            if (im !== 0) {
              const re = typeof nv === "number" ? nv : nv.re;
              xs.push(ce.number(ce._numericValue({ re, im: im ?? 0 })));
              i++;
              continue;
            }
          }
        }
      }
    }
    xs.push(op);
  }
  if (xs.length === 1) return xs[0];
  return ce._fn("Add", [...xs].sort(addOrder));
}
function addType(args) {
  if (args.length === 0) return "finite_integer";
  if (args.length === 1) return args[0].type;
  return widen(...args.map((x) => x.type.type));
}
function add3(...xs) {
  console.assert(xs.length > 0);
  if (!xs.every((x) => x.isValid)) return xs[0].engine._fn("Add", xs);
  const hasTensors = xs.some((x) => isBoxedTensor(x));
  if (hasTensors) return addTensors(xs[0].engine, xs);
  return new Terms(xs[0].engine, xs).asExpression();
}
function addN(...xs) {
  console.assert(xs.length > 0);
  if (!xs.every((x) => x.isValid)) return xs[0].engine._fn("Add", xs);
  const hasTensors = xs.some((x) => isBoxedTensor(x));
  if (hasTensors) {
    xs = xs.map((x) => isBoxedTensor(x) ? x.evaluate() : x.N());
    return addTensors(xs[0].engine, xs);
  }
  xs = xs.map((x) => x.isNumberLiteral ? x.evaluate() : x.N());
  return new Terms(xs[0].engine, xs).N();
}
function addTensors(ce, ops) {
  const tensors = [];
  const scalars = [];
  for (const op of ops) {
    const evaluated = op.evaluate();
    if (isBoxedTensor(evaluated)) {
      tensors.push(evaluated);
    } else {
      scalars.push(evaluated);
    }
  }
  if (tensors.length === 0) {
    return new Terms(ce, scalars).asExpression();
  }
  const referenceShape = tensors[0].shape;
  for (let i = 1; i < tensors.length; i++) {
    const shape = tensors[i].shape;
    if (shape.length !== referenceShape.length || !shape.every((dim, j) => dim === referenceShape[j])) {
      return ce.error(
        "incompatible-dimensions",
        `${referenceShape.join("x")} vs ${shape.join("x")}`
      );
    }
  }
  let scalarSum = ce.Zero;
  for (const s of scalars) {
    scalarSum = scalarSum.add(s);
  }
  if (referenceShape.length === 1) {
    const n = referenceShape[0];
    const result = [];
    for (let i = 0; i < n; i++) {
      let sum2 = scalarSum;
      for (const tensor of tensors) {
        const val = tensor.tensor.at(i + 1) ?? ce.Zero;
        sum2 = sum2.add(ce.box(val));
      }
      result.push(sum2.evaluate());
    }
    return ce.box(["List", ...result]);
  }
  if (referenceShape.length === 2) {
    const [m, n] = referenceShape;
    const rows = [];
    for (let i = 0; i < m; i++) {
      const row = [];
      for (let j = 0; j < n; j++) {
        let sum2 = scalarSum;
        for (const tensor of tensors) {
          const val = tensor.tensor.at(i + 1, j + 1) ?? ce.Zero;
          sum2 = sum2.add(ce.box(val));
        }
        row.push(sum2.evaluate());
      }
      rows.push(ce.box(["List", ...row]));
    }
    return ce.box(["List", ...rows]);
  }
  return ce._fn("Add", [...ops]);
}
var init_arithmetic_add = __esm({
  "src/compute-engine/boxed-expression/arithmetic-add.ts"() {
    init_utils5();
    init_flatten();
    init_order();
    init_terms();
    init_utils();
    init_subtype();
    init_boxed_tensor();
  }
});

// src/compute-engine/boxed-expression/polynomials.ts
function totalDegree(expr) {
  if (expr.symbol && !expr.isConstant) return 1;
  if (expr.operator === "Power" && expr.op2.isNumberLiteral) {
    if (totalDegree(expr.op1) === 0) return 0;
    const deg = asSmallInteger(expr.op2);
    if (deg !== null && deg > 0) return deg;
    return 0;
  }
  if (expr.operator === "Multiply") {
    let deg = 0;
    for (const arg of expr.ops) {
      const t = totalDegree(arg);
      deg = deg + t;
    }
    return deg;
  }
  if (expr.operator === "Add" || expr.operator === "Subtract") {
    let deg = 0;
    for (const arg of expr.ops) deg = Math.max(deg, totalDegree(arg));
    return deg;
  }
  if (expr.operator === "Negate") return totalDegree(expr.op1);
  if (expr.operator === "Divide") return totalDegree(expr.op1);
  return 0;
}
function maxDegree(expr) {
  if (expr.symbol && !expr.isConstant) return 1;
  if (expr.operator === "Power" && expr.op2.isNumberLiteral) {
    if (maxDegree(expr.op1) === 0) return 0;
    const deg = asSmallInteger(expr.op2);
    if (deg !== null && deg > 0) return deg;
    return 0;
  }
  if (expr.operator === "Multiply" || expr.operator === "Add" || expr.operator === "Subtract") {
    let deg = 0;
    for (const arg of expr.ops) deg = Math.max(deg, totalDegree(arg));
    return deg;
  }
  if (expr.operator === "Negate") return maxDegree(expr.op1);
  if (expr.operator === "Divide") return maxDegree(expr.op1);
  return 0;
}
function lex(expr) {
  if (expr.symbol && !expr.isConstant) return expr.symbol;
  if (!expr.ops) return "";
  return expr.ops.map((x) => lex(x)).join(" ").trim();
}
function revlex(expr) {
  return lex(expr).split(" ").reverse().join(" ").trim();
}
function polynomialDegree(expr, variable) {
  if (expr.isNumberLiteral) return 0;
  if (expr.symbol) {
    if (expr.symbol === variable) return 1;
    return 0;
  }
  const op = expr.operator;
  if (op === "Negate") return polynomialDegree(expr.op1, variable);
  if (op === "Add" || op === "Subtract") {
    let maxDeg = 0;
    for (const arg of expr.ops) {
      const deg = polynomialDegree(arg, variable);
      if (deg < 0) return -1;
      maxDeg = Math.max(maxDeg, deg);
    }
    return maxDeg;
  }
  if (op === "Multiply") {
    let totalDeg = 0;
    for (const arg of expr.ops) {
      const deg = polynomialDegree(arg, variable);
      if (deg < 0) return -1;
      totalDeg += deg;
    }
    return totalDeg;
  }
  if (op === "Power") {
    const baseDeg = polynomialDegree(expr.op1, variable);
    if (baseDeg < 0) return -1;
    if (baseDeg === 0) {
      if (expr.op2.has(variable)) return -1;
      return 0;
    }
    const exp3 = asSmallInteger(expr.op2);
    if (exp3 === null || exp3 < 0) return -1;
    return baseDeg * exp3;
  }
  if (expr.has(variable)) return -1;
  return 0;
}
function getPolynomialCoefficients(expr, variable) {
  const ce = expr.engine;
  const degree = polynomialDegree(expr, variable);
  if (degree < 0) return null;
  const coeffs = new Array(degree + 1).fill(ce.Zero);
  const expanded = expr.expand();
  const addCoefficient = (coef, deg) => {
    if (deg > degree) return false;
    coeffs[deg] = coeffs[deg].add(coef);
    return true;
  };
  const processTerm = (term) => {
    const termDeg = polynomialDegree(term, variable);
    if (termDeg < 0) return false;
    if (termDeg === 0) {
      return addCoefficient(term, 0);
    }
    if (term.symbol === variable) {
      return addCoefficient(ce.One, 1);
    }
    if (term.operator === "Negate") {
      const innerDeg = polynomialDegree(term.op1, variable);
      if (innerDeg === 0) {
        return addCoefficient(term, 0);
      }
      const innerCoeffs = getPolynomialCoefficients(term.op1, variable);
      if (!innerCoeffs) return false;
      for (let i = 0; i < innerCoeffs.length; i++) {
        if (!innerCoeffs[i].is(0)) {
          addCoefficient(innerCoeffs[i].neg(), i);
        }
      }
      return true;
    }
    if (term.operator === "Power") {
      if (term.op1.symbol === variable) {
        const exp3 = asSmallInteger(term.op2);
        if (exp3 !== null && exp3 >= 0) {
          return addCoefficient(ce.One, exp3);
        }
      }
      if (!term.op1.has(variable)) {
        return addCoefficient(term, 0);
      }
      return false;
    }
    if (term.operator === "Multiply") {
      const factors = term.ops;
      let coef = ce.One;
      let varDeg = 0;
      for (const factor3 of factors) {
        if (!factor3.has(variable)) {
          coef = coef.mul(factor3);
        } else if (factor3.symbol === variable) {
          varDeg += 1;
        } else if (factor3.operator === "Power" && factor3.op1.symbol === variable) {
          const exp3 = asSmallInteger(factor3.op2);
          if (exp3 !== null && exp3 >= 0) {
            varDeg += exp3;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      return addCoefficient(coef, varDeg);
    }
    return false;
  };
  if (expanded.operator === "Add") {
    for (const term of expanded.ops) {
      if (!processTerm(term)) return null;
    }
  } else {
    if (!processTerm(expanded)) return null;
  }
  return coeffs;
}
function fromCoefficients(coeffs, variable) {
  if (coeffs.length === 0) return coeffs[0]?.engine.Zero ?? null;
  const ce = coeffs[0].engine;
  const x = ce.symbol(variable);
  const terms = [];
  for (let i = 0; i < coeffs.length; i++) {
    const coef = coeffs[i];
    if (coef.is(0)) continue;
    if (i === 0) {
      terms.push(coef);
    } else if (i === 1) {
      if (coef.is(1)) {
        terms.push(x);
      } else if (coef.is(-1)) {
        terms.push(x.neg());
      } else {
        terms.push(coef.mul(x));
      }
    } else {
      const xPow = ce.box(["Power", variable, i]);
      if (coef.is(1)) {
        terms.push(xPow);
      } else if (coef.is(-1)) {
        terms.push(xPow.neg());
      } else {
        terms.push(coef.mul(xPow));
      }
    }
  }
  if (terms.length === 0) return ce.Zero;
  if (terms.length === 1) return terms[0];
  return add3(...terms);
}
function polynomialDivide(dividend, divisor, variable) {
  const ce = dividend.engine;
  const dividendCoeffs = getPolynomialCoefficients(dividend, variable);
  const divisorCoeffs = getPolynomialCoefficients(divisor, variable);
  if (!dividendCoeffs || !divisorCoeffs) return null;
  if (divisorCoeffs.every((c) => c.is(0))) return null;
  const actualDegree = (coeffs) => {
    for (let i = coeffs.length - 1; i >= 0; i--) {
      if (!coeffs[i].is(0)) return i;
    }
    return -1;
  };
  const dividendDeg = actualDegree(dividendCoeffs);
  const divisorDeg = actualDegree(divisorCoeffs);
  if (divisorDeg < 0) return null;
  if (dividendDeg < 0) {
    return [ce.Zero, ce.Zero];
  }
  if (dividendDeg < divisorDeg) {
    return [ce.Zero, dividend];
  }
  const remainder = dividendCoeffs.map((c) => c);
  const quotientCoeffs = new Array(
    dividendDeg - divisorDeg + 1
  ).fill(ce.Zero);
  const leadingDivisor = divisorCoeffs[divisorDeg];
  for (let i = dividendDeg; i >= divisorDeg; i--) {
    if (remainder[i].is(0)) continue;
    const quotientCoef = remainder[i].div(leadingDivisor);
    quotientCoeffs[i - divisorDeg] = quotientCoef;
    for (let j = 0; j <= divisorDeg; j++) {
      const product = quotientCoef.mul(divisorCoeffs[j]);
      remainder[i - divisorDeg + j] = remainder[i - divisorDeg + j].sub(product);
    }
  }
  const quotient = fromCoefficients(quotientCoeffs, variable);
  const remainderPoly = fromCoefficients(remainder, variable);
  return [quotient, remainderPoly];
}
function polynomialGCD(a, b, variable) {
  const ce = a.engine;
  const degA = polynomialDegree(a, variable);
  const degB = polynomialDegree(b, variable);
  if (degA < 0 || degB < 0) return ce.One;
  const aCoeffs = getPolynomialCoefficients(a, variable);
  const bCoeffs = getPolynomialCoefficients(b, variable);
  if (!aCoeffs || aCoeffs.every((c) => c.is(0))) {
    return makeMonic(b, variable);
  }
  if (!bCoeffs || bCoeffs.every((c) => c.is(0))) {
    return makeMonic(a, variable);
  }
  let p = a;
  let q = b;
  while (true) {
    const qCoeffs = getPolynomialCoefficients(q, variable);
    if (!qCoeffs || qCoeffs.every((c) => c.is(0))) {
      break;
    }
    const divResult = polynomialDivide(p, q, variable);
    if (!divResult) {
      return ce.One;
    }
    const [, remainder] = divResult;
    p = q;
    q = remainder;
  }
  return makeMonic(p, variable);
}
function makeMonic(poly, variable) {
  const ce = poly.engine;
  const coeffs = getPolynomialCoefficients(poly, variable);
  if (!coeffs) return poly;
  let leadingCoef = null;
  for (let i = coeffs.length - 1; i >= 0; i--) {
    if (!coeffs[i].is(0)) {
      leadingCoef = coeffs[i];
      break;
    }
  }
  if (!leadingCoef || leadingCoef.is(1)) return poly;
  const monicCoeffs = coeffs.map((c) => c.div(leadingCoef));
  return fromCoefficients(monicCoeffs, variable);
}
function cancelCommonFactors(expr, variable) {
  const ce = expr.engine;
  if (expr.operator !== "Divide") return expr;
  const numerator = expr.op1;
  const denominator = expr.op2;
  const numDeg = polynomialDegree(numerator, variable);
  const denDeg = polynomialDegree(denominator, variable);
  if (numDeg < 0 || denDeg < 0) return expr;
  const gcd5 = polynomialGCD(numerator, denominator, variable);
  const gcdDeg = polynomialDegree(gcd5, variable);
  if (gcdDeg <= 0) return expr;
  const numDivResult = polynomialDivide(numerator, gcd5, variable);
  const denDivResult = polynomialDivide(denominator, gcd5, variable);
  if (!numDivResult || !denDivResult) return expr;
  const [newNumerator] = numDivResult;
  const [newDenominator] = denDivResult;
  const denCoeffs = getPolynomialCoefficients(newDenominator, variable);
  if (denCoeffs && denCoeffs.length === 1 && denCoeffs[0].is(1)) {
    return newNumerator;
  }
  return newNumerator.div(newDenominator);
}
var init_polynomials = __esm({
  "src/compute-engine/boxed-expression/polynomials.ts"() {
    init_numerics();
    init_arithmetic_add();
  }
});

// src/compute-engine/boxed-expression/apply.ts
function apply(expr, fn, bigFn, complexFn) {
  if ((expr?.numericValue ?? null) === null) return void 0;
  const ce = expr.engine;
  let result = void 0;
  if (expr.im !== 0) result = complexFn?.(ce.complex(expr.re, expr.im));
  else {
    const bigRe = expr.bignumRe;
    if (bigRe !== void 0 && bignumPreferred(ce) && bigFn)
      result = bigFn(bigRe);
    else {
      const re = expr.re;
      if (bignumPreferred(ce) && bigFn) result = bigFn(ce.bignum(re));
      else result = fn(re);
    }
  }
  if (result === void 0) return void 0;
  if (result instanceof Complex)
    return ce.number(ce._numericValue({ re: result.re, im: result.im }));
  return ce.number(result);
}
function apply2(expr1, expr2, fn, bigFn, complexFn) {
  if (expr1.numericValue === null || expr2.numericValue === null)
    return void 0;
  const ce = expr1.engine;
  let result = void 0;
  if (expr1.im !== 0 || expr2.im !== 0) {
    result = complexFn?.(
      ce.complex(expr1.re, expr1.im),
      ce.complex(expr2.re, expr2.im)
    );
  }
  if (result === void 0 && bigFn) {
    let bigRe1 = expr1.bignumRe;
    let bigRe2 = expr2.bignumRe;
    if (bigRe1 !== void 0 || bigRe2 !== void 0) {
      bigRe1 ??= ce.bignum(expr1.re);
      bigRe2 ??= ce.bignum(expr2.re);
      result = bigFn(bigRe1, bigRe2);
    }
  }
  if (result === void 0) {
    const re1 = expr1.re;
    const re2 = expr2.re;
    if (!isNaN(re1) && !isNaN(re2)) {
      if (bignumPreferred(ce) && bigFn)
        result = bigFn(
          ce.bignum(expr1.bignumRe ?? re1),
          ce.bignum(expr2.bignumRe ?? re2)
        );
      else result = fn(re1, re2);
    }
  }
  if (result === void 0) return void 0;
  if (result instanceof Complex)
    return ce.number(
      ce._numericValue({ re: ce.chop(result.re), im: ce.chop(result.im) })
    );
  return ce.number(ce.chop(result));
}
var init_apply = __esm({
  "src/compute-engine/boxed-expression/apply.ts"() {
    init_complex();
    init_utils5();
  }
});

// src/compute-engine/boxed-expression/arithmetic-power.ts
function isSqrt(expr) {
  return expr.operator === "Sqrt" || expr.operator === "Power" && expr.op2.im === 0 && expr.op2.re === 0.5 || expr.operator === "Root" && expr.op2.im === 0 && expr.op2.re === 2;
}
function asRadical(expr) {
  if (isSqrt(expr)) return asRational(expr.op1) ?? null;
  if (expr.operator === "Divide" && expr.op1.is(1) && isSqrt(expr.op2)) {
    const n = expr.op2.re;
    if (!Number.isInteger(n)) return null;
    return [1, n];
  }
  return null;
}
function canonicalPower(a, b) {
  const ce = a.engine;
  const fullyCanonical = (a.isCanonical || a.isStructural) && (b.isCanonical || b.isStructural);
  const unchanged = () => ce._fn("Power", [a, b], { canonical: fullyCanonical });
  if (a.operator === "Power") {
    const [base, aPow] = a.ops;
    return ce._fn("Power", [
      base,
      ce.box(["Multiply", aPow, b], {
        canonical: fullyCanonical || "Power"
      })
    ]);
  }
  if (a.operator === "Divide" && a.op1 && a.op2 && b.isNegative === true) {
    const num = a.op1;
    const denom = a.op2;
    return pow2(num, b, { numericApproximation: false }).div(
      pow2(denom, b, { numericApproximation: false })
    );
  }
  if (b.isFunctionExpression || b.symbol !== null || !b.type.matches("number"))
    return unchanged();
  if (a.isNumberLiteral && a.is(0)) {
    if (b.type.matches("imaginary") || b.isNaN)
      return ce.NaN;
    if (b.is(0)) return ce.NaN;
    if (b.isInfinity) {
      if (b.isPositive) return ce.Zero;
      if (b.isNegative) return ce.ComplexInfinity;
      return ce.NaN;
    }
    if (b.isGreater(0)) return ce.Zero;
    if (b.isLess(0)) return ce.ComplexInfinity;
    return unchanged();
  }
  const aIsNum = a.type.matches("number") && (a.isFunctionExpression === false || a.operator === "Negate");
  if (b.is(0)) {
    if (aIsNum && a.isFinite !== void 0) return a.isFinite ? ce.One : ce.NaN;
    return unchanged();
  }
  if (aIsNum && a.is(1)) return b.isFinite ? ce.One : ce.NaN;
  if (b.is(1) && a.type.matches("number")) return a;
  if (b.is(-1)) {
    if (aIsNum) {
      if (a.isInfinity && (a.isNegative || a.isPositive)) return ce.Zero;
      if (a.is(-1)) return ce.NegativeOne;
      if (a.is(1)) return ce.One;
    }
    if (!(a.isCanonical || a.isStructural))
      return ce._fn("Power", [a, ce.number(-1)], { canonical: false });
    return a.inv();
  }
  if (b.isInfinity && aIsNum) {
    if (b.isPositive) {
      if (a.symbol === "ExponentialE") return ce.PositiveInfinity;
      if (a.is(-1)) return ce.NaN;
      if (a.isInfinity) return ce.ComplexInfinity;
      if (a.isNaN) return ce.NaN;
      if (a.isReal) {
        if (a.isGreater(1)) return ce.PositiveInfinity;
        if (a.isLess(-1)) return ce.ComplexInfinity;
        return ce.Zero;
      }
      return unchanged();
    }
    if (b.isNegative) {
      if (a.symbol === "ExponentialE") return ce.Zero;
      if (a.is(-1)) return ce.NaN;
      if (a.isInfinity) return ce.Zero;
      if (a.isNaN) return ce.NaN;
      if (a.isReal) {
        if (a.isGreater(0)) return a.isLess(1) ? ce.PositiveInfinity : ce.Zero;
        return a.isGreater(-1) ? ce.ComplexInfinity : ce.Zero;
      }
      return unchanged();
    }
    return ce.NaN;
  }
  if (a.isNumberLiteral && a.isInfinity) {
    if (a.isNegative) {
      if (b.isInteger === true) {
        if (b.isEven === true) return ce.PositiveInfinity;
        if (b.isOdd === true) return ce.NegativeInfinity;
      }
      if (b.isRational === true) {
        const [numExpr, denomExpr] = b.numeratorDenominator;
        const num = numExpr.re;
        const denom = denomExpr.re;
        if (typeof num === "number" && typeof denom === "number" && Number.isInteger(num) && Number.isInteger(denom)) {
          const numIsEven = num % 2 === 0;
          const numIsOdd = num % 2 !== 0;
          const denomIsOdd = denom % 2 !== 0;
          if (numIsEven && denomIsOdd) return ce.PositiveInfinity;
          if (numIsOdd && denomIsOdd) return ce.NegativeInfinity;
        }
      }
    }
    if (b.type.matches("imaginary")) return ce.NaN;
    if (b.type.matches("complex") && !isNaN(b.re)) {
      if (b.re > 0) return ce.ComplexInfinity;
      if (b.re < 0) return ce.Zero;
    }
  }
  if (b.is(0.5))
    return a.isCanonical || a.isStructural ? canonicalRoot(a, 2) : ce._fn("Sqrt", [a], { canonical: false });
  const r = asRational(b);
  if (r !== void 0 && r[0] === 1 && r[1] !== 1)
    return a.isCanonical || a.isStructural ? canonicalRoot(a, ce.number(r[1])) : ce._fn("Root", [a, ce.number(r[1])], { canonical: false });
  return unchanged();
}
function canonicalRoot(a, b) {
  const ce = a.engine;
  let exp3 = void 0;
  if (typeof b === "number") exp3 = b;
  else {
    if (b.isNumberLiteral && b.im === 0) exp3 = b.re;
  }
  if (exp3 === 1) return a;
  if (exp3 === 2) {
    if (a.isNumberLiteral && a.type.matches("rational")) {
      if (a.re < SMALL_INTEGER) {
        const v = a.sqrt();
        if (typeof v.numericValue === "number") return v;
        if (v.numericValue.isExact) return v;
      }
    }
    return ce._fn("Sqrt", [a], { canonical: a.isCanonical || a.isStructural });
  }
  return ce._fn("Root", [a, typeof b === "number" ? ce.number(b) : b], {
    canonical: (a.isCanonical || a.isStructural) && (typeof b === "number" || b.isCanonical || b.isStructural)
  });
}
function pow2(x, exp3, { numericApproximation }) {
  if (!(x.isCanonical || x.isStructural) || typeof exp3 !== "number" && !(exp3.isCanonical || exp3.isStructural))
    return x.engine._fn("Power", [x, x.engine.box(exp3)], { canonical: false });
  if (numericApproximation) {
    if (x.isNumberLiteral) {
      if (typeof exp3 === "number") {
        return apply(
          x,
          (x2) => Math.pow(x2, exp3),
          (x2) => x2.pow(exp3),
          (x2) => x2.pow(exp3)
        ) ?? pow2(x, exp3, { numericApproximation: false });
      } else if (exp3.isNumberLiteral)
        return apply2(
          x,
          exp3,
          (x2, exp4) => Math.pow(x2, exp4),
          (x2, exp4) => x2.pow(exp4),
          (x2, exp4) => x2.pow(exp4)
        ) ?? pow2(x, exp3, { numericApproximation: false });
    }
  }
  const ce = x.engine;
  if (typeof exp3 !== "number") exp3 = exp3.canonical;
  const canonicalResult = canonicalPower(x, ce.box(exp3));
  if (canonicalResult.operator !== "Power") return canonicalResult;
  const e = typeof exp3 === "number" ? exp3 : exp3.im === 0 ? exp3.re : void 0;
  if (x.symbol === "ComplexInfinity") return ce.NaN;
  if (x.symbol === "ExponentialE") {
    let theta = getImaginaryFactor(exp3);
    if (theta !== void 0) {
      theta = canonicalAngle(theta);
      if (theta !== void 0) {
        return ce.function("Cos", [theta]).add(ce.function("Sin", [theta]).mul(ce.I)).simplify();
      }
    } else {
      if (typeof exp3 === "number") {
        return ce.number(ce._numericValue(ce.E.N().numericValue).pow(exp3));
      } else if (exp3.isNumberLiteral) {
        return ce.number(
          ce._numericValue(ce.E.N().numericValue).pow(exp3.numericValue)
        );
      }
    }
  }
  if (x.operator === "Power") {
    const [base, power] = x.ops;
    return pow2(base, power.mul(exp3), { numericApproximation });
  }
  if (x.operator === "Divide") {
    const [num, denom] = x.ops;
    return pow2(num, exp3, { numericApproximation }).div(
      pow2(denom, exp3, { numericApproximation })
    );
  }
  if (x.operator === "Negate") {
    if (e !== void 0) {
      if (e % 2 === 0) return pow2(x.op1, exp3, { numericApproximation });
      return pow2(x.op1, exp3, { numericApproximation }).neg();
    }
  }
  if (x.operator === "Sqrt") {
    if (e === 2) return x.op1;
    if (e !== void 0 && e % 2 === 0) return x.op1.pow(e / 2);
    return pow2(x.op1, exp3, { numericApproximation }).sqrt();
  }
  if (x.operator === "Exp")
    return pow2(ce.E, x.op1.mul(exp3), { numericApproximation });
  if (x.operator === "Multiply") {
    const ops = x.ops.map((x2) => pow2(x2, exp3, { numericApproximation }));
    return ce._fn("Multiply", ops);
  }
  if (typeof exp3 !== "number" && exp3.isNumberLiteral) {
    const r = asRational(exp3);
    if (r !== void 0 && r[0] === 1)
      return root(x, ce.number(r[1]), { numericApproximation });
  }
  if (x.operator === "Root") {
    const [base, root2] = x.ops;
    return pow2(base, ce.box(exp3).div(root2), { numericApproximation });
  }
  if (x.isNumberLiteral && Number.isInteger(e)) {
    const n = x.numericValue;
    if (typeof n === "number") {
      return apply(
        x,
        (x2) => Math.pow(x2, e),
        (x2) => x2.pow(e),
        (x2) => x2.pow(e)
      ) ?? ce._fn("Power", [x, ce.box(exp3)]);
    } else {
      return ce.number(n.pow(e));
    }
  }
  return ce._fn("Power", [x, ce.box(exp3)]);
}
function root(a, b, { numericApproximation }) {
  if (!(a.isCanonical || a.isStructural) || !(b.isCanonical || b.isStructural))
    return a.engine._fn("Root", [a, b], { canonical: false });
  if (numericApproximation) {
    if (a.isNumberLiteral && b.isNumberLiteral) {
      const isNegative2 = a.isNegative;
      const isEven = b.isEven;
      if (isNegative2) a = a.neg();
      return apply2(
        a,
        b,
        (a2, b2) => {
          const result = Math.pow(a2, 1 / b2);
          if (isNegative2 && !isEven) return -result;
          return result;
        },
        (a2, b2) => {
          const result = a2.pow(b2.pow(-1));
          if (isNegative2 && !isEven) return result.neg();
          return result;
        },
        (a2, b2) => {
          const result = a2.pow(typeof b2 === "number" ? 1 / b2 : b2.inverse());
          if (isNegative2 && !isEven) return result.neg();
          return result;
        }
      ) ?? root(a, b, { numericApproximation: false });
    }
  }
  if (a.isNumberLiteral && b.isNumberLiteral && b.isInteger) {
    const e = typeof b === "number" ? b : b.im === 0 ? b.re : void 0;
    if (e !== void 0) {
      if (typeof a.numericValue === "number") {
        const v = a.engine._numericValue(a.numericValue)?.root(e);
        if (v?.isExact) return a.engine.number(v);
      } else {
        const v = a.numericValue.asExact?.root(e);
        if (v?.isExact) return a.engine.number(v);
      }
    }
  }
  return a.engine._fn("Root", [a, b]);
}
var init_arithmetic_power = __esm({
  "src/compute-engine/boxed-expression/arithmetic-power.ts"() {
    init_numeric();
    init_numerics();
    init_utils5();
    init_apply();
  }
});

// src/compute-engine/boxed-expression/order.ts
function isTrigonometricFunction(operator2) {
  if (!operator2 || typeof operator2 !== "string") return false;
  return operator2 in TRIGONOMETRIC_OPERATORS;
}
function addOrder(a, b) {
  const aTotalDeg = totalDegree(a);
  const bTotalDeg = totalDegree(b);
  if (aTotalDeg !== bTotalDeg) return bTotalDeg - aTotalDeg;
  const aMaxDeg = maxDegree(a);
  const bMaxDeg = maxDegree(b);
  if (aMaxDeg !== bMaxDeg) return bMaxDeg - aMaxDeg;
  const aLex = revlex(a);
  const bLex = revlex(b);
  if (aLex || bLex) {
    if (!aLex) return 1;
    if (!bLex) return -1;
    if (aLex < bLex) return -1;
    if (aLex > bLex) return 1;
  }
  return order(a, b);
}
function rank(expr) {
  if (typeof expr.numericValue === "number") {
    return Number.isInteger(expr.numericValue) ? "integer" : "real";
  }
  if (expr.numericValue) {
    const type2 = expr.numericValue.type;
    if (type2 === "integer" || type2 === "finite_integer") return "integer";
    if (type2 === "rational" || type2 === "finite_rational") return "rational";
    if (type2 === "real" || type2 === "finite_real") return "real";
    if (type2 === "complex" || type2 === "finite_complex") return "complex";
    if (type2 === "imaginary") return "complex";
    if (type2 === "finite_number") return "complex";
    if (type2 === "non_finite_number") return "constant";
    if (type2 === "number") return "real";
    return "other";
  }
  if (expr.symbol === "ImaginaryUnit") return "complex";
  if (asRadical(expr)) return "radical";
  if (expr.symbol && expr.isConstant) return "constant";
  if (expr.symbol) return "symbol";
  if (isTrigonometricFunction(expr.operator)) return "trig";
  if (expr.operator === "Add") return "add";
  if (expr.operator === "Power" || expr.operator === "Root") return "power";
  if (expr.operator === "Multiply" || expr.operator === "Negate")
    return "multiply";
  if (expr.operator === "Divide") return "divide";
  if (expr.operator === "Rational") return "rational";
  if (expr.operator === "Complex") return expr.im !== 0 ? "complex" : "real";
  if (expr.operator === "Sqrt") {
    if (expr.op1.isNumberLiteral && (expr.op1.isInteger || expr.op1.isRational))
      return "radical";
    return "power";
  }
  if (expr.ops) return "fn";
  if (expr.string) return "string";
  return "other";
}
function order(a, b) {
  if (a === b) return 0;
  const rankA = rank(a);
  const rankB = rank(b);
  if (rankA !== rankB) return RANKS.indexOf(rankA) - RANKS.indexOf(rankB);
  if (rankA === "complex") {
    const [reA, imA] = getComplex(a);
    const [reB, imB] = getComplex(b);
    if (imA !== imB) return imA - imB;
    return reA - reB;
  }
  if (rankA === "integer" || rankA === "rational" || rankA === "real") {
    let aN = a.numericValue;
    let bN = b.numericValue;
    if (aN === null && a.operator === "Rational") aN = a.op1.re / a.op2.re;
    if (bN === null && b.operator === "Rational") bN = b.op1.re / b.op2.re;
    const af = typeof aN === "number" ? aN : aN.re;
    const bf = typeof bN === "number" ? bN : bN.re;
    return af - bf;
  }
  if (rankA === "radical") return order(a.op1, b.op1);
  if (rankA === "constant" || rankA === "symbol") {
    if (a.symbol === b.symbol) return 0;
    return a.symbol > b.symbol ? 1 : -1;
  }
  if (rankA === "add") {
    const aOps = a.ops;
    const bOps = b.ops;
    if (aOps.length !== bOps.length) return bOps.length - aOps.length;
    for (let i = 0; i < aOps.length; i++) {
      const cmp2 = order(aOps[i], bOps[i]);
      if (cmp2 !== 0) return cmp2;
    }
    return 0;
  }
  if (rankA === "power") {
    const totalDegreeA = totalDegree(a);
    const totalDegreeB = totalDegree(b);
    if (totalDegreeA !== totalDegreeB) {
      return totalDegreeB - totalDegreeA;
    }
    const maxDegreeA = maxDegree(a);
    const maxDegreeB = maxDegree(b);
    if (maxDegreeA !== maxDegreeB) {
      return maxDegreeA - maxDegreeB;
    }
    return order(a.op1, b.op1);
  }
  if (rankA === "multiply") {
    const totalDegreeA = totalDegree(a);
    const totalDegreeB = totalDegree(b);
    if (totalDegreeA !== totalDegreeB) return totalDegreeB - totalDegreeA;
    const maxDegreeA = maxDegree(a);
    const maxDegreeB = maxDegree(b);
    if (maxDegreeA !== maxDegreeB) return maxDegreeA - maxDegreeB;
    const aOps = a.ops;
    const bOps = b.ops;
    if (aOps.length !== bOps.length) return bOps.length - aOps.length;
    for (let i = 0; i < aOps.length; i++) {
      const cmp2 = order(aOps[i], bOps[i]);
      if (cmp2 !== 0) return cmp2;
    }
    return 0;
  }
  if (rankA === "divide") {
    const totalDegreeA = totalDegree(a.op1);
    const totalDegreeB = totalDegree(b.op1);
    if (totalDegreeA !== totalDegreeB) return totalDegreeB - totalDegreeA;
    const maxDegreeA = maxDegree(a.op1);
    const maxDegreeB = maxDegree(b.op1);
    if (maxDegreeA !== maxDegreeB) return maxDegreeA - maxDegreeB;
    const numOrder = order(a.op1, b.op1);
    if (numOrder !== 0) return numOrder;
    return order(a.op2, b.op2);
  }
  if (rankA === "fn" || rankA === "trig") {
    if (a.operator == b.operator && a.nops === 1 && b.nops === 1) {
      return order(a.op1, b.op1);
    }
    const aComplexity = a.operatorDefinition?.complexity ?? DEFAULT_COMPLEXITY;
    const bComplexity = b.operatorDefinition?.complexity ?? DEFAULT_COMPLEXITY;
    if (aComplexity === bComplexity) {
      if (a.operator === b.operator) return getLeafCount(a) - getLeafCount(b);
      if (a.operator < b.operator) return 1;
      return -1;
    }
    return aComplexity - bComplexity;
  }
  if (rankA === "string") {
    if (a.string === b.string) return 0;
    if (b.string < a.string) return -1;
    return 1;
  }
  return (a.complexity ?? DEFAULT_COMPLEXITY) - (b.complexity ?? DEFAULT_COMPLEXITY);
}
function canonicalOrder(expr, { recursive = false }) {
  if (expr.isCanonical || expr.isStructural || !expr.ops) return expr;
  let ops = expr.ops;
  if (recursive) ops = ops.map((x) => canonicalOrder(x, { recursive }));
  ops = sortOperands(expr.operator, ops);
  return expr.engine._fn(expr.operator, ops, { canonical: false });
}
function sortOperands(operator2, xs) {
  if (xs.length === 0) return xs;
  const ce = xs[0].engine;
  if (operator2 === "Add") return [...xs].sort(addOrder);
  if (operator2 === "Multiply") return [...xs].sort(order);
  const def = ce.lookupDefinition(operator2);
  if (!def || !isOperatorDef(def)) return xs;
  const isCommutative = def.operator.commutative;
  if (!isCommutative) return xs;
  if (def.operator.commutativeOrder)
    return [...xs].sort(def.operator.commutativeOrder);
  return [...xs].sort(order);
}
function getLeafCount(expr) {
  if (!expr.ops) return 1;
  return 1 + [...expr.ops].reduce((acc, x) => acc + getLeafCount(x), 0);
}
function getComplex(a) {
  if (a.symbol === "ImaginaryUnit") return [0, 1];
  if (a.numericValue) {
    if (typeof a.numericValue === "number") return [a.numericValue, 0];
    const v = a.numericValue;
    return [v.re, v.im];
  }
  if (a.operator === "Complex") {
    const op1 = a.op1.numericValue;
    if (op1 === null) return [0, 0];
    const re = typeof op1 === "number" ? op1 : op1.re;
    const op2 = a.op2.numericValue;
    if (op2 === null) return [0, 0];
    const im = typeof op2 === "number" ? op2 : op2.re;
    return [re, im];
  }
  return [0, 0];
}
var DEFAULT_COMPLEXITY, TRIGONOMETRIC_OPERATORS, RANKS;
var init_order = __esm({
  "src/compute-engine/boxed-expression/order.ts"() {
    init_polynomials();
    init_arithmetic_power();
    init_utils5();
    DEFAULT_COMPLEXITY = 1e5;
    TRIGONOMETRIC_OPERATORS = {
      Sin: true,
      Cos: true,
      Tan: true,
      Cot: true,
      Sec: true,
      Csc: true,
      Sinh: true,
      Cosh: true,
      Tanh: true,
      Coth: true,
      Sech: true,
      Csch: true,
      Arcsin: true,
      Arccos: true,
      Arctan: true,
      Arccot: true,
      Arcsec: true,
      Arccsc: true,
      Arsinh: true,
      Arcosh: true,
      Artanh: true,
      Arcoth: true,
      Arcsch: true,
      Arsech: true
    };
    RANKS = [
      "integer",
      "rational",
      "radical",
      // Square root of a rational literal
      "real",
      "complex",
      "constant",
      "symbol",
      "multiply",
      "divide",
      "add",
      "trig",
      "fn",
      "power",
      "string",
      "other"
    ];
  }
});

// src/compute-engine/boxed-expression/product.ts
function commonTerms(lhs, rhs) {
  const ce = lhs.engine;
  const coef = lhs.coefficient.gcd(rhs.coefficient);
  if (coef.isOne) return [ce._numericValue(1), ce.One];
  const xs = [];
  for (const x of lhs.terms) {
    const y = rhs.terms.find((y2) => x.term.isSame(y2.term));
    if (!y) continue;
    const exponent = rationalGcd(x.exponent, y.exponent);
    if (isOne(exponent)) xs.push(x.term);
    else {
      const [n, d] = asMachineRational(exponent);
      if (d === 1) xs.push(x.term.pow(n));
      else if (n === 1) xs.push(x.term.root(d));
      else xs.push(x.term.pow(n).root(d));
    }
  }
  return [coef, xs.length === 0 ? ce.One : mul3(...xs)];
}
function termsAsExpression(ce, terms) {
  let result = terms.map(({ terms: terms2, exponent }) => {
    const t = flatten(terms2, "Multiply");
    const base = t.length <= 1 ? t[0] : ce._fn("Multiply", [...t].sort(order));
    return isOne(exponent) ? base : base.pow(ce.number(exponent));
  });
  result = flatten(result, "Multiply");
  if (result.length === 0) return ce.One;
  if (result.length === 1) return result[0];
  return ce._fn("Multiply", result.sort(order));
}
var Product;
var init_product = __esm({
  "src/compute-engine/boxed-expression/product.ts"() {
    init_types2();
    init_rationals();
    init_order();
    init_arithmetic_power();
    init_flatten();
    init_numerics();
    init_arithmetic_mul_div();
    Product = class _Product {
      constructor(ce, xs, options) {
        this.options = options;
        options = options ? { ...options } : {};
        if (!("canonical" in options)) options.canonical = true;
        this._isCanonical = options.canonical;
        this.engine = ce;
        this.coefficient = ce._numericValue(1);
        if (xs) for (const x of xs) this.mul(x);
      }
      engine;
      // Running literal products (if canonical)
      coefficient;
      // Other terms of the product, `term` is the key
      terms = [];
      // If `false`, the running products are not calculated
      _isCanonical = true;
      static from(expr) {
        return new _Product(expr.engine, [expr]);
      }
      /**
       * Add a term to the product.
       *
       * If `this._isCanonical` a running product of exact terms is kept.
       * Otherwise, terms and their exponent are tallied.
       */
      mul(term, exp3) {
        console.assert(term.isCanonical || term.isStructural);
        if (this.coefficient.isNaN) return;
        if (term.isNaN) {
          this.coefficient = this.engine._numericValue(NaN);
          return;
        }
        if (term.operator === "Multiply") {
          for (const t of term.ops) this.mul(t, exp3);
          return;
        }
        if (term.operator === "Negate") {
          this.mul(term.op1, exp3);
          this.coefficient = this.coefficient.neg();
          return;
        }
        if (this._isCanonical) {
          if (term.symbol === "Nothing") return;
          exp3 ??= [1, 1];
          const num = term.numericValue;
          if (num !== null) {
            if (term.is(1)) return;
            if (term.is(0)) {
              if (this.coefficient.isPositiveInfinity || this.coefficient.isNegativeInfinity) {
                this.coefficient = this.engine._numericValue(NaN);
                return;
              }
              this.coefficient = this.engine._numericValue(isZero(exp3) ? NaN : 0);
              return;
            }
            if (term.is(-1)) {
              if (isOne(exp3)) this.coefficient = this.coefficient.neg();
              else {
                this.coefficient = this.coefficient.mul(
                  this.engine._numericValue(-1).pow(this.engine._numericValue(exp3))
                );
              }
              return;
            }
            if (term.isInfinity) {
              if (this.coefficient.isZero) {
                this.coefficient = this.engine._numericValue(NaN);
                return;
              }
              if (isOne(exp3)) {
                const coefSign = this.coefficient.sgn();
                const termSign = term.isNegative ? -1 : 1;
                const resultSign = coefSign * termSign;
                this.coefficient = this.engine._numericValue(
                  resultSign < 0 ? -Infinity : Infinity
                );
              } else this.terms.push({ term, exponent: exp3 });
              return;
            }
            if (isOne(exp3)) {
              this.coefficient = this.coefficient.mul(num);
            } else
              this.coefficient = this.coefficient.mul(
                this.engine._numericValue(num).pow(this.engine._numericValue(exp3))
              );
            return;
          }
          const radical = asRadical(term);
          if (radical !== null) {
            this.coefficient = this.coefficient.mul(
              this.engine._numericValue({
                radical: radical[0] * radical[1],
                rational: [1, Number(radical[1])]
              }).pow(this.engine._numericValue(exp3))
            );
            return;
          }
          if (!term.symbol) {
            const isSymbolicRadical = (term.operator === "Sqrt" || term.operator === "Root" || term.operator === "Power") && term.op1?.isNumberLiteral === true;
            if (!isSymbolicRadical) {
              let coef;
              [coef, term] = term.toNumericValue();
              if (exp3 && !isOne(exp3))
                coef = coef.pow(this.engine._numericValue(exp3));
              this.coefficient = this.coefficient.mul(coef);
            }
          }
        }
        if (term.is(1) && (!exp3 || isOne(exp3))) return;
        if (term.is(0) === false && exp3 && isZero(exp3)) return;
        if (term.is(0)) {
          if (exp3 && isZero(exp3)) this.coefficient = this.engine._numericValue(NaN);
          else this.coefficient = this.engine._numericValue(0);
          return;
        }
        const exponent = exp3 ?? [1, 1];
        if (term.operator === "Power") {
          const r = asRational(term.op2);
          if (r) {
            const baseIsNumeric = term.op1?.isNumberLiteral === true;
            const expIsInteger = r[1] === 1 || r[1] === -1;
            if (!baseIsNumeric || expIsInteger) {
              this.mul(term.op1, mul2(exponent, r));
              return;
            }
          }
        }
        if (term.operator === "Sqrt") {
          const baseIsNumeric = term.op1?.isNumberLiteral === true;
          if (!baseIsNumeric) {
            this.mul(term.op1, mul2(exponent, [1, 2]));
            return;
          }
        }
        if (term.operator === "Root") {
          const r = asRational(term.op2);
          if (r) {
            const baseIsNumeric = term.op1?.isNumberLiteral === true;
            if (!baseIsNumeric) {
              this.mul(term.op1, mul2(exponent, inverse(r)));
              return;
            }
          }
        }
        if (term.operator === "Divide") {
          this.mul(term.op1, exponent);
          this.mul(term.op2, neg(exponent));
          return;
        }
        let found = false;
        for (const x of this.terms) {
          if (x.term.isSame(term)) {
            x.exponent = add2(x.exponent, exponent);
            found = true;
            break;
          }
        }
        if (!found) this.terms.push({ term, exponent });
      }
      /** Divide the product by a term of coefficient */
      div(term) {
        if (term instanceof NumericValue)
          this.coefficient = this.coefficient.div(term);
        else this.mul(term, [-1, 1]);
      }
      /** The terms of the product, grouped by degrees.
       *
       * If `mode` is `rational`, rationals are split into separate numerator and
       * denominator, so that a rational expression can be created later
       * If `mode` is `expression`, a boxed expression is returned, without
       * splitting rationals
       * If `mode` is `numeric`, the literals are combined into one expression
       *
       */
      groupedByDegrees(options) {
        options ??= {};
        if (!("mode" in options)) options.mode = "expression";
        const mode2 = options.mode;
        if (mode2 === "numeric" && (this.coefficient.isNegativeInfinity || this.coefficient.isPositiveInfinity))
          return [];
        if (this.coefficient.isZero) return [];
        const ce = this.engine;
        if (this.terms.length === 0) {
          if (mode2 === "numeric") {
            const c = this.coefficient.N();
            return [{ exponent: [1, 1], terms: [ce.number(c)] }];
          } else {
            return [{ exponent: [1, 1], terms: [ce.number(this.coefficient)] }];
          }
        }
        const xs = [];
        if (!this.coefficient.isOne) {
          if (mode2 === "rational" && this.coefficient.type === "finite_rational") {
            const num = this.coefficient.numerator;
            if (!num.isOne) xs.push({ exponent: [1, 1], terms: [ce.number(num)] });
            const denom = this.coefficient.denominator;
            if (!denom.isOne)
              xs.push({ exponent: [-1, 1], terms: [ce.number(denom)] });
          } else if (mode2 === "numeric") {
            const c = this.coefficient.N();
            xs.push({ exponent: [1, 1], terms: [ce.number(c)] });
          } else {
            xs.push({ exponent: [1, 1], terms: [ce.number(this.coefficient)] });
          }
        }
        for (const t of this.terms) {
          const exponent = reducedRational(t.exponent);
          if (exponent[0] === 0) continue;
          let found = false;
          for (const x of xs) {
            if (exponent[0] === x.exponent[0] && exponent[1] === x.exponent[1]) {
              x.terms.push(t.term);
              found = true;
              break;
            }
          }
          if (!found) xs.push({ exponent, terms: [t.term] });
        }
        return xs;
      }
      asExpression(options = { numericApproximation: false }) {
        const ce = this.engine;
        const coef = this.coefficient;
        if (coef.isNaN) return ce.NaN;
        if (coef.isPositiveInfinity) return ce.PositiveInfinity;
        if (coef.isNegativeInfinity) return ce.NegativeInfinity;
        if (coef.isZero) return ce.Zero;
        const isNegativeOne2 = coef.isNegativeOne;
        if (isNegativeOne2) this.coefficient = ce._numericValue(1);
        const groupedTerms = this.groupedByDegrees({
          mode: options.numericApproximation ? "numeric" : "expression"
        });
        if (groupedTerms === null) return ce.NaN;
        if (isNegativeOne2) {
          const result = termsAsExpression(ce, groupedTerms).neg();
          this.coefficient = ce._numericValue(-1);
          return result;
        }
        return termsAsExpression(ce, groupedTerms);
      }
      /** The product, expressed as a numerator and denominator */
      asNumeratorDenominator() {
        const ce = this.engine;
        const coef = this.coefficient;
        if (coef.isZero) return [ce.Zero, ce.One];
        if (coef.isPositiveInfinity || coef.isNegativeInfinity) {
          if (this.terms.length === 0) {
            return [
              coef.isPositiveInfinity ? ce.PositiveInfinity : ce.NegativeInfinity,
              ce.One
            ];
          }
          return [ce.NaN, ce.NaN];
        }
        const isNegativeOne2 = coef.isNegativeOne;
        if (isNegativeOne2) this.coefficient = ce._numericValue(1);
        const xs = this.groupedByDegrees({ mode: "rational" });
        this.coefficient = coef;
        if (xs === null) return [ce.NaN, ce.NaN];
        const xsNumerator = xs.filter((x) => x.exponent[0] >= 0);
        const xsDenominator = xs.filter((x) => x.exponent[0] < 0).map((x) => ({
          exponent: neg(x.exponent),
          terms: x.terms
        }));
        const num = termsAsExpression(ce, xsNumerator);
        return [
          isNegativeOne2 ? num.neg() : num,
          termsAsExpression(ce, xsDenominator)
        ];
      }
      asRationalExpression() {
        const [numerator, denominator] = this.asNumeratorDenominator();
        return canonicalDivide(numerator, denominator);
      }
    };
  }
});

// src/compute-engine/boxed-expression/serialize.ts
var serialize_exports = {};
__export(serialize_exports, {
  serializeJson: () => serializeJson
});
function _escapeJsonString(s) {
  return s;
}
function serializeSubtract(ce, a, b, options, metadata) {
  if (a.numericValue !== null && a.isNegative) {
    const v = a.numericValue;
    if (typeof v === "number") {
      return serializeJsonFunction(
        ce,
        "Subtract",
        [b, ce.number(-v)],
        options,
        metadata
      );
    }
    if (a.type.matches("rational")) {
      return serializeJsonFunction(
        ce,
        "Subtract",
        [b, ce.number(v.neg())],
        options,
        metadata
      );
    }
  }
  if (a.operator === "Negate" && b.operator !== "Negate")
    return serializeJsonFunction(ce, "Subtract", [b, a.op1], options, metadata);
  return null;
}
function serializePrettyJsonFunction(ce, name, args, options, metadata) {
  const exclusions = options.exclude;
  if (name === "Add" && args.length === 2 && !exclusions.includes("Subtract")) {
    const sub3 = serializeSubtract(ce, args[0], args[1], options, metadata) ?? serializeSubtract(ce, args[1], args[0], options, metadata);
    if (sub3) return sub3;
  }
  if (name === "Divide" && args.length === 2 && exclusions.includes("Divide")) {
    return serializeJsonFunction(
      ce,
      "Multiply",
      [args[0], ce._fn("Power", [args[1], ce.NegativeOne])],
      options,
      metadata
    );
  }
  if (name === "Multiply" && !exclusions.includes("Negate")) {
    if (args[0].im === 0 && args[0].re === -1) {
      if (args.length === 2)
        return serializeJsonFunction(ce, "Negate", [args[1]], options);
      return serializeJsonFunction(
        ce,
        "Negate",
        [ce._fn("Multiply", [...args.slice(1)].sort(order))],
        options,
        metadata
      );
    }
  }
  if (name === "Multiply" && !exclusions.includes("Divide")) {
    const result = new Product(ce, args, {
      canonical: false
    }).asRationalExpression();
    if (result.operator === "Divide")
      return serializeJsonFunction(
        ce,
        result.operator,
        result.ops,
        options,
        metadata
      );
  }
  if (name === "Power") {
    if (!exclusions.includes("Exp") && args[0]?.symbol === "ExponentialE")
      return serializeJsonFunction(ce, "Exp", [args[1]], options, metadata);
    if (args[1]?.numericValue !== null) {
      const exp3 = asSmallInteger(args[1]);
      if (exp3 === 2 && !exclusions.includes("Square"))
        return serializeJsonFunction(
          ce,
          "Square",
          [args[0]],
          options,
          metadata
        );
      if (exp3 !== null && exp3 < 0 && !exclusions.includes("Divide")) {
        return serializeJsonFunction(
          ce,
          "Divide",
          [ce.One, exp3 === -1 ? args[0] : args[0].pow(-exp3)],
          options,
          metadata
        );
      }
      const r = args[1].re;
      if (!exclusions.includes("Sqrt") && r === 0.5)
        return serializeJsonFunction(ce, "Sqrt", [args[0]], options, metadata);
      if (!exclusions.includes("Sqrt") && r === -0.5)
        return serializeJsonFunction(
          ce,
          "Divide",
          [ce.One, ce._fn("Sqrt", [args[0]])],
          options,
          metadata
        );
      if (isRational(r)) {
        const n = machineNumerator(r);
        const d = machineDenominator(r);
        if (n === 1) {
          if (!exclusions.includes("Sqrt") && d === 2)
            return serializeJsonFunction(
              ce,
              "Sqrt",
              [args[0]],
              options,
              metadata
            );
          if (!exclusions.includes("Root"))
            return serializeJsonFunction(
              ce,
              "Root",
              [args[0], ce.number(r[1])],
              options,
              metadata
            );
        }
        if (n === -1) {
          if (!exclusions.includes("Sqrt") && d === 2)
            return serializeJsonFunction(
              ce,
              "Divide",
              [ce.One, ce._fn("Sqrt", [args[0]])],
              options,
              metadata
            );
          if (!exclusions.includes("Root"))
            return serializeJsonFunction(
              ce,
              "Divide",
              [ce.One, ce._fn("Root", [args[0], ce.number(r[1])])],
              options,
              metadata
            );
        }
      }
    }
  }
  if (name === "Add" && args.length === 2 && !exclusions.includes("Subtract")) {
    if (args[1]?.numericValue !== null) {
      const t1 = asSmallInteger(args[1]);
      if (t1 !== null && t1 < 0)
        return serializeJsonFunction(
          ce,
          "Subtract",
          [args[0], ce.number(-t1)],
          options,
          metadata
        );
    }
    if (args[1]?.operator === "Negate") {
      return serializeJsonFunction(
        ce,
        "Subtract",
        [args[0], args[1].op1],
        options,
        metadata
      );
    }
  }
  if (name === "Tuple") {
    if (args.length === 1 && !exclusions.includes("Single"))
      return serializeJsonFunction(ce, "Single", args, options, metadata);
    if (args.length === 2 && !exclusions.includes("Pair"))
      return serializeJsonFunction(ce, "Pair", args, options, metadata);
    if (args.length === 3 && !exclusions.includes("Triple"))
      return serializeJsonFunction(ce, "Triple", args, options, metadata);
  }
  if (name === "Function" && args.length > 0) {
    if (args[0].operator === "Block") {
      const block = args[0];
      if (block.nops === 1) {
        const params = args.slice(1);
        if (params.every((x) => /_\d?/.test(x.symbol))) {
          if (block.op1.ops?.every((x, i) => x.symbol === params[i]?.symbol)) {
            return serializeJsonFunction(
              ce,
              "Function",
              [ce.symbol(block.op1.operator, { canonical: false })],
              options,
              metadata
            );
          }
          return serializeJsonFunction(
            ce,
            "Function",
            [block.op1],
            options,
            metadata
          );
        }
        return serializeJsonFunction(
          ce,
          "Function",
          [block.op1, ...args.slice(1)],
          options,
          metadata
        );
      }
    }
  }
  return serializeJsonFunction(ce, name, args, options, metadata);
}
function serializeJsonFunction(ce, name, args, options, metadata) {
  const exclusions = options.exclude;
  if (name === "Negate" && args.length === 1) {
    const num0 = args[0]?.numericValue;
    if (num0 !== null) {
      if (typeof num0 === "number")
        return serializeJsonNumber(ce, -num0, options);
      if (num0 instanceof Decimal)
        return serializeJsonNumber(ce, num0.neg(), options);
      if (num0 instanceof Complex)
        return serializeJsonNumber(ce, num0.neg(), options);
      if (isRational(num0)) return serializeJsonNumber(ce, neg(num0), options);
    }
  }
  if (typeof name === "string" && exclusions.includes(name)) {
    if (name === "Rational" && args.length === 2)
      return serializeJsonFunction(ce, "Divide", args, options, metadata);
    if (name === "Complex" && args.length === 2)
      return serializeJsonFunction(
        ce,
        "Add",
        [
          args[0],
          ce._fn("Multiply", [args[1] ?? ce.symbol("Undefined"), ce.I])
        ],
        options,
        metadata
      );
    if (name === "Sqrt" && args.length === 1)
      return serializeJsonFunction(
        ce,
        "Power",
        [args[0], exclusions.includes("Half") ? ce.number([1, 2]) : ce.Half],
        options,
        metadata
      );
    if (name === "Root" && args.length === 2 && args[1]?.numericValue !== null) {
      const n = asSmallInteger(args[1]);
      if (n === 2) return serializeJsonFunction(ce, "Sqrt", [args[0]], options);
      if (n !== null) {
        if (n < 0)
          return serializeJsonFunction(
            ce,
            "Divide",
            [
              ce.One,
              ce._fn("Power", [
                args[0] ?? ce.symbol("Undefined"),
                ce.number([1, -n])
              ])
            ],
            options,
            metadata
          );
        return serializeJsonFunction(
          ce,
          "Power",
          [args[0], ce.number([1, -n])],
          options,
          metadata
        );
      }
    }
    if (name === "Square" && args.length === 1)
      return serializeJsonFunction(
        ce,
        "Power",
        [args[0], ce.number(2)],
        options,
        metadata
      );
    if (name === "Exp" && args.length === 1)
      return serializeJsonFunction(
        ce,
        "Power",
        [ce.E, args[0]],
        options,
        metadata
      );
    if (name === "Pair" || name == "Single" || name === "Triple")
      return serializeJsonFunction(ce, "Tuple", args, options, metadata);
    if (name === "Subtract" && args.length === 2)
      return serializeJsonFunction(
        ce,
        "Add",
        [args[0], ce._fn("Negate", [args[1] ?? ce.symbol("Undefined")])],
        options,
        metadata
      );
    if (name === "Subtract" && args.length === 1)
      return serializeJsonFunction(ce, "Negate", args, options, metadata);
  }
  const jsonHead = _escapeJsonString(name);
  const fn = [
    jsonHead,
    ...args.map((x) => x ? serializeJson(ce, x, options) : "Undefined")
  ];
  const md = { ...metadata ?? {} };
  if (options.metadata.includes("latex")) {
    md.latex = _escapeJsonString(
      md.latex ?? ce.box({ fn }).latex
    );
  } else md.latex = "";
  if (!options.metadata.includes("wikidata")) md.wikidata = "";
  if (!md.latex && !md.wikidata && options.shorthands.includes("function"))
    return fn;
  if (md.latex && md.wikidata)
    return { fn, latex: md.latex, wikidata: md.wikidata };
  if (md.latex) return { fn, latex: md.latex };
  if (md.wikidata) return { fn, wikidata: md.wikidata };
  return { fn };
}
function serializeJsonString(s, options) {
  s = _escapeJsonString(s);
  if (options.shorthands.includes("string")) {
    if (matchesNumber(s) || matchesSymbol(s)) return `'${s}'`;
    return s;
  }
  return { str: s };
}
function serializeJsonSymbol(ce, sym, options, metadata) {
  if (sym === "Half" && options.exclude.includes("Half")) {
    return serializeJsonNumber(ce, [1, 2], options, metadata);
  }
  metadata = { ...metadata };
  if (options.metadata.includes("latex")) {
    metadata.latex = metadata.latex ?? ce.box({ sym }).latex;
    if (metadata.latex !== void 0)
      metadata.latex = _escapeJsonString(metadata.latex);
  } else metadata.latex = void 0;
  if (options.metadata.includes("wikidata")) {
    if (metadata.wikidata === void 0) {
      const def = ce.lookupDefinition(sym);
      if (def) {
        const wikidata = isOperatorDef(def) ? def.operator.wikidata : def.value.wikidata;
        if (wikidata !== void 0)
          metadata.wikidata = _escapeJsonString(wikidata);
      }
    }
  } else metadata.wikidata = void 0;
  sym = _escapeJsonString(sym);
  if (metadata.latex === void 0 && metadata.wikidata === void 0 && options.shorthands.includes("symbol")) {
    if (matchesSymbol(sym)) return sym;
    return `\`${sym}\``;
  }
  if (metadata.latex !== void 0 && metadata.wikidata !== void 0)
    return { sym, latex: metadata.latex, wikidata: metadata.wikidata };
  if (metadata.latex !== void 0) return { sym, latex: metadata.latex };
  if (metadata.wikidata !== void 0)
    return { sym, wikidata: metadata.wikidata };
  return { sym };
}
function serializeRepeatingDecimals(s, options) {
  if (!options.repeatingDecimal) return s;
  let [_, wholepart, fractionalPart, exponent] = s.match(/^(.*)\.([0-9]+)([e|E][-+]?[0-9]+)?$/) ?? [];
  if (!fractionalPart) return s.toLowerCase();
  const lastDigit = fractionalPart[fractionalPart.length - 1];
  fractionalPart = fractionalPart.slice(0, -1);
  const MAX_REPEATING_PATTERN_LENGTH = 16;
  let prefix = "";
  for (let i = 0; i < fractionalPart.length - MAX_REPEATING_PATTERN_LENGTH; i++) {
    prefix = fractionalPart.substring(0, i);
    for (let j = 0; j <= MAX_REPEATING_PATTERN_LENGTH; j++) {
      const repetend = fractionalPart.substring(i, i + j + 1);
      const times = Math.floor(
        (fractionalPart.length - prefix.length) / repetend.length
      );
      if (times < 3) break;
      if ((prefix + repetend.repeat(times + 1)).startsWith(fractionalPart)) {
        if (repetend === "0") {
          if (lastDigit === "0")
            return wholepart + "." + prefix + (exponent ?? "");
          return s;
        }
        return wholepart + "." + prefix + "(" + repetend + ")" + (exponent ?? "");
      }
    }
  }
  fractionalPart += lastDigit;
  while (fractionalPart.endsWith("0"))
    fractionalPart = fractionalPart.slice(0, -1);
  if (typeof options.fractionalDigits === "number") {
    fractionalPart = fractionalPart.slice(0, options.fractionalDigits);
  }
  if (exponent)
    return `${wholepart}.${fractionalPart}${exponent.toLowerCase()}`;
  return `${wholepart}.${fractionalPart}`;
}
function serializeJsonNumber(ce, value, options, metadata) {
  metadata = { ...metadata };
  if (!options.metadata.includes("latex")) metadata.latex = void 0;
  const shorthandAllowed = metadata.latex === void 0 && metadata.wikidata === void 0 && !options.metadata.includes("latex") && options.shorthands.includes("number");
  const exclusions = options.exclude;
  if (value instanceof NumericValue) {
    if (value.isNaN) return serializeJsonSymbol(ce, "NaN", options, metadata);
    if (value.isPositiveInfinity)
      return serializeJsonSymbol(ce, "PositiveInfinity", options, metadata);
    if (value.isNegativeInfinity)
      return serializeJsonSymbol(ce, "NegativeInfinity", options, metadata);
    if (value.isComplexInfinity)
      return serializeJsonSymbol(ce, "ComplexInfinity", options, metadata);
    if (shorthandAllowed) {
      if (value.isZero) return 0;
      if (value.isOne) return 1;
      if (value.isNegativeOne) return -1;
    }
    if (value instanceof ExactNumericValue) {
      console.assert(value.im === 0);
      const rationalExpr = (r) => {
        if (isInteger(r))
          return serializeJsonNumber(ce, value.rational[0], options);
        return [
          "Rational",
          serializeJsonNumber(ce, value.rational[0], options),
          serializeJsonNumber(ce, value.rational[1], options)
        ];
      };
      if (value.radical === 1) return rationalExpr(value.rational);
      if (isOne(value.rational)) return ["Sqrt", value.radical];
      if (isNegativeOne(value.rational))
        return ["Negate", ["Sqrt", value.radical]];
      if (value.rational[0] == 1)
        return [
          "Divide",
          ["Sqrt", value.radical],
          serializeJsonNumber(ce, value.rational[1], options)
        ];
      if (value.rational[0] == -1)
        return [
          "Negate",
          [
            "Divide",
            ["Sqrt", value.radical],
            serializeJsonNumber(ce, value.rational[1], options)
          ]
        ];
      return [
        "Multiply",
        rationalExpr(value.rational),
        ["Sqrt", value.radical]
      ];
    }
    if (value.im === 0) {
      const re = value.bignumRe ?? value.re;
      return serializeJsonNumber(ce, re, options, metadata);
    }
    if (!Number.isFinite(value.im))
      return serializeJsonSymbol(ce, "ComplexInfinity", options, metadata);
    return serializeJsonFunction(
      ce,
      "Complex",
      [ce.number(value.bignumRe ?? value.re), ce.number(value.im)],
      options,
      {
        ...metadata,
        wikidata: "Q11567"
      }
    );
  }
  let num = "";
  if (value instanceof Decimal) {
    let result2;
    if (value.isNaN()) result2 = "NaN";
    else if (!value.isFinite())
      result2 = value.isPositive() ? "PositiveInfinity" : "NegativeInfinity";
    else {
      if (shorthandAllowed && isInMachineRange(value)) return value.toNumber();
      if (value.isInteger() && value.e < value.precision() + 4)
        num = value.toFixed(0);
      else {
        const precision = options.fractionalDigits;
        let s;
        if (precision === "max") s = value.toString();
        else if (precision === "auto") s = value.toPrecision(ce.precision);
        else s = value.toDecimalPlaces(precision).toString();
        num = serializeRepeatingDecimals(s, options);
        if (shorthandAllowed) {
          const val = value.toNumber();
          if (val.toString() === num) return val;
        }
      }
    }
    if (options.metadata.includes("latex"))
      metadata.latex = metadata.latex ?? ce.box(result2 ?? { num }).latex;
    if (result2) {
      if (metadata.latex !== void 0)
        return { sym: result2, latex: metadata.latex };
      if (shorthandAllowed) return result2;
      return { sym: result2 };
    }
    if (metadata.latex !== void 0) return { num, latex: metadata.latex };
    return shorthandAllowed ? num : { num };
  }
  if (value instanceof Complex) {
    if (value.isInfinite())
      return serializeJsonSymbol(ce, "ComplexInfinity", options, metadata);
    if (value.isNaN()) {
      num = "NaN";
      if (options.metadata.includes("latex"))
        metadata.latex = metadata.latex ?? ce.box({ num }).latex;
      return metadata.latex !== void 0 ? { num, latex: metadata.latex } : { num };
    }
    return serializeJsonFunction(
      ce,
      "Complex",
      [ce.number(value.re), ce.number(value.im)],
      options,
      {
        ...metadata,
        wikidata: "Q11567"
      }
    );
  }
  if (isRational(value)) {
    const allowRational = !exclusions.includes("Rational");
    if (shorthandAllowed && options.shorthands.includes("function") && isMachineRational(value)) {
      if (value[0] === 1 && value[1] === 2 && !exclusions.includes("Half"))
        return serializeJsonSymbol(ce, "Half", options, metadata);
      return [allowRational ? "Rational" : "Divide", value[0], value[1]];
    }
    return serializeJsonFunction(
      ce,
      allowRational ? "Rational" : "Divide",
      [ce.number(value[0]), ce.number(value[1])],
      options,
      { ...metadata }
    );
  }
  if (typeof value === "bigint") {
    if (value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {
      value = Number(value);
    } else {
      if (options.metadata.includes("latex"))
        metadata.latex = metadata.latex ?? ce.box({ num: value.toString() }).latex;
      if (metadata.latex !== void 0)
        return { num: value.toString(), latex: metadata.latex };
      return shorthandAllowed ? numberToExpression(value, options.fractionalDigits) : { num: numberToString(value, options.fractionalDigits) };
    }
  }
  let result;
  if (Number.isNaN(value)) result = "NaN";
  else if (!Number.isFinite(value))
    result = value > 0 ? "PositiveInfinity" : "NegativeInfinity";
  else num = serializeRepeatingDecimals(value.toString(), options);
  if (options.metadata.includes("latex"))
    metadata.latex = metadata.latex ?? ce.box({ num }).latex;
  if (result) {
    if (metadata.latex !== void 0)
      return { sym: result, latex: metadata.latex };
    return shorthandAllowed ? result : { sym: result };
  }
  if (metadata.latex !== void 0) return { num, latex: metadata.latex };
  if (shorthandAllowed && num === value.toString()) return value;
  return { num };
}
function serializeJson(ce, expr, options) {
  const wikidata = expr.wikidata;
  if (expr.numericValue !== null)
    return serializeJsonNumber(ce, expr.numericValue, options, {
      latex: expr.verbatimLatex
    });
  if (expr.rank > 0) return expr.json;
  if (expr.type.matches("dictionary")) return expr.toMathJson(options);
  if (expr.string !== null) return serializeJsonString(expr.string, options);
  if (expr.symbol !== null) {
    return serializeJsonSymbol(ce, expr.symbol, options, {
      latex: expr.verbatimLatex,
      wikidata
    });
  }
  if (expr.ops) {
    if (expr.isValid && (expr.isCanonical || expr.isStructural) && options.prettify)
      return serializePrettyJsonFunction(
        ce,
        expr.operator,
        expr.structural.ops,
        options,
        {
          latex: expr.verbatimLatex,
          wikidata
        }
      );
    return serializeJsonFunction(
      ce,
      expr.operator,
      expr.structural.ops,
      options,
      {
        latex: expr.verbatimLatex,
        wikidata
      }
    );
  }
  return expr.json;
}
var init_serialize2 = __esm({
  "src/compute-engine/boxed-expression/serialize.ts"() {
    init_complex();
    init_decimal();
    init_numeric_bignum();
    init_rationals();
    init_strings();
    init_expression();
    init_types2();
    init_exact_numeric_value();
    init_product();
    init_order();
    init_numerics();
    init_utils5();
    init_utils2();
  }
});

// src/compute-engine/numerics/interval.ts
function interval(expr) {
  if (expr.operator === "Interval") {
    let op1 = expr.op1;
    let op2 = expr.op2;
    let openStart = false;
    let openEnd = false;
    if (op1.operator === "Open") {
      openStart = true;
      op1 = op1.op1;
    } else if (op1.operator === "Closed") {
      op1 = op1.op1;
    }
    if (op2.operator === "Open") {
      openEnd = true;
      op2 = op2.op1;
    } else if (op2.operator === "Closed") {
      op2 = op2.op1;
    }
    const start = op1.N();
    const end = op2.N();
    if (!start.isNumberLiteral || !end.isNumberLiteral) return void 0;
    return { start: start.re, openStart, end: end.re, openEnd };
  }
  if (expr.symbol === "EmptySet")
    return { start: 0, openStart: true, end: 0, openEnd: true };
  if (expr.symbol === "RealNumbers")
    return {
      start: -Infinity,
      openStart: false,
      end: Infinity,
      openEnd: false
    };
  if (expr.symbol === "NegativeNumbers")
    return { start: -Infinity, openStart: false, end: 0, openEnd: true };
  if (expr.symbol === "NonPositiveNumbers")
    return { start: -Infinity, openStart: false, end: 0, openEnd: false };
  if (expr.symbol === "PositiveNumbers")
    return { start: 0, openStart: true, end: Infinity, openEnd: false };
  if (expr.symbol === "NonNegativeNumbers")
    return { start: 0, openStart: false, end: Infinity, openEnd: false };
  return void 0;
}
var init_interval = __esm({
  "src/compute-engine/numerics/interval.ts"() {
  }
});

// src/math-json/types.ts
var init_types3 = __esm({
  "src/math-json/types.ts"() {
  }
});

// src/common/type/types.ts
var init_types4 = __esm({
  "src/common/type/types.ts"() {
  }
});

// src/compute-engine/numerics/types.ts
var init_types5 = __esm({
  "src/compute-engine/numerics/types.ts"() {
  }
});

// src/compute-engine/global-types.ts
var init_global_types = __esm({
  "src/compute-engine/global-types.ts"() {
  }
});

// src/compute-engine/types.ts
var init_types6 = __esm({
  "src/compute-engine/types.ts"() {
    init_types3();
    init_boxed_type();
    init_types4();
    init_types5();
    init_types2();
    init_global_types();
  }
});

// src/compute-engine/boxed-expression/canonical-utils.ts
function canonical(ce, xs, scope) {
  if (xs.every((x) => x.isCanonical)) return xs;
  return xs.map((x) => ce.box(x, { scope }));
}
var init_canonical_utils = __esm({
  "src/compute-engine/boxed-expression/canonical-utils.ts"() {
  }
});

// src/compute-engine/library/collections.ts
function range(expr) {
  if (expr.nops === 0) return [1, 0, 0];
  let op1 = expr.op1.re;
  if (!isFinite(op1)) op1 = 1;
  else op1 = Math.round(op1);
  if (expr.nops === 1) return [1, op1, 1];
  let op2 = expr.op2.re;
  if (!isFinite(op2) && !op2) op2 = 1;
  else if (isFinite(op2)) op2 = Math.round(op2);
  if (expr.nops === 2) return [op1, op2, op2 > op1 ? 1 : -1];
  let op3 = expr.op3.re;
  if (!isFinite(op3)) op3 = 1;
  else op3 = Math.abs(Math.round(op3));
  return [op1, op2, op1 < op2 ? op3 : -op3];
}
function rangeLast(r) {
  const [lower, upper, step] = r;
  if (!Number.isFinite(upper)) return step > 0 ? Infinity : -Infinity;
  if (step > 0) return upper - (upper - lower) % step;
  return upper + (lower - upper) % step;
}
function canonicalList(ops, { engine: ce }) {
  const op1 = ops[0];
  if (ops.length === 1 && op1.operator === "Matrix") {
    const [body, delimiters, columns] = op1.ops;
    if (!delimiters || delimiters.string === "..") {
      if (!columns) return ce._fn("Matrix", [body, delimiters]);
      return ce._fn("Matrix", [body, ce.string("[]"), columns]);
    }
  }
  ops = ops.map((op) => {
    if (op.operator === "Delimiter") {
      if (op.op1.operator === "Sequence")
        return ce._fn("List", canonical(ce, op.op1.ops));
      return ce._fn("List", [op.op1?.canonical ?? ce.Nothing]);
    }
    return op.canonical;
  });
  return ce._fn("List", ops);
}
function canonicalSet(ops, { engine }) {
  const set = [];
  const has = (x) => set.some((y) => y.isSame(x));
  for (const op of ops) if (!has(op)) set.push(op);
  return engine._fn("Set", set);
}
function tally(collection) {
  const values = [];
  const counts = [];
  const indexOf = (expr) => {
    for (let i = 0; i < values.length; i++)
      if (values[i].isSame(expr)) return i;
    return -1;
  };
  for (const op of collection.each()) {
    const index = indexOf(op);
    if (index >= 0) counts[index]++;
    else {
      values.push(op);
      counts.push(1);
    }
  }
  return [values, counts];
}
function* reduceCollection(collection, fn, initial) {
  let acc = initial;
  let counter = 0;
  for (const x of collection.each()) {
    const result = fn(acc, x);
    if (result === null) return void 0;
    counter += 1;
    if (counter % 1e3 === 0) yield acc;
    acc = result;
  }
  return acc;
}
function joinResultType(ops) {
  if (ops.some((op) => op.type.matches("record"))) return "record";
  if (ops.some((op) => op.type.matches("dictionary"))) return "dictionary";
  if (ops.some((op) => op.type.matches("set"))) return "set";
  return "list";
}
function defaultCollectionEq(a, b) {
  if (a.operator !== b.operator) return false;
  if (a.nops !== b.nops) return false;
  return a.ops.every((x, i) => x.isSame(b.ops[i]));
}
function fromRange(start, end) {
  return Array.from({ length: end - start + 1 }, (_, index) => start + index);
}
function sortedIndices(expr, fn = void 0) {
  const f = fn ? applicable(fn) : void 0;
  const cmpFn = f ? (a, b) => {
    const r = f([a, b]);
    return r?.isNegative ? -1 : r?.is(0) ? 0 : 1;
  } : (a, b) => {
    if (a.isLess(b)) return -1;
    if (a.isEqual(b)) return 0;
    return 1;
  };
  const l = expr.count;
  if (l === void 0 || !Number.isFinite(l) || l < 1) return void 0;
  const indices = Array.from({ length: l }, (_, i) => i + 1);
  indices.sort((i, j) => {
    const va = expr.at(i);
    const vb = expr.at(j);
    return cmpFn(va, vb);
  });
  return indices;
}
function enlist(xs) {
  if (xs.length === 0) return [];
  const result = [];
  for (const x of xs) {
    if (x.symbol === "Nothing") continue;
    if (x.operator === "Sequence") {
      result.push(...enlist(x.ops));
    } else if (x.string) {
      result.push(x);
    } else if (x.isCollection) {
      result.push(...enlist([...x.each()]));
    } else {
      result.push(x);
    }
  }
  return result;
}
function takeIterator(expr) {
  const count = Math.max(0, toInteger(expr.op2) ?? 0);
  if (count === 0) return { next: () => ({ value: void 0, done: true }) };
  let index = 1;
  let n = 0;
  return {
    next: () => {
      if (n >= Math.abs(count)) return { value: void 0, done: true };
      const value = expr.op1.at(index);
      if (!value) return { value: void 0, done: true };
      index += 1;
      n += 1;
      return { value, done: false };
    }
  };
}
function takeCount(expr) {
  const [xs, op2] = expr.ops;
  const count = xs.count;
  if (count === void 0) return void 0;
  const n = Math.max(0, toInteger(op2) ?? 0);
  if (!Number.isFinite(n)) return Infinity;
  return Math.min(count, n);
}
function zipCount(expr) {
  const counts = expr.ops.map((x) => x.count);
  if (counts.some((c) => c === void 0)) return void 0;
  if (counts.some((c) => !Number.isFinite(c))) return Infinity;
  if (counts.length === 0) return 0;
  return Math.min(...counts);
}
var DEFAULT_LINSPACE_COUNT, COLLECTIONS_LIBRARY;
var init_collections = __esm({
  "src/compute-engine/library/collections.ts"() {
    init_validate();
    init_numerics();
    init_collection_utils();
    init_function_utils();
    init_parse();
    init_utils();
    init_interval();
    init_interruptible();
    init_types6();
    init_serialize();
    init_canonical_utils();
    DEFAULT_LINSPACE_COUNT = 50;
    COLLECTIONS_LIBRARY = {
      //
      // Data Structures
      //
      List: {
        complexity: 8200,
        signature: "(any*) -> list",
        type: (ops, { engine: ce }) => parseType(`list<${BoxedType.widen(...ops.map((op) => op.type))}>`),
        canonical: canonicalList,
        lazy: true,
        evaluate: (ops, { engine, materialization: eager }) => {
          if (!eager) return void 0;
          return engine._fn(
            "List",
            enlist(ops).map((op) => op.evaluate({ materialization: eager }))
          );
        },
        eq: defaultCollectionEq,
        collection: basicIndexedCollectionHandlers()
      },
      // Extensional set. Elements do not repeat. The order of the elements is not significant.
      // For intensional set, use `Filter` with a condition, e.g. `Filter(RealNumbers, _ > 0)`
      Set: {
        complexity: 8200,
        signature: "(any*) -> set",
        type: (ops, { engine: ce }) => parseType(`set<${BoxedType.widen(...ops.map((op) => op.type))}>`),
        canonical: canonicalSet,
        eq: (a, b) => {
          if (a.operator !== b.operator) return false;
          if (a.nops !== b.nops) return false;
          const has = (x) => b.ops.some((y) => x.isSame(y));
          return a.ops.every(has);
        },
        collection: {
          ...basicIndexedCollectionHandlers(),
          // A set is not indexable
          at: void 0,
          indexWhere: void 0
        }
      },
      Tuple: {
        description: "A fixed number of heterogeneous elements",
        complexity: 8200,
        signature: "(any*) -> tuple",
        type: (ops) => parseType(`tuple<${ops.map((op) => op.type).join(", ")}>`),
        canonical: (ops, { engine }) => engine.tuple(...ops),
        eq: defaultCollectionEq,
        collection: {
          ...basicIndexedCollectionHandlers(),
          keys: (expr) => {
            return ["first", "second", "last"];
          }
        }
      },
      KeyValuePair: {
        description: "A key/value pair",
        complexity: 8200,
        signature: "(key: string, value: any) -> tuple<string, unknown>",
        type: ([key, value]) => parseType(`tuple<string, ${value.type}>`),
        canonical: (args, { engine }) => {
          const [key, value] = checkTypes(engine, args, ["string", "any"]);
          if (!key.isValid || !value.isValid)
            return engine._fn("KeyValuePair", [key, value]);
          return engine.tuple(key, value);
        }
      },
      Single: {
        description: "A tuple with a single element",
        complexity: 8200,
        signature: "(value: any) -> tuple<any>",
        type: ([value]) => parseType(`tuple<${value.type}>`),
        canonical: (ops, { engine }) => engine.tuple(...checkArity(engine, ops, 1))
      },
      Pair: {
        description: "A tuple of two elements",
        complexity: 8200,
        signature: "(first: any, second: any) -> tuple<any, any>",
        type: ([first, second]) => parseType(`tuple<${first.type}, ${second.type}>`),
        canonical: (ops, { engine }) => engine.tuple(...checkArity(engine, ops, 2))
      },
      Triple: {
        description: "A tuple of three elements",
        complexity: 8200,
        signature: "(first: any, second: any, third: any) -> tuple<any, any, any>",
        type: ([first, second, third]) => parseType(`tuple<${first.type}, ${second.type}, ${third.type}>`),
        canonical: (ops, { engine }) => engine.tuple(...checkArity(engine, ops, 3))
      },
      //
      // Numeric Collections
      //
      Range: {
        complexity: 8200,
        signature: "(number, number?, step: number?) -> indexed_collection<integer>",
        canonical: (ops, { engine: ce }) => {
          if (ops.length === 0) return null;
          if (ops.length === 1) return ce._fn("Range", [ce.One, ops[0].canonical]);
          if (ops.length === 2)
            return ce._fn("Range", [ops[0].canonical, ops[1].canonical]);
          return ce._fn("Range", [
            ops[0].canonical,
            ops[1].canonical,
            ops[2].canonical.evaluate()
          ]);
        },
        eq: (a, b) => {
          if (a.operator !== b.operator) return false;
          const [al, au, as] = range(a);
          const [bl, bu, bs] = range(b);
          return al === bl && au === bu && as === bs;
        },
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const [lower, upper, step] = range(expr);
            if (step === 0) return 0;
            if (!isFinite(lower) || !isFinite(upper)) return Infinity;
            return 1 + Math.max(0, Math.floor((upper - lower) / step));
          },
          contains: (expr, target) => {
            if (!target.type.matches("integer")) return false;
            const t = target.re;
            const [lower, upper, step] = range(expr);
            if (step === 0) return false;
            if (step > 0) return t >= lower && t <= upper;
            return t <= lower && t >= upper;
          },
          iterator: (expr) => {
            const [lower, upper, step] = range(expr);
            const maxCount = step === 0 ? 0 : Math.floor((upper - lower) / step) + 1;
            let index = 1;
            return {
              next: () => {
                if (index === maxCount + 1) return { value: void 0, done: true };
                index += 1;
                return {
                  value: expr.engine.number(lower + step * (index - 1 - 1)),
                  done: false
                };
              }
            };
          },
          // Return the nth step of the range.
          // Questionable if this is useful.
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const [lower, upper, step] = range(expr);
            if (index < 1 || index > 1 + (upper - lower) / step) return void 0;
            return expr.engine.number(lower + step * (index - 1));
          },
          indexWhere: void 0,
          subsetOf: (expr, target) => {
            if (target.operator === "Range") {
              const [al, au, as] = range(expr);
              const [bl, bu, bs] = range(target);
              return al >= bl && au <= bu && as % bs === 0;
            }
            if (!target.isCollection) return false;
            let i = 1;
            for (const x of target.each()) {
              if (!expr.contains(x)) return false;
              if (!expr.at(i)?.isSame(x)) return false;
              i++;
            }
            return true;
          },
          eltsgn: (expr) => {
            const [lower, upper, step] = range(expr);
            if (step === 0) return "zero";
            if (step > 0) return lower <= upper ? "positive" : "negative";
            return lower >= upper ? "positive" : "negative";
          },
          elttype: (_expr) => "finite_integer"
        }
      },
      Interval: {
        description: "A set of real numbers between two endpoints. The endpoints may or may not be included.",
        complexity: 8200,
        lazy: true,
        signature: "(number, number) -> set<real>",
        canonical: ([lo, hi], { engine }) => {
          if (!lo || !hi) return null;
          const [lower, upper] = checkTypes(
            engine,
            [lo.canonical, hi.canonical],
            ["number", "number"]
          );
          if (!lower.isValid || !upper.isValid) return null;
          return engine._fn("Interval", [lower, upper]);
        },
        eq: (a, b) => {
          const intervalA = interval(a);
          const intervalB = interval(b);
          if (!intervalA || !intervalB) return false;
          return intervalA.start === intervalB.start && intervalA.end === intervalB.end && intervalA.openStart === intervalB.openStart && intervalA.openEnd === intervalB.openEnd;
        },
        collection: {
          count: (_expr) => Infinity,
          iterator: (expr) => {
            const int = interval(expr);
            if (!int) return { next: () => ({ value: void 0, done: true }) };
            if (int.start >= int.end) {
              return { next: () => ({ value: void 0, done: true }) };
            }
            const ce = expr.engine;
            let level = 0;
            let index = 0;
            return {
              next: () => {
                const pointsAtLevel = Math.pow(2, level);
                if (index >= pointsAtLevel) {
                  level++;
                  index = 0;
                }
                const t = (2 * index + 1) / Math.pow(2, level + 1);
                const value = int.start + t * (int.end - int.start);
                index++;
                return { value: ce.number(value), done: false };
              }
            };
          },
          isEmpty: (_expr) => {
            const int = interval(_expr);
            if (!int) return false;
            if (int.openStart && int.start === int.end) return true;
            if (int.openEnd && int.start === int.end) return true;
            if (int.openStart && int.openEnd) return false;
            return int.start >= int.end;
          },
          isFinite: (_expr) => false,
          contains: (expr, target) => {
            const int = interval(expr);
            if (!int) return false;
            if (int.openStart && target.isLessEqual(int.start)) return false;
            if (int.openEnd && target.isGreaterEqual(int.end)) return false;
            return target.isGreaterEqual(int.start) && target.isLessEqual(int.end);
          },
          eltsgn: (expr) => {
            const i = interval(expr);
            if (!i) return "unsigned";
            if (i.start === i.end) return "unsigned";
            if (i.start >= 0 && !i.openStart) return "non-negative";
            if (i.end <= 0 && !i.openEnd) return "non-positive";
            if (i.start > 0 && i.end > 0) return "positive";
            if (i.start < 0 && i.end < 0) return "negative";
            return void 0;
          },
          elttype: (expr) => {
            const i = interval(expr);
            if (!i) return "never";
            if (isFinite(i.start) && isFinite(i.end)) return "finite_real";
            return "real";
          }
        }
      },
      Linspace: {
        complexity: 8200,
        signature: "(start: number, end: number?, count: number?) -> indexed_collection",
        // @todo: the canonical form should consider if this can be simplified to a range (if the elements are integers)
        // @todo: need eq handler
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            let count = expr.op3.re;
            if (!isFinite(count)) count = DEFAULT_LINSPACE_COUNT;
            return Math.max(0, Math.floor(count));
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const lower = expr.op1.re;
            const upper = expr.op2.re;
            let count = expr.op3.re;
            if (!isFinite(count)) count = DEFAULT_LINSPACE_COUNT;
            if (!isFinite(lower) || !isFinite(upper)) return void 0;
            if (index < 1 || index > count) return void 0;
            return expr.engine.number(
              lower + (upper - lower) * (index - 1) / count
            );
          },
          iterator: (expr) => {
            let lower = expr.op1.re;
            let upper = expr.op2.re;
            let totalCount;
            if (!isFinite(upper)) {
              upper = lower;
              lower = 1;
              totalCount = DEFAULT_LINSPACE_COUNT;
            } else {
              totalCount = Math.max(
                0,
                !isFinite(expr.op3.re) ? DEFAULT_LINSPACE_COUNT : expr.op3.re
              );
            }
            let index = 1;
            return {
              next: () => {
                if (index === totalCount + 1)
                  return { value: void 0, done: true };
                index += 1;
                return {
                  value: expr.engine.number(
                    lower + (upper - lower) * (index - 1 - 1) / totalCount
                  ),
                  done: false
                };
              }
            };
          },
          contains: (expr, target) => {
            if (!target.type.matches("finite_real")) return false;
            const t = target.re;
            const lower = expr.op1.re;
            const upper = expr.op2.re;
            if (t < lower || t > upper) return false;
            let count = expr.op3.re;
            if (!isFinite(count)) count = DEFAULT_LINSPACE_COUNT;
            if (count === 0) return false;
            const step = (upper - lower) / count;
            return (t - lower) % step === 0;
          }
        }
      },
      //
      // Operations on collections (indexed or not)
      //
      Contains: {
        description: "Return True if the collection contains the given element, False otherwise.",
        complexity: 8200,
        signature: "(collection, element: any) -> boolean",
        evaluate: ([xs, value], { engine: ce }) => {
          return xs.contains(value) ? ce.True : ce.False;
        }
      },
      Count: {
        description: ["Return the number of elements in the collection."],
        complexity: 8200,
        signature: "(collection) -> integer",
        evaluate: ([xs], { engine }) => xs.isEmptyCollection ? engine.Zero : engine.number(xs.count),
        sgn: ([xs]) => xs.isEmptyCollection ? "zero" : "positive"
      },
      IsEmpty: {
        description: ["Return True if the collection is empty, False otherwise."],
        complexity: 8200,
        signature: "(collection) -> boolean",
        evaluate: ([xs], { engine: ce }) => xs.isEmptyCollection ? ce.True : ce.False
      },
      // Exists: {
      //   description:
      //     'Return True if any element of the collection satisfies the predicate, False otherwise.',
      //   complexity: 8200,
      //   signature: '(collection, function) -> boolean',
      //   type: () => 'boolean',
      //   evaluate: ([xs, fn], { engine: ce }) => {
      //     const f = applicable(fn);
      //     if (!f) return ce.False;
      //     for (const item of xs.each()) {
      //       if (f([item])?.symbol === 'True') return ce.True;
      //     }
      //     return ce.False;
      //   },
      // },
      // ForAll: {
      //   description:
      //     'Return True if all elements of the collection satisfy the predicate, False otherwise.',
      //   complexity: 8200,
      //   signature: '(collection, function) -> boolean',
      //   type: () => 'boolean',
      //   evaluate: ([xs, fn], { engine: ce }) => {
      //     const f = applicable(fn);
      //     if (!f) return ce.False;
      //     for (const item of xs.each()) {
      //       if (f([item])?.symbol !== 'True') return ce.False;
      //     }
      //     return ce.True;
      //   },
      // },
      // { f(x) for x in xs }
      // { 2x | x  [ 1 , 10 ] }
      Map: {
        description: [
          "Return the collection where each element has been transformed by the mapping function.",
          "Equivalent to `[f(x) for x in xs]`."
        ],
        complexity: 8200,
        lazy: true,
        signature: "(collection, function) -> collection",
        // If the input collection is indexed, the output collection is indexed.
        type: (ops) => ops[0].type,
        canonical: (ops, { engine }) => {
          const collection = checkType(engine, ops[0]?.canonical, "collection");
          const fn = canonicalFunctionLiteral(ops[1]);
          if (!collection.isValid || !fn) return null;
          return engine._fn("Map", [collection, fn]);
        },
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => expr.op1.count,
          isEmpty: (expr) => expr.op1.isEmptyCollection,
          isFinite: (expr) => expr.op1.isFiniteCollection,
          iterator: (expr) => {
            const f = applicable(expr.op2);
            if (!f) return { next: () => ({ value: void 0, done: true }) };
            const source = expr.op1.each();
            return {
              next: () => {
                while (true) {
                  const { value, done } = source.next();
                  if (done) return { value: void 0, done: true };
                  const v = f([value]) ?? expr.engine.Nothing;
                  return { value: v, done: false };
                }
              }
            };
          },
          at: (expr, index) => {
            if (!expr.isIndexedCollection) return void 0;
            if (typeof index !== "number") return void 0;
            if (!Number.isFinite(index) || index === 0) return void 0;
            const item = expr.op1.at(index);
            if (!item) return void 0;
            return applicable(expr.op2)?.([item]);
          }
        }
      },
      Filter: {
        description: [
          "Return the elements of the collection for which the predicate function returns True.",
          "Equivalent to `[x for x in xs if p(x)]`."
        ],
        complexity: 8200,
        lazy: true,
        signature: "(collection, predicate: function) -> collection",
        // If the input collection is indexed, the output collection is indexed.
        type: (ops) => ops[0].type,
        canonical: (ops, { engine }) => {
          const collection = checkType(engine, ops[0]?.canonical, "collection");
          const fn = canonicalFunctionLiteral(ops[1]);
          if (!collection.isValid || !fn) return null;
          return engine._fn("Filter", [collection, fn]);
        },
        collection: {
          isLazy: (_expr) => true,
          count: (_expr) => Infinity,
          contains: (expr, target) => {
            if (!expr.contains(target)) return false;
            const f = applicable(expr.op2);
            return f([target])?.symbol === "True";
          },
          iterator: (expr) => {
            const f = applicable(expr.op2);
            if (!f) return { next: () => ({ value: void 0, done: true }) };
            const source = expr.op1.each();
            let count = 0;
            const limit2 = expr.engine.iterationLimit;
            return {
              next: () => {
                while (true) {
                  const { value, done } = source.next();
                  count += 1;
                  if (count > limit2) {
                    throw new CancellationError({
                      cause: "iteration-limit-exceeded",
                      message: `Iteration limit of ${limit2} exceeded while evaluating Filter()`
                    });
                  }
                  if (done) return { value: void 0, done: true };
                  const pred = f([value]);
                  if (!pred) {
                    throw new Error(
                      `Invalid filter predicate. ${spellCheckMessage(expr.op2)}`
                    );
                  }
                  if (pred.symbol === "True") return { value, done: false };
                  if (pred.symbol !== "False") {
                    throw new Error(
                      `Filter predicate must return "True" or "False". ${spellCheckMessage(expr.op2)}`
                    );
                  }
                }
              }
            };
          },
          /**
           * Return the element at the given 1based `index` **after** applying the
           * filter predicate.
           *
           * * If `index` is positive, iterate through the source collection until
           *   the `index`th element that satisfies the predicate is found.
           * * If `index` is negative, first materialise the filtered result (only
           *   possible for finite source collections) and count from the end
           *   (1 last, 2 penultimate, ).
           * * For nonnumeric indexes or outofrange requests, return
           *   `undefined`.
           *
           * The function never mutates the source collection and stops iterating
           * as soon as the requested element is found.
           */
          at: (expr, index) => {
            if (typeof index !== "number" || !Number.isFinite(index) || index === 0)
              return void 0;
            const predicate2 = applicable(expr.op2);
            if (!predicate2) return void 0;
            if (index < 0) {
              if (!expr.op1.isFiniteCollection) return void 0;
              const data = Array.from(expr.each());
              const i = data.length + index + 1;
              if (i < 1 || i > data.length) return void 0;
              return data[i - 1];
            }
            let count = 0;
            for (const item of expr.op1.each()) {
              const pred = predicate2([item])?.symbol;
              if (pred === "True") {
                count += 1;
                if (count === index) return item;
              } else if (pred !== "False") {
                throw new Error(
                  `Filter predicate must return "True" or "False". ${spellCheckMessage(expr.op2)}`
                );
              }
            }
            return void 0;
          }
        }
      },
      // Haskell: "foldl"
      // For "foldr", apply Reverse() first
      Reduce: {
        complexity: 8200,
        lazy: true,
        signature: "(collection, function, initial:value?) -> value",
        canonical: (ops, { engine }) => {
          const collection = checkType(engine, ops[0], "collection");
          const fn = canonicalFunctionLiteral(ops[1]);
          if (!collection.isValid || !fn) return null;
          const initial = ops[2]?.canonical;
          if (initial?.isValid)
            return engine._fn("Reduce", [collection, fn, initial]);
          return engine._fn("Reduce", [collection, fn]);
        },
        type: (ops) => parseType(functionResult(ops[1].type.type) ?? "unknown"),
        evaluate: ([collection, fn, initial], { engine: ce }) => {
          if (!collection.isFiniteCollection) return void 0;
          initial ??= ce.Nothing;
          if (initial.type.matches("real") && collection.type.matches(ce.type("collection<real>"))) {
            const jsf = fn.compile();
            if (!jsf) return void 0;
            let accumulator2 = initial.re;
            let first2 = true;
            for (const item of collection.each()) {
              if (first2) accumulator2 = item.re;
              else accumulator2 = jsf(accumulator2, item.re);
              first2 = false;
            }
            return ce.box(accumulator2);
          }
          const f = applicable(fn);
          let accumulator = initial;
          let first = true;
          for (const item of collection.each()) {
            if (first) accumulator = item;
            else accumulator = f([accumulator, item]) ?? ce.Nothing;
            first = false;
          }
          return accumulator;
        }
      },
      Join: {
        description: [
          "Join the elements of some collections into a flat collection."
        ],
        complexity: 8200,
        signature: "(collection*) -> collection",
        type: joinResultType,
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            let total = 0;
            for (const op of expr.ops) {
              const count = op.count;
              if (count === void 0) return void 0;
              if (!Number.isFinite(count)) return Infinity;
              total += count;
            }
            return total;
          },
          contains: (expr, target) => expr.ops.some((op) => op.contains(target)),
          iterator: (expr) => {
            const iters = expr.ops.map((op) => op.each());
            let index = 0;
            return {
              next: () => {
                while (true) {
                  const { value, done } = iters[index].next();
                  if (!done) return { value, done: false };
                  index += 1;
                  if (index >= iters.length)
                    return { value: void 0, done: true };
                }
              }
            };
          }
        }
      },
      //
      // Operations on indexed collections
      //
      At: {
        description: [
          "Access an element of an indexed collection.",
          "If the index is negative, it is counted from the end.",
          "Multiple indices can be provided to access nested collections (e.g., matrices)."
        ],
        complexity: 8200,
        signature: "(value: indexed_collection, index: (number|string)+) -> unknown",
        type: ([xs]) => xs.operatorDefinition?.collection?.elttype?.(xs) ?? collectionElementType(xs.type.type) ?? "any",
        evaluate: (ops, { engine: ce }) => {
          let expr = ops[0];
          let index = 1;
          while (ops[index]) {
            const def = expr.baseDefinition;
            const at = def?.collection?.at;
            if (!at) return void 0;
            const s = ops[index].string;
            if (s !== null) expr = at(expr, s) ?? ce.Nothing;
            else {
              const i = ops[index].re;
              if (!Number.isInteger(i)) return void 0;
              expr = at(expr, i) ?? ce.Nothing;
            }
            index += 1;
          }
          return expr;
        }
      },
      // Miranda: `take` (also Haskell)
      Take: {
        description: ["Return `n` elements from a collection."],
        complexity: 8200,
        signature: "(xs: indexed_collection, count: number) -> indexed_collection",
        type: ([xs]) => `list<${collectionElementType(xs.type.type)}>`,
        evaluate: (ops, { engine, materialization: eager }) => {
          if (!eager) return void 0;
          const takeExpr = engine._fn("Take", ops);
          const elements = Array.from(takeExpr.each());
          return engine._fn("List", elements);
        },
        collection: {
          isLazy: (_expr) => true,
          count: takeCount,
          isEmpty: (expr) => {
            const [xs, op2] = expr.ops;
            if (xs.isEmptyCollection) return true;
            if (xs.isFiniteCollection === false) return false;
            const n = Math.max(0, toInteger(op2) ?? 0);
            const count = xs.count;
            if (count === void 0) return void 0;
            if (!Number.isFinite(n)) return false;
            return Math.min(count, n) === 0;
          },
          isFinite: (expr) => expr.op1.isFiniteCollection,
          iterator: takeIterator,
          at: (expr, index) => {
            if (typeof index !== "number" || index === 0) return void 0;
            const n = Math.max(0, toInteger(expr.op2) ?? 0);
            if (n === 0) return void 0;
            if (index > 0) {
              if (index > n) return void 0;
              return expr.op1.at(index);
            }
            const count = takeCount(expr);
            if (count === void 0 || count === 0) return void 0;
            if (index < -count) return void 0;
            return expr.op1.at(count + index);
          }
        }
      },
      // Miranda: `drop` (also Haskell)
      Drop: {
        description: ["Return the collection without the first n elements."],
        complexity: 8200,
        signature: "(xs: indexed_collection, count: number) -> indexed_collection",
        type: ([xs]) => `list<${collectionElementType(xs.type.type)}>`,
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const [xs, n] = expr.ops;
            const count = xs.count;
            if (count === void 0) return void 0;
            if (!Number.isFinite(count)) return Infinity;
            if (xs.isEmptyCollection) return 0;
            const nValue = toInteger(n) ?? 0;
            if (nValue >= count) return 0;
            return Math.max(0, count - nValue);
          },
          isFinite: (expr) => expr.op1.isFiniteCollection,
          iterator: (expr) => {
            const [xs, nExpr] = expr.ops;
            const n = toInteger(nExpr) ?? 0;
            if (n <= 0) return xs.each();
            let index = n + 1;
            return {
              next: () => {
                const value = expr.op1.at(index++);
                if (value === void 0) return { value: void 0, done: true };
                return { value, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const [xs, nExpr] = expr.ops;
            const n = toInteger(nExpr) ?? 0;
            if (n <= 0) return void 0;
            return xs.at(index + n);
          }
        }
      },
      First: {
        complexity: 8200,
        signature: "(collection) -> any",
        type: ([xs]) => xs.operatorDefinition?.collection?.elttype?.(xs) ?? "any",
        evaluate: ([xs], { engine: ce }) => xs.at(1) ?? ce.Nothing
      },
      Second: {
        complexity: 8200,
        signature: "(collection) -> any",
        type: ([xs]) => xs.operatorDefinition?.collection?.elttype?.(xs) ?? "any",
        evaluate: ([xs], { engine: ce }) => xs.at(2) ?? ce.Nothing
      },
      Last: {
        complexity: 8200,
        signature: "(collection) -> any",
        type: ([xs]) => xs.operatorDefinition?.collection?.elttype?.(xs) ?? "any",
        evaluate: ([xs], { engine: ce }) => xs.at(-1) ?? ce.Nothing
      },
      Rest: {
        description: [
          "Return the collection without the first element.",
          "If the collection has only one element, return an empty collection."
        ],
        complexity: 8200,
        signature: "(indexed_collection) -> indexed_collection",
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            return Math.max(0, count - 1);
          },
          isEmpty: (expr) => {
            if (expr.op1.isEmptyCollection) return true;
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            return count <= 1;
          },
          isFinite: (expr) => expr.op1.isFiniteCollection,
          iterator: (expr) => {
            return {
              next: () => {
                let index = 1;
                const value = expr.op1.at(index > 0 ? index + 1 : index);
                if (!value) return { value: void 0, done: true };
                index += 1;
                return { value, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            return expr.op1.at(index > 0 ? index + 1 : index);
          }
        }
      },
      Most: {
        complexity: 8200,
        description: [
          "Return the collection without the last element.",
          "If the collection has only one element, return an empty collection."
        ],
        signature: "(indexed_collection) -> indexed_collection",
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            return Math.max(0, count - 1);
          },
          isFinite: (expr) => expr.op1.isFiniteCollection,
          isEmpty: (expr) => {
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            return count <= 1;
          },
          iterator: (expr) => {
            const l = expr.op1.count;
            if (l === void 0 || l <= 1)
              return { next: () => ({ value: void 0, done: true }) };
            let index = 1;
            const last = l - 1;
            return {
              next: () => {
                if (index > last) return { value: void 0, done: true };
                const value = expr.op1.at(index++);
                return { value, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const l = expr.op1.count;
            if (l === void 0) return void 0;
            if (index < 1) index = l + 1 + index;
            if (index < 1 || index > l - 1) return void 0;
            return expr.op1.at(index);
          }
        }
      },
      Slice: {
        description: [
          "Return a range of elements from an indexed collection.",
          "If the index is negative, it is counted from the end."
        ],
        complexity: 8200,
        signature: "(value: indexed_collection, start: number, end: number) -> list",
        type: ([xs]) => parseType(`list<${collectionElementType(xs.type.type)}>`),
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const start = toInteger(expr.op2) ?? 1;
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            const end = toInteger(expr.op3) ?? count;
            if (start < 1) return Math.max(0, end + start - 1);
            return Math.max(0, Math.min(end, count) - start + 1);
          },
          isFinite: (_expr) => true,
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const count = expr.op1.count;
            if (count === void 0) return void 0;
            let start = toInteger(expr.op2) ?? 1;
            if (start < 1) start = count + 1 + start;
            if (start < 1) start = 1;
            if (start > count) return void 0;
            let end = toInteger(expr.op3) ?? count;
            if (end < 1) end = count + 1 + end;
            if (end < 1) end = 1;
            if (end > count) end = count;
          },
          iterator: (expr) => {
            let start = toInteger(expr.op2) ?? 1;
            const count = expr.op1.count;
            if (count === void 0)
              return { next: () => ({ value: void 0, done: true }) };
            if (start < 1) start = count + 1 + start;
            if (start < 1) start = 1;
            if (start > count)
              return { next: () => ({ value: void 0, done: true }) };
            let end = toInteger(expr.op3) ?? count;
            if (end < 1) end = count + 1 + end;
            if (end < 1) end = 1;
            if (end > count) end = count;
            let index = start;
            const last = end;
            return {
              next: () => {
                if (index > last) return { value: void 0, done: true };
                const value = expr.op1.at(index);
                index += 1;
                return { value, done: false };
              }
            };
          }
        }
      },
      // APL: rotate 
      Reverse: {
        complexity: 8200,
        signature: "(indexed_collection) -> indexed_collection",
        type: ([xs]) => xs.type,
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => expr.op1.count,
          isEmpty: (expr) => expr.op1.isEmptyCollection,
          isFinite: (expr) => expr.op1.isFiniteCollection,
          contains: (expr, target) => expr.op1.contains(target) ?? false,
          iterator: (expr) => {
            let index = -1;
            return {
              next: () => {
                if (index === 0) return { value: void 0, done: true };
                const value = expr.op1.at(index);
                index -= 1;
                return { value, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            return expr.op1.at(-index);
          }
        }
      },
      RotateLeft: {
        description: "Rotate the elements of the collection to the left by n positions.",
        complexity: 8200,
        signature: "(indexed_collection, integer?) -> indexed_collection",
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => expr.op1.count,
          isEmpty: (expr) => expr.op1.isEmptyCollection,
          isFinite: (expr) => expr.op1.isFiniteCollection,
          contains: (expr, target) => expr.op1.contains(target) ?? false,
          iterator: (expr) => {
            const l = expr.op1.count;
            if (l === void 0 || l <= 0)
              return { next: () => ({ value: void 0, done: true }) };
            let n = toInteger(expr.op2) ?? 1;
            n = (n % l + l) % l;
            let index = 1;
            const last = l;
            return {
              next: () => {
                if (index === last + 1) return { value: void 0, done: true };
                index += 1;
                const v = expr.op1.at((index - 1 - 1 + n) % l + 1);
                if (v === void 0) return { value: void 0, done: true };
                return { value: v, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const l = expr.op1.count;
            if (l === void 0 || l <= 0) return void 0;
            if (index < 1) index = l + 1 + index;
            if (index < 1 || index > l) return void 0;
            let n = toInteger(expr.op2) ?? 1;
            n = (n % l + l) % l;
            return expr.op1.at((index - 1 + n) % l + 1);
          }
        }
      },
      RotateRight: {
        description: "Rotate the elements of the collection to the right by n positions.",
        complexity: 8200,
        signature: "(indexed_collection, integer?) -> indexed_collection",
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => expr.op1.count,
          contains: (expr, target) => expr.op1.contains(target) ?? false,
          iterator: (expr) => {
            const l = expr.op1.count;
            if (l === void 0 || l <= 0)
              return { next: () => ({ value: void 0, done: true }) };
            let n = toInteger(expr.op2) ?? 1;
            n = (n % l + l) % l;
            let index = 1;
            return {
              next: () => {
                if (index === l + 1) return { value: void 0, done: true };
                index += 1;
                const i = (index - 1 - 1 + (l - n)) % l + 1;
                const v = expr.op1.at(i);
                if (v === void 0) return { value: void 0, done: true };
                return { value: v, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number") return void 0;
            const l = expr.op1.count;
            if (l === void 0 || l <= 0) return void 0;
            if (index < 1) index = l + 1 + index;
            if (index < 1 || index > l) return void 0;
            let n = toInteger(expr.op2) ?? 1;
            n = (n % l + l) % l;
            const i = (index - 1 + (l - n)) % l + 1;
            return expr.op1.at(i);
          }
        }
      },
      // Return a list of the elements of each collection.
      // If all collections are Set, return a Set
      // ["Join", ["List", 1, 2, 3], ["List", 4, 5, 6]] -> ["List", 1, 2, 3, 4, 5, 6]
      IndexOf: {
        description: "Return the 1-based index of the first occurrence of value in collection, or 0 if not found.",
        complexity: 8200,
        signature: "(collection, any) -> integer",
        evaluate: ([xs, value], { engine: ce }) => {
          const index = xs.indexWhere((x) => x.isSame(value)) ?? void 0;
          return ce.number(index ?? 0);
        }
      },
      IndexWhere: {
        description: "Return the 1-based index of the first element satisfying the predicate, or 0 if not found.",
        complexity: 8200,
        signature: "(collection, function) -> integer",
        evaluate: ([xs, fn], { engine: ce }) => {
          const f = applicable(fn);
          if (!f) return ce.Zero;
          const index = xs.indexWhere((x) => {
            const pred = f([x])?.symbol;
            if (pred === "True") return true;
            if (pred === "False") return false;
            throw new Error(
              `Filter predicate must return "True" or "False". ${spellCheckMessage(fn)}`
            );
          }) ?? void 0;
          return ce.number(index ?? 0);
        }
      },
      Find: {
        description: "Return the first element of the collection satisfying the predicate, or Nothing if none found.",
        complexity: 8200,
        signature: "(collection, function) -> any",
        type: (ops) => ops[0].type,
        evaluate: ([xs, fn], { engine: ce }) => {
          const f = applicable(fn);
          if (!f) return ce.Nothing;
          for (const item of xs.each()) {
            const pred = f([item])?.symbol;
            if (pred === "False") continue;
            if (pred === "True") return item;
            throw new Error(
              `Filter predicate must return "True" or "False". ${spellCheckMessage(fn)}`
            );
          }
          return ce.Nothing;
        }
      },
      CountIf: {
        description: "Return the number of elements in the collection satisfying the predicate.",
        complexity: 8200,
        signature: "(collection, function) -> integer",
        evaluate: ([xs, fn], { engine: ce }) => {
          const f = applicable(fn);
          if (!f) return ce.Zero;
          let count = 0;
          for (const item of xs.each()) {
            const pred = f([item])?.symbol;
            if (pred === "False") continue;
            if (pred === "True") count++;
            else
              throw new Error(
                `Filter predicate must return "True" or "False". ${spellCheckMessage(fn)}`
              );
          }
          return ce.number(count);
        }
      },
      Position: {
        description: "Return a list of indexes of elements in the collection satisfying the predicate.",
        complexity: 8200,
        signature: "(collection, function) -> list<integer>",
        type: () => "list<integer>",
        evaluate: ([xs, fn], { engine: ce }) => {
          const f = applicable(fn);
          if (!f) return ce.function("List", []);
          const indices = [];
          let index = 1;
          for (const item of xs.each()) {
            const pred = f([item])?.symbol;
            if (pred === "True") indices.push(ce.number(index));
            if (pred !== "False")
              throw new Error(
                `Filter predicate must return "True" or "False". ${spellCheckMessage(fn)}`
              );
            index++;
          }
          return ce.function("List", indices);
        }
      },
      // Return the indexes of the elements so they are in sorted order.
      // `Sort` is equivalent to `["Take", xs, ["Ordering", xs]]`.
      // APL: Grade Up `` and Grade Down ``
      // Mathematica: `Ordering`
      Ordering: {
        description: "Return the indexes that would sort the collection.",
        complexity: 8200,
        signature: "(indexed_collection, function?) -> list<integer>",
        evaluate: ([xs, fn], { engine: ce }) => {
          if (!xs.isFiniteCollection) return ce.function("List", []);
          const indices = sortedIndices(xs, fn);
          if (!indices) return ce.function("List", []);
          return ce.function("List", indices);
        }
      },
      Sort: {
        description: "Return the elements of the collection sorted according to the given comparison function.",
        complexity: 8200,
        signature: "(indexed_collection, function?) -> indexed_collection",
        type: (ops) => ops[0].type,
        evaluate: ([xs, fn], { engine: ce }) => {
          if (!xs.isFiniteCollection) return ce.function(xs.operator, []);
          const indices = sortedIndices(xs, fn);
          if (!indices) return void 0;
          return ce.function(
            xs.operator,
            indices.map((i) => xs.at(i))
          );
        }
      },
      // Randomize the order of the elements in the collection.
      Shuffle: {
        description: "Randomize the order of the elements in the collection.",
        complexity: 8200,
        signature: "(indexed_collection) -> indexed_collection",
        type: (ops) => ops[0].type,
        evaluate: ([xs], { engine: ce }) => {
          if (!xs.isFiniteCollection) return void 0;
          const data = Array.from(xs.each());
          for (let i = data.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [data[i], data[j]] = [data[j], data[i]];
          }
          return ce.function(xs.operator, data);
        }
      },
      Tabulate: {
        description: "Create a collection by applying a function to each index in the specified dimensions.",
        // @todo: do a lazy version of this (implemented as a collection handler)
        complexity: 8200,
        lazy: true,
        signature: "(function, integer, integer?) -> collection",
        canonical: (ops, { engine }) => {
          const fn = canonicalFunctionLiteral(ops[0]);
          if (!fn) return null;
          if (!ops[2])
            return engine._fn("Tabulate", [
              fn,
              checkType(engine, ops[1]?.canonical, "integer")
            ]);
          return engine._fn("Tabulate", [
            fn,
            checkType(engine, ops[1]?.canonical, "integer"),
            checkType(engine, ops[2]?.canonical, "integer")
          ]);
        },
        evaluate: (ops, { engine: ce }) => {
          const fn = applicable(ops[0]);
          if (!fn) return void 0;
          if (ops.length === 1) return ce._fn("List", []);
          const dims = ops.slice(1).map((op) => toInteger(op));
          if (dims.some((d) => d === null || d <= 0)) return void 0;
          if (dims.length === 1) {
            return ce._fn(
              "List",
              Array.from(
                { length: dims[0] ?? 0 },
                (_, i) => fn([ce.number(i + 1)]) ?? ce.Nothing
              )
            );
          }
          const fillArray = (dims2, index, level = 0) => {
            if (level === dims2.length) {
              const idx = index.map((i) => ce.number(i));
              return fn(idx);
            }
            const arr = ["List"];
            for (let i = 1; i <= dims2[level]; i++) {
              index[level] = i;
              arr.push(fillArray(dims2, index, level + 1));
            }
            return arr;
          };
          return ce.box(fillArray(dims, Array(dims.length).fill(0)));
        }
      },
      /* Return a tuple of the unique elements, and their respective count
       * Ex: Tally([a, c, a, d, a, c]) = [[a, c, d], [3, 2, 1]]
       */
      Tally: {
        description: "Return a tuple with the unique elements of the collection and their respective counts.",
        complexity: 8200,
        signature: "(collection) -> tuple<list, list<integer>>",
        type: ([xs], { engine: ce }) => {
          const t = xs.type.type;
          if (t === "string")
            return parseType(`tuple<list<string>, list<integer>>`);
          return parseType(
            `tuple<list<${collectionElementType(t)}>, list<integer>>`
          );
        },
        evaluate: (ops, { engine: ce }) => {
          if (!ops[0].isFiniteCollection) return void 0;
          const [values, counts] = tally(ops[0]);
          return ce.tuple(ce.function("List", values), ce.function("List", counts));
        }
      },
      // Return the first element of Tally()
      // Equivalent to `Union` in Mathematica, `distinct` in Scala,
      // Unique or Nub ,  in APL
      Unique: {
        description: "Return a list of the unique elements of the collection.",
        complexity: 8200,
        signature: "(collection) -> list",
        type: ([xs]) => `list<${collectionElementType(xs.type.type)}>`,
        evaluate: (ops, { engine: ce }) => {
          if (!ops[0].isFiniteCollection) return void 0;
          const [values, _counts] = tally(ops[0]);
          return ce.function("List", values);
        }
      },
      // Partition a collection into k nearly equal parts or by a predicate function
      Partition: {
        wikidata: "Q381060",
        complexity: 8200,
        signature: "(collection, integer | function) -> list",
        type: ([xs]) => `list<${collectionElementType(xs.type.type)}>`,
        evaluate: ([xs, arg], { engine: ce }) => {
          if (!xs.isFiniteCollection) return void 0;
          const k = toInteger(arg);
          if (k !== null && k > 0) {
            const all = Array.from(xs.each());
            const result = [];
            const chunkSize = Math.ceil(all.length / k);
            for (let i = 0; i < k; i++) {
              const chunk = all.slice(i * chunkSize, (i + 1) * chunkSize);
              result.push(ce.function("List", chunk));
            }
            return ce.function("List", result);
          }
          const fn = applicable(arg);
          if (!fn) return void 0;
          const trueGroup = [];
          const falseGroup = [];
          for (const item of xs.each()) {
            const pred = fn([item])?.symbol;
            if (pred === "True") trueGroup.push(item);
            else if (pred === "False") falseGroup.push(item);
            else
              throw new Error(
                `Partition predicate must return "True" or "False". ${spellCheckMessage(arg)}`
              );
          }
          return ce.function("List", [
            ce.function("List", trueGroup),
            ce.function("List", falseGroup)
          ]);
        }
      },
      Chunk: {
        description: "Split the collection into `k` nearly equal-sized chunks.",
        complexity: 8200,
        signature: "(collection, integer) -> list<list>",
        evaluate: ([xs, n], { engine: ce }) => {
          const k = toInteger(n);
          if (!xs.isFiniteCollection || k === null || k <= 0) return void 0;
          const all = Array.from(xs.each());
          const result = [];
          const chunkSize = Math.ceil(all.length / k);
          for (let i = 0; i < k; i++) {
            const chunk = all.slice(i * chunkSize, (i + 1) * chunkSize);
            result.push(ce.function("List", chunk));
          }
          return ce.function("List", result);
        }
      },
      GroupBy: {
        description: [
          "Partition the collection into a dictionary of lists based on the key returned by the function."
        ],
        complexity: 8200,
        signature: "(collection, function) -> dictionary<list>",
        evaluate: ([xs, fn], { engine: ce }) => {
          if (!xs.isFiniteCollection) return void 0;
          const f = applicable(fn);
          if (!f) return void 0;
          const groups = {};
          for (const item of xs.each()) {
            const keyExpr = f([item]) ?? ce.Nothing;
            const key = keyExpr.symbol ?? keyExpr.string ?? keyExpr.toString();
            if (!(key in groups)) groups[key] = [];
            groups[key].push(item);
          }
          return ce.function(
            "Dictionary",
            Object.entries(groups).map(
              ([k, vals]) => ce._fn("Tuple", [ce.string(k), ce.function("List", vals)])
            )
          );
        }
      },
      // Similar to Transpose, but acts on a sequence of collections
      // Equivalent to zip in Python
      // The length of the result is the length of the shortest argument
      // Ex: Zip([a, b, c], [1, 2]) = [[a, 1], [b, 2]]
      Zip: {
        description: "Combine multiple collections element-wise into a list of tuples. The result has the length of the shortest input.",
        complexity: 8200,
        signature: "(indexed_collection+) -> list",
        collection: {
          isLazy: (_expr) => true,
          count: zipCount,
          isFinite: (expr) => expr.ops.every((x) => x.isFiniteCollection),
          isEmpty: (expr) => {
            return expr.nops === 0 || expr.ops.every((x) => x.isEmptyCollection);
          },
          iterator: (expr) => {
            const minCount = zipCount(expr);
            if (minCount === void 0 || minCount <= 0)
              return { next: () => ({ value: void 0, done: true }) };
            let index = 1;
            return {
              next: () => {
                if (index === minCount + 1) return { value: void 0, done: true };
                index += 1;
                const items = expr.ops.map((op) => op.at(index - 1));
                if (items.some((x) => x === void 0))
                  return { value: void 0, done: true };
                return {
                  value: expr.engine.tuple(...items),
                  done: false
                };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number" || index < 1) return void 0;
            const minCount = zipCount(expr);
            if (minCount === void 0 || index < 1 || index > minCount)
              return void 0;
            const items = expr.ops.map((op) => op.at(index));
            if (items.some((x) => x === void 0)) return void 0;
            return expr.engine.tuple(...items);
          }
        }
      },
      // Iterate(fn, init) -> [fn(1, init), fn(2, fn(1, init)), ...]
      // Iterate(fn) -> [fn(1), fn(2), ...]
      // Infinite series. Can use Take(Iterate(fn), n) to get a finite series
      Iterate: {
        description: "Produce an infinite sequence by repeatedly applying a function to the previous value, starting with an initial value.",
        complexity: 8200,
        signature: "((index: integer, acc:any) -> any, initial: any?) -> list",
        canonical: ([f, initialExpr], { engine }) => {
          const fn = canonicalFunctionLiteral(f);
          if (!fn) return null;
          const initial = initialExpr?.canonical;
          if (!initial) return engine._fn("Iterate", [fn]);
          return engine._fn("Iterate", [fn, initial]);
        },
        collection: {
          isLazy: (_expr) => true,
          count: () => Infinity,
          iterator: (expr) => {
            const f = applicable(expr.op1);
            if (!f) return { next: () => ({ value: void 0, done: true }) };
            let acc = expr.op2 ?? expr.engine.Nothing;
            let n = 0;
            return {
              next: () => {
                n += 1;
                acc = f([expr.engine.number(n), acc]) ?? expr.engine.Nothing;
                return { value: acc, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number" || index < 1) return void 0;
            const f = applicable(expr.op1);
            if (!f) return void 0;
            let acc = expr.op2 ?? expr.engine.Nothing;
            for (let i = 1; i < index; i++) {
              acc = f([expr.engine.number(i), acc]) ?? expr.engine.Nothing;
            }
            return acc;
          }
        }
      },
      // Repeat(x) -> [x, x, ...]
      // This is an infinite series. Can use Take(Repeat(x), n) to get a finite series
      // x is evaluated once. Although could use Hold()?
      // So that First(Repeat(Hold(Random(5))), 10) would return 10 random numbers...
      Repeat: {
        description: "Produce an infinite sequence by repeating a single value.",
        complexity: 8200,
        signature: "(value: any) -> list",
        collection: {
          isLazy: (_expr) => true,
          count: () => Infinity,
          isEmpty: (expr) => false,
          // Never empty
          isFinite: () => false,
          // Infinite collection
          contains: (expr, target) => expr.op1.isSame(target),
          iterator: (expr) => ({ next: () => ({ value: expr.op1, done: false }) }),
          at: (expr, index) => expr.op1
        }
      },
      // Cycle(list) -> [list[1], list[2], ...]
      // -> repeats infinitely
      Cycle: {
        description: "Produce an infinite sequence by cycling through the elements of a finite collection.",
        complexity: 8200,
        signature: "(list) -> list",
        collection: {
          isLazy: (_expr) => true,
          count: () => Infinity,
          isEmpty: (expr) => expr.isEmptyCollection,
          isFinite: (expr) => !expr.isEmptyCollection,
          contains: (expr, target) => expr.op1.contains(target) ?? false,
          iterator: (expr) => {
            let index = 1;
            const l = expr.op1.count;
            if (l === void 0 || l === 0)
              return { next: () => ({ value: void 0, done: true }) };
            return {
              next: () => {
                const i = (index - 1 - 1) % l + 1;
                const value = expr.op1.at(i);
                if (value === void 0) return { value: void 0, done: true };
                index += 1;
                return { value, done: false };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number" || index < 1) return void 0;
            const l = expr.op1.count;
            if (l === void 0 || l === 0) return void 0;
            const i = (index - 1) % l + 1;
            return expr.op1.at(i);
          }
        }
      },
      // Fill(f, [n, m])
      // Fill a nxm matrix with the result of f(i, j)
      // Fill( Random(5), [3, 3] )
      Fill: {
        description: "Produce a 2D list (matrix) by applying a function to each pair of row and column indexes.",
        complexity: 8200,
        signature: "(function, tuple) -> list",
        collection: {
          isLazy: (_expr) => true,
          count: (expr) => {
            const dims = expr.op2.ops.map((op) => toInteger(op) ?? 0);
            return dims[0] ?? 0;
          },
          iterator: (expr) => {
            const f = applicable(expr.op1);
            if (!f) return { next: () => ({ value: void 0, done: true }) };
            const dims = expr.op2.ops.map((op) => toInteger(op) ?? 0);
            const rows = dims[0] ?? 0;
            const cols = dims[1] ?? 0;
            const last = rows;
            let index = 1;
            return {
              next: () => {
                if (index === last + 1) return { value: void 0, done: true };
                index += 1;
                const row = [];
                for (let j = 1; j <= cols; j++) {
                  row.push(
                    f([expr.engine.number(index - 1), expr.engine.number(j)]) ?? expr.engine.Nothing
                  );
                }
                return {
                  value: expr.engine.function("List", row),
                  done: false
                };
              }
            };
          },
          at: (expr, index) => {
            if (typeof index !== "number" || index < 1) return void 0;
            const f = applicable(expr.op1);
            if (!f) return void 0;
            const dims = expr.op2.ops.map((op) => toInteger(op) ?? 0);
            const rows = dims[0] ?? 0;
            const cols = dims[1] ?? 0;
            if (index > rows * cols) return void 0;
            const row = Math.ceil(index / cols);
            const col = (index - 1) % cols + 1;
            return f([expr.engine.number(row), expr.engine.number(col)]) ?? expr.engine.Nothing;
          }
        }
      },
      //
      // Create eager collections from other collections.
      //
      ListFrom: {
        description: "Create a list from the elements of a collection.",
        complexity: 8200,
        signature: "(value*) -> list",
        type: (ops) => {
          if (ops.length === 0) return "list";
          let type2 = "unknown";
          for (const xs of ops) {
            if (xs.isCollection && !xs.isFiniteCollection) return "list";
            type2 = widen(type2, collectionElementType(xs.type.type) ?? type2);
          }
          return parseType(`list<${typeToString(type2)}>`);
        },
        evaluate: (ops, { engine: ce }) => {
          const elements = [];
          for (const xs of ops) {
            if (!xs.isCollection) elements.push(xs);
            else {
              if (!xs.isFiniteCollection) return void 0;
              elements.push(...Array.from(xs.each()));
            }
          }
          return ce.function("List", elements);
        }
      },
      SetFrom: {
        description: "Create a set from the elements of a collection.",
        complexity: 8200,
        signature: "(value*) -> set",
        type: (ops) => {
          if (ops.length === 0) return "set";
          let type2 = "unknown";
          for (const xs of ops) {
            if (xs.isCollection && !xs.isFiniteCollection) return "set";
            type2 = widen(type2, collectionElementType(xs.type.type) ?? type2);
          }
          return parseType(`set<${typeToString(type2)}>`);
        },
        evaluate: (ops, { engine: ce }) => {
          const elements = [];
          for (const xs of ops) {
            if (xs.isCollection) elements.push(xs);
            else {
              if (!xs.isFiniteCollection) return void 0;
              elements.push(...Array.from(xs.each()));
            }
          }
          return ce.function("Set", elements);
        }
      },
      TupleFrom: {
        description: "Create a tuple from the elements of a collection.",
        complexity: 8200,
        signature: "(value*) -> tuple",
        evaluate: (ops, { engine: ce }) => {
          const elements = [];
          for (const xs of ops) {
            if (xs.isCollection) elements.push(xs);
            else {
              if (!xs.isFiniteCollection) return void 0;
              elements.push(...Array.from(xs.each()));
            }
          }
          return ce.tuple(...elements);
        }
      },
      DictionaryFrom: {
        description: "Create a dictionary from the elements of a collection of (key, value) pairs.",
        complexity: 8200,
        signature: "(collection) -> dictionary",
        evaluate: ([xs], { engine: ce }) => {
          if (!xs.isCollection) return void 0;
          if (xs.operator === "Record") return ce.function("Dictionary", xs.ops);
          const entries = [];
          for (const keyValue of xs.each()) {
            if (keyValue.nops !== 2) {
              throw new Error(
                `Expected a collection of pairs, got ${keyValue.type}`
              );
            }
            const key = keyValue.op1;
            const value = keyValue.op2;
            if (!key.string) {
              throw new Error(`Expected a string key, got ${key.type}`);
            }
            entries.push(ce.tuple(key, value));
          }
          return ce.function("Dictionary", entries);
        }
      },
      RecordFrom: {
        description: "Create a record from the elements of a collection of (key, value) pairs.",
        complexity: 8200,
        signature: "(collection) -> record",
        evaluate: ([xs], { engine: ce }) => {
          if (!xs.isCollection) return void 0;
          if (xs.operator === "Dictionary") return ce.function("Record", xs.ops);
          const entries = [];
          for (const keyValue of xs.each()) {
            if (keyValue.nops !== 2) {
              throw new Error(
                `Expected a collection of pairs, got ${keyValue.type}`
              );
            }
            const key = keyValue.op1;
            const value = keyValue.op2;
            if (!key.string) {
              throw new Error(`Expected a string key, got ${key.type}`);
            }
            entries.push(ce.tuple(key, value));
          }
          return ce.function("Record", entries);
        }
      }
    };
  }
});

// src/compute-engine/library/logic-utils.ts
function isContradiction(args) {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    for (let j = i + 1; j < args.length; j++) {
      const other = args[j];
      if (arg.operator === "Not" && arg.op1.isSame(other) || other.operator === "Not" && other.op1.isSame(arg)) {
        return true;
      }
    }
  }
  return false;
}
function isTautologyCheck(args) {
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    for (let j = i + 1; j < args.length; j++) {
      const other = args[j];
      if (arg.operator === "Not" && arg.op1.isSame(other) || other.operator === "Not" && other.op1.isSame(arg)) {
        return true;
      }
    }
  }
  return false;
}
function evaluateAnd(args, { engine: ce }) {
  if (args.length === 0) return ce.True;
  const ops = [];
  for (let arg of args) {
    if (arg.operator === "Or" && isTautologyCheck(arg.ops)) {
      arg = ce.True;
    }
    if (arg.symbol === "False") return ce.False;
    if (arg.symbol !== "True") {
      let duplicate = false;
      for (const x of ops) {
        if (x.isSame(arg)) {
          duplicate = true;
        } else if (arg.operator === "Not" && arg.op1.isSame(x) || x.operator === "Not" && x.op1.isSame(arg)) {
          return ce.False;
        }
      }
      if (!duplicate) ops.push(arg);
    }
  }
  if (ops.length === 0) return ce.True;
  if (ops.length === 1) return ops[0];
  const absorbed = applyAbsorptionAnd(ops);
  if (absorbed.length === 0) return ce.True;
  if (absorbed.length === 1) return absorbed[0];
  return ce._fn("And", absorbed);
}
function applyAbsorptionAnd(ops) {
  const result = [];
  for (const op of ops) {
    if (op.operator === "Or" && op.ops) {
      let absorbed = false;
      for (const orArg of op.ops) {
        for (const other of ops) {
          if (other !== op && orArg.isSame(other)) {
            absorbed = true;
            break;
          }
        }
        if (absorbed) break;
      }
      if (!absorbed) result.push(op);
    } else {
      result.push(op);
    }
  }
  return result;
}
function evaluateOr(args, { engine: ce }) {
  if (args.length === 0) return ce.True;
  const ops = [];
  for (let arg of args) {
    if (arg.operator === "And" && isContradiction(arg.ops)) {
      arg = ce.False;
    }
    if (arg.symbol === "True") return ce.True;
    if (arg.symbol !== "False") {
      let duplicate = false;
      for (const x of ops) {
        if (x.isSame(arg)) {
          duplicate = true;
        } else if (arg.operator === "Not" && arg.op1.isSame(x) || x.operator === "Not" && x.op1.isSame(arg)) {
          return ce.True;
        }
      }
      if (!duplicate) ops.push(arg);
    }
  }
  if (ops.length === 0) return ce.False;
  if (ops.length === 1) return ops[0];
  const absorbed = applyAbsorptionOr(ops);
  if (absorbed.length === 0) return ce.False;
  if (absorbed.length === 1) return absorbed[0];
  return ce._fn("Or", absorbed);
}
function applyAbsorptionOr(ops) {
  const result = [];
  for (const op of ops) {
    if (op.operator === "And" && op.ops) {
      let absorbed = false;
      for (const andArg of op.ops) {
        for (const other of ops) {
          if (other !== op && andArg.isSame(other)) {
            absorbed = true;
            break;
          }
        }
        if (absorbed) break;
      }
      if (!absorbed) result.push(op);
    } else {
      result.push(op);
    }
  }
  return result;
}
function evaluateNot(args, { engine: ce }) {
  const op1 = args[0]?.symbol;
  if (op1 === "True") return ce.False;
  if (op1 === "False") return ce.True;
  return void 0;
}
function evaluateEquivalent(args, { engine: ce }) {
  const lhs = args[0].symbol;
  const rhs = args[1].symbol;
  if (lhs === "True" && rhs === "True" || lhs === "False" && rhs === "False")
    return ce.True;
  if (lhs === "True" && rhs === "False" || lhs === "False" && rhs === "True")
    return ce.False;
  return void 0;
}
function evaluateImplies(args, { engine: ce }) {
  const lhs = args[0].symbol;
  const rhs = args[1].symbol;
  if (lhs === "True" && rhs === "True" || lhs === "False" && rhs === "False" || lhs === "False" && rhs === "True")
    return ce.True;
  if (lhs === "True" && rhs === "False") return ce.False;
  return void 0;
}
function evaluateXor(args, { engine: ce }) {
  if (args.length === 0) return ce.False;
  let trueCount = 0;
  const unknowns = [];
  for (const arg of args) {
    if (arg.symbol === "True") {
      trueCount++;
    } else if (arg.symbol === "False") {
    } else {
      unknowns.push(arg);
    }
  }
  if (unknowns.length === 0) {
    return trueCount % 2 === 1 ? ce.True : ce.False;
  }
  if (unknowns.length === 1 && trueCount % 2 === 1) {
    return ce._fn("Not", [unknowns[0]]);
  }
  if (unknowns.length === 1 && trueCount % 2 === 0) {
    return unknowns[0];
  }
  return void 0;
}
function evaluateNand(args, { engine: ce }) {
  if (args.length === 0) return ce.False;
  for (const arg of args) {
    if (arg.symbol === "False") return ce.True;
  }
  let allTrue = true;
  for (const arg of args) {
    if (arg.symbol !== "True") {
      allTrue = false;
      break;
    }
  }
  if (allTrue) return ce.False;
  return void 0;
}
function evaluateNor(args, { engine: ce }) {
  if (args.length === 0) return ce.True;
  for (const arg of args) {
    if (arg.symbol === "True") return ce.False;
  }
  let allFalse = true;
  for (const arg of args) {
    if (arg.symbol !== "False") {
      allFalse = false;
      break;
    }
  }
  if (allFalse) return ce.True;
  return void 0;
}
function toNNF(expr, ce) {
  const op = expr.operator;
  if (!op) return expr;
  if (expr.symbol === "True" || expr.symbol === "False") return expr;
  if (op === "Not") {
    const inner = expr.op1;
    if (!inner) return expr;
    const innerOp = inner.operator;
    if (innerOp === "Not") {
      return toNNF(inner.op1, ce);
    }
    if (innerOp === "And") {
      const negatedOps = inner.ops.map((x) => toNNF(ce._fn("Not", [x]), ce));
      return ce._fn("Or", negatedOps);
    }
    if (innerOp === "Or") {
      const negatedOps = inner.ops.map((x) => toNNF(ce._fn("Not", [x]), ce));
      return ce._fn("And", negatedOps);
    }
    if (inner.symbol === "True") return ce.False;
    if (inner.symbol === "False") return ce.True;
    if (innerOp === "Implies") {
      const a = inner.op1;
      const b = inner.op2;
      return toNNF(ce._fn("And", [a, ce._fn("Not", [b])]), ce);
    }
    if (innerOp === "Equivalent") {
      const a = inner.op1;
      const b = inner.op2;
      return toNNF(
        ce._fn("Or", [
          ce._fn("And", [a, ce._fn("Not", [b])]),
          ce._fn("And", [ce._fn("Not", [a]), b])
        ]),
        ce
      );
    }
    if (innerOp === "Xor") {
      const ops = inner.ops;
      if (ops.length === 2) {
        const a = ops[0];
        const b = ops[1];
        return toNNF(
          ce._fn("Or", [
            ce._fn("And", [a, b]),
            ce._fn("And", [ce._fn("Not", [a]), ce._fn("Not", [b])])
          ]),
          ce
        );
      }
      return toNNF(ce._fn("Not", [toNNF(inner, ce)]), ce);
    }
    if (innerOp === "Nand") {
      return toNNF(ce._fn("And", inner.ops), ce);
    }
    if (innerOp === "Nor") {
      return toNNF(ce._fn("Or", inner.ops), ce);
    }
    return expr;
  }
  if (op === "Implies") {
    const a = expr.op1;
    const b = expr.op2;
    return toNNF(ce._fn("Or", [ce._fn("Not", [a]), b]), ce);
  }
  if (op === "Equivalent") {
    const a = expr.op1;
    const b = expr.op2;
    return toNNF(
      ce._fn("And", [
        ce._fn("Or", [ce._fn("Not", [a]), b]),
        ce._fn("Or", [ce._fn("Not", [b]), a])
      ]),
      ce
    );
  }
  if (op === "Xor") {
    const ops = expr.ops;
    if (ops.length === 2) {
      const a = ops[0];
      const b = ops[1];
      return toNNF(
        ce._fn("And", [
          ce._fn("Or", [a, b]),
          ce._fn("Or", [ce._fn("Not", [a]), ce._fn("Not", [b])])
        ]),
        ce
      );
    }
    if (ops.length > 2) {
      const first = ce._fn("Xor", [ops[0], ops[1]]);
      const rest = ops.slice(2);
      return toNNF(ce._fn("Xor", [first, ...rest]), ce);
    }
    if (ops.length === 1) return toNNF(ops[0], ce);
    return ce.False;
  }
  if (op === "Nand") {
    const ops = expr.ops;
    return toNNF(ce._fn("Not", [ce._fn("And", ops)]), ce);
  }
  if (op === "Nor") {
    const ops = expr.ops;
    return toNNF(ce._fn("Not", [ce._fn("Or", ops)]), ce);
  }
  if (op === "And" || op === "Or") {
    const nnfOps = expr.ops.map((x) => toNNF(x, ce));
    return ce._fn(op, nnfOps);
  }
  return expr;
}
function distributeOrOverAnd(expr, ce) {
  const op = expr.operator;
  if (op !== "Or") {
    if (op === "And") {
      return ce._fn(
        "And",
        expr.ops.map((x) => distributeOrOverAnd(x, ce))
      );
    }
    return expr;
  }
  const orOperands = [];
  for (const operand2 of expr.ops) {
    if (operand2.operator === "Or") {
      orOperands.push(...operand2.ops);
    } else {
      orOperands.push(operand2);
    }
  }
  const andIndex = orOperands.findIndex((x) => x.operator === "And");
  if (andIndex === -1) {
    return expr;
  }
  const andExpr = orOperands[andIndex];
  const otherOperands = [
    ...orOperands.slice(0, andIndex),
    ...orOperands.slice(andIndex + 1)
  ];
  const otherOr = otherOperands.length === 1 ? otherOperands[0] : ce._fn("Or", otherOperands);
  const distributed = ce._fn(
    "And",
    andExpr.ops.map((x) => ce._fn("Or", [x, otherOr]))
  );
  return distributeOrOverAnd(distributed, ce);
}
function toCNF(expr, ce) {
  const nnf = toNNF(expr, ce);
  const cnf = distributeOrOverAnd(nnf, ce);
  return cnf.simplify();
}
function distributeAndOverOr(expr, ce) {
  const op = expr.operator;
  if (op !== "And") {
    if (op === "Or") {
      return ce._fn(
        "Or",
        expr.ops.map((x) => distributeAndOverOr(x, ce))
      );
    }
    return expr;
  }
  const andOperands = [];
  for (const operand2 of expr.ops) {
    if (operand2.operator === "And") {
      andOperands.push(...operand2.ops);
    } else {
      andOperands.push(operand2);
    }
  }
  const orIndex = andOperands.findIndex((x) => x.operator === "Or");
  if (orIndex === -1) {
    return expr;
  }
  const orExpr = andOperands[orIndex];
  const otherOperands = [
    ...andOperands.slice(0, orIndex),
    ...andOperands.slice(orIndex + 1)
  ];
  const otherAnd = otherOperands.length === 1 ? otherOperands[0] : ce._fn("And", otherOperands);
  const distributed = ce._fn(
    "Or",
    orExpr.ops.map((x) => ce._fn("And", [x, otherAnd]))
  );
  return distributeAndOverOr(distributed, ce);
}
function toDNF(expr, ce) {
  const nnf = toNNF(expr, ce);
  const dnf = distributeAndOverOr(nnf, ce);
  return dnf.simplify();
}
function extractVariables(expr) {
  const variables = /* @__PURE__ */ new Set();
  function visit(e) {
    if (e.symbol === "True" || e.symbol === "False") return;
    if (e.symbol && e.operator === "Symbol") {
      variables.add(e.symbol);
      return;
    }
    if (e.ops) {
      for (const op of e.ops) {
        visit(op);
      }
    }
  }
  visit(expr);
  return Array.from(variables).sort();
}
function evaluateWithAssignment(expr, assignment, ce) {
  const subs = {};
  for (const [variable, value] of Object.entries(assignment)) {
    subs[variable] = value ? ce.True : ce.False;
  }
  const substituted = expr.subs(subs).canonical;
  return substituted.evaluate();
}
function* generateAssignments(variables) {
  const n = variables.length;
  const total = 1 << n;
  for (let i = 0; i < total; i++) {
    const assignment = {};
    for (let j = 0; j < n; j++) {
      assignment[variables[j]] = (i >> n - 1 - j & 1) === 1;
    }
    yield assignment;
  }
}
var init_logic_utils = __esm({
  "src/compute-engine/library/logic-utils.ts"() {
  }
});

// src/compute-engine/library/logic-analysis.ts
function filterValuesWithCondition(values, variable, conditionExpr, ce) {
  return values.filter((value) => {
    const substituted = conditionExpr.subs({ [variable]: value });
    const result = substituted.evaluate();
    return result.symbol === "True";
  });
}
function extractFiniteDomainWithReason(condition, ce) {
  if (condition.operator !== "Element") {
    return { status: "error", reason: "expected-element-expression" };
  }
  const variable = condition.op1?.symbol;
  if (!variable) {
    return { status: "error", reason: "expected-index-variable" };
  }
  const domain = condition.op2;
  if (!domain) {
    return { status: "error", reason: "expected-domain" };
  }
  const maybeCondition = condition.op3;
  const filterCondition = condition.nops >= 3 && maybeCondition && maybeCondition.symbol !== "Nothing" ? maybeCondition : null;
  const successResult = (values) => {
    if (filterCondition) {
      const filteredValues = filterValuesWithCondition(
        values,
        variable,
        filterCondition,
        ce
      );
      return { status: "success", variable, values: filteredValues };
    }
    return { status: "success", variable, values };
  };
  if (domain.operator === "Set" || domain.operator === "List") {
    const values = domain.ops;
    if (values && values.length <= 1e3) {
      if (domain.operator === "List" && values.length === 2) {
        const start = asSmallInteger(values[0]);
        const end = asSmallInteger(values[1]);
        if (start !== null && end !== null) {
          const count = end - start + 1;
          if (count > 0 && count <= 1e3) {
            const rangeValues = [];
            for (let i = start; i <= end; i++) {
              rangeValues.push(ce.number(i));
            }
            return successResult(rangeValues);
          }
          if (count > 1e3) {
            return {
              status: "non-enumerable",
              variable,
              domain,
              reason: "domain-too-large"
            };
          }
        }
      }
      return successResult([...values]);
    }
    if (values && values.length > 1e3) {
      return {
        status: "non-enumerable",
        variable,
        domain,
        reason: "domain-too-large"
      };
    }
    return { status: "error", reason: "empty-domain" };
  }
  if (domain.operator === "Range") {
    const start = asSmallInteger(domain.op1);
    const end = asSmallInteger(domain.op2);
    const step = domain.ops && domain.ops.length >= 3 ? asSmallInteger(domain.op3) : 1;
    if (start !== null && end !== null && step !== null && step !== 0) {
      const count = Math.floor((end - start) / step) + 1;
      if (count > 0 && count <= 1e3) {
        const values = [];
        for (let i = start; step > 0 ? i <= end : i >= end; i += step) {
          values.push(ce.number(i));
        }
        return successResult(values);
      }
      if (count > 1e3) {
        return {
          status: "non-enumerable",
          variable,
          domain,
          reason: "domain-too-large"
        };
      }
    }
    return {
      status: "non-enumerable",
      variable,
      domain,
      reason: "non-integer-bounds"
    };
  }
  if (domain.operator === "Interval") {
    let op1 = domain.op1;
    let op2 = domain.op2;
    let openStart = false;
    let openEnd = false;
    if (op1?.operator === "Open") {
      openStart = true;
      op1 = op1.op1;
    } else if (op1?.operator === "Closed") {
      op1 = op1.op1;
    }
    if (op2?.operator === "Open") {
      openEnd = true;
      op2 = op2.op1;
    } else if (op2?.operator === "Closed") {
      op2 = op2.op1;
    }
    let start = asSmallInteger(op1);
    let end = asSmallInteger(op2);
    if (start !== null && end !== null) {
      if (openStart) start += 1;
      if (openEnd) end -= 1;
      const count = end - start + 1;
      if (count > 0 && count <= 1e3) {
        const values = [];
        for (let i = start; i <= end; i++) {
          values.push(ce.number(i));
        }
        return successResult(values);
      }
      if (count > 1e3) {
        return {
          status: "non-enumerable",
          variable,
          domain,
          reason: "domain-too-large"
        };
      }
    }
    return {
      status: "non-enumerable",
      variable,
      domain,
      reason: "non-integer-bounds"
    };
  }
  if (domain.symbol) {
    const knownInfiniteSets = [
      "Integers",
      "NonNegativeIntegers",
      "PositiveIntegers",
      "NegativeIntegers",
      "Rationals",
      "Reals",
      "PositiveReals",
      "NonNegativeReals",
      "NegativeReals",
      "NonPositiveReals",
      "ExtendedReals",
      "Complexes",
      "ImaginaryNumbers",
      "Numbers",
      "ExtendedComplexes",
      "AlgebraicNumbers",
      "TranscendentalNumbers"
    ];
    if (knownInfiniteSets.includes(domain.symbol)) {
      return {
        status: "non-enumerable",
        variable,
        domain,
        reason: "infinite-domain"
      };
    }
    const domainValue = domain.value;
    if (domainValue && domainValue.operator === "Set") {
      const values = domainValue.ops;
      if (values && values.length <= 1e3) {
        return successResult([...values]);
      }
      if (values && values.length > 1e3) {
        return {
          status: "non-enumerable",
          variable,
          domain,
          reason: "domain-too-large"
        };
      }
    }
    return {
      status: "non-enumerable",
      variable,
      domain,
      reason: "unknown-domain"
    };
  }
  return {
    status: "non-enumerable",
    variable,
    domain,
    reason: "unrecognized-domain-type"
  };
}
function extractFiniteDomain(condition, ce) {
  const result = extractFiniteDomainWithReason(condition, ce);
  if (result.status === "success") {
    return { variable: result.variable, values: result.values };
  }
  return null;
}
function bodyContainsVariable(expr, variable) {
  if (expr.symbol === variable) return true;
  if (expr.ops) {
    for (const op of expr.ops) {
      if (bodyContainsVariable(op, variable)) return true;
    }
  }
  return false;
}
function collectNestedDomains(body, ce) {
  const canonicalBody = body.canonical;
  const op = canonicalBody.operator;
  if (op !== "ForAll" && op !== "Exists") return [];
  const condition = canonicalBody.op1;
  const innerBody = canonicalBody.op2;
  if (!condition || !innerBody) return [];
  const domain = extractFiniteDomain(condition, ce);
  if (!domain) return [];
  const innerDomains = collectNestedDomains(innerBody, ce);
  return [
    { variable: domain.variable, values: domain.values },
    ...innerDomains
  ];
}
function getInnermostBody(body) {
  const canonicalBody = body.canonical;
  const op = canonicalBody.operator;
  if (op === "ForAll" || op === "Exists") {
    const innerBody = canonicalBody.op2;
    if (innerBody) return getInnermostBody(innerBody);
  }
  return canonicalBody;
}
function evaluateForAllCartesian(domains, body, ce) {
  const indices = domains.map(() => 0);
  const lengths = domains.map((d) => d.values.length);
  if (lengths.some((l) => l === 0)) return ce.True;
  while (true) {
    const subs = {};
    for (let i = 0; i < domains.length; i++) {
      subs[domains[i].variable] = domains[i].values[indices[i]];
    }
    const substituted = body.subs(subs).canonical;
    const result = substituted.evaluate();
    if (result.symbol === "False") {
      return ce.False;
    }
    if (result.symbol !== "True") {
      return void 0;
    }
    let dim = domains.length - 1;
    while (dim >= 0) {
      indices[dim]++;
      if (indices[dim] < lengths[dim]) break;
      indices[dim] = 0;
      dim--;
    }
    if (dim < 0) break;
  }
  return ce.True;
}
function evaluateExistsCartesian(domains, body, ce) {
  const indices = domains.map(() => 0);
  const lengths = domains.map((d) => d.values.length);
  if (lengths.some((l) => l === 0)) return ce.False;
  while (true) {
    const subs = {};
    for (let i = 0; i < domains.length; i++) {
      subs[domains[i].variable] = domains[i].values[indices[i]];
    }
    const substituted = body.subs(subs).canonical;
    const result = substituted.evaluate();
    if (result.symbol === "True") {
      return ce.True;
    }
    let dim = domains.length - 1;
    while (dim >= 0) {
      indices[dim]++;
      if (indices[dim] < lengths[dim]) break;
      indices[dim] = 0;
      dim--;
    }
    if (dim < 0) break;
  }
  return ce.False;
}
function isSatisfiable(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length === 0) {
    const result = expr.evaluate();
    return result.symbol === "True" ? ce.True : ce.False;
  }
  if (variables.length > 20) {
    return ce._fn("IsSatisfiable", [expr]);
  }
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol === "True") {
      return ce.True;
    }
  }
  return ce.False;
}
function isTautology(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length === 0) {
    const result = expr.evaluate();
    return result.symbol === "True" ? ce.True : ce.False;
  }
  if (variables.length > 20) {
    return ce._fn("IsTautology", [expr]);
  }
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol !== "True") {
      return ce.False;
    }
  }
  return ce.True;
}
function generateTruthTable(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length > 10) {
    return ce._fn("TruthTable", [expr]);
  }
  const rows = [];
  const header = ce._fn("List", [
    ...variables.map((v) => ce.string(v)),
    ce.string("Result")
  ]);
  rows.push(header);
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    const row = ce._fn("List", [
      ...variables.map((v) => assignment[v] ? ce.True : ce.False),
      result
    ]);
    rows.push(row);
  }
  return ce._fn("List", rows);
}
function mintermToQMTerm(minterm, numVars) {
  const term = [];
  for (let i = numVars - 1; i >= 0; i--) {
    term.push(minterm >> i & 1);
  }
  return term;
}
function countOnes(term) {
  return term.filter((x) => x === 1).length;
}
function canCombine(term1, term2) {
  let diffPos = -1;
  for (let i = 0; i < term1.length; i++) {
    if (term1[i] === -1 || term2[i] === -1) {
      if (term1[i] !== term2[i]) return -1;
    } else if (term1[i] !== term2[i]) {
      if (diffPos !== -1) return -1;
      diffPos = i;
    }
  }
  return diffPos;
}
function combineTerms(term1, diffPos) {
  const result = [...term1];
  result[diffPos] = -1;
  return result;
}
function termToString(term) {
  return term.map((x) => x === -1 ? "-" : x.toString()).join("");
}
function findPrimeImplicants(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length > 12) {
    return null;
  }
  if (variables.length === 0) {
    const result = expr.evaluate();
    if (result.symbol === "True") return [ce.True];
    if (result.symbol === "False") return [];
    return null;
  }
  const minterms = [];
  let index = 0;
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol === "True") {
      minterms.push(index);
    }
    index++;
  }
  if (minterms.length === 0) {
    return [];
  }
  if (minterms.length === 1 << variables.length) {
    return [ce.True];
  }
  const primeImplicants = quineMcCluskey(minterms, variables.length);
  return primeImplicants.map((term) => qmTermToExpression(term, variables, ce));
}
function findPrimeImplicates(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length > 12) {
    return null;
  }
  if (variables.length === 0) {
    const result = expr.evaluate();
    if (result.symbol === "True") return [];
    if (result.symbol === "False") return [ce.False];
    return null;
  }
  const maxterms = [];
  let index = 0;
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol === "False") {
      maxterms.push(index);
    }
    index++;
  }
  if (maxterms.length === 0) {
    return [];
  }
  if (maxterms.length === 1 << variables.length) {
    return [ce.False];
  }
  const primeImplicateTerms = quineMcCluskey(maxterms, variables.length);
  return primeImplicateTerms.map((term) => qmTermToClause(term, variables, ce));
}
function quineMcCluskey(minterms, numVars) {
  let currentTerms = /* @__PURE__ */ new Map();
  for (const minterm of minterms) {
    const term = mintermToQMTerm(minterm, numVars);
    currentTerms.set(termToString(term), { term, combined: false });
  }
  const primeImplicants = [];
  while (currentTerms.size > 0) {
    const nextTerms = /* @__PURE__ */ new Map();
    const groups = /* @__PURE__ */ new Map();
    for (const [key, { term }] of currentTerms) {
      const ones = countOnes(term);
      if (!groups.has(ones)) {
        groups.set(ones, []);
      }
      groups.get(ones).push({ key, term });
    }
    const sortedGroupKeys = Array.from(groups.keys()).sort((a, b) => a - b);
    for (let i = 0; i < sortedGroupKeys.length - 1; i++) {
      const group1 = groups.get(sortedGroupKeys[i]);
      const group2 = groups.get(sortedGroupKeys[i + 1]);
      for (const { key: key1, term: term1 } of group1) {
        for (const { key: key2, term: term2 } of group2) {
          const diffPos = canCombine(term1, term2);
          if (diffPos !== -1) {
            const entry1 = currentTerms.get(key1);
            const entry2 = currentTerms.get(key2);
            entry1.combined = true;
            entry2.combined = true;
            const newTerm = combineTerms(term1, diffPos);
            const newKey = termToString(newTerm);
            if (!nextTerms.has(newKey)) {
              nextTerms.set(newKey, { term: newTerm, combined: false });
            }
          }
        }
      }
    }
    for (const { term, combined } of currentTerms.values()) {
      if (!combined) {
        primeImplicants.push(term);
      }
    }
    currentTerms = nextTerms;
  }
  return primeImplicants;
}
function qmTermToExpression(term, variables, ce) {
  const literals = [];
  for (let i = 0; i < term.length; i++) {
    if (term[i] === 1) {
      literals.push(ce.symbol(variables[i]));
    } else if (term[i] === 0) {
      literals.push(ce._fn("Not", [ce.symbol(variables[i])]));
    }
  }
  if (literals.length === 0) return ce.True;
  if (literals.length === 1) return literals[0];
  return ce._fn("And", literals);
}
function qmTermToClause(term, variables, ce) {
  const literals = [];
  for (let i = 0; i < term.length; i++) {
    if (term[i] === 0) {
      literals.push(ce.symbol(variables[i]));
    } else if (term[i] === 1) {
      literals.push(ce._fn("Not", [ce.symbol(variables[i])]));
    }
  }
  if (literals.length === 0) return ce.False;
  if (literals.length === 1) return literals[0];
  return ce._fn("Or", literals);
}
function minimalDNF(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length > 12) {
    return null;
  }
  if (variables.length === 0) {
    const result = expr.evaluate();
    return result.symbol === "True" ? ce.True : ce.False;
  }
  const minterms = [];
  let index = 0;
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol === "True") {
      minterms.push(index);
    }
    index++;
  }
  if (minterms.length === 0) return ce.False;
  if (minterms.length === 1 << variables.length) return ce.True;
  const primeImplicants = quineMcCluskey(minterms, variables.length);
  const cover = findMinimalCover(primeImplicants, minterms, variables.length);
  if (cover.length === 0) return ce.False;
  if (cover.length === 1) return qmTermToExpression(cover[0], variables, ce);
  return ce._fn(
    "Or",
    cover.map((term) => qmTermToExpression(term, variables, ce))
  );
}
function minimalCNF(expr, ce) {
  const variables = extractVariables(expr);
  if (variables.length > 12) {
    return null;
  }
  if (variables.length === 0) {
    const result = expr.evaluate();
    return result.symbol === "True" ? ce.True : ce.False;
  }
  const maxterms = [];
  let index = 0;
  for (const assignment of generateAssignments(variables)) {
    const result = evaluateWithAssignment(expr, assignment, ce);
    if (result.symbol === "False") {
      maxterms.push(index);
    }
    index++;
  }
  if (maxterms.length === 0) return ce.True;
  if (maxterms.length === 1 << variables.length) return ce.False;
  const primeImplicates = quineMcCluskey(maxterms, variables.length);
  const cover = findMinimalCover(primeImplicates, maxterms, variables.length);
  if (cover.length === 0) return ce.True;
  if (cover.length === 1) return qmTermToClause(cover[0], variables, ce);
  return ce._fn(
    "And",
    cover.map((term) => qmTermToClause(term, variables, ce))
  );
}
function getCoveredMinterms(term, numVars) {
  const covered = [];
  const dontCarePositions = [];
  for (let i = 0; i < term.length; i++) {
    if (term[i] === -1) {
      dontCarePositions.push(i);
    }
  }
  const numDontCares = dontCarePositions.length;
  const numCombinations = 1 << numDontCares;
  for (let combo = 0; combo < numCombinations; combo++) {
    let minterm = 0;
    for (let i = 0; i < numVars; i++) {
      const dcIndex = dontCarePositions.indexOf(i);
      let bit;
      if (dcIndex !== -1) {
        bit = combo >> numDontCares - 1 - dcIndex & 1;
      } else {
        bit = term[i];
      }
      minterm = minterm << 1 | bit;
    }
    covered.push(minterm);
  }
  return covered;
}
function findMinimalCover(primes, termsTocover, numVars) {
  const uncovered = new Set(termsTocover);
  const cover = [];
  const mintermToPrimes = /* @__PURE__ */ new Map();
  for (const minterm of termsTocover) {
    mintermToPrimes.set(minterm, []);
  }
  for (let i = 0; i < primes.length; i++) {
    const covered = getCoveredMinterms(primes[i], numVars);
    for (const m of covered) {
      if (mintermToPrimes.has(m)) {
        mintermToPrimes.get(m).push(i);
      }
    }
  }
  const usedPrimes = /* @__PURE__ */ new Set();
  for (const [minterm, coveringPrimes] of mintermToPrimes) {
    if (coveringPrimes.length === 1 && uncovered.has(minterm)) {
      const primeIndex = coveringPrimes[0];
      if (!usedPrimes.has(primeIndex)) {
        usedPrimes.add(primeIndex);
        cover.push(primes[primeIndex]);
        const coveredByPrime = getCoveredMinterms(primes[primeIndex], numVars);
        for (const m of coveredByPrime) {
          uncovered.delete(m);
        }
      }
    }
  }
  while (uncovered.size > 0) {
    let bestPrime = -1;
    let bestCount = 0;
    for (let i = 0; i < primes.length; i++) {
      if (usedPrimes.has(i)) continue;
      const covered = getCoveredMinterms(primes[i], numVars);
      const count = covered.filter((m) => uncovered.has(m)).length;
      if (count > bestCount) {
        bestCount = count;
        bestPrime = i;
      }
    }
    if (bestPrime === -1) break;
    usedPrimes.add(bestPrime);
    cover.push(primes[bestPrime]);
    const coveredByPrime = getCoveredMinterms(primes[bestPrime], numVars);
    for (const m of coveredByPrime) {
      uncovered.delete(m);
    }
  }
  return cover;
}
var init_logic_analysis = __esm({
  "src/compute-engine/library/logic-analysis.ts"() {
    init_numerics();
    init_logic_utils();
  }
});

// src/compute-engine/library/utils.ts
function convertInfiniteSetToLimits(domainSymbol) {
  switch (domainSymbol) {
    case "NonNegativeIntegers":
      return { lower: 0, upper: MAX_ITERATION, isFinite: false };
    case "PositiveIntegers":
      return { lower: 1, upper: 1 + MAX_ITERATION, isFinite: false };
    default:
      return void 0;
  }
}
function normalizeIndexingSet(indexingSet) {
  console.assert(indexingSet?.operator === "Limits");
  let lower = 1;
  let upper = lower + MAX_ITERATION;
  let index = void 0;
  let isFinite2 = true;
  index = indexingSet.op1.symbol;
  console.assert(index, "Indexing set must have an index");
  lower = Math.floor(indexingSet.op2.re);
  if (isNaN(lower)) lower = 1;
  if (!Number.isFinite(lower)) isFinite2 = false;
  if (indexingSet.op3.symbol === "Nothing" || indexingSet.op3.isInfinity) {
    isFinite2 = false;
  } else {
    if (!isNaN(indexingSet.op3.re))
      upper = Math.floor(indexingSet.op3.re ?? upper);
    if (!Number.isFinite(upper)) isFinite2 = false;
  }
  if (!isFinite2 && Number.isFinite(lower)) upper = lower + MAX_ITERATION;
  return { index, lower, upper, isFinite: isFinite2 };
}
function normalizeIndexingSets(ops) {
  return ops.map((op) => normalizeIndexingSet(op));
}
function indexingSetCartesianProduct(indexingSets) {
  console.assert(indexingSets.length > 0, "Indexing sets must not be empty");
  let { index, lower, upper, isFinite: isFinite2 } = indexingSets[0];
  if (!isFinite2) upper = lower + MAX_ITERATION;
  let result = fromRange(lower, upper).map((x) => [x]);
  if (indexingSets.length === 1) return result;
  for (let i = 1; i < indexingSets.length; i++) {
    let { index: index2, lower: lower2, upper: upper2, isFinite: isFinite3 } = indexingSets[i];
    if (!isFinite3) upper2 = lower2 + MAX_ITERATION;
    result = cartesianProduct(
      result.map((x) => x[0]),
      fromRange(lower2, upper2)
    );
  }
  return result;
}
function cartesianProduct(array1, array2) {
  return array1.flatMap((item1) => array2.map((item2) => [item1, item2]));
}
function canonicalLimitsSequence(ops, options) {
  const ce = options.engine;
  const result = [];
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.operator === "Range") {
      result.push(
        canonicalLimits([ce.Nothing, op.op1, op.op2], options) ?? ce.error("missing")
      );
    } else if (op.operator && ["Limits", "Tuple", "Triple", "Pair", "Single", "Hold"].includes(
      op.operator
    )) {
      result.push(canonicalLimits(op.ops, options) ?? ce.error("missing"));
    } else if (op.symbol) {
      if (ops[i + 1]?.isNumberLiteral) {
        if (ops[i + 2]?.isNumberLiteral) {
          result.push(
            canonicalLimits([op, ops[i + 1], ops[i + 2]], options) ?? ce.error("missing")
          );
          i += 2;
        } else {
          result.push(
            canonicalLimits([op, ops[i + 1]], options) ?? ce.error("missing")
          );
          i += 1;
        }
      } else {
        result.push(canonicalLimits([op], options) ?? ce.error("missing"));
      }
    }
  }
  return result;
}
function canonicalLimits(ops, { engine: ce }) {
  if (ops.length === 1) {
    const op = ops[0];
    if (op.symbol) return ce._fn("Limits", [op, ce.Nothing, ce.Nothing]);
    if (op.operator === "Hold") return canonicalLimits(op.ops, { engine: ce });
    return ce._fn("Limits", [ce.typeError("symbol", void 0, op)]);
  } else if (ops.length > 1) {
    let index = ce.Nothing;
    let lower = ce.Nothing;
    let upper = ops[1].canonical;
    if (ops.length === 2) {
      if (ops[0].operator === "Hold") {
        index = ops[0].op1;
        upper = ops[1].canonical;
      } else if (ops[0].symbol) {
        index = ops[0];
        upper = ops[1].canonical;
      } else {
        index = ce.Nothing;
        lower = ops[0].canonical;
        upper = ops[1].canonical;
      }
    } else if (ops.length === 3) {
      index = ops[0] ?? ce.Nothing;
      lower = ops[1]?.canonical ?? ce.Nothing;
      upper = ops[2]?.canonical ?? ce.Nothing;
    }
    if (index.operator === "Hold") index = index.op1;
    if (!index.symbol) index = ce.typeError("symbol", index.type, index);
    return ce._fn("Limits", [index, lower, upper]);
  }
  return null;
}
function canonicalIndexingSet(expr) {
  const ce = expr.engine;
  let index;
  let upper = null;
  let lower = null;
  if (expr.operator === "Element") {
    const indexExpr = expr.op1;
    const collection = expr.op2;
    const condition = expr.op3;
    if (!indexExpr?.symbol) return void 0;
    if (indexExpr.symbol !== "Nothing") ce.declare(indexExpr.symbol, "integer");
    if (condition) {
      return ce.function("Element", [
        indexExpr.canonical,
        collection.canonical,
        condition.canonical
      ]);
    }
    return ce.function("Element", [indexExpr.canonical, collection.canonical]);
  }
  if (expr.operator === "Limits") {
    const canonicalIndex = expr.op1.canonical;
    const canonicalLower = expr.op2?.canonical ?? ce.Nothing;
    const canonicalUpper = expr.op3?.canonical ?? ce.Nothing;
    if (!canonicalIndex.symbol)
      return ce.function("Limits", [
        ce.typeError("symbol", void 0, canonicalIndex)
      ]);
    return ce.function("Limits", [
      canonicalIndex,
      canonicalLower,
      canonicalUpper
    ]);
  }
  if (expr.operator === "Tuple" || expr.operator === "Triple" || expr.operator === "Pair" || expr.operator === "Single") {
    index = expr.op1;
    lower = expr.ops[1]?.canonical ?? null;
    upper = expr.ops[2]?.canonical ?? null;
  } else index = expr;
  if (index.operator === "Hold") index = index.op1;
  if (!index.symbol) return void 0;
  if (index.symbol && index.symbol !== "Nothing")
    ce.declare(index.symbol, "integer");
  if (upper && lower) return ce.function("Limits", [index, lower, upper]);
  if (upper) return ce.function("Limits", [index, ce.One, upper]);
  if (lower) return ce.function("Limits", [index, lower]);
  return ce.function("Limits", [index]);
}
function canonicalBigop(bigOp2, body, indexingSets, scope) {
  const ce = body.engine;
  ce.pushScope(scope);
  const indexes = indexingSets.map(
    (x) => canonicalIndexingSet(x) ?? ce.error("missing")
  );
  body = body?.canonical ?? ce.error("missing");
  ce.popScope();
  if (body.isCollection) {
    if (bigOp2 === "Sum") return ce.box(["Reduce", body, "Add", 0]);
    return ce.box(["Reduce", body, "Multiply", 1]);
  }
  return ce._fn(bigOp2, [body, ...indexes], { scope });
}
function* reduceBigOp(body, indexes, fn, initial) {
  if (body.isCollection)
    return yield* reduceCollection(body.evaluate(), fn, initial);
  if (indexes.length === 0) return fn(initial, body) ?? void 0;
  const ce = body.engine;
  const elementSets = indexes.filter((x) => x.operator === "Element");
  if (elementSets.length > 0) {
    const gen = reduceElementIndexingSets(body, indexes, fn, initial, true);
    let iterResult = gen.next();
    while (!iterResult.done) {
      const result2 = iterResult.value;
      if (result2 !== void 0 && typeof result2 !== "object") {
        yield result2;
      }
      iterResult = gen.next();
    }
    const finalResult = iterResult.value;
    if (finalResult && typeof finalResult === "object" && "status" in finalResult) {
      const typedResult = finalResult;
      if (typedResult.status === "success") {
        return typedResult.value;
      }
      if (typedResult.status === "non-enumerable") {
        return NON_ENUMERABLE_DOMAIN;
      }
      return void 0;
    }
    return finalResult;
  }
  const indexingSets = normalizeIndexingSets(indexes);
  const cartesianArray = indexingSetCartesianProduct(indexingSets);
  let result = initial;
  let counter = 0;
  for (const element of cartesianArray) {
    indexingSets.forEach((x, i) => ce.assign(x.index, element[i]));
    result = fn(result, body) ?? void 0;
    counter += 1;
    if (counter % 1e3 === 0) yield result;
    if (result === void 0) break;
  }
  return result ?? void 0;
}
function* reduceElementIndexingSets(body, indexes, fn, initial, returnReason = false) {
  const ce = body.engine;
  const elementDomains = [];
  const limitsSets = [];
  for (const idx of indexes) {
    if (idx.operator === "Element") {
      const domainResult = extractFiniteDomainWithReason(idx, ce);
      if (domainResult.status === "error") {
        if (returnReason) {
          return {
            status: "error",
            reason: domainResult.reason
          };
        }
        return void 0;
      }
      if (domainResult.status === "non-enumerable") {
        if (domainResult.reason === "infinite-domain" && domainResult.domain?.symbol) {
          const limits = convertInfiniteSetToLimits(domainResult.domain.symbol);
          if (limits) {
            limitsSets.push({
              index: domainResult.variable,
              ...limits
            });
            continue;
          }
        }
        if (returnReason) {
          return {
            status: "non-enumerable",
            reason: domainResult.reason,
            domain: domainResult.domain
          };
        }
        return void 0;
      }
      elementDomains.push({
        variable: domainResult.variable,
        values: domainResult.values
      });
    } else {
      limitsSets.push(normalizeIndexingSet(idx));
    }
  }
  if (limitsSets.length > 0) {
    for (const limits of limitsSets) {
      const values = [];
      for (let i = limits.lower; i <= limits.upper; i++) {
        values.push(ce.number(i));
      }
      elementDomains.push({ variable: limits.index, values });
    }
  }
  const indices = elementDomains.map(() => 0);
  const lengths = elementDomains.map((d) => d.values.length);
  if (lengths.some((l) => l === 0)) {
    if (returnReason) {
      return { status: "success", value: initial };
    }
    return initial;
  }
  let result = initial;
  let counter = 0;
  while (true) {
    for (let i = 0; i < elementDomains.length; i++) {
      ce.assign(
        elementDomains[i].variable,
        elementDomains[i].values[indices[i]]
      );
    }
    result = fn(result, body) ?? void 0;
    counter++;
    if (counter % 1e3 === 0) yield result;
    if (result === void 0) break;
    let dim = elementDomains.length - 1;
    while (dim >= 0) {
      indices[dim]++;
      if (indices[dim] < lengths[dim]) break;
      indices[dim] = 0;
      dim--;
    }
    if (dim < 0) break;
  }
  if (returnReason) {
    return { status: "success", value: result };
  }
  return result ?? void 0;
}
var NON_ENUMERABLE_DOMAIN;
var init_utils4 = __esm({
  "src/compute-engine/library/utils.ts"() {
    init_numeric();
    init_collections();
    init_logic_analysis();
    NON_ENUMERABLE_DOMAIN = Symbol("non-enumerable-domain");
  }
});

// src/compute-engine/compilation/base-compiler.ts
var base_compiler_exports = {};
__export(base_compiler_exports, {
  BaseCompiler: () => BaseCompiler
});
var BaseCompiler;
var init_base_compiler = __esm({
  "src/compute-engine/compilation/base-compiler.ts"() {
    init_utils5();
    init_collection_utils();
    init_utils3();
    init_utils4();
    BaseCompiler = class _BaseCompiler {
      /**
       * Compile an expression to target language source code
       */
      static compile(expr, target, prec = 0) {
        if (expr === void 0) return "";
        if (!expr.isValid) {
          throw new Error(
            `Cannot compile invalid expression: "${expr.toString()}"`
          );
        }
        const s = expr.symbol;
        if (s !== null) {
          const op = target.operators?.(s);
          if (op !== void 0) {
            return `(a,b) => a ${op[0]} b`;
          }
          return target.var?.(s) ?? s;
        }
        if (expr.isNumberLiteral) {
          if (expr.im !== 0) throw new Error("Complex numbers are not supported");
          return target.number(expr.re);
        }
        const str = expr.string;
        if (str !== null) return target.string(str);
        return _BaseCompiler.compileExpr(
          expr.engine,
          expr.operator,
          expr.ops,
          prec,
          target
        );
      }
      /**
       * Compile a function expression
       */
      static compileExpr(engine, h, args, prec, target) {
        if (h === "Error") throw new Error("Error");
        if (h === "Sequence") {
          if (args.length === 0) return "";
          return `(${args.map((arg) => _BaseCompiler.compile(arg, target, prec)).join(", ")})`;
        }
        if (h === "Sum" || h === "Product") {
          return _BaseCompiler.compileLoop(h, args, target);
        }
        const op = target.operators?.(h);
        if (op !== void 0) {
          const isFunction2 = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(op[0]);
          if (isFunction2) {
            if (args === null) return `${op[0]}()`;
            return `${op[0]}(${args.map((arg) => _BaseCompiler.compile(arg, target)).join(", ")})`;
          } else {
            if (args.every((x) => !x.isCollection)) {
              if (isRelationalOperator(h) && args.length > 2) {
                const result = [];
                for (let i = 0; i < args.length - 1; i++) {
                  result.push(
                    _BaseCompiler.compileExpr(
                      engine,
                      h,
                      [args[i], args[i + 1]],
                      op[1],
                      target
                    )
                  );
                }
                return `(${result.join(") && (")})`;
              }
              if (args === null) return "";
              let resultStr;
              if (args.length === 1) {
                resultStr = `${op[0]}${_BaseCompiler.compile(args[0], target, op[1])}`;
              } else {
                resultStr = args.map((arg) => _BaseCompiler.compile(arg, target, op[1])).join(` ${op[0]} `);
              }
              return op[1] < prec ? `(${resultStr})` : resultStr;
            }
          }
        }
        if (h === "Function") {
          const params = args.slice(1).map((x) => x.symbol);
          return `((${params.join(", ")}) => ${_BaseCompiler.compile(
            args[0].canonical,
            {
              ...target,
              var: (id) => params.includes(id) ? id : target.var(id)
            }
          )})`;
        }
        if (h === "Declare") return `let ${args[0].symbol}`;
        if (h === "Assign")
          return `${args[0].symbol} = ${_BaseCompiler.compile(args[1], target)}`;
        if (h === "Return")
          return `return ${_BaseCompiler.compile(args[0], target)}`;
        if (h === "If") {
          if (args.length !== 3) throw new Error("If: wrong number of arguments");
          const fn2 = target.functions?.(h);
          if (fn2) {
            if (typeof fn2 === "function") {
              return fn2(args, (expr) => _BaseCompiler.compile(expr, target), target);
            }
            if (args === null) return `${fn2}()`;
            return `${fn2}(${args.map((x) => _BaseCompiler.compile(x, target)).join(", ")})`;
          }
          return `((${_BaseCompiler.compile(args[0], target)}) ? (${_BaseCompiler.compile(
            args[1],
            target
          )}) : (${_BaseCompiler.compile(args[2], target)}))`;
        }
        if (h === "Block") {
          return _BaseCompiler.compileBlock(args, target);
        }
        const fn = target.functions?.(h);
        if (!fn) throw new Error(`Unknown operator \`${h}\``);
        if (typeof fn === "function") {
          const def = engine.lookupDefinition(h);
          if (isOperatorDef(def) && def.operator.broadcastable && args.length === 1 && isFiniteIndexedCollection(args[0])) {
            const v = _BaseCompiler.tempVar();
            return `(${_BaseCompiler.compile(args[0], target)}).map((${v}) => ${fn(
              [args[0].engine.box(v)],
              (expr) => _BaseCompiler.compile(expr, target),
              target
            )})`;
          }
          return fn(args, (expr) => _BaseCompiler.compile(expr, target), target);
        }
        if (args === null) return `${fn}()`;
        return `${fn}(${args.map((x) => _BaseCompiler.compile(x, target)).join(", ")})`;
      }
      /**
       * Compile a block expression
       */
      static compileBlock(args, target) {
        const locals = [];
        for (const arg of args) {
          if (arg.operator === "Declare") locals.push(arg.ops[0].symbol);
        }
        if (args.length === 1 && locals.length === 0) {
          return _BaseCompiler.compile(args[0], target);
        }
        const result = args.map(
          (arg) => _BaseCompiler.compile(arg, {
            ...target,
            var: (id) => {
              if (locals.includes(id)) return id;
              return target.var(id);
            }
          })
        );
        result[result.length - 1] = `return ${result[result.length - 1]}`;
        return `(() => {${target.ws("\n")}${result.join(
          `;${target.ws("\n")}`
        )}${target.ws("\n")}})()`;
      }
      /**
       * Compile loop constructs (Sum/Product)
       */
      static compileLoop(h, args, target) {
        if (args === null) throw new Error("Sum/Product: no arguments");
        if (!args[0]) throw new Error("Sum/Product: no body");
        const { index, lower, upper, isFinite: isFinite2 } = normalizeIndexingSet(args[1]);
        const op = h === "Sum" ? "+" : "*";
        if (!index) {
          const indexVar = _BaseCompiler.tempVar();
          const acc2 = _BaseCompiler.tempVar();
          const col = _BaseCompiler.compile(args[0], target);
          return `${col}.reduce((${acc2}, ${indexVar}) => ${acc2} ${op} ${indexVar}, ${op === "+" ? "0" : "1"})`;
        }
        const fn = _BaseCompiler.compile(args[0], {
          ...target,
          var: (id) => {
            if (id === index) return index;
            return target.var(id);
          }
        });
        const acc = _BaseCompiler.tempVar();
        return `(() => {
  let ${acc} = ${op === "+" ? "0" : "1"};
  let ${index} = ${lower};
  while (${index} <= ${upper}) {
    ${acc} ${op}= ${fn};
    ${index}++;
  }
  return ${acc};
})()`;
      }
      /**
       * Generate a temporary variable name
       */
      static tempVar() {
        return `_${Math.random().toString(36).substring(4)}`;
      }
      /**
       * Inline or wrap expression in IIFE based on complexity
       */
      static inlineExpression(body, x) {
        const isSimple = /^[\p{L}_][\p{L}\p{N}_]*$/u.test(x) || /^[0-9]+$/.test(x);
        if (isSimple) {
          return new Function("x", `return \`${body}\`;`)(x);
        } else {
          const t = _BaseCompiler.tempVar();
          return new Function(
            "x",
            `return \`(() => { const ${t} = \${x}; return ${body.replace(/\\\${x}/g, t)}; })()\`;`
          )(x);
        }
      }
    };
  }
});

// src/compute-engine/boxed-expression/abstract-boxed-expression.ts
function getSubexpressions(expr, name) {
  const result = !name || expr.operator === name ? [expr] : [];
  if (expr.ops) {
    for (const op of expr.ops) result.push(...getSubexpressions(op, name));
  }
  return result;
}
function getSymbols(expr, result) {
  if (expr.symbol) {
    result.add(expr.symbol);
    return;
  }
  if (expr.ops) for (const op of expr.ops) getSymbols(op, result);
}
function getUnknowns(expr, result) {
  if (expr.symbol) {
    const s = expr.symbol;
    if (s === "Unknown" || s === "Undefined" || s === "Nothing") return;
    if (expr.valueDefinition?.isConstant) return;
    if (expr.operatorDefinition) return;
    const value = expr.engine._getSymbolValue(s);
    if (value === void 0) result.add(s);
    return;
  }
  if (expr.ops) for (const op of expr.ops) getUnknowns(op, result);
}
var _BoxedExpression;
var init_abstract_boxed_expression = __esm({
  "src/compute-engine/boxed-expression/abstract-boxed-expression.ts"() {
    init_boxed_type();
    init_serializer_style();
    init_serializer();
    init_ascii_math();
    init_compare();
    init_interruptible();
    _BoxedExpression = class {
      engine;
      /** Verbatim LaTeX, obtained from a source, i.e. from parsing,
       *  not generated synthetically
       */
      verbatimLatex;
      constructor(ce, metadata) {
        this.engine = ce;
        if (metadata?.latex !== void 0) this.verbatimLatex = metadata.latex;
      }
      /**
       *
       * `Object.valueOf()`: return a JavaScript primitive value for the expression
       *
       * Primitive values are: boolean, number, bigint, string, null, undefined
       *
       */
      valueOf() {
        try {
          if (this.symbol === "True") return true;
          if (this.symbol === "False") return false;
          if (this.symbol === "NaN") return NaN;
          if (this.symbol === "PositiveInfinity") return Infinity;
          if (this.symbol === "NegativeInfinity") return -Infinity;
          if (this.symbol === "ComplexInfinity") return "~oo";
          if (this.isInfinity) {
            if (this.isPositive) return Infinity;
            if (this.isNegative) return -Infinity;
            return "~oo";
          }
          if (typeof this.string === "string") return this.string;
          if (typeof this.symbol === "string")
            return this.value?.valueOf() ?? this.symbol;
          return toAsciiMath(this);
        } catch (e) {
          if (e instanceof CancellationError) {
            const msg = e.message ?? "<canceled>";
            return e.cause ? `${msg}: ${e.cause}` : `${msg}`;
          }
          if (e.message) return e.message;
          return "<error>";
        }
      }
      [Symbol.toPrimitive](hint) {
        if (hint === "number") {
          const v = this.valueOf();
          return typeof v === "number" ? v : null;
        }
        return this.toString();
      }
      /** Object.toString() */
      toString() {
        try {
          if (this.isLazyCollection) {
            const materialized = this.evaluate({ materialization: true });
            if (!materialized.isLazyCollection) return toAsciiMath(materialized);
          }
          return toAsciiMath(this);
        } catch (e) {
          if (e instanceof CancellationError) {
            const msg = e.message ?? "<canceled>";
            return e.cause ? `${msg}: ${e.cause}` : `${msg}`;
          }
          if (e.message) return e.message;
          return "<error>";
        }
      }
      toLatex(options) {
        if (this.isLazyCollection) {
          const materialized = this.evaluate({
            materialization: options?.materialization ?? true
          });
          if (!materialized.isLazyCollection) return materialized.toLatex(options);
        }
        const json = this.toMathJson({ prettify: options?.prettify ?? true });
        let effectiveOptions = {
          imaginaryUnit: "\\imaginaryI",
          positiveInfinity: "\\infty",
          negativeInfinity: "-\\infty",
          notANumber: "\\operatorname{NaN}",
          decimalSeparator: this.engine.decimalSeparator,
          digitGroupSeparator: "\\,",
          // for thousands, etc...
          exponentProduct: "\\cdot",
          beginExponentMarker: "10^{",
          // could be 'e'
          endExponentMarker: "}",
          digitGroup: 3,
          truncationMarker: "\\ldots",
          repeatingDecimal: "vinculum",
          fractionalDigits: "max",
          notation: "auto",
          avoidExponentsInRange: [-7, 20],
          prettify: true,
          // (overridden subseq. by options)
          materialization: false,
          invisibleMultiply: "",
          // '\\cdot',
          invisiblePlus: "",
          // '+',
          // invisibleApply: '',
          multiply: "\\times",
          missingSymbol: "\\blacksquare",
          // openGroup: '(',
          // closeGroup: ')',
          // divide: '\\frac{#1}{#2}',
          // subtract: '#1-#2',
          // add: '#1+#2',
          // negate: '-#1',
          // squareRoot: '\\sqrt{#1}',
          // nthRoot: '\\sqrt[#2]{#1}',
          applyFunctionStyle: getApplyFunctionStyle,
          groupStyle: getGroupStyle,
          rootStyle: getRootStyle,
          fractionStyle: getFractionStyle,
          logicStyle: getLogicStyle,
          powerStyle: getPowerStyle,
          numericSetStyle: getNumericSetStyle
        };
        if (options?.fractionalDigits === "auto")
          effectiveOptions.fractionalDigits = -this.engine.precision;
        else effectiveOptions.fractionalDigits = options?.fractionalDigits ?? "max";
        if (typeof effectiveOptions.fractionalDigits === "number" && effectiveOptions.fractionalDigits > this.engine.precision)
          effectiveOptions.fractionalDigits = this.engine.precision;
        effectiveOptions = {
          ...effectiveOptions,
          ...options ?? {},
          fractionalDigits: effectiveOptions.fractionalDigits
        };
        if (!effectiveOptions.prettify && this.verbatimLatex)
          return this.verbatimLatex;
        return serializeLatex(
          json,
          this.engine._indexedLatexDictionary,
          effectiveOptions
        );
      }
      get latex() {
        return this.toLatex();
      }
      /** Called by `JSON.stringify()` when serializing to json.
       *
       * Note: this is a standard method of JavaScript objects.
       *
       */
      toJSON() {
        return this.json;
      }
      toMathJson(options) {
        const defaultOptions = {
          exclude: [],
          shorthands: ["function", "symbol", "string", "number", "dictionary"],
          metadata: [],
          fractionalDigits: "max",
          repeatingDecimal: true,
          prettify: true
        };
        if (options) {
          if (typeof options.shorthands === "string" && options.shorthands === "all" || options.shorthands?.includes("all")) {
            defaultOptions.shorthands = [
              "function",
              "symbol",
              "string",
              "number",
              "dictionary"
            ];
          }
          if (Array.isArray(options.shorthands))
            defaultOptions.shorthands = options.shorthands;
          if (typeof options.metadata === "string" && options.metadata === "all" || options.metadata?.includes("all")) {
            defaultOptions.metadata = ["latex", "wikidata"];
          }
          if (options.fractionalDigits === "auto")
            defaultOptions.fractionalDigits = -this.engine.precision;
          if (typeof options.fractionalDigits === "number")
            defaultOptions.fractionalDigits = options.fractionalDigits;
        }
        const opts = {
          ...defaultOptions,
          ...options,
          fractionalDigits: defaultOptions.fractionalDigits,
          shorthands: defaultOptions.shorthands,
          metadata: defaultOptions.metadata
        };
        const { serializeJson: serializeJson2 } = (init_serialize2(), __toCommonJS(serialize_exports));
        return serializeJson2(this.engine, this, opts);
      }
      print() {
        const log3 = console["info"];
        log3?.(this.toString());
      }
      get isStructural() {
        return true;
      }
      get canonical() {
        return this;
      }
      get structural() {
        return this;
      }
      get isValid() {
        return true;
      }
      get isPure() {
        return false;
      }
      get isConstant() {
        return true;
      }
      get isNumberLiteral() {
        return false;
      }
      get numericValue() {
        return null;
      }
      toNumericValue() {
        return [this.engine._numericValue(1), this];
      }
      get isEven() {
        return void 0;
      }
      get isOdd() {
        return void 0;
      }
      get re() {
        return NaN;
      }
      get im() {
        return NaN;
      }
      get bignumRe() {
        return void 0;
      }
      get bignumIm() {
        return void 0;
      }
      get sgn() {
        return void 0;
      }
      // x > 0
      get isPositive() {
        return void 0;
      }
      // x >= 0
      get isNonNegative() {
        return void 0;
      }
      // x < 0
      get isNegative() {
        return void 0;
      }
      // x <= 0
      get isNonPositive() {
        return void 0;
      }
      //
      // Algebraic operations
      //
      neg() {
        return this.engine.NaN;
      }
      inv() {
        return this.engine.NaN;
      }
      abs() {
        return this.engine.NaN;
      }
      add(rhs) {
        return this.engine.NaN;
      }
      sub(rhs) {
        return this.add(rhs.neg());
      }
      mul(rhs) {
        return this.engine.NaN;
      }
      div(rhs) {
        return this.engine.NaN;
      }
      pow(exp3) {
        return this.engine.NaN;
      }
      root(exp3) {
        return this.engine.NaN;
      }
      sqrt() {
        return this.engine.NaN;
      }
      ln(base) {
        return this.engine.NaN;
      }
      get numerator() {
        return this;
      }
      get denominator() {
        return this.engine.One;
      }
      get numeratorDenominator() {
        return [this, this.engine.One];
      }
      is(other) {
        if (typeof other === "number" || typeof other === "bigint") return false;
        if (other === null || other === void 0) return false;
        if (typeof other === "boolean") {
          if (other === true) return this.value?.symbol === "True";
          if (other === false) return this.value?.symbol === "False";
          return false;
        }
        if (typeof other === "string") return this.value?.string === other;
        return same(this, this.engine.box(other));
      }
      isSame(other) {
        return same(this, other);
      }
      isEqual(other) {
        return eq(this, other);
      }
      isLess(other) {
        const c = cmp(this, other);
        if (c === void 0) return void 0;
        return c === "<";
      }
      isLessEqual(other) {
        const c = cmp(this, other);
        if (c === void 0) return void 0;
        return c === "<=" || c === "<" || c === "=";
      }
      isGreater(other) {
        const c = cmp(this, other);
        if (c === void 0) return void 0;
        return c === ">";
      }
      isGreaterEqual(other) {
        const c = cmp(this, other);
        if (c === void 0) return void 0;
        return c === ">=" || c === ">" || c === "=";
      }
      get symbol() {
        return null;
      }
      get tensor() {
        return null;
      }
      get string() {
        return null;
      }
      getSubexpressions(operator2) {
        return getSubexpressions(this, operator2);
      }
      get subexpressions() {
        return this.getSubexpressions("");
      }
      get symbols() {
        const set = /* @__PURE__ */ new Set();
        getSymbols(this, set);
        return Array.from(set).sort();
      }
      get unknowns() {
        const set = /* @__PURE__ */ new Set();
        getUnknowns(this, set);
        return Array.from(set).sort();
      }
      get errors() {
        return this.getSubexpressions("Error");
      }
      get isFunctionExpression() {
        return false;
      }
      // Only return non-null for functions
      get ops() {
        return null;
      }
      get isScoped() {
        return false;
      }
      get localScope() {
        return void 0;
      }
      get nops() {
        return 0;
      }
      get op1() {
        return this.engine.Nothing;
      }
      get op2() {
        return this.engine.Nothing;
      }
      get op3() {
        return this.engine.Nothing;
      }
      get isNaN() {
        return void 0;
      }
      get isInfinity() {
        return void 0;
      }
      // Not +- Infinity, not NaN
      get isFinite() {
        return void 0;
      }
      get shape() {
        return [];
      }
      get rank() {
        return 0;
      }
      subs(_sub, options) {
        return options?.canonical === true ? this.canonical : this;
      }
      map(fn, options) {
        if (!this.ops) return fn(this);
        const canonical2 = options?.canonical ?? this.isCanonical;
        const recursive = options?.recursive ?? true;
        const ops = this.ops.map((x) => recursive ? x.map(fn, options) : fn(x));
        return fn(this.engine.function(this.operator, ops, { canonical: canonical2 }));
      }
      solve(_vars) {
        return null;
      }
      replace(_rules) {
        return null;
      }
      has(_v) {
        return false;
      }
      get description() {
        if (!this.baseDefinition) return void 0;
        if (!this.baseDefinition.description) return void 0;
        if (typeof this.baseDefinition.description === "string")
          return [this.baseDefinition.description];
        return this.baseDefinition.description;
      }
      get url() {
        return this.baseDefinition?.url ?? void 0;
      }
      get wikidata() {
        return this.baseDefinition?.wikidata ?? void 0;
      }
      // set wikidata(val: string | undefined) {}
      get complexity() {
        return void 0;
      }
      get baseDefinition() {
        return void 0;
      }
      get valueDefinition() {
        return void 0;
      }
      get operatorDefinition() {
        return void 0;
      }
      infer(t, inferenceMode) {
        return false;
      }
      bind() {
        return;
      }
      reset() {
        return;
      }
      get value() {
        return void 0;
      }
      set value(_value) {
        throw new Error(`Can't change the value of \\(${this.toString()}\\)`);
      }
      get type() {
        return BoxedType.unknown;
      }
      set type(_type) {
        throw new Error(`Can't change the type of \\(${this.toString()}\\)`);
      }
      get isNumber() {
        return void 0;
      }
      get isInteger() {
        return void 0;
      }
      get isRational() {
        return void 0;
      }
      get isReal() {
        return void 0;
      }
      simplify(_options) {
        return this;
      }
      trigSimplify() {
        return this.simplify({ strategy: "fu" });
      }
      expand() {
        const { expand: expand3 } = (init_expand(), __toCommonJS(expand_exports));
        return expand3(this) ?? this;
      }
      evaluate(_options) {
        return this.simplify();
      }
      evaluateAsync(_options) {
        return Promise.resolve(this.evaluate());
      }
      N() {
        return this.evaluate({ numericApproximation: true });
      }
      compile(options) {
        try {
          const expr = this;
          let languageTarget;
          if (options?.target) {
            const { BaseCompiler: BaseCompiler2 } = (init_base_compiler(), __toCommonJS(base_compiler_exports));
            const code = BaseCompiler2.compile(expr, options.target);
            const result = function() {
              return code;
            };
            Object.defineProperty(result, "toString", { value: () => code });
            Object.defineProperty(result, "isCompiled", { value: true });
            return result;
          }
          const targetName = options?.to ?? "javascript";
          languageTarget = this.engine._getCompilationTarget(targetName);
          if (!languageTarget) {
            throw new Error(
              `Compilation target "${targetName}" is not registered. Available targets: ${Array.from(this.engine["_compilationTargets"].keys()).join(", ")}`
            );
          }
          return languageTarget.compileToExecutable(expr, {
            operators: options?.operators,
            functions: options?.functions,
            vars: options?.vars,
            imports: options?.imports,
            preamble: options?.preamble
          });
        } catch (e) {
          if (options?.fallback ?? true) {
            const { applicableN1: applicableN12 } = (init_function_utils(), __toCommonJS(function_utils_exports));
            return applicableN12(this);
          }
          throw e;
        }
      }
      get isCollection() {
        return false;
      }
      get isIndexedCollection() {
        return false;
      }
      get isLazyCollection() {
        return false;
      }
      contains(_rhs) {
        return void 0;
      }
      subsetOf(_target, _strict) {
        return void 0;
      }
      get count() {
        return void 0;
      }
      get isEmptyCollection() {
        if (!this.isCollection) return void 0;
        const count = this.count;
        if (count === void 0) return void 0;
        return count === 0;
      }
      get isFiniteCollection() {
        if (!this.isCollection) return void 0;
        const count = this.count;
        if (count === void 0) return void 0;
        return Number.isFinite(count);
      }
      each() {
        return (function* () {
        })();
      }
      at(_index) {
        return void 0;
      }
      get(_key) {
        return void 0;
      }
      indexWhere(_predicate) {
        return void 0;
      }
    };
  }
});

// src/compute-engine/boxed-expression/rules.ts
function checkConditions(x, conditions) {
  for (const cond of conditions) if (CONDITIONS[cond](x) !== true) return false;
  return true;
}
function tokenizeLaTeX(input) {
  const regex = /\\[a-zA-Z]+|[{}]|[\d]+|[+\-*/^_=()><,.;]|[a-zA-Z]/g;
  const tokens = input.match(regex);
  if (!tokens) return [];
  return tokens.filter((x) => !/^[ \f\n\r\t\v\xA0\u2028\u2029]+$/.test(x));
}
function parseModifier(parser) {
  const next = parser.peek;
  let modifier = null;
  if (next === "\\mathrm") {
    parser.nextToken();
    modifier = parser.parseStringGroup();
  } else if (/^[a-z]$/.test(next)) {
    modifier = parser.nextToken();
    while (/^[a-z]$/.test(parser.peek)) modifier += parser.nextToken();
  } else {
    const shortcuts = {
      ">0": "positive",
      "\\gt0": "positive",
      "<0": "negative",
      "\\lt0": "negative",
      ">=0": "nonnegative",
      "\\geq0": "nonnegative",
      "<=0": "nonpositive",
      "\\leq0": "nonpositive",
      "!=0": "notzero",
      "\\neq0": "notzero",
      "\\neq1": "notone",
      "!=1": "notone",
      "\\in\\R": "real",
      "\\in\\mathbb{R}": "real",
      "\\in\\C": "complex",
      "\\in\\mathbb{C}": "complex",
      "\\in\\Q": "rational",
      "\\in\\mathbb{Q}": "rational",
      "\\in\\Z^+": "integer,positive",
      "\\in\\Z^-": "intger,negative",
      "\\in\\Z^*": "nonzero",
      "\\in\\R^+": "positive",
      "\\in\\R^-": "negative",
      "\\in\\R^*": "real,nonzero",
      "\\in\\Z": "integer",
      "\\in\\mathbb{Z}": "integer",
      "\\in\\N": "integer,nonnegative",
      "\\in\\mathbb{N}": "integer,nonnegative",
      "\\in\\N^*": "integer,positive",
      "\\in\\N_0": "integer,nonnegative",
      "\\in\\R\\backslash\\Q": "irrational"
    };
    for (const shortcut in shortcuts) {
      if (parser.matchAll(tokenizeLaTeX(shortcut))) {
        modifier = shortcuts[shortcut];
        break;
      }
    }
  }
  if (!modifier) return null;
  if (!Object.keys(CONDITIONS).includes(modifier))
    throw new Error(`Unexpected condition "${modifier}" in a rule`);
  return modifier;
}
function parserModifiers(parser) {
  const modifiers = [];
  do {
    const modifier = parseModifier(parser);
    if (!modifier) break;
    modifiers.push(modifier);
  } while (parser.match(","));
  return modifiers.join(",");
}
function parseModifierExpression(parser) {
  let conditions = null;
  if (parser.match(":")) conditions = parserModifiers(parser);
  else if (parser.matchAll(["_", "<{>"])) {
    conditions = parserModifiers(parser);
    if (!parser.match("<}>")) return null;
  }
  return conditions;
}
function parseRulePart(ce, rule, options) {
  if (rule === void 0 || typeof rule === "function") return void 0;
  if (typeof rule === "string") {
    let expr = ce.parse(rule, { canonical: options?.canonical ?? false });
    if (options?.autoWildcard) {
      expr = expr.map(
        (x) => {
          if (x.symbol && x.symbol.length === 1)
            return ce.symbol("_" + x.symbol);
          return x;
        },
        { canonical: false }
      );
    }
    return expr;
  }
  const canonical2 = options?.canonical ?? (rule instanceof _BoxedExpression ? rule.isCanonical : false);
  return ce.box(rule, { canonical: canonical2 });
}
function parseRule(ce, rule, options) {
  const makeWildcardEntry = (x) => {
    return {
      kind: "symbol",
      latexTrigger: x,
      // domain: { kind: 'Any' },
      parse: (parser, until) => {
        if (!wildcards[x]) wildcards[x] = `_${x}`;
        const conditions = parseModifierExpression(parser);
        if (conditions !== null) {
          if (!wildcardConditions[x]) wildcardConditions[x] = conditions;
          else wildcardConditions[x] += "," + conditions;
        }
        return wildcards[x];
      }
    };
  };
  const previousDictionary = ce.latexDictionary;
  const wildcards = {};
  const wildcardConditions = {};
  ce.latexDictionary = [
    ...previousDictionary,
    {
      kind: "prefix",
      precedence: 100,
      latexTrigger: "...",
      parse: (parser, until) => {
        const id = parser.nextToken();
        if (!"abcfghjklmnopqrstuvwxyz".includes(id)) return null;
        let prefix = "__";
        if (parser.match("?")) prefix = "___";
        if (wildcards[id] && wildcards[id] !== `${prefix}${id}`)
          throw new Error(`Duplicate wildcard "${id}"`);
        if (!wildcards[id]) wildcards[id] = `${prefix}${id}`;
        const conditions = parseModifierExpression(parser);
        if (conditions === null) return `${prefix}${id}`;
        if (!wildcardConditions[id]) wildcardConditions[id] = conditions;
        else wildcardConditions[id] += "," + conditions;
        return `${prefix}${id}`;
      }
    },
    ..."abcfghjklmnopqrstuvwxyz".split("").map(makeWildcardEntry),
    {
      kind: "infix",
      precedence: 100,
      latexTrigger: "->",
      parse: (parser, lhs, until) => {
        const rhs = parser.parseExpression({ ...until, minPrec: 20 });
        if (rhs === null) return null;
        let conditionPredicate = null;
        if (parser.match(";")) {
          let done = false;
          const start = parser.index;
          do {
            parser.skipSpace();
            const id = parser.nextToken();
            if (wildcards[id]) {
              const conditions2 = parseModifierExpression(parser);
              if (conditions2 === null || !conditions2) {
                done = true;
                parser.index = start;
                break;
              }
              if (!wildcardConditions[id]) wildcardConditions[id] = conditions2;
              else wildcardConditions[id] += "," + conditions2;
            }
          } while (!done && !parser.atEnd);
          conditionPredicate = parser.parseExpression(until);
        }
        const conditions = [];
        for (const id in wildcardConditions) {
          const xs = wildcardConditions[id].split(",");
          if (xs.length === 0) continue;
          if (xs.length === 1) {
            conditions.push(["Condition", wildcards[id], xs[0]]);
          } else conditions.push(["Condition", wildcards[id], ["And", ...xs]]);
        }
        let conditionExpression = void 0;
        if (conditionPredicate && conditions.length > 0) {
          conditionExpression = ["And", conditionPredicate, ...conditions];
        } else if (conditionPredicate) conditionExpression = conditionPredicate;
        else if (conditions.length === 1) conditionExpression = conditions[0];
        else if (conditions.length > 1)
          conditionExpression = ["And", ...conditions];
        if (conditionExpression) return ["Rule", lhs, rhs, conditionExpression];
        return ["Rule", lhs, rhs];
      }
    }
  ];
  const canonical2 = options?.canonical ?? false;
  const systemScope = ce.contextStack[0]?.lexicalScope;
  if (systemScope) {
    ce.pushScope({ parent: systemScope, bindings: /* @__PURE__ */ new Map() });
  }
  const expr = ce.parse(rule);
  ce.latexDictionary = previousDictionary;
  if (!expr.isValid || expr.operator !== "Rule") {
    if (systemScope) {
      ce.popScope();
    }
    throw new Error(
      `Invalid rule "${rule}"
|   ${dewildcard(expr).toString()}
|   A rule should be of the form:
|   <match> -> <replace>; <condition>`
    );
  }
  let [match2, replace2, condition] = expr.ops;
  if (canonical2) {
    match2 = match2.canonical;
    replace2 = replace2.canonical;
  }
  if (systemScope) {
    ce.popScope();
  }
  if (!includesWildcards(replace2, match2))
    throw new Error(
      `Invalid rule "${rule}"
|   The replace expression contains wildcards not present in the match expression`
    );
  if (match2.isSame(replace2)) {
    throw new Error(
      `Invalid rule "${rule}"
|   The match and replace expressions are the same.
|   This may be because the rule is not necessary due to canonical simplification`
    );
  }
  let condFn = void 0;
  if (condition !== void 0) {
    if (!includesWildcards(condition, match2))
      throw new Error(
        `Invalid rule "${rule}"
|   The condition expression contains wildcards not present in the match expression`
      );
    condFn = (sub3) => condition.subs(sub3).canonical.evaluate()?.symbol === "True";
  }
  return boxRule(ce, { match: match2, replace: replace2, condition: condFn, id: rule }, options);
}
function boxRule(ce, rule, options) {
  if (rule === void 0 || rule === null)
    throw new Error("Expected a rule, not " + rule);
  if (isBoxedRule(rule)) return rule;
  if (typeof rule === "string") return parseRule(ce, rule, options);
  if (typeof rule === "function")
    return {
      _tag: "boxed-rule",
      match: void 0,
      replace: rule,
      condition: void 0,
      id: rule.toString().replace(/\n/g, " ")
    };
  let { match: match2, replace: replace2, condition, id, onMatch, onBeforeMatch } = rule;
  if (replace2 === void 0)
    throw new Error(
      `Invalid rule "${id ?? JSON.stringify(rule, void 0, 4)}"
|   A rule must include at least a replace property`
    );
  let condFn;
  if (typeof condition === "string") {
    const latex = asLatexString(condition);
    if (latex) {
      const condPattern = ce.parse(latex, {
        canonical: options?.canonical ?? false
      });
      condFn = (x, _ce) => condPattern.subs(x).evaluate()?.symbol === "True";
    }
  } else {
    if (condition !== void 0 && typeof condition !== "function")
      throw new Error(
        `Invalid rule ${id ?? JSON.stringify(rule, void 0, 4)}
|   condition is not a valid function`
      );
    condFn = condition;
  }
  if (typeof match2 === "function") {
    throw new Error(
      `Invalid rule ${id ?? JSON.stringify(rule, void 0, 4)}
|   match is not a valid expression.
|   Use a replace function instead to validate and replace the expression`
    );
  }
  const systemScope = ce.contextStack[0]?.lexicalScope;
  if (systemScope) {
    ce.pushScope({ parent: systemScope, bindings: /* @__PURE__ */ new Map() });
  } else {
    ce.pushScope();
  }
  const matchExpr = parseRulePart(ce, match2, { canonical: false });
  const replaceExpr = parseRulePart(ce, replace2, options);
  ce.popScope();
  if (!id) {
    if (typeof match2 === "string") id = match2;
    else id = JSON.stringify(match2, void 0, 4);
    if (replace2) {
      id += " -> ";
      if (typeof replace2 === "string") id += replace2;
      else if (typeof replace2 === "function")
        id += replace2?.toString().replace(/\n/g, " ");
      else id = JSON.stringify(replace2, void 0, 4);
    }
    if (typeof condition === "string") id += `; ${condition}`;
    else if (typeof condition === "function")
      id += `; ${condition.toString().replace(/\n/g, " ")}`;
  }
  if (matchExpr && !matchExpr.isValid) {
    throw new Error(
      `Invalid rule ${id}
|   the match expression is not valid: ${matchExpr.toString()}`
    );
  }
  if (replaceExpr && !replaceExpr.isValid) {
    throw new Error(
      `Invalid rule ${id ?? JSON.stringify(rule, void 0, 4)}
|   The replace expression is not valid: ${replaceExpr?.toString()}`
    );
  }
  if (!replaceExpr && typeof replace2 !== "function")
    throw new Error(
      `Invalid rule ${id ?? JSON.stringify(rule, void 0, 4)}
|   The replace expression could not be parsed`
    );
  return {
    _tag: "boxed-rule",
    match: matchExpr,
    replace: replaceExpr ?? replace2,
    condition: condFn,
    useVariations: rule.useVariations,
    id,
    onMatch,
    onBeforeMatch
  };
}
function boxRules(ce, rs, options) {
  if (!rs) return { rules: [] };
  if (typeof rs === "object" && "rules" in rs) return rs;
  if (!Array.isArray(rs)) rs = [rs];
  const rules = [];
  for (const rule of rs) {
    try {
      rules.push(boxRule(ce, rule, options));
    } catch (e) {
      throw new Error(
        `
${e.message}
|   Skipping rule ${JSON.stringify(rule, void 0, 4)}

`
      );
    }
  }
  return { rules };
}
function applyRule(rule, expr, substitution, options) {
  let canonical2 = options?.canonical ?? (expr.isCanonical || expr.isStructural);
  let operandsMatched = false;
  if (expr.ops && options?.recursive) {
    const newOps = expr.ops.map((op) => {
      const subExpr = applyRule(rule, op, {}, options);
      if (!subExpr) return op;
      operandsMatched = true;
      return subExpr.value;
    });
    if (operandsMatched) {
      if (!canonical2 && options?.canonical === void 0 && newOps.every((x) => x.isCanonical))
        canonical2 = true;
      expr = expr.engine.function(expr.operator, newOps, { canonical: canonical2 });
    }
  }
  let { match: match2, replace: replace2, condition, id, onMatch, onBeforeMatch } = rule;
  const because = id ?? "";
  if (canonical2 && match2) {
    const awc = getWildcards(match2);
    const canonicalMatch = match2.canonical;
    const bwc = getWildcards(canonicalMatch);
    if (!awc.every((x) => bwc.includes(x)))
      return operandsMatched ? { value: expr, because } : null;
  }
  const useVariations = rule.useVariations ?? options?.useVariations ?? false;
  const matchPermutations = options?.matchPermutations ?? true;
  onBeforeMatch?.(rule, expr);
  const sub3 = match2 ? expr.match(match2, {
    substitution,
    useVariations,
    recursive: false,
    matchPermutations
  }) : {};
  if (sub3 === null) return operandsMatched ? { value: expr, because } : null;
  if (typeof condition === "function") {
    const conditionSub = {
      ...Object.fromEntries(
        Object.entries(sub3).map(([k, v]) => [k.slice(1), v])
      ),
      ...sub3
    };
    try {
      if (!condition(conditionSub, expr.engine))
        return operandsMatched ? { value: expr, because } : null;
    } catch (e) {
      console.error(
        `
|   Rule "${rule.id}"
|   Error while checking condition
|    ${e.message}`
      );
      return null;
    }
  }
  if (!canonical2 && options?.canonical === void 0 && replace2 instanceof _BoxedExpression && replace2.isCanonical)
    canonical2 = true;
  const result = typeof replace2 === "function" ? replace2(expr, sub3) : replace2.subs(sub3, { canonical: canonical2 });
  if (!result) return null;
  onMatch?.(rule, expr, result);
  if (isRuleStep(result))
    return canonical2 ? { ...result, value: result.value.canonical } : result;
  return { value: canonical2 ? result.canonical : result, because };
}
function replace(expr, rules, options) {
  if (!rules) throw new Error("replace(): Expected one or more rules");
  const iterationLimit = options?.iterationLimit ?? 1;
  let iterationCount = 0;
  const once = options?.once ?? false;
  let ruleSet;
  if (typeof rules === "object" && "rules" in rules) ruleSet = rules.rules;
  else {
    ruleSet = expr.engine.rules(
      Array.isArray(rules) ? rules : [rules]
    ).rules;
  }
  let done = false;
  const steps = [];
  while (!done && iterationCount < iterationLimit) {
    done = true;
    for (const rule of ruleSet) {
      try {
        const result = applyRule(rule, expr, {}, options);
        if (result !== null && result.value !== expr && !result.value.isSame(expr)) {
          if (once) return [result];
          if (steps.some((x) => x.value.isSame(result.value))) return steps;
          steps.push(result);
          done = false;
          expr = result.value;
        }
      } catch (e) {
        console.error(`
${expr.toString()}
${rule.id}
${e.message}`);
        return steps;
      }
    }
    iterationCount += 1;
  }
  return steps;
}
function matchAnyRules(expr, rules, sub3, options) {
  const results = [];
  for (const rule of rules.rules) {
    const r = applyRule(rule, expr, sub3, options);
    if (r !== null && !results.some((x) => x.isSame(r.value)))
      results.push(r.value);
  }
  return results;
}
function dewildcard(expr) {
  const symbol2 = expr.symbol;
  if (symbol2) {
    if (symbol2.startsWith("_")) return expr.engine.symbol(symbol2.slice(1));
  }
  if (expr.ops) {
    const ops = expr.ops.map((x) => dewildcard(x));
    return expr.engine.function(expr.operator, ops, { canonical: false });
  }
  return expr;
}
function getWildcards(expr) {
  const wildcards = [];
  if (expr.symbol && expr.symbol.startsWith("_")) wildcards.push(expr.symbol);
  if (expr.ops) expr.ops.forEach((x) => wildcards.push(...getWildcards(x)));
  return wildcards;
}
function includesWildcards(a, b) {
  const awc = getWildcards(a);
  const bwc = getWildcards(b);
  return awc.every((x) => bwc.includes(x));
}
function isRuleStep(x) {
  return x && typeof x === "object" && "because" in x && "value" in x;
}
function isBoxedRule(x) {
  return x && typeof x === "object" && x._tag === "boxed-rule";
}
var CONDITIONS;
var init_rules = __esm({
  "src/compute-engine/boxed-expression/rules.ts"() {
    init_abstract_boxed_expression();
    init_utils3();
    init_arithmetic();
    CONDITIONS = {
      boolean: (x) => x.type.matches("boolean"),
      string: (x) => x.string !== null,
      number: (x) => x.isNumberLiteral,
      symbol: (x) => x.symbol !== null,
      expression: (x) => true,
      numeric: (x) => {
        const [c, term] = x.toNumericValue();
        return term.is(1);
      },
      integer: (x) => x.isInteger,
      rational: (x) => x.isRational,
      irrational: (x) => x.isRational === false,
      real: (x) => x.isReal,
      notreal: (x) => !x.isReal,
      // number with a non-zero imaginary part:
      complex: (x) => x.type.matches("complex"),
      // number with a zero real part and non-zero imaginary part:
      imaginary: (x) => x.type.matches("imaginary"),
      positive: (x) => x.isPositive,
      negative: (x) => x.isNegative,
      nonnegative: (x) => x.isNonNegative,
      nonpositive: (x) => x.isNonPositive,
      even: (x) => x.isEven,
      odd: (x) => x.isOdd,
      prime: (x) => isPrime2(x) === true,
      composite: (x) => isPrime2(x) === false,
      notzero: (x) => x.is(0) === false,
      notone: (x) => x.is(1) === false,
      finite: (x) => x.isFinite,
      infinite: (x) => x.isFinite === false,
      constant: (x) => x.valueDefinition?.isConstant ?? false,
      variable: (x) => !(x.valueDefinition?.isConstant ?? true),
      function: (x) => x.operatorDefinition !== void 0,
      relation: (x) => isRelationalOperator(x.operator),
      equation: (x) => x.operator === "Equal",
      inequality: (x) => isInequalityOperator(x.operator),
      collection: (x) => x.isCollection,
      list: (x) => x.operator === "List",
      set: (x) => x.operator === "Set",
      tuple: (x) => x.operator === "Tuple" || x.operator === "Single" || x.operator === "Pair" || x.operator === "Triple",
      single: (x) => x.operator === "Single",
      pair: (x) => x.operator === "Pair",
      triple: (x) => x.operator === "Triple",
      scalar: (x) => x.rank === 0,
      tensor: (x) => x.rank > 0,
      vector: (x) => x.rank === 1,
      matrix: (x) => x.rank === 2,
      unit: (x) => x.operator === "Unit",
      dimension: (x) => x.operator === "Dimension",
      angle: (x) => x.operator === "Angle",
      polynomial: (x) => x.unknowns.length === 1
    };
  }
});

// src/compute-engine/boxed-expression/solve.ts
function filter(sub3) {
  for (const [k, v] of Object.entries(sub3)) {
    if (k !== "x" && k !== "_x" && v.has("_x")) return false;
  }
  return true;
}
function clearDenominators(expr, variable) {
  if (expr.operator !== "Add") return expr;
  const ops = expr.ops;
  if (!ops || ops.length === 0) return expr;
  const denominators = ops.map((op) => op.denominator).filter((d) => !d.is(1));
  if (denominators.length === 0) return expr;
  const lcmFactors = [];
  for (const denom of denominators) {
    let isDuplicate = false;
    for (const existing of lcmFactors) {
      if (denom.isSame(existing)) {
        isDuplicate = true;
        break;
      }
      if (denom.symbol && existing.symbol && denom.symbol === existing.symbol) {
        isDuplicate = true;
        break;
      }
    }
    if (!isDuplicate) {
      lcmFactors.push(denom);
    }
  }
  let lcm5 = lcmFactors[0];
  for (let i = 1; i < lcmFactors.length; i++) {
    lcm5 = lcm5.mul(lcmFactors[i]);
  }
  return expr.mul(lcm5).simplify();
}
function transformSqrtLinearEquation(expr, variable) {
  if (expr.operator !== "Add") return expr;
  const ce = expr.engine;
  const ops = expr.ops;
  if (!ops || ops.length === 0) return expr;
  let sqrtTerm = null;
  let sqrtIndex = -1;
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.operator === "Sqrt") {
      sqrtTerm = op;
      sqrtIndex = i;
      break;
    }
    if (op.operator === "Multiply" && op.ops) {
      for (const factor3 of op.ops) {
        if (factor3.operator === "Sqrt") {
          break;
        }
      }
    }
  }
  if (!sqrtTerm || sqrtIndex < 0) return expr;
  const sqrtArg = sqrtTerm.op1;
  if (!sqrtArg) return expr;
  if (!sqrtArg.has(variable)) return expr;
  const nonSqrtTerms = ops.filter((_, i) => i !== sqrtIndex);
  if (nonSqrtTerms.length === 0) return expr;
  let gExpr;
  if (nonSqrtTerms.length === 1) {
    gExpr = nonSqrtTerms[0].neg();
  } else {
    gExpr = ce.function("Add", nonSqrtTerms).neg();
  }
  if (gExpr.has("Sqrt")) return expr;
  const gSquared = gExpr.mul(gExpr);
  const transformed = sqrtArg.sub(gSquared).simplify();
  return transformed;
}
function solveTwoSqrtEquation(expr, variable) {
  if (expr.operator !== "Add") return null;
  const ce = expr.engine;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return null;
  const sqrtTerms = [];
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.operator === "Sqrt" && op.op1) {
      sqrtTerms.push({ term: op, arg: op.op1, index: i });
      continue;
    }
    if (op.operator === "Negate" && op.op1?.operator === "Sqrt" && op.op1.op1) {
      sqrtTerms.push({ term: op, arg: op.op1.op1, index: i });
      continue;
    }
    if (op.operator === "Multiply" && op.ops) {
      for (const factor3 of op.ops) {
        if (factor3.operator === "Sqrt" && factor3.op1) {
          sqrtTerms.push({ term: op, arg: factor3.op1, index: i });
          break;
        }
      }
    }
  }
  if (sqrtTerms.length !== 2) return null;
  if (!sqrtTerms[0].arg.has(variable) || !sqrtTerms[1].arg.has(variable)) {
    return null;
  }
  const sqrtIndices = new Set(sqrtTerms.map((s) => s.index));
  const nonSqrtTerms = ops.filter((_, i) => !sqrtIndices.has(i));
  let eExpr;
  if (nonSqrtTerms.length === 0) {
    return null;
  } else if (nonSqrtTerms.length === 1) {
    eExpr = nonSqrtTerms[0].neg();
  } else {
    eExpr = ce.function("Add", nonSqrtTerms).neg();
  }
  if (eExpr.has(variable)) return null;
  const fExpr = sqrtTerms[0].arg;
  const gExpr = sqrtTerms[1].arg;
  let fSign = 1;
  let gSign = 1;
  if (sqrtTerms[0].term.operator === "Negate") fSign = -1;
  if (sqrtTerms[0].term.operator === "Multiply") {
    const coef = sqrtTerms[0].term.ops?.find((o) => o.operator !== "Sqrt");
    if (coef?.isNegative) fSign = -1;
    const absCoef = coef?.abs().N().numericValue;
    if (absCoef !== 1 && absCoef !== null) return null;
  }
  if (sqrtTerms[1].term.operator === "Negate") gSign = -1;
  if (sqrtTerms[1].term.operator === "Multiply") {
    const coef = sqrtTerms[1].term.ops?.find((o) => o.operator !== "Sqrt");
    if (coef?.isNegative) gSign = -1;
    const absCoef = coef?.abs().N().numericValue;
    if (absCoef !== 1 && absCoef !== null) return null;
  }
  if (fSign !== 1) {
    if (gSign === 1) {
      return solveTwoSqrtEquationCore(ce, gExpr, fExpr, eExpr, fSign, variable);
    }
    return null;
  }
  return solveTwoSqrtEquationCore(ce, fExpr, gExpr, eExpr, gSign, variable);
}
function solveTwoSqrtEquationCore(ce, fExpr, gExpr, eExpr, gSign, variable) {
  const eSquared = eExpr.mul(eExpr);
  const leftSide = fExpr.sub(eSquared).sub(gExpr).simplify();
  const four = ce.number(4);
  const rightSide = four.mul(eSquared).mul(gExpr).simplify();
  const leftSquared = leftSide.mul(leftSide).simplify();
  const finalEquation = leftSquared.sub(rightSide).simplify();
  const solutions = findUnivariateRoots(finalEquation, variable);
  if (solutions.length === 0) return null;
  const validSolutions = [];
  for (const sol of solutions) {
    const fVal = fExpr.subs({ [variable]: sol }).N();
    const gVal = gExpr.subs({ [variable]: sol }).N();
    if (fVal.isNegative || gVal.isNegative) continue;
    const sqrtF = fVal.sqrt();
    const sqrtG = gVal.sqrt();
    const lhs = gSign === 1 ? sqrtF.add(sqrtG) : sqrtF.sub(sqrtG);
    const eVal = eExpr.N();
    const diff = lhs.sub(eVal).abs().N();
    const diffNum = diff.numericValue;
    let diffReal = 0;
    if (typeof diffNum === "number") {
      diffReal = diffNum;
    } else if (diffNum && typeof diffNum === "object" && "decimal" in diffNum) {
      diffReal = diffNum.decimal?.toNumber?.() ?? 0;
    }
    if (diffReal < 1e-9) {
      validSolutions.push(sol);
    }
  }
  return validSolutions.length > 0 ? validSolutions : null;
}
function solveNestedSqrtEquation(expr, variable) {
  if (expr.operator !== "Add") return null;
  const ce = expr.engine;
  const ops = expr.ops;
  if (!ops || ops.length === 0) return null;
  let outerSqrt = null;
  let sqrtIndex = -1;
  for (let i = 0; i < ops.length; i++) {
    if (ops[i].operator === "Sqrt") {
      outerSqrt = ops[i];
      sqrtIndex = i;
      break;
    }
  }
  if (!outerSqrt || sqrtIndex < 0) return null;
  const outerArg = outerSqrt.op1;
  if (!outerArg) return null;
  let hasInnerSqrtX = false;
  let innerSqrtCoeff = null;
  if (outerArg.operator === "Add" && outerArg.ops) {
    for (const term of outerArg.ops) {
      if (term.operator === "Sqrt" && term.op1?.symbol === variable) {
        hasInnerSqrtX = true;
        innerSqrtCoeff = ce.One;
        break;
      }
      if (term.operator === "Negate" && term.op1?.operator === "Sqrt" && term.op1?.op1?.symbol === variable) {
        hasInnerSqrtX = true;
        innerSqrtCoeff = ce.NegativeOne;
        break;
      }
      if (term.operator === "Multiply" && term.ops) {
        for (const factor3 of term.ops) {
          if (factor3.operator === "Sqrt" && factor3.op1?.symbol === variable) {
            hasInnerSqrtX = true;
            const otherFactors = term.ops.filter((f) => f !== factor3);
            innerSqrtCoeff = otherFactors.length === 1 ? otherFactors[0] : ce.function("Multiply", otherFactors);
            break;
          }
        }
        if (hasInnerSqrtX) break;
      }
    }
  }
  if (!hasInnerSqrtX) return null;
  const nonSqrtTerms = ops.filter((_, i) => i !== sqrtIndex);
  if (nonSqrtTerms.length === 0) return null;
  let aExpr;
  if (nonSqrtTerms.length === 1) {
    aExpr = nonSqrtTerms[0].neg();
  } else {
    aExpr = ce.function("Add", nonSqrtTerms).neg();
  }
  if (aExpr.has(variable)) return null;
  const uSymbolName = "__internalU";
  const uSymbol = ce.symbol(uSymbolName);
  const step1 = outerArg.replace(
    { match: ["Sqrt", variable], replace: uSymbol },
    { recursive: true }
  );
  const substitutedArg = step1?.subs({
    [variable]: ce.box(["Power", uSymbolName, 2])
  });
  if (!substitutedArg) return null;
  const aSquared = aExpr.mul(aExpr);
  const uEquation = substitutedArg.sub(aSquared).simplify();
  ce.pushScope();
  ce.declare(uSymbolName, { type: "real" });
  const uSolutions = findUnivariateRoots(uEquation, uSymbolName);
  ce.popScope();
  if (uSolutions.length === 0) return null;
  const xSolutions = [];
  for (const uVal of uSolutions) {
    const uNumeric = uVal.N();
    if (uNumeric.isNegative) continue;
    const uNum = uNumeric.numericValue;
    if (uNum !== null) {
      let uReal = null;
      if (typeof uNum === "number") {
        uReal = uNum;
      } else if (typeof uNum === "object" && "decimal" in uNum) {
        const decimal = uNum.decimal;
        if (decimal && typeof decimal.toNumber === "function") {
          uReal = decimal.toNumber();
        }
      } else if (typeof uNum === "object" && "re" in uNum) {
        uReal = uNum.re;
      }
      if (uReal !== null && uReal < -1e-10) continue;
    }
    const xVal = uVal.mul(uVal).simplify();
    xSolutions.push(xVal);
  }
  return xSolutions.length > 0 ? xSolutions : null;
}
function findUnivariateRoots(expr, x) {
  const ce = expr.engine;
  if (expr.operator === "Equal")
    expr = expr.op1.expand().sub(expr.op2.expand()).simplify();
  else expr = expr.expand().simplify();
  const originalExpr = expr;
  expr = clearDenominators(expr);
  const twoSqrtSolutions = solveTwoSqrtEquation(expr, x);
  if (twoSqrtSolutions !== null) {
    return twoSqrtSolutions;
  }
  const nestedSqrtSolutions = solveNestedSqrtEquation(expr, x);
  if (nestedSqrtSolutions !== null) {
    return validateRoots(originalExpr, x, nestedSqrtSolutions);
  }
  expr = transformSqrtLinearEquation(expr, x);
  const rules = ce.getRuleSet("solve-univariate");
  let exprs = [expr.subs({ [x]: "_x" }, { canonical: false })];
  ce.pushScope();
  ce.declare("_x", "number");
  let result = exprs.flatMap(
    (expr2) => matchAnyRules(
      expr2,
      rules,
      { _x: ce.symbol("_x") },
      { useVariations: true, canonical: true }
    )
  );
  if (result.length === 0) {
    exprs = exprs.flatMap((expr2) => harmonize(expr2));
    result = exprs.flatMap(
      (expr2) => matchAnyRules(
        expr2,
        rules,
        { _x: ce.symbol(x) },
        { useVariations: true, canonical: true }
      )
    );
  }
  if (result.length === 0) {
    exprs = exprs.flatMap((expr2) => expand2(expr2.canonical)).filter((x2) => x2 !== null);
    exprs = exprs.flatMap((expr2) => harmonize(expr2));
    result = exprs.flatMap(
      (expr2) => matchAnyRules(
        expr2,
        rules,
        { _x: ce.symbol(x) },
        { useVariations: true, canonical: true }
      )
    );
  }
  ce.popScope();
  return validateRoots(
    originalExpr,
    x,
    result.map((x2) => x2.evaluate().simplify())
  );
}
function harmonize(expr) {
  const ce = expr.engine;
  const rules = ce.getRuleSet("harmonization");
  return matchAnyRules(expr, rules, { _x: ce.symbol("_x") });
}
function validateRoots(expr, x, roots) {
  const validRoots = roots.filter((root2) => {
    const value = expr.subs({ [x]: root2 }).canonical.evaluate();
    if (value === null) return false;
    if (!value.isValid) return false;
    if (value.isNaN) return false;
    if (value.has(x)) return false;
    return value.isEqual(0);
  });
  const uniqueRoots = [];
  for (const root2 of validRoots) {
    const isDuplicate = uniqueRoots.some(
      (existing) => existing.isSame(root2) || existing.isEqual(root2)
    );
    if (!isDuplicate) uniqueRoots.push(root2);
  }
  return uniqueRoots;
}
var UNIVARIATE_ROOTS, HARMONIZATION_RULES;
var init_solve = __esm({
  "src/compute-engine/boxed-expression/solve.ts"() {
    init_utils3();
    init_rules();
    init_expand();
    UNIVARIATE_ROOTS = [
      // ax = 0
      {
        match: ["Multiply", "_x", "__a"],
        replace: 0,
        id: "ax",
        condition: filter
      },
      // a/x + b = 0
      {
        match: ["Add", ["Divide", "_a", "_x"], "__b"],
        replace: Infinity,
        useVariations: true,
        // Handle a/x = 0
        condition: filter
      },
      // ax + b = 0
      {
        match: ["Add", ["Multiply", "_x", "__a"], "__b"],
        replace: ["Divide", ["Negate", "__b"], "__a"],
        useVariations: true,
        // Handle ax = 0
        condition: filter
      },
      // -ax + b = 0  =>  x = b/a
      // This handles cases where the coefficient is negative and represented as Negate(Multiply(...))
      {
        match: ["Add", ["Negate", ["Multiply", "_x", "__a"]], "__b"],
        replace: ["Divide", "__b", "__a"],
        useVariations: true,
        condition: filter
      },
      // ax^n + b = 0
      {
        match: ["Add", ["Multiply", "_a", ["Power", "_x", "_n"]], "__b"],
        replace: [
          "Power",
          ["Divide", ["Negate", "__b"], "_a"],
          ["Divide", 1, "_n"]
        ],
        useVariations: true,
        condition: (sub3) => filter(sub3) && !sub3._n.is(0)
      },
      {
        match: ["Add", ["Multiply", "_a", ["Power", "_x", "_n"]], "__b"],
        replace: [
          "Negate",
          ["Power", ["Divide", ["Negate", "__b"], "_a"], ["Divide", 1, "_n"]]
        ],
        useVariations: true,
        condition: (sub3) => filter(sub3) && !sub3._n.is(0) && (sub3._n.isEven ?? false)
      },
      //
      // Quadratic without constant: ax^2 + bx = 0
      // Factor: x(ax + b) = 0  x = 0 or x = -b/a
      //
      {
        match: [
          "Add",
          ["Multiply", "__a", ["Power", "_x", 2]],
          ["Multiply", "__b", "_x"]
        ],
        replace: 0,
        useVariations: true,
        condition: filter
      },
      {
        match: [
          "Add",
          ["Multiply", "__a", ["Power", "_x", 2]],
          ["Multiply", "__b", "_x"]
        ],
        replace: ["Divide", ["Negate", "__b"], "__a"],
        useVariations: true,
        condition: filter
      },
      //
      // Quadratic formula
      // ax^2 + bx + c = 0
      //
      {
        match: [
          "Add",
          ["Multiply", "__a", ["Power", "_x", 2]],
          ["Multiply", "__b", "_x"],
          "__c"
        ],
        replace: [
          "Divide",
          [
            "Add",
            ["Negate", "__b"],
            [
              "Sqrt",
              ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]
            ]
          ],
          ["Multiply", 2, "__a"]
        ],
        useVariations: true,
        condition: filter
      },
      {
        match: [
          "Add",
          ["Multiply", "__a", ["Power", "_x", 2]],
          ["Multiply", "__b", "_x"],
          "__c"
        ],
        replace: [
          "Divide",
          [
            "Subtract",
            ["Negate", "__b"],
            [
              "Sqrt",
              ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]
            ]
          ],
          ["Multiply", 2, "__a"]
        ],
        useVariations: true,
        condition: filter
      },
      // a^x + b = 0
      {
        id: "a^x + b = 0",
        match: ["Add", ["Power", "_a", "_x"], "__b"],
        replace: ["Ln", ["Negate", "__b"], "_a"],
        useVariations: true,
        onBeforeMatch: () => {
        },
        condition: (sub3) => filter(sub3) && (sub3._a.isPositive ?? false) && (sub3.__b.isNegative ?? false)
      },
      // a * e^(bx) + c = 0
      {
        match: [
          "Add",
          ["Multiply", "__a", ["Exp", ["Multiply", "__b", "_x"]]],
          "__c"
        ],
        replace: ["Divide", ["Ln", ["Negate", ["Divide", "__c", "__a"]]], "__b"],
        useVariations: true,
        condition: (sub3) => filter(sub3) && ((!sub3.__a.is(0) && sub3.__c.div(sub3.__a).isNegative) ?? false)
      },
      // a * e^(x) + c = 0
      {
        match: ["Add", ["Multiply", "__a", ["Exp", "_x"]], "__c"],
        replace: ["Ln", ["Negate", ["Divide", "__c", "__a"]]],
        useVariations: true,
        condition: (sub3) => filter(sub3) && ((!sub3.__a.is(0) && sub3.__c.div(sub3.__a).isNegative) ?? false) && !sub3.__a.has("_x") && !sub3.__c.has("_x")
      },
      // e^(x) + c = 0
      {
        match: ["Add", ["Exp", "_x"], "__c"],
        replace: ["Ln", ["Negate", "__c"]],
        useVariations: true,
        condition: (sub3) => filter(sub3) && (sub3.__c.isNegative ?? false)
      },
      // e^(bx) + c = 0
      {
        match: ["Add", ["Exp", ["Multiply", "__b", "_x"]], "__c"],
        replace: ["Divide", ["Ln", ["Negate", "__c"]], "__b"],
        useVariations: true,
        condition: (sub3) => filter(sub3) && (sub3.__c.isNegative ?? false)
      },
      // a * log_b(x) + c = 0
      {
        match: ["Add", ["Multiply", "__a", ["Log", "_x", "__b"]], "__c"],
        replace: ["Power", "__b", ["Negate", ["Divide", "__c", "__a"]]],
        useVariations: true,
        condition: (sub3) => (filter(sub3) && !sub3.__a.is(0) && sub3.__b.isPositive) ?? false
      },
      // a * log_b(x) = 0
      {
        match: ["Multiply", "__a", ["Log", "_x", "__b"]],
        replace: ["Power", "__b", ["Negate", ["Divide", "__c", "__a"]]],
        useVariations: true,
        condition: (sub3) => (filter(sub3) && !sub3.__a.is(0) && sub3.__b.isPositive) ?? false
      },
      // |ax + b| + c = 0
      {
        match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"],
        replace: ["Divide", ["Subtract", "__b", "__c"], "__a"],
        condition: filter
      },
      {
        match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"],
        replace: ["Divide", ["Negate", ["Add", "__b", "__c"], "__a"]],
        condition: filter
      },
      //
      // Square root equations: ax + bx + c = 0
      // Using substitution u = x, this becomes au + bu + c = 0
      // Solving: u = (-b  (b - 4ac)) / 2a
      // Then x = u = ((-b  (b - 4ac)) / 2a)
      //
      // ax + bx + c = 0 (plus root)
      {
        match: [
          "Add",
          ["Multiply", "_x", "__a"],
          ["Multiply", "__b", ["Sqrt", "_x"]],
          "___c"
        ],
        replace: [
          "Power",
          [
            "Divide",
            [
              "Add",
              ["Negate", "__b"],
              [
                "Sqrt",
                ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "___c"]]
              ]
            ],
            ["Multiply", 2, "__a"]
          ],
          2
        ],
        useVariations: true,
        condition: filter
      },
      // ax + bx + c = 0 (minus root)
      {
        match: [
          "Add",
          ["Multiply", "_x", "__a"],
          ["Multiply", "__b", ["Sqrt", "_x"]],
          "___c"
        ],
        replace: [
          "Power",
          [
            "Divide",
            [
              "Subtract",
              ["Negate", "__b"],
              [
                "Sqrt",
                ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "___c"]]
              ]
            ],
            ["Multiply", 2, "__a"]
          ],
          2
        ],
        useVariations: true,
        condition: filter
      },
      // Handle negated coefficient: ax - bx + c = 0
      // This handles the Negate(Multiply(...)) pattern
      {
        match: [
          "Add",
          ["Multiply", "_x", "__a"],
          ["Negate", ["Multiply", "__b", ["Sqrt", "_x"]]],
          "___c"
        ],
        replace: [
          "Power",
          [
            "Divide",
            [
              "Add",
              "__b",
              ["Sqrt", ["Add", ["Square", "__b"], ["Multiply", 4, "__a", "___c"]]]
            ],
            ["Multiply", 2, "__a"]
          ],
          2
        ],
        useVariations: true,
        condition: filter
      },
      // ax - bx + c = 0 (minus root)
      {
        match: [
          "Add",
          ["Multiply", "_x", "__a"],
          ["Negate", ["Multiply", "__b", ["Sqrt", "_x"]]],
          "___c"
        ],
        replace: [
          "Power",
          [
            "Divide",
            [
              "Subtract",
              "__b",
              ["Sqrt", ["Add", ["Square", "__b"], ["Multiply", 4, "__a", "___c"]]]
            ],
            ["Multiply", 2, "__a"]
          ],
          2
        ],
        useVariations: true,
        condition: filter
      },
      //
      // Additional solve rules
      //
      // ax + b = 0  =>  x = (b/a) (only valid when -b/a  0)
      {
        match: ["Add", ["Multiply", "__a", ["Sqrt", "_x"]], "__b"],
        replace: ["Square", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const a = sub3.__a;
          const b = sub3.__b;
          if (!a || !b) return false;
          const ratio = b.div(a);
          return ratio.isNonPositive ?? true;
        }
      },
      // aln(x) + b = 0  =>  x = e^(-b/a)
      {
        match: ["Add", ["Multiply", "__a", ["Ln", "_x"]], "__b"],
        replace: ["Exp", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: filter
      },
      // ln(x) + b = 0  =>  x = e^(-b)
      {
        match: ["Add", ["Ln", "_x"], "__b"],
        replace: ["Exp", ["Negate", "__b"]],
        useVariations: true,
        condition: filter
      },
      //
      // Trigonometric equations
      //
      // Note: These return principal values only. For general solutions,
      // add 2n for sin/cos or n for tan (where n  ).
      //
      // asin(x) + b = 0  =>  x = arcsin(-b/a)
      // Valid when -1  -b/a  1
      {
        match: ["Add", ["Multiply", "__a", ["Sin", "_x"]], "__b"],
        replace: ["Arcsin", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const a = sub3.__a;
          const b = sub3.__b;
          if (!a || a.is(0)) return false;
          const ratio = b.div(a).neg();
          const val = ratio.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // Second solution for sin: x =  - arcsin(-b/a)
      {
        match: ["Add", ["Multiply", "__a", ["Sin", "_x"]], "__b"],
        replace: [
          "Subtract",
          "Pi",
          ["Arcsin", ["Divide", ["Negate", "__b"], "__a"]]
        ],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const a = sub3.__a;
          const b = sub3.__b;
          if (!a || a.is(0)) return false;
          const ratio = b.div(a).neg();
          const val = ratio.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // sin(x) + b = 0  =>  x = arcsin(-b)  (when a = 1)
      {
        match: ["Add", ["Sin", "_x"], "__b"],
        replace: ["Arcsin", ["Negate", "__b"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const b = sub3.__b;
          const val = b.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // Second solution for sin(x) + b = 0: x =  - arcsin(-b)
      {
        match: ["Add", ["Sin", "_x"], "__b"],
        replace: ["Subtract", "Pi", ["Arcsin", ["Negate", "__b"]]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const b = sub3.__b;
          const val = b.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // acos(x) + b = 0  =>  x = arccos(-b/a)
      // Valid when -1  -b/a  1
      {
        match: ["Add", ["Multiply", "__a", ["Cos", "_x"]], "__b"],
        replace: ["Arccos", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const a = sub3.__a;
          const b = sub3.__b;
          if (!a || a.is(0)) return false;
          const ratio = b.div(a).neg();
          const val = ratio.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // Second solution for cos: x = -arccos(-b/a)  (since cos(-x) = cos(x))
      {
        match: ["Add", ["Multiply", "__a", ["Cos", "_x"]], "__b"],
        replace: ["Negate", ["Arccos", ["Divide", ["Negate", "__b"], "__a"]]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const a = sub3.__a;
          const b = sub3.__b;
          if (!a || a.is(0)) return false;
          const ratio = b.div(a).neg();
          const val = ratio.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // cos(x) + b = 0  =>  x = arccos(-b)  (when a = 1)
      {
        match: ["Add", ["Cos", "_x"], "__b"],
        replace: ["Arccos", ["Negate", "__b"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const b = sub3.__b;
          const val = b.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // Second solution for cos(x) + b = 0: x = -arccos(-b)
      {
        match: ["Add", ["Cos", "_x"], "__b"],
        replace: ["Negate", ["Arccos", ["Negate", "__b"]]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          const b = sub3.__b;
          const val = b.numericValue;
          if (val === null) return true;
          if (typeof val === "number") return Math.abs(val) <= 1;
          return true;
        }
      },
      // atan(x) + b = 0  =>  x = arctan(-b/a)
      // Tan has no domain restriction for the ratio
      {
        match: ["Add", ["Multiply", "__a", ["Tan", "_x"]], "__b"],
        replace: ["Arctan", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          return !sub3.__a.is(0);
        }
      },
      // tan(x) + b = 0  =>  x = arctan(-b)  (when a = 1)
      {
        match: ["Add", ["Tan", "_x"], "__b"],
        replace: ["Arctan", ["Negate", "__b"]],
        useVariations: true,
        condition: filter
      },
      // acot(x) + b = 0  =>  x = arccot(-b/a)
      {
        match: ["Add", ["Multiply", "__a", ["Cot", "_x"]], "__b"],
        replace: ["Arccot", ["Divide", ["Negate", "__b"], "__a"]],
        useVariations: true,
        condition: (sub3) => {
          if (!filter(sub3)) return false;
          return !sub3.__a.is(0);
        }
      },
      // cot(x) + b = 0  =>  x = arccot(-b)
      {
        match: ["Add", ["Cot", "_x"], "__b"],
        replace: ["Arccot", ["Negate", "__b"]],
        useVariations: true,
        condition: filter
      }
    ];
    HARMONIZATION_RULES = [
      // |ax + b| + c -> ax+b+c, -ax-b+c
      {
        match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"],
        replace: ["Add", ["Multiply", "__a", "_x"], "__b", "__c"]
      },
      {
        match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"],
        replace: [
          "Add",
          ["Negate", ["Multiply", "__a", "_x"]],
          ["Negate", "__b"],
          "__c"
        ]
      },
      // a(b^n) -> a
      {
        match: ["Multiply", "__a", ["Power", "_b", "_n"]],
        replace: "_b",
        condition: ({ __a, _b, _n }) => !__a.has("_x") && _b.has("_x") && !_n.is(0) && !_n.has("_x")
      },
      // ab(x)  -> a^2 b(x)
      {
        match: ["Multiply", "__a", ["Sqrt", "_b"]],
        replace: ["Multiply", ["Square", "_a"], "__b"],
        condition: ({ _b }) => _b.has("_x")
      },
      // a(x)/b -> a(x)
      {
        match: ["Divide", "_a", "_b"],
        replace: "_a",
        // @todo: check _b after the substitution
        condition: ({ _a, _b }) => _a.has("_x") && !_b.is(0)
      },
      // ab(x) -> b(x)
      // The solution for a product are the solutions for each term,
      {
        match: ["Multiply", "__a", "_b"],
        replace: "_b",
        condition: ({ __a, _b }) => !__a.has("_x") && _b.has("_x")
      },
      // ln(a(x))+ln(b(x))+c -> ln(a(x)b(x)) + c
      {
        match: ["Add", ["Ln", "_a"], ["Ln", "_b"], "__c"],
        replace: ["Add", ["Ln", ["Multiply", "_a", "_b"]], "__c"]
      },
      // e^a * e^b -> e^(a+b)
      {
        match: ["Multiply", ["Exp", "__a"], ["Exp", "__b"], "__c"],
        replace: ["Multiply", ["Exp", ["Add", "_a", "_b"]], "__c"]
      },
      // ln(f(x)) -> f(x) - 1
      {
        match: ["Ln", "_a"],
        replace: ["Subtract", "_a", 1],
        // @todo: additional condition, f(x) > 0
        condition: ({ _a }) => _a.has("_x")
      },
      // sin(f(x)) -> f(x)
      {
        match: ["Sin", "_a"],
        replace: "_a",
        condition: ({ _a }) => _a.has("_x")
      },
      // cos(f(x)) -> f(x) - /2
      {
        match: ["Cos", "_a"],
        replace: ["Subtract", "_a", ["Divide", "Pi", 2]],
        condition: ({ _a }) => _a.has("_x")
      },
      // tan(f(x)) -> f(x) - /4
      {
        match: ["Tan", "_a"],
        replace: "_a",
        condition: ({ _a }) => _a.has("_x")
      },
      // sin(a) + cos(a) -> 1
      {
        match: ["Add", ["Sin", "_a"], ["Cos", "_a"]],
        replace: 1,
        condition: ({ _a }) => _a.has("_x")
      },
      // sin^2(a) - cos^2(a) -> sin(x) +/- (2)/2
      {
        match: ["Subtract", ["Square", ["Sin", "_a"]], ["Square", ["Cos", "_a"]]],
        replace: ["PlusMinus", ["Sin", "_a"], ["Divide", ["Sqrt", 2], 2]],
        condition: ({ _a }) => _a.has("_x")
      }
    ];
  }
});

// src/compute-engine/assume.ts
var assume_exports = {};
__export(assume_exports, {
  assume: () => assume,
  getInequalityBoundsFromAssumptions: () => getInequalityBoundsFromAssumptions,
  getSignFromAssumptions: () => getSignFromAssumptions
});
function inferTypeFromValue(ce, value) {
  if (value.type.matches("integer")) {
    return ce.type("integer");
  }
  if (value.type.matches("rational")) {
    return ce.type("real");
  }
  if (value.type.matches("real")) {
    return ce.type("real");
  }
  if (value.type.matches("complex")) {
    return ce.type("number");
  }
  return value.type;
}
function assume(proposition) {
  if (proposition.operator === "Element") return assumeElement(proposition);
  if (proposition.operator === "Equal") return assumeEquality(proposition);
  if (isInequalityOperator(proposition.operator))
    return assumeInequality(proposition);
  throw new Error(
    "Unsupported assumption. Use `Element`, `Equal` or an inequality"
  );
}
function assumeEquality(proposition) {
  console.assert(proposition.operator === "Equal");
  const unknowns = proposition.unknowns;
  if (unknowns.length === 0) {
    const val = proposition.evaluate();
    if (val.symbol === "True") return "tautology";
    if (val.symbol === "False") return "contradiction";
    console.log(proposition.canonical.evaluate());
    return "not-a-predicate";
  }
  const ce = proposition.engine;
  const lhs = proposition.op1.symbol;
  if (lhs && !hasValue(ce, lhs) && !proposition.op2.has(lhs)) {
    const val = proposition.op2.evaluate();
    if (!val.isValid) return "not-a-predicate";
    const def = ce.lookupDefinition(lhs);
    if (!def || !isValueDef(def)) {
      ce.declare(lhs, { value: val });
      return "ok";
    }
    if (def.value.type && !val.type.matches(def.value.type)) {
      if (!def.value.inferredType) return "contradiction";
    }
    ce._setCurrentContextValue(lhs, val);
    if (def.value.inferredType) def.value.type = inferTypeFromValue(ce, val);
    return "ok";
  }
  if (unknowns.length === 1) {
    const lhs2 = unknowns[0];
    const sols = findUnivariateRoots(proposition, lhs2);
    if (sols.length === 0) {
      ce.context.assumptions.set(
        ce.function("Equal", [proposition.op1.sub(proposition.op2), 0]),
        true
      );
    }
    const val = sols.length === 1 ? sols[0] : ce.function("List", sols);
    const def = ce.lookupDefinition(lhs2);
    if (!def || !isValueDef(def)) {
      ce.declare(lhs2, { value: val });
      return "ok";
    }
    if (def.value.type && !sols.every((sol) => !sol.type || val.type.matches(sol.type)))
      return "contradiction";
    ce._setCurrentContextValue(lhs2, val);
    if (def.value.inferredType) def.value.type = inferTypeFromValue(ce, val);
    return "ok";
  }
  ce.context.assumptions.set(proposition, true);
  return "ok";
}
function assumeInequality(proposition) {
  const ce = proposition.engine;
  let op = "";
  let lhs;
  let rhs;
  if (proposition.operator === "Less") {
    lhs = proposition.op1;
    rhs = proposition.op2;
    op = "<";
  } else if (proposition.operator === "LessEqual") {
    lhs = proposition.op1;
    rhs = proposition.op2;
    op = "<=";
  } else if (proposition.operator === "Greater") {
    lhs = proposition.op2;
    rhs = proposition.op1;
    op = "<";
  } else if (proposition.operator === "GreaterEqual") {
    lhs = proposition.op2;
    rhs = proposition.op1;
    op = "<=";
  }
  if (!op) return "internal-error";
  const p = lhs.sub(rhs);
  const result = ce.box([op === "<" ? "Less" : "LessEqual", p, 0]).evaluate();
  if (result.symbol === "True") return "tautology";
  if (result.symbol === "False") return "contradiction";
  const unknowns = result.unknowns;
  if (unknowns.length === 0) return "not-a-predicate";
  if (unknowns.length === 1) {
    const symbol2 = unknowns[0];
    const bounds = getInequalityBoundsFromAssumptions(ce, symbol2);
    const originalOp = proposition.operator;
    const isSymbolOnLeft = proposition.op1.symbol === symbol2;
    const otherSide = isSymbolOnLeft ? proposition.op2 : proposition.op1;
    if (otherSide.numericValue !== null) {
      const k = otherSide.numericValue;
      if (typeof k === "number" && isFinite(k)) {
        let effectiveOp;
        if (originalOp === "Greater") {
          effectiveOp = isSymbolOnLeft ? "greater" : "less";
        } else if (originalOp === "GreaterEqual") {
          effectiveOp = isSymbolOnLeft ? "greaterEqual" : "lessEqual";
        } else if (originalOp === "Less") {
          effectiveOp = isSymbolOnLeft ? "less" : "greater";
        } else {
          effectiveOp = isSymbolOnLeft ? "lessEqual" : "greaterEqual";
        }
        if (effectiveOp === "greater" || effectiveOp === "greaterEqual") {
          const isStrict = effectiveOp === "greater";
          if (bounds.lowerBound !== void 0) {
            const lowerVal = bounds.lowerBound.numericValue;
            if (typeof lowerVal === "number" && isFinite(lowerVal)) {
              if (isStrict) {
                if (lowerVal > k) return "tautology";
                if (bounds.lowerStrict && lowerVal >= k) return "tautology";
              } else {
                if (lowerVal > k) return "tautology";
                if (bounds.lowerStrict && lowerVal >= k) return "tautology";
                if (!bounds.lowerStrict && lowerVal >= k) return "tautology";
              }
            }
          }
          if (bounds.upperBound !== void 0) {
            const upperVal = bounds.upperBound.numericValue;
            if (typeof upperVal === "number" && isFinite(upperVal)) {
              if (isStrict) {
                if (upperVal < k) return "contradiction";
                if (bounds.upperStrict && upperVal <= k) return "contradiction";
                if (!bounds.upperStrict && upperVal <= k)
                  return "contradiction";
              } else {
                if (upperVal < k) return "contradiction";
                if (bounds.upperStrict && upperVal <= k) return "contradiction";
              }
            }
          }
        } else {
          const isStrict = effectiveOp === "less";
          if (bounds.upperBound !== void 0) {
            const upperVal = bounds.upperBound.numericValue;
            if (typeof upperVal === "number" && isFinite(upperVal)) {
              if (isStrict) {
                if (upperVal < k) return "tautology";
                if (bounds.upperStrict && upperVal <= k) return "tautology";
              } else {
                if (upperVal < k) return "tautology";
                if (upperVal <= k) return "tautology";
              }
            }
          }
          if (bounds.lowerBound !== void 0) {
            const lowerVal = bounds.lowerBound.numericValue;
            if (typeof lowerVal === "number" && isFinite(lowerVal)) {
              if (isStrict) {
                if (lowerVal > k) return "contradiction";
                if (bounds.lowerStrict && lowerVal >= k) return "contradiction";
                if (!bounds.lowerStrict && lowerVal >= k)
                  return "contradiction";
              } else {
                if (lowerVal > k) return "contradiction";
                if (bounds.lowerStrict && lowerVal > k) return "contradiction";
              }
            }
          }
        }
      }
    }
  }
  if (unknowns.length === 1) {
    const symbol2 = unknowns[0];
    const def = ce.lookupDefinition(symbol2);
    if (!def) {
      ce.declare(symbol2, { type: "real" });
    } else if (isValueDef(def) && def.value.inferredType) {
      def.value.type = ce.type("real");
    }
  }
  console.assert(result.operator === "Less" || result.operator === "LessEqual");
  ce.context.assumptions.set(result, true);
  return "ok";
}
function assumeElement(proposition) {
  console.assert(proposition.operator === "Element");
  const ce = proposition.engine;
  const undefs = undefinedIdentifiers(proposition.op1);
  if (undefs.length === 1) {
    const dom = proposition.op2.evaluate();
    if (!dom.isValid) return "not-a-predicate";
    const type2 = domainToType(dom);
    if (type2 === "unknown")
      throw new Error(`Invalid domain "${dom.toString()}"`);
    ce.declare(undefs[0], type2);
    return "ok";
  }
  if (proposition.op1.symbol && hasDef(ce, proposition.op1.symbol)) {
    const domain = proposition.op2.evaluate();
    if (!domain.isValid) return "not-a-predicate";
    const type2 = domainToType(domain);
    if (!ce.context?.lexicalScope?.bindings.has(proposition.op1.symbol))
      ce.declare(proposition.op1.symbol, domainToType(domain));
    const def = ce.lookupDefinition(proposition.op1.symbol);
    if (isValueDef(def)) {
      if (def.value.type && !isSubtype(type2, def.value.type.type))
        return "contradiction";
      def.value.type = new BoxedType(type2, ce._typeResolver);
      return "ok";
    }
    if (isOperatorDef(def)) {
      if (!isSubtype(type2, functionResult(def.operator.signature.type)))
        return "contradiction";
      return "ok";
    }
    return "not-a-predicate";
  }
  if (undefs.length > 0) {
    ce.context.assumptions.set(proposition, true);
    return "ok";
  }
  const val = proposition.evaluate();
  if (val.symbol === "True") return "tautology";
  if (val.symbol === "False") return "contradiction";
  return "not-a-predicate";
}
function hasDef(ce, s) {
  return ce.lookupDefinition(s) !== void 0;
}
function undefinedIdentifiers(expr) {
  return expr.symbols.filter((x) => !hasDef(expr.engine, x));
}
function hasValue(ce, s) {
  const def = ce.lookupDefinition(s);
  if (!def) return false;
  if (isValueDef(def) && def.value.isConstant) return true;
  if (ce._getSymbolValue(s) !== void 0) return true;
  return false;
}
function getSignFromAssumptions(ce, symbol2) {
  const assumptions = ce.context?.assumptions;
  if (!assumptions) return void 0;
  for (const [assumption, _] of assumptions.entries()) {
    const op = assumption.operator;
    if (!op) continue;
    if (op !== "Less" && op !== "LessEqual") continue;
    const ops = assumption.ops;
    if (!ops || ops.length !== 2) continue;
    const [lhs, rhs] = ops;
    if (!rhs.is(0)) continue;
    if (lhs.symbol === symbol2) {
      if (op === "Less") return "negative";
      if (op === "LessEqual") return "non-positive";
    }
    if (lhs.operator === "Negate" && lhs.op1?.symbol === symbol2) {
      if (op === "Less") return "positive";
      if (op === "LessEqual") return "non-negative";
    }
    if (lhs.operator === "Subtract") {
      const [a, b] = lhs.ops ?? [];
      if (a && b) {
        if (b.symbol === symbol2 && a.isNonNegative === true) {
          if (op === "Less") return "positive";
        }
        if (a.symbol === symbol2 && b.isNonPositive === true) {
          if (op === "Less") return "negative";
        }
      }
    }
    if (lhs.operator === "Add" && lhs.ops) {
      for (const term of lhs.ops) {
        if (term.symbol === symbol2) {
          const otherTerms = lhs.ops.filter((t) => t !== term);
          if (otherTerms.length > 0 && otherTerms.every((t) => t.isNonNegative === true)) {
            if (op === "Less") return "negative";
            if (op === "LessEqual") return "non-positive";
          }
        }
        if (term.operator === "Negate" && term.op1?.symbol === symbol2) {
          const otherTerms = lhs.ops.filter((t) => t !== term);
          if (otherTerms.length > 0 && otherTerms.every((t) => t.isNonPositive === true)) {
            if (op === "Less") return "positive";
            if (op === "LessEqual") return "non-negative";
          }
        }
      }
    }
  }
  return void 0;
}
function getInequalityBoundsFromAssumptions(ce, symbol2) {
  const result = {};
  const assumptions = ce.context?.assumptions;
  if (!assumptions) return result;
  for (const [assumption, _] of assumptions.entries()) {
    const op = assumption.operator;
    if (!op) continue;
    if (op !== "Less" && op !== "LessEqual") continue;
    const ops = assumption.ops;
    if (!ops || ops.length !== 2) continue;
    const [lhs, rhs] = ops;
    if (!rhs.is(0)) continue;
    const isStrict = op === "Less";
    if (lhs.operator === "Negate" && lhs.op1?.symbol === symbol2) {
      const bound = ce.Zero;
      if (result.lowerBound === void 0 || bound.isGreater(result.lowerBound) === true) {
        result.lowerBound = bound;
        result.lowerStrict = isStrict;
      }
    }
    if (lhs.operator === "Add" && lhs.ops) {
      let hasNegatedSymbol = false;
      let constantSum = 0;
      for (const term of lhs.ops) {
        if (term.operator === "Negate" && term.op1?.symbol === symbol2) {
          hasNegatedSymbol = true;
        } else if (term.isNumberLiteral) {
          const val = typeof term.numericValue === "number" ? term.numericValue : term.numericValue?.re;
          if (val !== void 0 && Number.isFinite(val)) {
            constantSum += val;
          }
        }
      }
      if (hasNegatedSymbol && constantSum !== 0) {
        const bound = ce.box(constantSum);
        if (result.lowerBound === void 0 || bound.isGreater(result.lowerBound) === true) {
          result.lowerBound = bound;
          result.lowerStrict = isStrict;
        }
      }
    }
    if (lhs.symbol === symbol2) {
      const bound = ce.Zero;
      if (result.upperBound === void 0 || bound.isLess(result.upperBound) === true) {
        result.upperBound = bound;
        result.upperStrict = isStrict;
      }
    }
    if (lhs.operator === "Add" && lhs.ops) {
      let hasSymbol = false;
      let constantSum = 0;
      for (const term of lhs.ops) {
        if (term.symbol === symbol2) {
          hasSymbol = true;
        } else if (term.isNumberLiteral) {
          const val = typeof term.numericValue === "number" ? term.numericValue : term.numericValue?.re;
          if (val !== void 0 && Number.isFinite(val)) {
            constantSum += val;
          }
        }
      }
      if (hasSymbol && constantSum !== 0) {
        const bound = ce.box(-constantSum);
        if (result.upperBound === void 0 || bound.isLess(result.upperBound) === true) {
          result.upperBound = bound;
          result.upperStrict = isStrict;
        }
      }
    }
  }
  return result;
}
var init_assume = __esm({
  "src/compute-engine/assume.ts"() {
    init_subtype();
    init_utils();
    init_boxed_type();
    init_solve();
    init_utils5();
    init_utils3();
  }
});

// src/compute-engine/boxed-expression/compare.ts
function same(a, b) {
  if (a === b) return true;
  if (a.ops) {
    if (a.operator !== b.operator) return false;
    if (a.nops !== b.nops) return false;
    return a.ops.every((op, i) => same(op, b.ops[i]));
  }
  if (a.isNumberLiteral) {
    if (!b.isNumberLiteral) return false;
    const av = a.numericValue;
    const bv = b.numericValue;
    if (av === bv) return true;
    if (typeof av === "number") {
      if (typeof bv === "number") return av === bv;
      return bv.eq(av);
    }
    return av.eq(bv);
  }
  if (a.string || b.string) return a.string === b.string;
  if (a.symbol || b.symbol) return a.symbol === b.symbol;
  if (a.rank !== 0) {
    if (a.rank !== b.rank) return false;
    for (let i = 0; i < a.rank; i++)
      if (a.shape[i] !== b.shape[i]) return false;
    return a.tensor.equals(
      b.tensor
    );
  }
  return false;
}
function eq(a, inputB) {
  if (a.operatorDefinition?.eq) {
    const cmp2 = a.operatorDefinition.eq(a, a.engine.box(inputB));
    if (cmp2 !== void 0) return cmp2;
  }
  if (typeof inputB !== "number" && inputB.operatorDefinition?.eq) {
    const cmp2 = inputB.operatorDefinition.eq(inputB, a);
    if (cmp2 !== void 0) return cmp2;
  }
  a = a.N();
  let b = typeof inputB !== "number" ? inputB.N() : a.engine.box(inputB);
  if (a.ops || b.ops) {
    let cmp2 = a.operatorDefinition?.eq?.(a, b);
    if (cmp2 !== void 0) return cmp2;
    cmp2 = b.operatorDefinition?.eq?.(b, a);
    if (cmp2 !== void 0) return cmp2;
    if (a.isSame(b)) return true;
    if (a.unknowns.length === 0 && b.unknowns.length === 0) {
      if (a.isFinite && b.isFinite)
        return isZeroWithTolerance(a.sub(b).simplify().N());
      if (a.isNaN || b.isNaN) return false;
      if (a.isInfinity && b.isInfinity && a.sgn === b.sgn) return true;
      return false;
    }
    a = a.expand().simplify();
    b = b.expand().simplify();
    if (!sameUnknowns(a, b)) return void 0;
    return same(a, b);
  }
  if (a.symbol) {
    const cmp2 = a.valueDefinition?.eq?.(b);
    if (cmp2 !== void 0) return cmp2;
  }
  if (b.symbol) {
    const cmp2 = b.valueDefinition?.eq?.(a);
    if (cmp2 !== void 0) return cmp2;
  }
  if (a.symbol && b.symbol) return a.symbol === b.symbol;
  const ce = a.engine;
  if (a.isNumberLiteral && b.isNumberLiteral) {
    if (a.isFinite && b.isFinite) return isZeroWithTolerance(a.sub(b));
    if (a.isNaN || b.isNaN) return false;
    if (a.isInfinity && b.isInfinity && a.sgn === b.sgn) return true;
    return false;
  }
  if (ce.ask(ce.box(["Equal", a, b])).length > 0) return true;
  if (ce.ask(ce.box(["NotEqual", a, b])).length > 0) return false;
  if (a.unknowns.length > 0 || b.unknowns.length > 0) return void 0;
  return same(a, b);
}
function cmp(a, b) {
  if (a.isNumberLiteral) {
    if (typeof b !== "number" && typeof b.numericValue === "number")
      b = b.numericValue;
    if (typeof b === "number") {
      if (b === 0) {
        const s = a.sgn;
        if (s === void 0) return void 0;
        if (s === "zero") return "=";
        if (s === "positive") return ">";
        if (s === "negative") return "<";
        if (s === "non-negative") return ">=";
        if (s === "non-positive") return "<=";
        return void 0;
      }
      if (a.isNumberLiteral) {
        const av2 = a.numericValue;
        if (typeof av2 === "number") {
          if (Math.abs(av2 - b) <= a.engine.tolerance) return "=";
          return av2 < b ? "<" : ">";
        }
        if (av2.eq(b)) return "=";
        return av2.lt(b) ? "<" : ">";
      }
      return void 0;
    }
    if (!b.isNumberLiteral) {
      if (b.symbol) {
        const { getInequalityBoundsFromAssumptions: getInequalityBoundsFromAssumptions2 } = (init_assume(), __toCommonJS(assume_exports));
        const bounds = getInequalityBoundsFromAssumptions2(a.engine, b.symbol);
        const aNum = typeof a.numericValue === "number" ? a.numericValue : a.numericValue?.re;
        if (aNum !== void 0 && Number.isFinite(aNum)) {
          if (bounds.lowerBound !== void 0) {
            const lowerNum = typeof bounds.lowerBound.numericValue === "number" ? bounds.lowerBound.numericValue : bounds.lowerBound.numericValue?.re;
            if (lowerNum !== void 0 && Number.isFinite(lowerNum)) {
              if (lowerNum > aNum) return "<";
              if (lowerNum === aNum && bounds.lowerStrict) return "<";
              if (lowerNum === aNum && !bounds.lowerStrict) return "<=";
            }
          }
          if (bounds.upperBound !== void 0) {
            const upperNum = typeof bounds.upperBound.numericValue === "number" ? bounds.upperBound.numericValue : bounds.upperBound.numericValue?.re;
            if (upperNum !== void 0 && Number.isFinite(upperNum)) {
              if (upperNum < aNum) return ">";
              if (upperNum === aNum && bounds.upperStrict) return ">";
              if (upperNum === aNum && !bounds.upperStrict) return ">=";
            }
          }
        }
      }
      return void 0;
    }
    const av = a.numericValue;
    const bv = b.numericValue;
    if (typeof av === "number") {
      if (bv.eq(av)) return "=";
      if (bv.lt(av)) return ">";
      return "<";
    }
    return av.eq(bv) ? "=" : av.lt(bv) ? "<" : ">";
  }
  if (typeof b === "number") {
    if (a.symbol) {
      const { getInequalityBoundsFromAssumptions: getInequalityBoundsFromAssumptions2 } = (init_assume(), __toCommonJS(assume_exports));
      const bounds = getInequalityBoundsFromAssumptions2(a.engine, a.symbol);
      if (bounds.lowerBound !== void 0) {
        const lowerNum = typeof bounds.lowerBound.numericValue === "number" ? bounds.lowerBound.numericValue : bounds.lowerBound.numericValue?.re;
        if (lowerNum !== void 0 && Number.isFinite(lowerNum)) {
          if (lowerNum > b) return ">";
          if (lowerNum === b && bounds.lowerStrict) return ">";
          if (lowerNum === b && !bounds.lowerStrict) return ">=";
        }
      }
      if (bounds.upperBound !== void 0) {
        const upperNum = typeof bounds.upperBound.numericValue === "number" ? bounds.upperBound.numericValue : bounds.upperBound.numericValue?.re;
        if (upperNum !== void 0 && Number.isFinite(upperNum)) {
          if (upperNum < b) return "<";
          if (upperNum === b && bounds.upperStrict) return "<";
          if (upperNum === b && !bounds.upperStrict) return "<=";
        }
      }
    }
    return void 0;
  }
  if (a.ops || b.ops) {
    const cmp2 = a.operatorDefinition?.eq?.(a, b);
    if (cmp2 !== void 0) return "=";
    const diff = a.sub(b).N();
    if (!diff.isNumberLiteral) return void 0;
    if (typeof diff.numericValue === "number") {
      if (diff.numericValue === 0) return "=";
      return diff.numericValue < 0 ? "<" : ">";
    }
    const tol = a.engine.tolerance;
    if (diff.numericValue.isZeroWithTolerance(tol)) return "=";
    return diff.numericValue.lt(0) ? "<" : ">";
  }
  if (a.symbol) {
    if (a.symbol === b.symbol) return "=";
    const cmpResult = a.valueDefinition?.cmp?.(b);
    if (cmpResult) return cmpResult;
    const eqResult = a.valueDefinition?.eq?.(b);
    if (eqResult === true) return "=";
    if (b.isNumberLiteral) {
      const { getInequalityBoundsFromAssumptions: getInequalityBoundsFromAssumptions2 } = (init_assume(), __toCommonJS(assume_exports));
      const bounds = getInequalityBoundsFromAssumptions2(a.engine, a.symbol);
      const bNum = typeof b.numericValue === "number" ? b.numericValue : b.numericValue?.re;
      if (bNum !== void 0 && Number.isFinite(bNum)) {
        if (bounds.lowerBound !== void 0) {
          const lowerNum = typeof bounds.lowerBound.numericValue === "number" ? bounds.lowerBound.numericValue : bounds.lowerBound.numericValue?.re;
          if (lowerNum !== void 0 && Number.isFinite(lowerNum)) {
            if (lowerNum > bNum) return ">";
            if (lowerNum === bNum && bounds.lowerStrict) return ">";
            if (lowerNum === bNum && !bounds.lowerStrict) return ">=";
          }
        }
        if (bounds.upperBound !== void 0) {
          const upperNum = typeof bounds.upperBound.numericValue === "number" ? bounds.upperBound.numericValue : bounds.upperBound.numericValue?.re;
          if (upperNum !== void 0 && Number.isFinite(upperNum)) {
            if (upperNum < bNum) return "<";
            if (upperNum === bNum && bounds.upperStrict) return "<";
            if (upperNum === bNum && !bounds.upperStrict) return "<=";
          }
        }
      }
    }
    return void 0;
  }
  if (a.string) {
    if (!b.string) return void 0;
    if (a.string === b.string) return "=";
    return a.string < b.string ? "<" : ">";
  }
  if (a.tensor) {
    if (!b.tensor) return void 0;
    if (a.tensor.equals(b.tensor))
      return "=";
    return void 0;
  }
  return void 0;
}
function isZeroWithTolerance(expr) {
  if (!expr.isNumberLiteral) return false;
  const n = expr.numericValue;
  const ce = expr.engine;
  if (typeof n === "number") return ce.chop(n) === 0;
  return n.isZeroWithTolerance(ce.tolerance);
}
function sameUnknowns(a, b) {
  const ua = a.unknowns;
  const ub = b.unknowns;
  if (ua.length !== ub.length) return false;
  for (const u of ua) if (!ub.includes(u)) return false;
  return true;
}
var init_compare = __esm({
  "src/compute-engine/boxed-expression/compare.ts"() {
  }
});

// src/compute-engine/function-utils.ts
var function_utils_exports = {};
__export(function_utils_exports, {
  applicable: () => applicable,
  applicableN1: () => applicableN1,
  apply: () => apply3,
  canonicalFunctionLiteral: () => canonicalFunctionLiteral,
  canonicalFunctionLiteralArguments: () => canonicalFunctionLiteralArguments,
  lookup: () => lookup,
  makeLambdaN1: () => makeLambdaN1,
  order: () => order2,
  parseFunctionSignature: () => parseFunctionSignature,
  predicate: () => predicate
});
function predicate(_expr) {
  return () => false;
}
function order2(_expr) {
  return (a, b) => {
    const c = cmp(a, b);
    if (c === "=") return 0;
    if (c === "<" || c === "<=") return -1;
    return 1;
  };
}
function canonicalFunctionLiteral(expr) {
  if (!expr) return void 0;
  if (expr.operator === "Function" && expr.isCanonical) return expr;
  if (expr.symbol) return expr;
  if (expr.operator === "BuiltinFunction") return expr.op1;
  if (expr.operator === "Delimiter") {
    if (expr.op1.operator === "Sequence") {
      if (expr.op1.nops === 1) {
        expr = expr.op1;
      } else {
        return canonicalFunctionLiteral(
          expr.engine._fn("Block", expr.op1.ops, { canonical: false })
        );
      }
    }
    return canonicalFunctionLiteral(expr.op1);
  }
  if (expr.operator === "Function")
    return canonicalFunctionLiteralArguments(expr.engine, expr.ops);
  if (expr.operator) {
    console.assert(expr.operator !== "Function");
    const ce = expr.engine;
    let body = expr.subs({ _: "_1" });
    let i = 1;
    let params = [];
    while (i < 10) {
      if (body.has(`_${i}`))
        params.push(body.engine.symbol(`_${i}`, { canonical: false }));
      i++;
    }
    if (params.length === 0) {
      if (body.operator !== "Block") body = ce.function("Block", [body]);
      else body = body.canonical;
      const unknowns = body.unknowns;
      if (unknowns.length > 0) {
        params = unknowns.map((x) => ce.symbol(x, { canonical: false }));
      }
    }
    return canonicalFunctionLiteralArguments(ce, [body, ...params]);
  }
  return void 0;
}
function canonicalFunctionLiteralArguments(ce, ops) {
  if (ops.length === 0) return void 0;
  const block = ops[0].operator === "Block" ? ops[0].canonical : ce.function("Block", [ops[0]]);
  const params = ops.slice(1).map((x) => x.symbol ? x : ce.error("expected-a-symbol", x.toString()));
  console.assert(block.isScoped);
  for (const param of params) {
    if (param.symbol && !block.localScope.bindings.has(param.symbol)) {
      ce.declare(
        param.symbol,
        { inferred: true, type: "unknown" },
        block.localScope
      );
    }
  }
  return ce._fn("Function", [block, ...params]);
}
function apply3(fn, args) {
  const result = makeLambda(fn)?.(args);
  if (result) return result;
  return fn.engine.function("Apply", [fn, ...args]);
}
function makeLambda(expr) {
  const ce = expr.engine;
  if (expr.symbol) return (args) => ce.function(expr.symbol, args).evaluate();
  const canonicalExpr = canonicalFunctionLiteral(expr);
  if (!canonicalExpr) throw new Error("Invalid function literal");
  expr = canonicalExpr;
  console.assert(expr.operator === "Function");
  console.assert(expr.isCanonical);
  console.assert(expr.ops);
  if (expr.ops.length === 1) {
    console.assert(expr.ops[0]);
    return () => expr.ops[0].evaluate();
  }
  const [body, ...params] = expr.ops;
  console.assert(body.isScoped);
  return (args) => {
    if (args.length > params.length) {
      throw new Error(
        `Too many arguments for function "${expr.toString()}": expected ${params.length}, got ${args.length}`
      );
    }
    if (ce.strict && !args.every((x) => x.isValid)) return void 0;
    if (args.length < params.length) {
      const allSymbols = /* @__PURE__ */ new Set([
        ...body.symbols,
        ...params.map((p) => p.symbol)
      ]);
      const extras = params.slice(args.length).map((_, i) => {
        let name = `_${i + 1}`;
        let counter = 0;
        while (allSymbols.has(name)) {
          name = `_${i + 1}_${counter++}`;
        }
        allSymbols.add(name);
        return ce.symbol(name, { canonical: false });
      });
      const substitutions = Object.fromEntries(
        params.slice(args.length).map((param, i) => [param.symbol, extras[i]])
      );
      const newBody = body.evaluate({
        withArguments: Object.fromEntries(
          params.slice(0, args.length).map((key, i) => [key.symbol, args[i]])
        )
      }).subs(substitutions);
      return ce.function("Function", [newBody, ...extras]);
    }
    const result = body.evaluate({
      withArguments: Object.fromEntries(
        params.map((key, i) => [key.symbol, args[i].evaluate()])
      )
    });
    return result.isValid ? result : void 0;
  };
}
function makeLambdaN1(expr) {
  const lambda = makeLambda(expr);
  if (!lambda) return void 0;
  return (arg) => lambda([expr.engine.number(arg)])?.valueOf() ?? NaN;
}
function applicable(fn) {
  return makeLambda(fn) ?? ((xs) => fn.engine.function("Apply", [fn, ...xs]).evaluate());
}
function applicableN1(fn) {
  const lambda = makeLambda(fn);
  const ce = fn.engine;
  if (lambda) return (x) => lambda([ce.number(x)])?.re ?? NaN;
  return (x) => ce.function("Apply", [fn, ce.number(x)]).evaluate().re;
}
function parseFunctionSignature(s) {
  const m = s.match(/(.+)\((.*)\)/);
  if (!m) return [s, void 0];
  const id = m[1];
  const args = m[2].split(",").map((x) => x.trim());
  return [id, args];
}
function lookup(id, scope) {
  console.assert(typeof id === "string" && id.length > 0);
  let currentScope = scope;
  while (currentScope) {
    const def = currentScope.bindings.get(id);
    if (def) return def;
    currentScope = currentScope.parent;
  }
  return void 0;
}
var init_function_utils = __esm({
  "src/compute-engine/function-utils.ts"() {
    init_compare();
  }
});

// src/compute-engine/boxed-expression/boxed-operator-definition.ts
var OPERATOR_DEF_KEYS, _BoxedOperatorDefinition;
var init_boxed_operator_definition = __esm({
  "src/compute-engine/boxed-expression/boxed-operator-definition.ts"() {
    init_boxed_type();
    init_function_utils();
    init_order();
    init_utils();
    init_subtype();
    init_collection_utils();
    OPERATOR_DEF_KEYS = /* @__PURE__ */ new Set([
      // Base
      "engine",
      "name",
      "description",
      "examples",
      "wikidata",
      "url",
      // Function Flags
      "lazy",
      "scoped",
      "broadcastable",
      "associative",
      "commutative",
      "commutativeOrder",
      "idempotent",
      "involution",
      "pure",
      "inferredSignature",
      "signature",
      "type",
      "sgn",
      "even",
      "complexity",
      "canonical",
      "evaluate",
      "evaluateAsync",
      "evalDimension",
      "compile",
      "eq",
      "neq",
      "cmp",
      // Collection Handlers
      "collection"
    ]);
    _BoxedOperatorDefinition = class {
      engine;
      name;
      description;
      url;
      wikidata;
      broadcastable = false;
      associative = false;
      commutative = false;
      commutativeOrder;
      idempotent = false;
      involution = false;
      pure = true;
      complexity = DEFAULT_COMPLEXITY;
      lazy = false;
      scoped = false;
      signature;
      inferredSignature = true;
      type;
      sgn;
      eq;
      neq;
      even;
      canonical;
      evaluate;
      evaluateAsync;
      evalDimension;
      compile;
      collection;
      constructor(ce, name, def) {
        this.name = name;
        this.engine = ce;
        if (def.signature) {
          this.inferredSignature = false;
          this.signature = def.signature instanceof BoxedType ? def.signature : new BoxedType(def.signature, ce._typeResolver);
        } else this.signature = new BoxedType("(any*) -> unknown");
        this.update(def);
        ce.listenToConfigurationChange(this);
      }
      /** For debugging */
      toJSON() {
        const result = { name: this.name };
        if (this.wikidata) result.wikidata = this.wikidata;
        if (this.description) result.description = this.description;
        if (this.url) result.url = this.url;
        result.broadcastable = this.broadcastable;
        result.associative = this.associative;
        result.commutative = this.commutative;
        result.idempotent = this.idempotent;
        result.involution = this.involution;
        result.pure = this.pure;
        result.lazy = this.lazy;
        result.complexity = this.complexity;
        result.scoped = this.scoped;
        result.signature = this.signature.toString();
        result.inferredSignature = this.inferredSignature;
        if (this.collection) result.collection = this.collection;
        return result;
      }
      infer(sig) {
        const newSig = new BoxedType(sig, this.engine._typeResolver);
        if (!newSig.matches(this.signature))
          throw new Error(
            `Operator Definition "${this.name}": inferred signature "${newSig}" does not match current signature "${this.signature}"`
          );
        if (this.inferredSignature) this.signature = newSig;
      }
      update(def) {
        if (this.engine.strict) {
          for (const key in def) {
            if (!OPERATOR_DEF_KEYS.has(key))
              throw new Error(
                `Operator Definition "${this.name}": unexpected key "${key}"`
              );
          }
        }
        if ("name" in def && def.name !== this.name)
          throw new Error(
            `Operator Definition "${this.name}": cannot change name to "${def.name}"`
          );
        if ("engine" in def && def.engine !== this.engine)
          throw new Error(
            `Operator Definition "${this.name}": cannot change engine`
          );
        this.lazy = def.lazy ?? this.lazy;
        this.scoped = def.scoped ?? this.scoped;
        const idempotent = def.idempotent ?? this.idempotent;
        const involution = def.involution ?? this.involution;
        if (idempotent && involution)
          throw new Error(
            `Operator Definition "${this.name}": the 'idempotent' and 'involution' flags are mutually exclusive`
          );
        this.idempotent = idempotent;
        this.involution = involution;
        this.description = def.description ?? this.description;
        this.collection = def.collection ?? this.collection;
        this.url = def.url ?? this.url;
        this.wikidata = def.wikidata ?? this.wikidata;
        this.broadcastable = def.broadcastable ?? this.broadcastable;
        this.associative = def.associative ?? this.associative;
        this.commutative = def.commutative ?? this.commutative;
        this.commutativeOrder = def.commutativeOrder ?? this.commutativeOrder;
        if (this.commutativeOrder && !this.commutative)
          throw new Error(
            `Operator Definition "${this.name}": the 'commutativeOrder' handler requires the 'commutative' flag`
          );
        if (def.canonical && (def.associative || def.commutative || def.idempotent || def.involution))
          throw new Error(
            `Operator Definition "${this.name}": the 'canonical' handler is incompatible with the 'associative', 'commutative', 'idempotent', and 'involution' flags`
          );
        this.pure = def.pure ?? this.pure;
        this.complexity = def.complexity ?? this.complexity;
        if (def.signature) {
          const oldSig = def.signature;
          const newSig = def.signature instanceof BoxedType ? def.signature : this.engine.type(def.signature);
          if (oldSig && !newSig.matches(this.engine.type(oldSig))) {
            console.log(newSig.matches(this.engine.type(oldSig)));
            throw new Error(
              `Operator Definition "${this.name}": signature "${newSig}" does not match "${oldSig}"`
            );
          }
          this.signature = newSig;
          if ("inferredSignature" in def)
            this.inferredSignature = def.inferredSignature;
        }
        this.type = def.type ?? this.type;
        this.evaluateAsync = def.evaluateAsync ?? this.evaluateAsync;
        this.canonical = def.canonical ?? this.canonical;
        this.evalDimension = def.evalDimension ?? this.evalDimension;
        this.sgn = def.sgn ?? this.sgn;
        this.even = def.even ?? this.even;
        this.compile = def.xcompile ?? this.compile;
        this.eq = def.eq ?? this.eq;
        this.neq = def.neq ?? this.neq;
        this.scoped = def.scoped ?? this.scoped;
        this.lazy = def.lazy ?? this.lazy;
        if (def.collection)
          this.collection = defaultCollectionHandlers(def.collection);
        if (this.collection) {
          const resultType = functionResult(this.signature.type);
          if (!resultType)
            throw new Error(
              `Operator Definition "${this.name}": a collection handler is defined, but the signature "${this.signature}" does not have a result type`
            );
          if (!isSubtype(resultType, "collection"))
            throw new Error(
              `Operator Definition "${this.name}": a collection handler is defined, but the signature "${this.signature}" is not a collection type`
            );
          if (isSubtype(resultType, "indexed_collection") && !this.collection.at) {
            throw new Error(
              `Operator Definition "${this.name}" returns an indexed collection, but the 'at' handler is missing`
            );
          }
        }
        let evaluate = void 0;
        if (def.evaluate && typeof def.evaluate !== "function") {
          const scope = this.scoped ? {
            parent: this.engine.context.lexicalScope,
            bindings: /* @__PURE__ */ new Map()
          } : void 0;
          const boxedFn = this.engine.box(def.evaluate, {
            canonical: false,
            scope
          });
          if (!boxedFn.isValid)
            throw Error(`Invalid function ${boxedFn.toString()}`);
          if (this.inferredSignature && boxedFn.operator === "Function") {
            const body = boxedFn.ops[0];
            const params = boxedFn.ops.slice(1);
            const bodyType = body.type.toString();
            const paramTypes = params.map(() => "unknown").join(", ");
            this.signature = new BoxedType(
              `(${paramTypes}) -> ${bodyType}`,
              this.engine._typeResolver
            );
          }
          const fn = applicable(boxedFn);
          evaluate = (xs) => fn(xs);
          Object.defineProperty(evaluate, "toString", {
            value: () => boxedFn.toString()
          });
        } else evaluate = def.evaluate ?? this.evaluate;
        this.evaluate = evaluate;
      }
      onConfigurationChange() {
        return;
      }
    };
  }
});

// src/compute-engine/boxed-expression/boxed-value-definition.ts
function dynamicValue(ce, value) {
  if (value === void 0) return void 0;
  if (isLatexString(value)) return ce.parse(value) ?? ce.symbol("Undefined");
  if (typeof value === "function") return ce.box(value(ce) ?? "Undefined");
  if (value instanceof _BoxedExpression) return value;
  return ce.box(value);
}
function inferTypeFromValue2(ce, value) {
  if (!value) return ce.type("unknown");
  if (value.type.matches("integer")) {
    return ce.type("integer");
  }
  if (value.type.matches("rational")) {
    return ce.type("real");
  }
  if (value.type.matches("real")) {
    return ce.type("real");
  }
  if (value.type.matches("complex")) {
    return ce.type("number");
  }
  return value.type;
}
var _BoxedValueDefinition;
var init_boxed_value_definition = __esm({
  "src/compute-engine/boxed-expression/boxed-value-definition.ts"() {
    init_parse();
    init_utils();
    init_boxed_type();
    init_collection_utils();
    init_abstract_boxed_expression();
    init_utils3();
    _BoxedValueDefinition = class {
      name;
      /** Used for debugging and error messages */
      wikidata;
      description;
      url;
      _engine;
      // The defValue is the value as specified in the original definition.
      // It is used to update the actual value when the environment changes,
      // for example when the precision of the Compute Engine is changed.
      _defValue;
      // If `null`, the value needs to be recalculated from _defValue
      // If `undefined`, the value is not defined (for example, the symbol `True` does not have a value: the symbol itself *is* the value)
      _value;
      // If `null`, the type is the type of the value
      // Note that `_type` may be different (wider) than the value's type
      _type;
      // If true, the `_type` is inferred
      inferredType;
      // If `true`, the value or type cannot be changed
      _isConstant = false;
      // If 'never', the symbol is replaced by its value during canonicalization.
      // If 'evaluate', the symbol is replaced by its value during evaluation.
      // If 'N', the symbol is replaced during a numeric evaluation.
      holdUntil = "evaluate";
      // Those optional handlers are used to compare the symbol with other
      // symbols or values. This is useful for example with sets
      eq;
      neq;
      cmp;
      // This optional handler is used to do collection operations on the symbol
      collection;
      // This optional handler is used to evaluate subscripted expressions of this symbol
      subscriptEvaluate;
      constructor(ce, name, def) {
        this._engine = ce;
        this.name = name;
        if (def.wikidata) this.wikidata = def.wikidata;
        if (def.description) this.description = def.description;
        if (def.url) this.url = def.url;
        if (def.holdUntil) this.holdUntil = def.holdUntil;
        if (def.isConstant) {
          this._isConstant = def.isConstant;
          this._defValue = def.value;
        }
        if (def.type) {
          const type2 = def.type instanceof BoxedType ? def.type : parseType(def.type);
          if (!isValidType(type2))
            throw new Error(
              [`Symbol "${this.name}"`, `The type "${def.type}" is invalid `].join(
                "\n|   "
              )
            );
          this._type = new BoxedType(type2, ce._typeResolver);
          this.inferredType = def.inferred ?? false;
          ce.listenToConfigurationChange(this);
        }
        this._value = dynamicValue(this._engine, def.value);
        if (this._value) {
          if (!this._type || this._type.isUnknown) {
            if (this.isConstant) {
              this._type = this._value.type;
              this.inferredType = false;
            } else {
              this._type = inferTypeFromValue2(ce, this._value);
              this.inferredType = true;
            }
          } else {
            if (!this._value.type.matches(this._type)) {
              throw new Error(
                [
                  `Symbol "${this.name}"`,
                  `The value "${this._value.toString()}" of type "${this._value.type}" is not compatible with the type "${this._type}"`
                ].join("\n|   ")
              );
            }
          }
        }
        if (def.eq) this.eq = def.eq;
        if (def.neq) this.neq = def.neq;
        if (def.cmp) this.cmp = def.cmp;
        if (def.collection) {
          if (name === "Take") debugger;
          this.collection = defaultCollectionHandlers(def.collection);
        }
        if (def.subscriptEvaluate) this.subscriptEvaluate = def.subscriptEvaluate;
        if (this.holdUntil === "never" && !this.isConstant)
          throw new Error(
            [
              `Symbol "${this.name}"`,
              `The "holdUntil" property cannot be "never" for a non-constant symbol`
            ].join("\n|   ")
          );
      }
      /** For debugging */
      toJSON() {
        const result = { name: this.name, isConstant: this._isConstant };
        if (this.wikidata) result.wikidata = this.wikidata;
        if (this.description) result.description = this.description;
        if (this.url) result.url = this.url;
        if (this._type) result.type = this._type.toString();
        result.inferredType = this.inferredType;
        result.holdUntil = this.holdUntil;
        if (this.collection) result.collection = this.collection;
        return result;
      }
      get isConstant() {
        return this._isConstant;
      }
      get value() {
        if (this._value === null)
          this._value = dynamicValue(this._engine, this._defValue);
        return this._value;
      }
      get type() {
        return this._type ?? this._value?.type ?? BoxedType.unknown;
      }
      set type(t) {
        if (this._isConstant)
          throw new Error(
            `The type of the constant "${this.name}" cannot be changed`
          );
        this._type = t instanceof BoxedType ? t : new BoxedType(t, this._engine._typeResolver);
        if (this._type.isUnknown) {
          this._defValue = void 0;
          this._value = void 0;
        }
      }
      onConfigurationChange() {
        if (this.isConstant) this._value = null;
      }
    };
  }
});

// src/compute-engine/boxed-expression/utils.ts
function hasSymbolicTranscendental(expr) {
  const op = expr.operator;
  const transcendentals = [
    "Ln",
    "Log",
    "Log2",
    "Log10",
    "Sin",
    "Cos",
    "Tan",
    "Exp"
  ];
  if (transcendentals.includes(op) && expr.op1?.isConstant) {
    const simplified = expr.simplify();
    if (simplified.isRational) {
      return false;
    }
    return true;
  }
  if (expr.ops) {
    for (const child of expr.ops) {
      if (hasSymbolicTranscendental(child)) return true;
    }
  }
  return false;
}
function isDictionary(expr) {
  return expr !== null && expr !== void 0 && expr instanceof _BoxedExpression && expr.type.matches("dictionary");
}
function isBoxedExpression(x) {
  return x instanceof _BoxedExpression;
}
function bignumPreferred(ce) {
  return ce.precision > MACHINE_PRECISION;
}
function hashCode(s) {
  let hash = 0;
  for (let i = 0; i < s.length; i++)
    hash = Math.imul(31, hash) + s.charCodeAt(i) | 0;
  return Math.abs(hash);
}
function normalizedUnknownsForSolve(syms) {
  if (syms === null || syms === void 0) return [];
  if (typeof syms === "string") return [syms];
  if (isBoxedExpression(syms)) return normalizedUnknownsForSolve(syms.symbol);
  if (typeof syms[Symbol.iterator] === "function")
    return Array.from(syms).map(
      (s) => typeof s === "string" ? s : s.symbol
    );
  return [];
}
function domainToType(expr) {
  if (expr.symbol === "Numbers") return "number";
  if (expr.symbol === "ComplexNumbers") return "complex";
  if (expr.symbol === "ImaginaryNumbers") return "imaginary";
  if (expr.symbol === "RealNumbers") return "real";
  if (expr.symbol === "RationalNumbers") return "rational";
  if (expr.symbol === "Integers") return "integer";
  return "unknown";
}
function angleToRadians(x) {
  if (!x) return x;
  const ce = x.engine;
  const angularUnit = ce.angularUnit;
  if (angularUnit === "rad") return x;
  if (angularUnit === "deg") x = x.mul(ce.Pi).div(180);
  if (angularUnit === "grad") x = x.mul(ce.Pi).div(200);
  if (angularUnit === "turn") x = x.mul(ce.Pi).mul(2);
  return x;
}
function canonicalAngle(x) {
  if (!x) return x;
  const theta = angleToRadians(x);
  if (!theta) return void 0;
  if (theta.N().im !== 0) return theta;
  const ce = theta.engine;
  const [k, t] = getPiTerm(theta);
  if (k.isZero) return ce.number(t);
  const k2 = ce._numericValue(k.bignumRe ? k.bignumRe.mod(2) : k.re % 2);
  return ce.number(t.add(ce.Pi.mul(k2).N().numericValue));
}
function getImaginaryFactor(expr) {
  if (typeof expr === "number") return void 0;
  const ce = expr.engine;
  if (expr.symbol === "ImaginaryUnit") return ce.One;
  if (expr.re === 0) return ce.number(expr.im);
  if (expr.operator === "Negate") return getImaginaryFactor(expr.op1)?.neg();
  if (expr.operator === "Complex") {
    if (expr.op1.is(0) && !isNaN(expr.op2.re)) return ce.number(expr.op2.re);
    return void 0;
  }
  if (expr.operator === "Multiply" && expr.nops === 2) {
    const [op1, op2] = expr.ops;
    if (op1.symbol === "ImaginaryUnit") return op2;
    if (op2.symbol === "ImaginaryUnit") return op1;
    if (op2.isNumberLiteral && op2.re === 0 && op2.im !== 0)
      return op1.mul(op2.im);
    if (op1.isNumberLiteral && op1.re === 0 && op1.im !== 0)
      return op2.mul(op1.im);
  }
  if (expr.operator === "Divide") {
    const denom = expr.op2;
    if (denom.is(0)) return void 0;
    return getImaginaryFactor(expr.op1)?.div(denom);
  }
  return void 0;
}
function isImaginaryUnit(expr) {
  const { engine } = expr;
  if (expr === engine.I) return true;
  if (expr.isNumberLiteral) return expr.re === 0 && expr.im === 1;
  if (expr.symbol !== null) return expr.canonical.isSame(engine.I);
  return false;
}
function getPiTerm(expr) {
  const ce = expr.engine;
  if (expr.symbol === "Pi") return [ce._numericValue(1), ce._numericValue(0)];
  if (expr.operator === "Negate") {
    const [k, t] = getPiTerm(expr.ops[0]);
    return [k.neg(), t.neg()];
  }
  if (expr.operator === "Add" && expr.nops === 2) {
    const [k1, t1] = getPiTerm(expr.op1);
    const [k2, t2] = getPiTerm(expr.op2);
    return [k1.add(k2), t1.add(t2)];
  }
  if (expr.operator === "Multiply" && expr.nops === 2) {
    if (expr.op1.isNumberLiteral) {
      const [k, t] = getPiTerm(expr.op2);
      const n = expr.op1.numericValue;
      return [k.mul(n), t.mul(n)];
    }
    if (expr.op2.isNumberLiteral) {
      const [k, t] = getPiTerm(expr.op1);
      const n = expr.op2.numericValue;
      return [k.mul(n), t.mul(n)];
    }
  }
  if (expr.operator === "Divide") {
    if (expr.op2.isNumberLiteral) {
      const [k1, t1] = getPiTerm(expr.op1);
      const d = expr.op2.numericValue;
      return [k1.div(d), t1.div(d)];
    }
  }
  return [ce._numericValue(0), ce._numericValue(expr.N().numericValue ?? 0)];
}
function isValidOperatorDef(def) {
  if (def === void 0 || def === null || typeof def !== "object")
    return false;
  if (isBoxedExpression(def)) return false;
  if ("signature" in def || "complexity" in def) {
    if ("constant" in def) {
      throw new Error(
        "Operator definition cannot have a `constant` field and value definition cannot have a `signature` field."
      );
    }
  }
  if (!("evaluate" in def) && !("signature" in def) && !("sgn" in def) && !("complexity" in def) && !("canonical" in def))
    return false;
  if ("type" in def && def.type !== void 0 && typeof def.type !== "function") {
    throw new Error(
      "The `type` field of an operator definition should be a function"
    );
  }
  if ("sgn" in def && def.sgn !== void 0 && typeof def.sgn !== "function") {
    throw new Error(
      "The `sgn` field of an operator definition should be a function"
    );
  }
  return true;
}
function isValidValueDef(def) {
  if (def === void 0 || def === null || typeof def !== "object")
    return false;
  if (isBoxedExpression(def)) return false;
  if ("value" in def || "constant" in def || "inferred" in def || "subscriptEvaluate" in def) {
    if ("type" in def && typeof def.type === "function") return false;
    if ("signature" in def) {
      throw new Error(
        "Value definition cannot have a `signature` field. Use a `type` field instead."
      );
    }
    if ("sgn" in def) {
      throw new Error(
        "Value definition cannot have a `sgn` field. Use a `flags.sgn` field instead."
      );
    }
    return true;
  }
  if ("type" in def && def.type !== void 0 && typeof def.type !== "function") {
    return true;
  }
  if ("description" in def) {
    throw new Error("Definitions should have a `type` or `value` field.");
  }
  return false;
}
function isValueDef(def) {
  return def !== void 0 && "value" in def;
}
function isOperatorDef(def) {
  return def !== void 0 && "operator" in def;
}
function updateDef(ce, name, def, newDef) {
  if (newDef instanceof _BoxedValueDefinition) {
    delete def.operator;
    def.value = newDef.value;
  } else if (isValidValueDef(newDef)) {
    delete def.operator;
    def.value = new _BoxedValueDefinition(ce, name, newDef);
  } else if (newDef instanceof _BoxedOperatorDefinition) {
    delete def.value;
    def.operator = newDef;
  } else if (isValidOperatorDef(newDef)) {
    delete def.value;
    def.operator = new _BoxedOperatorDefinition(ce, name, newDef);
  }
}
var init_utils5 = __esm({
  "src/compute-engine/boxed-expression/utils.ts"() {
    init_numeric();
    init_boxed_operator_definition();
    init_boxed_value_definition();
    init_abstract_boxed_expression();
  }
});

// src/compute-engine/boxed-expression/validate.ts
function typeCouldBeCollection(type2) {
  if (typeof type2 === "string") {
    return type2 === "collection" || type2 === "indexed_collection" || type2 === "list" || type2 === "set" || type2 === "tuple" || type2 === "any";
  }
  if (type2.kind === "list" || type2.kind === "set" || type2.kind === "tuple")
    return true;
  if (type2.kind === "union") return type2.types.some((t) => typeCouldBeCollection(t));
  return false;
}
function typeCouldBeNumericCollection(type2) {
  if (typeof type2 === "string") {
    return type2 === "list" || type2 === "set" || type2 === "collection" || type2 === "indexed_collection";
  }
  if (type2.kind === "list" || type2.kind === "set") return true;
  if (type2.kind === "union")
    return type2.types.some((t) => typeCouldBeNumericCollection(t));
  return false;
}
function checkArity(ce, ops, count) {
  ops = flatten(ops);
  if (!ce.strict) return ops;
  if (ops.length === count) return ops;
  const xs = [...ops.slice(0, count)];
  let i = Math.min(count, ops.length);
  while (i < count) {
    xs.push(ce.error("missing"));
    i += 1;
  }
  while (i < ops.length) {
    xs.push(ce.error("unexpected-argument", ops[i].toString()));
    i += 1;
  }
  return xs;
}
function checkNumericArgs(ce, ops, options) {
  let count = typeof options === "number" ? options : options?.count;
  const flattenHead = typeof options === "number" ? void 0 : options?.flatten;
  ops = flatten(ops, flattenHead);
  if (!ce.strict) {
    let inferredType = "real";
    for (const x of ops)
      if (isSubtype("complex", x.type.type)) {
        inferredType = "number";
        break;
      }
    for (const x of ops)
      if (!isFiniteIndexedCollection(x)) x.infer(inferredType);
    return ops;
  }
  let isValid = true;
  count ??= ops.length;
  const xs = [];
  for (let i = 0; i <= Math.max(count - 1, ops.length - 1); i++) {
    const op = ops[i];
    if (i > count - 1) {
      isValid = false;
      xs.push(ce.error("unexpected-argument", op.toString()));
    } else if (op === void 0) {
      isValid = false;
      xs.push(ce.error("missing"));
    } else if (!op.isValid) {
      isValid = false;
      xs.push(op);
    } else if (op.isNumber) {
      xs.push(op);
    } else if (op.symbol && !ce.lookupDefinition(op.symbol)) {
      xs.push(op);
    } else if (op.type.isUnknown || op.type.type === "any") {
      xs.push(op);
    } else if (typeCouldBeNumericCollection(op.type.type)) {
      xs.push(op);
    } else if (isBoxedTensor(op)) {
      xs.push(op);
    } else if (isFiniteIndexedCollection(op)) {
      for (const x of op.each()) {
        if (!x.isNumber) {
          isValid = false;
          break;
        }
      }
      if (!isValid) xs.push(ce.typeError("number", op.type, op));
      else xs.push(op);
    } else if (op.valueDefinition?.inferredType && isSubtype("number", op.type.type)) {
      xs.push(op);
    } else if (op.operatorDefinition?.inferredSignature && isSubtype("number", op.type.type)) {
      xs.push(op);
    } else if (op.operator === "Hold" || op.valueDefinition?.value?.operator === "Hold") {
      xs.push(op);
    } else {
      isValid = false;
      xs.push(ce.typeError("number", op.type, op));
    }
  }
  if (isValid) {
    let inferredType = "real";
    for (const x of xs)
      if (isSubtype("complex", x.type.type)) {
        inferredType = "number";
        break;
      }
    for (const x of xs)
      if (isFiniteIndexedCollection(x))
        for (const y of x.each()) y.infer(inferredType);
      else x.infer(inferredType);
  }
  return xs;
}
function checkType(ce, arg, type2) {
  if (arg === void 0 || arg === null) return ce.error("missing");
  if (type2 === void 0)
    return ce.error("unexpected-argument", arg.toString());
  arg = arg.canonical;
  if (!arg.isValid) return arg;
  if (arg.type.matches(type2)) return arg;
  return ce.typeError(type2, arg.type, arg);
}
function checkTypes(ce, args, types) {
  if (args.length === types.length && args.every((x, i) => x.type.matches(types[i])))
    return args;
  const xs = [];
  for (let i = 0; i <= types.length - 1; i++)
    xs.push(checkType(ce, args[i], types[i]));
  for (let i = types.length; i <= args.length - 1; i++)
    xs.push(ce.error("unexpected-argument", args[i].toString()));
  return xs;
}
function validateArguments(ce, ops, signature, lazy, threadable) {
  if (!ce.strict) return null;
  if (typeof signature === "string") return null;
  if (signature.kind !== "signature") return null;
  const result = [];
  let isValid = true;
  const params = signature.args?.map((x) => x.type) ?? [];
  const optParams = signature.optArgs?.map((x) => x.type) ?? [];
  const varParam = signature.variadicArg?.type;
  const varParamCount = signature.variadicMin ?? 0;
  let i = 0;
  for (const param of params) {
    const op = ops[i++];
    if (!op) {
      result.push(ce.error("missing"));
      isValid = false;
      continue;
    }
    if (lazy) {
      result.push(op);
      continue;
    }
    if (!op.isValid) {
      result.push(op);
      isValid = false;
      continue;
    }
    if (op.type.isUnknown || op.type.type === "any") {
      result.push(op);
      continue;
    }
    if (threadable && (isFiniteIndexedCollection(op) || typeCouldBeCollection(op.type.type))) {
      result.push(op);
      continue;
    }
    if (op.valueDefinition?.inferredType && op.type.matches(param)) {
      result.push(op);
      continue;
    }
    if (op.operatorDefinition?.inferredSignature && op.type.matches(param)) {
      result.push(op);
      continue;
    }
    if (!op.type.matches(param)) {
      result.push(ce.typeError(param, op.type, op));
      isValid = false;
      continue;
    }
    result.push(op);
  }
  for (const param of optParams) {
    const op = ops[i];
    if (!op) {
      break;
    }
    if (lazy) {
      result.push(op);
      i += 1;
      continue;
    }
    if (!op.isValid) {
      result.push(op);
      isValid = false;
      i += 1;
      continue;
    }
    if (op.type.isUnknown || op.type.type === "any") {
      result.push(op);
      i += 1;
      continue;
    }
    if (threadable && (isFiniteIndexedCollection(op) || typeCouldBeCollection(op.type.type))) {
      result.push(op);
      i += 1;
      continue;
    }
    if (op.valueDefinition?.inferredType && op.type.matches(param)) {
      result.push(op);
      i += 1;
      continue;
    }
    if (!op.type.matches(param)) {
      result.push(ce.typeError(param, op.type, op));
      isValid = false;
      i += 1;
      continue;
    }
    result.push(op);
    i += 1;
  }
  if (varParam) {
    let additionalParam = 0;
    for (const op of ops.slice(i)) {
      i += 1;
      additionalParam += 1;
      if (lazy) {
        result.push(op);
        continue;
      }
      if (!op.isValid) {
        result.push(op);
        isValid = false;
        continue;
      }
      if (op.type.isUnknown || op.type.type === "any") {
        result.push(op);
        continue;
      }
      if (threadable && (isFiniteIndexedCollection(op) || typeCouldBeCollection(op.type.type))) {
        result.push(op);
        continue;
      }
      if (op.valueDefinition?.inferredType && op.type.matches(varParam)) {
        result.push(op);
        continue;
      }
      if (!op.type.matches(varParam)) {
        result.push(ce.typeError(varParam, op.type, op));
        isValid = false;
        continue;
      }
      result.push(op);
    }
    if (additionalParam < varParamCount) {
      result.push(ce.error("missing"));
      isValid = false;
    }
  }
  if (i < ops.length) {
    for (const op of ops.slice(i)) {
      result.push(ce.error("unexpected-argument", op.toString()));
      isValid = false;
    }
  }
  if (!isValid) return result;
  i = 0;
  for (const param of params) {
    if (!lazy) {
      if (!threadable || !isFiniteIndexedCollection(ops[i]) && !typeCouldBeCollection(ops[i].type.type))
        ops[i].infer(param);
    }
    i += 1;
  }
  for (const param of optParams) {
    if (!ops[i]) break;
    if (!threadable || !isFiniteIndexedCollection(ops[i]) && !typeCouldBeCollection(ops[i].type.type))
      ops[i]?.infer(param);
    i += 1;
  }
  if (varParam) {
    for (const op of ops.slice(i)) {
      if (!lazy) {
        if (!threadable || !isFiniteIndexedCollection(op) && !typeCouldBeCollection(op.type.type))
          op.infer(varParam);
      }
      i += 1;
    }
  }
  return null;
}
function spellcheckSymbols(expr) {
  let suggestions = {};
  const knownSymbols = getSymbolNames(expr.engine);
  const knownOperators = getOperatorNames(expr.engine);
  if (expr.symbol && !suggestions[expr.symbol] && !expr.symbol.startsWith("_")) {
    if (!knownSymbols.includes(expr.symbol)) {
      const match2 = fuzzyStringMatch(expr.symbol, knownSymbols);
      if (match2) suggestions[expr.symbol] = match2;
    }
  } else if (expr.ops && !suggestions[expr.operator] && !expr.operator.startsWith("_")) {
    const operator2 = expr.operator;
    if (!knownOperators.includes(operator2)) {
      const match2 = fuzzyStringMatch(operator2, knownOperators);
      if (match2) suggestions[operator2] = match2;
    }
    for (const op of expr.ops)
      suggestions = { ...suggestions, ...spellcheckSymbols(op) };
  }
  return suggestions;
}
function getOperatorNames(ce) {
  const names = [];
  let currentScope = ce.context.lexicalScope;
  while (currentScope) {
    for (const key of currentScope.bindings.keys()) {
      const def = currentScope.bindings.get(key);
      if (isOperatorDef(def)) names.push(key);
    }
    currentScope = currentScope.parent;
  }
  return names;
}
function getSymbolNames(ce) {
  const names = [];
  let currentScope = ce.context.lexicalScope;
  while (currentScope) {
    for (const key of currentScope.bindings.keys()) {
      const def = currentScope.bindings.get(key);
      if (isValueDef(def)) names.push(key);
    }
    currentScope = currentScope.parent;
  }
  return names;
}
function spellCheckMessage(expr) {
  const suggestions = spellcheckSymbols(expr);
  if (Object.keys(suggestions).length === 0) return "";
  if (Object.keys(suggestions).length === 1) {
    const [symbol2, suggestion] = Object.entries(suggestions)[0];
    return `Unknown symbol "${symbol2}". Did you mean "${suggestion}"?`;
  }
  const lines = [];
  for (const [symbol2, suggestion] of Object.entries(suggestions)) {
    lines.push(`- "${symbol2}" -> "${suggestion}"?`);
  }
  return `Unknown symbols found:
${lines.join("\n")}`;
}
var init_validate = __esm({
  "src/compute-engine/boxed-expression/validate.ts"() {
    init_collection_utils();
    init_flatten();
    init_subtype();
    init_fuzzy_string_match();
    init_utils5();
    init_boxed_tensor();
  }
});

// src/compute-engine/numerics/numeric-complex.ts
function gamma(c) {
  return c;
}
function gammaln(c) {
  return c;
}
var init_numeric_complex = __esm({
  "src/compute-engine/numerics/numeric-complex.ts"() {
  }
});

// src/compute-engine/numerics/special-functions.ts
function gammaln2(z) {
  if (z < 0) return NaN;
  const pi = Math.PI;
  const z3 = z * z * z;
  return z * Math.log(z) - z - 0.5 * Math.log(z) + 0.5 * Math.log(2 * pi) + 1 / (12 * z) - 1 / (360 * z3) + 1 / (1260 * z3 * z * z);
}
function gamma2(z) {
  if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma2(1 - z));
  if (z > 100) return Math.exp(gammaln2(z));
  z -= 1;
  let x = lanczos_7_c[0];
  for (let i = 1; i < gammaG + 2; i++) x += lanczos_7_c[i] / (z + i);
  const t = z + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
}
function erfInv(x) {
  const pi = Math.PI;
  const pi2 = pi * pi;
  const pi3 = pi2 * pi;
  const x2 = x * x;
  const x3 = x * x2;
  const x5 = x3 * x2;
  const x7 = x5 * x2;
  return Math.sqrt(pi) / 2 * (x + pi / 12 * x3 + 7 * pi2 / 480 * x5 + 127 * pi3 / 40320 * x7 + 4369 * pi2 * pi2 / 5806080 * x7 * x2 + 34807 * pi3 * pi2 / 182476800 * x7 * x2 * x2);
}
function erf(x) {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const sign3 = x < 0 ? -1 : 1;
  x = Math.abs(x);
  const t = 1 / (1 + p * x);
  const y = ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t;
  return sign3 * (1 - y * Math.exp(-x * x));
}
function bigGammaln(ce, z) {
  if (z.isNegative()) return ce._BIGNUM_NAN;
  const GAMMA_P_LN = ce._cache("gamma-p-ln", () => {
    return [
      "0.99999999999999709182",
      "57.156235665862923517",
      "-59.597960355475491248",
      "14.136097974741747174",
      "-0.49191381609762019978",
      "0.33994649984811888699e-4",
      "0.46523628927048575665e-4",
      "-0.98374475304879564677e-4",
      "0.15808870322491248884e-3",
      "-0.21026444172410488319e-3",
      "0.2174396181152126432e-3",
      "-0.16431810653676389022e-3",
      "0.84418223983852743293e-4",
      "-0.2619083840158140867e-4",
      "0.36899182659531622704e-5"
    ].map((x2) => ce.bignum(x2));
  });
  let x = GAMMA_P_LN[0];
  for (let i = GAMMA_P_LN.length - 1; i > 0; --i) {
    x = x.add(GAMMA_P_LN[i].div(z.add(i)));
  }
  const GAMMA_G_LN = ce._cache("gamma-g-ln", () => ce.bignum(607).div(128));
  const t = z.add(GAMMA_G_LN).add(ce._BIGNUM_HALF);
  return ce._BIGNUM_NEGATIVE_ONE.acos().mul(ce._BIGNUM_TWO).log().mul(ce._BIGNUM_HALF).add(
    t.log().mul(z.add(ce._BIGNUM_HALF)).minus(t).add(x.log()).minus(z.log())
  );
}
function bigGamma(ce, z) {
  if (z.lessThan(ce._BIGNUM_HALF)) {
    const pi = ce._BIGNUM_NEGATIVE_ONE.acos();
    return pi.div(
      pi.mul(z).sin().mul(bigGamma(ce, ce._BIGNUM_ONE.sub(z)))
    );
  }
  if (z.greaterThan(100)) return bigGammaln(ce, z).exp();
  z = z.sub(1);
  const LANCZOS_7_C = ce._cache("lanczos-7-c", () => {
    return [
      "0.99999999999980993227684700473478",
      "676.520368121885098567009190444019",
      "-1259.13921672240287047156078755283",
      "771.3234287776530788486528258894",
      "-176.61502916214059906584551354",
      "12.507343278686904814458936853",
      "-0.13857109526572011689554707",
      "9.984369578019570859563e-6",
      "1.50563273514931155834e-7"
    ].map((x2) => ce.bignum(x2));
  });
  let x = LANCZOS_7_C[0];
  for (let i = 1; i < gammaG + 2; i++) x = x.add(LANCZOS_7_C[i].div(z.add(i)));
  const t = z.add(gammaG).add(ce._BIGNUM_HALF);
  return ce._BIGNUM_NEGATIVE_ONE.acos().times(ce._BIGNUM_TWO).sqrt().mul(x.mul(t.neg().exp()).mul(t.pow(z.add(ce._BIGNUM_HALF))));
}
var gammaG, lanczos_7_c;
var init_special_functions = __esm({
  "src/compute-engine/numerics/special-functions.ts"() {
    gammaG = 7;
    lanczos_7_c = [
      0.9999999999998099,
      676.5203681218851,
      -1259.1392167224028,
      771.3234287776531,
      -176.6150291621406,
      12.507343278686905,
      -0.13857109526572012,
      9984369578019572e-21,
      15056327351493116e-23
    ];
  }
});

// src/compute-engine/library/arithmetic.ts
function numberSgn(x) {
  if (x === void 0) return void 0;
  if (isNaN(x)) return "unsigned";
  if (x > 0) return "positive";
  if (x < 0) return "negative";
  return "zero";
}
function oppositeSgn(x) {
  if (x === "positive") return "negative";
  if (x === "non-negative") return "non-positive";
  if (x === "negative") return "positive";
  if (x === "non-positive") return "non-negative";
  return x;
}
function lnSign(x) {
  if (x.isGreater(1)) return "positive";
  if (x.isGreaterEqual(1)) return "non-negative";
  if (x.isLessEqual(1) && x.isGreaterEqual(0)) return "non-positive";
  if (x.isLess(1) && x.isGreaterEqual(0)) return "negative";
  if (x.is(1)) return "zero";
  if (x.isNegative || x.isReal === false) return "unsigned";
  return void 0;
}
function evaluateAbs(arg) {
  const ce = arg.engine;
  const num = arg.numericValue;
  if (num !== null) {
    if (typeof num === "number") return ce.number(Math.abs(num));
    return ce.number(num.abs());
  }
  if (arg.isNonNegative) return arg;
  if (arg.isNegative) return arg.neg();
  return void 0;
}
function processMinMaxItem(item, mode2) {
  const ce = item.engine;
  const upper = mode2 === "Max" || mode2 === "Supremum";
  if (item.operator === "Interval") {
    const b = upper ? item.op2 : item.op1;
    if (!b.isNumber || b.numericValue === null) return [void 0, [item]];
    return [b, []];
  }
  if (item.operator === "Range") {
    if (upper) {
      const r = range(item);
      const last = rangeLast(r);
      return [ce.number(Math.max(r[0], last)), []];
    } else {
      return [ce.number(range(item)[0]), []];
    }
  }
  if (item.operator === "Linspace") {
    if (item.nops === 1) item = upper ? item.op1 : ce.One;
    else if (upper) item = item.op2;
    else item = item.op1;
    return [item, []];
  }
  if (item.isCollection) {
    let result = void 0;
    const rest = [];
    for (const op of item.each()) {
      const [val, others] = processMinMaxItem(op, mode2);
      if (val) {
        if (!result) result = val;
        else {
          if (upper && val.isGreater(result) || !upper && val.isLess(result))
            result = val;
        }
      }
      rest.push(...others);
    }
    return [result, rest];
  }
  if (!item.isNumber || item.numericValue === null) return [void 0, [item]];
  return [item, []];
}
function evaluateMinMax(ce, ops, mode2) {
  const upper = mode2 === "Max" || mode2 === "Supremum";
  ops = flatten(ops);
  if (ops.length === 0)
    return upper ? ce.NegativeInfinity : ce.PositiveInfinity;
  let result = void 0;
  const rest = [];
  for (const op of ops) {
    const [val, others] = processMinMaxItem(op, mode2);
    if (val) {
      if (!result) result = val;
      else {
        if (upper && val.isGreater(result) || !upper && val.isLess(result))
          result = val;
      }
    }
    rest.push(...others);
  }
  if (rest.length > 0)
    return ce.box(result ? [mode2, result, ...rest] : [mode2, ...rest]);
  return result ?? (upper ? ce.NegativeInfinity : ce.PositiveInfinity);
}
function evaluateGcdLcm(ops, mode2) {
  const ce = ops[0].engine;
  const fn = mode2 === "LCM" ? lcm : gcd;
  const bigFn = mode2 === "LCM" ? lcm3 : gcd3;
  const rest = [];
  if (bignumPreferred(ce)) {
    let result2 = null;
    for (const op of ops) {
      if (result2 === null) {
        result2 = asBignum(op);
        if (result2 === null || !result2.isInteger()) rest.push(op);
      } else {
        const d = asBignum(op);
        if (d && d.isInteger()) result2 = bigFn(result2, d);
        else rest.push(op);
      }
    }
    if (rest.length === 0) return result2 === null ? ce.One : ce.number(result2);
    if (result2 === null) return ce._fn(mode2, rest);
    return ce._fn(mode2, [ce.number(result2), ...rest]);
  }
  let result = null;
  for (const op of ops) {
    if (result === null) {
      if (op.isInteger) rest.push(op);
    } else {
      if (!op.isInteger) rest.push(op);
      else result = fn(result, op.re);
    }
  }
  if (rest.length === 0) return result === null ? ce.One : ce.number(result);
  if (result === null) return ce._fn(mode2, rest);
  return ce._fn(mode2, [ce.number(result), ...rest]);
}
function isPrime2(expr) {
  if (!expr.isInteger) return void 0;
  if (expr.isNegative) return void 0;
  const value = expr.numericValue;
  if (value === null) return void 0;
  const n = toInteger(expr);
  if (n !== null) return isPrime(n);
  const b = asBigint(expr);
  if (b !== null) return isPrimeBigint(b);
  return void 0;
}
var ARITHMETIC_LIBRARY;
var init_arithmetic = __esm({
  "src/compute-engine/library/arithmetic.ts"() {
    init_decimal();
    init_validate();
    init_utils5();
    init_numerics();
    init_order();
    init_apply();
    init_flatten();
    init_numeric_complex();
    init_numeric_bignum();
    init_numeric_bigint();
    init_special_functions();
    init_numeric();
    init_rationals();
    init_primes();
    init_arithmetic_add();
    init_arithmetic_mul_div();
    init_utils4();
    init_arithmetic_power();
    init_parse();
    init_collections();
    init_interruptible();
    init_canonical_utils();
    ARITHMETIC_LIBRARY = [
      {
        //
        // Functions
        //
        Abs: {
          wikidata: "Q3317982",
          // magnitude 'Q120812 (for reals)
          broadcastable: true,
          idempotent: true,
          complexity: 1200,
          signature: "(number) -> number",
          type: ([x]) => x.type,
          sgn: ([x]) => {
            if (x.is(0)) return "zero";
            if (x.isNumberLiteral) return "positive";
            return "non-negative";
          },
          evaluate: ([x]) => evaluateAbs(x)
        },
        Add: {
          wikidata: "Q32043",
          associative: true,
          commutative: true,
          commutativeOrder: addOrder,
          broadcastable: true,
          idempotent: true,
          complexity: 1300,
          lazy: true,
          // Accept numbers, vectors, and matrices for element-wise addition
          signature: "(value+) -> value",
          type: addType,
          sgn: (ops) => {
            if (ops.some((x) => x.isNaN)) return "unsigned";
            if (ops.every((x) => x.is(0))) return "zero";
            if (ops.every((x) => x.isNonNegative))
              return ops.some((x) => x.isPositive) ? "positive" : "non-negative";
            if (ops.every((x) => x.isNonPositive))
              return ops.some((x) => x.isNegative) ? "negative" : "non-positive";
            return void 0;
          },
          // @fastpath: canonicalization is done in the function
          // makeNumericFunction().
          evaluate: (ops, { numericApproximation }) => (
            // Do not evaluate in the case of numericApproximation
            // to avoid premature rounding errors.
            // For example: `\\frac{2}{3}+\\frac{12345678912345678}{987654321987654321}+\\frac{987654321987654321}{12345678912345678}`
            numericApproximation ? addN(...ops) : add3(...ops.map((x) => x.evaluate()))
          )
        },
        Ceil: {
          description: "Rounds a number up to the next largest integer",
          complexity: 1250,
          broadcastable: true,
          signature: "(number) -> integer",
          sgn: ([x]) => {
            if (x.isLessEqual(-1)) return "negative";
            if (x.isPositive) return "positive";
            if (x.isNonNegative) return "non-negative";
            if (x.isNonPositive && x.isGreater(-1)) return "zero";
            if (x.isNonPositive) return "non-positive";
            if (x.isReal == false && x.isNumberLiteral)
              return x.im > 0 || x.im <= -1 ? "unsigned" : numberSgn(x.re);
            return void 0;
          },
          evaluate: ([x]) => apply(
            x,
            Math.ceil,
            (x2) => x2.ceil(),
            (z) => z.ceil(0)
          )
        },
        Chop: {
          associative: true,
          broadcastable: true,
          idempotent: true,
          complexity: 1200,
          signature: "(number) -> number",
          type: ([x]) => x.type,
          evaluate: (ops) => {
            const op = ops[0];
            const ce = op.engine;
            return apply(
              op,
              (x) => ce.chop(x),
              (x) => ce.chop(x),
              (x) => ce.complex(ce.chop(x.re), ce.chop(x.im))
            );
          }
        },
        // Complex: {
        //   // This function is converted during boxing, so unlikely to encounter
        //   wikidata: 'Q11567',
        //   complexity: 500,
        // },
        Divide: {
          wikidata: "Q1226939",
          complexity: 2500,
          broadcastable: true,
          // - if numer product of numbers, or denom product of numbers,
          // i.e. 2x/2 -> 0.707x, 2/2x -> 1.4142x
          signature: "(number, number+) -> number",
          type: ([num, den]) => {
            if (den.is(1)) return num.type;
            if (den.isNaN || num.isNaN) return "number";
            if (den.isFinite === false || num.isFinite === false)
              return "non_finite_number";
            if (den.isInteger && num.isInteger) return "finite_rational";
            if (den.isReal && num.isReal) return "finite_real";
            return "finite_number";
          },
          sgn: (ops) => {
            const [n, d] = [ops[0], ops[1]];
            if (d.is(0)) return "unsigned";
            if (d.isPositive) return n.sgn;
            if (d.isNegative) return oppositeSgn(n.sgn);
            const s = d.sgn;
            if (n.is(0) && s === "not-zero" || n.isFinite && d.isInfinity)
              return "zero";
            if (n.sgn === "not-zero" && s === "not-zero") return "not-zero";
            return void 0;
          },
          canonical: (args, { engine }) => {
            const ce = engine;
            args = checkNumericArgs(ce, args);
            let result = args[0];
            if (result === void 0) return ce.error("missing");
            if (args.length < 2) return result;
            const rest = args.slice(1);
            for (const x of rest) result = canonicalDivide(result, x);
            return result;
          },
          evaluate: ([num, den]) => num.div(den)
        },
        Exp: {
          wikidata: "Q168698",
          broadcastable: true,
          complexity: 3500,
          signature: "(number) -> number",
          // Because it gets canonicalized to Power, the sgn handler is not called
          // sgn: ([x]) => {
          //   if (
          //     (x.isNumberLiteral && x.re === -Infinity) ||
          //     (x.isNegative && x.isInfinity)
          //   )
          //     return 'zero';
          //   if (x.isReal == false && x.isNumberLiteral) {
          //     let n = chop(1 - x.im! / Math.PI) + 1;
          //     return n % 1 !== 0
          //       ? 'unsigned'
          //       : n % 2 === 0
          //         ? 'positive'
          //         : 'negative';
          //   }
          //   if (x.isReal || (x.isInfinity && x.isPositive)) return 'positive';
          //   return undefined;
          // },
          // Exp(x) -> e^x
          canonical: (args, { engine }) => {
            args = checkNumericArgs(engine, args, 1);
            return engine.function("Power", [engine.E, ...args]);
          }
        },
        Factorial: {
          description: "Factorial function: the product of all positive integers less than or equal to n",
          wikidata: "Q120976",
          broadcastable: true,
          complexity: 9e3,
          signature: "(integer) -> integer",
          // Assumes that the inside of the factorial is an integer
          sgn: ([x]) => x.isNonNegative ? "positive" : x.isNegative || x.isReal === false ? "unsigned" : void 0,
          canonical: (args, { engine }) => {
            const x = args[0];
            if (x.isNumberLiteral && x.isNegative)
              return engine._fn("Factorial", [x.neg()]).neg();
            return engine._fn("Factorial", [x]);
          },
          evaluate: ([x]) => {
            const ce = x.engine;
            if (!x.isNumberLiteral) return void 0;
            if (x.im !== 0 && x.im !== void 0)
              return ce.number(gamma(ce.complex(x.re, x.im).add(1)));
            if (!x.isFinite) return void 0;
            if (x.isNegative) return ce.number(gamma2(1 + x.re));
            try {
              return ce.number(
                run(
                  factorial3(BigInt((x.bignumRe ?? x.re).toFixed())),
                  ce._timeRemaining
                )
              );
            } catch (e) {
              return void 0;
            }
          },
          evaluateAsync: async ([x], { signal }) => {
            const ce = x.engine;
            if (!x.isNumberLiteral) return void 0;
            if (x.im !== 0 && x.im !== void 0)
              return ce.number(gamma(ce.complex(x.re, x.im).add(1)));
            if (!x.isFinite) return void 0;
            if (x.isNegative) return ce.number(gamma2(1 + x.re));
            try {
              return ce.number(
                await runAsync(
                  factorial3(BigInt((x.bignumRe ?? x.re).toFixed())),
                  (ce._deadline ?? Infinity) - Date.now(),
                  signal
                )
              );
            } catch (e) {
              return void 0;
            }
          }
        },
        Factorial2: {
          description: "Double Factorial Function",
          complexity: 9e3,
          broadcastable: true,
          signature: "(integer) -> integer",
          sgn: ([x]) => x.isNonNegative ? "positive" : x.isNegative || x.isReal === false ? "unsigned" : void 0,
          evaluate: (ops) => {
            const x = ops[0];
            const n = toInteger(x);
            if (n === null) return void 0;
            const ce = x.engine;
            if (bignumPreferred(ce))
              return ce.number(factorial23(ce, ce.bignum(n)));
            return ce.number(factorial22(n));
          }
        },
        Floor: {
          wikidata: "Q56860783",
          complexity: 1250,
          broadcastable: true,
          signature: "(number) -> integer",
          sgn: ([x]) => {
            if (x.isNegative) return "negative";
            if (x.isGreaterEqual(1)) return "positive";
            if (x.isNonNegative && x.isLess(1)) return "zero";
            if (x.isNonNegative) return "non-negative";
            if (x.isReal == false && x.isNumberLiteral)
              return x.im < 0 || x.im >= 1 ? "unsigned" : numberSgn(x.re);
            return void 0;
          },
          evaluate: ([x]) => apply(
            x,
            Math.floor,
            (x2) => x2.floor(),
            (z) => z.floor(0)
          )
        },
        Gamma: {
          wikidata: "Q190573",
          complexity: 8e3,
          broadcastable: true,
          signature: "(number) -> number",
          sgn: ([x]) => x.isPositive ? "positive" : x.is(0) ? "zero" : void 0,
          evaluate: ([x], { numericApproximation, engine }) => numericApproximation ? apply(
            x,
            (x2) => gamma2(x2),
            (x2) => bigGamma(engine, x2),
            (x2) => gamma(x2)
          ) : void 0
        },
        GammaLn: {
          complexity: 8e3,
          broadcastable: true,
          signature: "(number) -> number",
          evaluate: (ops, { numericApproximation, engine }) => numericApproximation ? apply(
            ops[0],
            (x) => gammaln2(x),
            (x) => bigGammaln(engine, x),
            (x) => gammaln(x)
          ) : void 0
        },
        // Digamma function (x) = d/dx ln((x)) = '(x)/(x)
        // Also known as the psi function
        Digamma: {
          description: "Digamma function, the logarithmic derivative of the gamma function",
          wikidata: "Q1142755",
          complexity: 8200,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Trigamma function (x) = d/dx (x) = d/dx ln((x))
        // The derivative of the digamma function
        Trigamma: {
          description: "Trigamma function, the derivative of the digamma function",
          wikidata: "Q2371722",
          complexity: 8400,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        // PolyGamma function (x) = d/dx (x)
        // The n-th derivative of the digamma function
        // PolyGamma(0, x) = Digamma(x), PolyGamma(1, x) = Trigamma(x)
        PolyGamma: {
          description: "Polygamma function, the n-th derivative of the digamma function",
          wikidata: "Q1817679",
          complexity: 8500,
          broadcastable: true,
          signature: "(order: integer, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Riemann zeta function (s) = _{n=1}^ 1/n^s
        // Converges for Re(s) > 1, analytically continued elsewhere
        Zeta: {
          description: "Riemann zeta function",
          wikidata: "Q187235",
          complexity: 8500,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Beta function B(a,b) = (a)(b)/(a+b) =  t^(a-1)(1-t)^(b-1) dt
        Beta: {
          description: "Euler beta function",
          wikidata: "Q189062",
          complexity: 8200,
          broadcastable: true,
          signature: "(number, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Lambert W function: W(x)e^(W(x)) = x
        // Also known as the product logarithm or omega function
        LambertW: {
          description: "Lambert W function (product logarithm)",
          wikidata: "Q429963",
          complexity: 8300,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Bessel function of the first kind J_n(x)
        // Solution to Bessel's differential equation that is finite at the origin
        BesselJ: {
          description: "Bessel function of the first kind",
          wikidata: "Q627488",
          complexity: 8500,
          broadcastable: true,
          signature: "(order: number, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Bessel function of the second kind Y_n(x)
        // Also known as Neumann function or Weber function
        BesselY: {
          description: "Bessel function of the second kind (Neumann function)",
          wikidata: "Q627488",
          complexity: 8500,
          broadcastable: true,
          signature: "(order: number, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Modified Bessel function of the first kind I_n(x)
        BesselI: {
          description: "Modified Bessel function of the first kind",
          wikidata: "Q627488",
          complexity: 8500,
          broadcastable: true,
          signature: "(order: number, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Modified Bessel function of the second kind K_n(x)
        // Also known as Macdonald function
        BesselK: {
          description: "Modified Bessel function of the second kind (Macdonald function)",
          wikidata: "Q627488",
          complexity: 8500,
          broadcastable: true,
          signature: "(order: number, number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Airy function of the first kind Ai(x)
        // Solution to Airy differential equation y'' - xy = 0
        AiryAi: {
          description: "Airy function of the first kind",
          wikidata: "Q403629",
          complexity: 8400,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        // Airy function of the second kind Bi(x)
        AiryBi: {
          description: "Airy function of the second kind",
          wikidata: "Q403629",
          complexity: 8400,
          broadcastable: true,
          signature: "(number) -> number"
          // Numerical evaluation not yet implemented
        },
        Ln: {
          description: "Natural Logarithm",
          wikidata: "Q204037",
          complexity: 4e3,
          broadcastable: true,
          signature: "(number, base: number?) -> number",
          sgn: ([x]) => lnSign(x),
          // @fastpath: this doesn't get called. See makeNumericFunction()
          evaluate: ([z], { numericApproximation, engine }) => {
            if (!numericApproximation) return z.ln();
            return apply(
              z,
              (x) => x === 0 ? -Infinity : x >= 0 ? Math.log(x) : engine.complex(x).log(),
              (x) => x.isZero() ? -Infinity : !x.isNeg() ? x.ln() : engine.complex(x.toNumber()).log(),
              (z2) => z2.isZero() ? NaN : z2.log()
            );
          }
        },
        Log: {
          description: "Log(z, b = 10) = Logarithm of base b",
          wikidata: "Q11197",
          complexity: 4100,
          broadcastable: true,
          signature: "(number, base: number?) -> number",
          sgn: ([x, base]) => {
            if (!base) return lnSign(x);
            if (base.is(1) || base.isReal == false) return "unsigned";
            if (base.isGreater(1)) return lnSign(x);
            if (base.isLess(1)) return oppositeSgn(lnSign(x));
            return void 0;
          },
          // @fastpath: this doesn't get called. See makeNumericFunction()
          // canonical: (ce, [x, base]) => {
          //   if (!x) return ce._fn('Log', [ce.error('missing'), base]);
          //   return x.ln(base ?? 10);
          // },
          evaluate: (ops, { numericApproximation, engine }) => {
            if (!numericApproximation) return ops[0]?.ln(ops[1] ?? 10) ?? void 0;
            const ce = engine;
            if (ops[1] === void 0)
              return apply(
                ops[0],
                (x) => x === 0 ? -Infinity : x >= 0 ? Math.log10(x) : ce.complex(x).log().div(Math.LN10),
                (x) => x.isZero() ? -Infinity : !x.isNeg() ? Decimal.log10(x) : ce.complex(x.toNumber()).log().div(Math.LN10),
                (z) => z.isZero() ? NaN : z.log().div(Math.LN10)
              );
            return apply2(
              ops[0],
              ops[1],
              (z, b) => Math.log(z) / Math.log(b),
              (z, b) => z.log(b),
              (z, b) => z.log().div(typeof b === "number" ? Math.log(b) : b.log())
            );
          }
        },
        Lb: {
          description: "Base-2 Logarithm",
          wikidata: "Q581168",
          complexity: 4100,
          broadcastable: true,
          signature: "(number) -> number",
          sgn: ([x]) => lnSign(x),
          canonical: ([x], { engine }) => engine._fn("Log", [x, engine.number(2)])
        },
        Lg: {
          description: "Base-10 Logarithm",
          wikidata: "Q966582",
          complexity: 4100,
          broadcastable: true,
          signature: "(number) -> number",
          sgn: ([x]) => lnSign(x),
          canonical: ([x], { engine }) => engine._fn("Log", [x])
        },
        Mod: {
          description: "Modulo",
          wikidata: "Q1799665",
          complexity: 2500,
          broadcastable: true,
          signature: "(number, number) -> number",
          sgn: (ops) => {
            const n = ops[1];
            if (n === void 0 || n.isReal == false) return void 0;
            if (n.is(0)) return "unsigned";
            if (ops[0].isNumberLiteral && n.isNumberLiteral) {
              const v = apply2(
                ops[0],
                n,
                // In JavaScript, the % is remainder, not modulo
                // so adapt it to return a modulo
                (a, b) => (a % b + b) % b,
                (a, b) => a.modulo(b)
              );
              return v?.sgn ?? void 0;
            }
            return void 0;
          },
          evaluate: ([a, b]) => apply2(
            a,
            b,
            // In JavaScript, the % is remainder, not modulo
            // so adapt it to return a modulo
            (a2, b2) => (a2 % b2 + b2) % b2,
            (a2, b2) => a2.modulo(b2)
          )
        },
        Multiply: {
          wikidata: "Q40276",
          associative: true,
          commutative: true,
          idempotent: true,
          complexity: 2100,
          broadcastable: true,
          lazy: true,
          signature: "(number*) -> number",
          type: (ops) => {
            if (ops.length === 0) return "finite_integer";
            if (ops.length === 1) return ops[0].type;
            if (ops.some((x) => x.isNaN)) return "number";
            if (ops.some((x) => x.isFinite === false)) return "non_finite_number";
            if (ops.every((x) => x.isInteger)) return "finite_integer";
            if (ops.every((x) => x.isReal)) return "finite_real";
            if (ops.every((x) => x.isRational)) return "finite_rational";
            return "finite_number";
          },
          // @fastpath: canonicalization is done in the function
          // makeNumericFunction().
          //
          sgn: (ops) => {
            if (ops.some((x) => x.sgn === void 0 || x.isReal === false))
              return void 0;
            if (ops.some((x) => x.is(0)))
              return ops.every((x) => x.isFinite) ? "zero" : ops.some((x) => x.isFinite === false) ? "unsigned" : void 0;
            if (ops.some((x) => x.isFinite === false || x.isFinite === void 0) && ops.some((x) => {
              const s = x.sgn;
              s !== "positive" && s !== "negative" && s !== "not-zero";
            }))
              return void 0;
            if (ops.every((x) => x.isPositive || x.isNegative)) {
              let sumNeg = 0;
              ops.forEach((x) => {
                if (x.isNegative) sumNeg++;
              });
              return sumNeg % 2 === 0 ? "positive" : "negative";
            }
            if (ops.every((x) => x.isNonPositive || x.isNonNegative)) {
              let sumNeg = 0;
              ops.forEach((x) => {
                if (x.isNonPositive) sumNeg++;
              });
              return sumNeg % 2 === 0 ? "non-positive" : "non-negative";
            }
            if (ops.every(
              (x) => x.sgn === "not-zero" || x.sgn === "positive" || x.sgn === "negative"
            ))
              return "not-zero";
            return void 0;
          },
          evaluate: (ops, { numericApproximation }) => (
            // Use evaluate i both cases: do not introduce premature rounding errors
            numericApproximation ? mulN(...ops) : mul3(...ops.map((x) => x.evaluate()))
          )
        },
        Negate: {
          description: "Additive Inverse",
          wikidata: "Q715358",
          complexity: 2e3,
          broadcastable: true,
          signature: "(number) -> number",
          type: ([x]) => x.type,
          sgn: ([x]) => oppositeSgn(x.sgn),
          canonical: (args, { engine }) => {
            args = checkNumericArgs(engine, args);
            if (args.length === 0) return engine.error("missing");
            return args[0].neg();
          },
          evaluate: ([x]) => x.neg()
        },
        PlusMinus: {
          description: "Plus or Minus",
          wikidata: "Q120812",
          complexity: 1200,
          signature: "(value, value) -> tuple",
          canonical: (args, { engine: ce }) => {
            args = checkNumericArgs(ce, args, 2);
            if (args.length === 0) return ce.error("missing");
            return ce._fn("PlusMinus", [args[0], args[1].abs()]);
          },
          type: ([x, y]) => parseType(`tuple<${x.type}, ${y.type}>`),
          evaluate: ([x, y], { engine }) => engine.tuple(x.add(y.neg()), x.add(y))
        },
        Power: {
          wikidata: "Q33456",
          broadcastable: true,
          complexity: 3500,
          signature: "(number, number) -> number",
          type: ([base, exp3]) => {
            if (base.isNaN || exp3.isNaN) return "number";
            if (!exp3.isFinite) return "non_finite_number";
            if (base.isInteger && exp3.isInteger) return "finite_integer";
            if (base.isRational && exp3.isInteger) return "finite_rational";
            if (base.isReal && exp3.isReal) return "finite_real";
            return "finite_number";
          },
          canonical: (args, { engine }) => {
            args = checkNumericArgs(engine, args, 2);
            if (args.length !== 2) return engine._fn("Power", args);
            const [base, exp3] = args;
            return canonicalPower(base, exp3);
          },
          sgn: ([a, b]) => {
            const aSgn = a.sgn;
            const bSgn = b.sgn;
            if (a.isReal === false || b.isReal === false || a.isNaN || b.isNaN || aSgn === void 0 || bSgn === void 0)
              return void 0;
            if (a.is(0))
              return b.isNonPositive ? "unsigned" : b.isPositive ? "zero" : void 0;
            if (a.is(0) && b.is(0)) return "unsigned";
            if (a.isNonNegative || b.numerator.isOdd && b.denominator.isOdd)
              return a.sgn;
            if (b.numerator.isEven && b.denominator.isOdd) {
              if (a.isReal) {
                const s = a.sgn;
                return s === "positive" || s === "not-zero" || s === "negative" ? "positive" : "non-negative";
              }
              if (a.type.matches("complex")) return "negative";
              return !a.is(0) ? "not-zero" : void 0;
            }
            if (b.isRational === false || b.numerator.isOdd && b.denominator.isEven && a.isNonPositive)
              return "unsigned";
            return void 0;
          },
          // x^n
          // evaluate: (ops) => ops[0].pow(ops[1]),
          evaluate: ([x, n], { numericApproximation }) => pow2(x, n, { numericApproximation: numericApproximation ?? false })
          // Defined as RealNumbers for all power in RealNumbers when base > 0;
          // when x < 0, only defined if n is an integer
          // if x is a non-zero complex, defined as ComplexNumbers
          // Square root of a prime is irrational (AlgebraicNumbers)
          // https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational
        },
        Rational: {
          complexity: 2400,
          signature: "(number, integer?) -> rational",
          sgn: ([n]) => n.sgn,
          canonical: (args, { engine }) => {
            const ce = engine;
            args = flatten(args);
            if (args.length === 0) return ce._fn("Rational", [ce.error("missing")]);
            if (args.length === 1)
              return ce._fn("Rational", [checkType(ce, args[0], "real")]);
            args = checkTypes(ce, args, ["integer", "integer"]);
            if (args.length !== 2 || !args[0].isValid || !args[1].isValid)
              return ce._fn("Rational", args);
            return args[0].div(args[1]);
          },
          evaluate: (ops, { numericApproximation, engine }) => {
            const ce = engine;
            if (ops.length === 1) {
              const f = ops[0].N();
              if (f.numericValue === null || f.im !== 0) return void 0;
              return ce.number(rationalize(f.re));
            }
            if (numericApproximation) {
              return apply2(
                ops[0],
                ops[1],
                (a, b) => a / b,
                (a, b) => a.div(b),
                (a, b) => a.div(b)
              );
            }
            const [n, d] = [asSmallInteger(ops[0]), asSmallInteger(ops[1])];
            if (n !== null && d !== null) return ce.number([n, d]);
            return void 0;
          }
        },
        Root: {
          complexity: 3200,
          broadcastable: true,
          signature: "(number, number) -> number",
          type: ([base, exp3]) => {
            if (base.isNaN || exp3.isNaN) return "number";
            if (base.isFinite === false || exp3.isFinite === false)
              return "non_finite_number";
            if (exp3.is(0)) return "finite_integer";
            if (exp3.is(1)) return base.type;
            if (base.isReal && exp3.isReal) {
              if (base.isPositive === true) return "finite_real";
              return "finite_number";
            }
            return "finite_number";
          },
          sgn: ([x, n]) => {
            if (x.isReal === false || n.isReal === false) return "unsigned";
            if (x.is(0)) {
              if (n.isNonPositive) {
                return "unsigned";
              }
              if (n.isPositive) return "zero";
            }
            if (x.isPositive === true) return "positive";
            if (x.isNonNegative === true) return "non-negative";
            if (n.isOdd === true || n.numerator.isOdd && n.denominator.isOdd) {
              return x.sgn;
            }
            if (x.isNegative && n.isOdd === false) return "unsigned";
            return void 0;
          },
          canonical: (args, { engine }) => {
            args = checkNumericArgs(engine, args, 2);
            const [base, exp3] = args;
            return canonicalRoot(base, exp3);
          },
          evaluate: ([x, n], { numericApproximation }) => root(x, n, { numericApproximation })
        },
        Round: {
          complexity: 1250,
          broadcastable: true,
          signature: "(number) -> integer",
          type: ([x]) => {
            if (x.isNaN) return "number";
            if (x.isFinite === false || x.isReal === false)
              return "non_finite_number";
            return "finite_integer";
          },
          sgn: ([x]) => {
            if (x.isNaN) return "unsigned";
            if (x.isNumberLiteral)
              return x.im >= 0.5 || x.im <= -0.5 ? "unsigned" : numberSgn(Math.round(x.re));
            if (x.isGreaterEqual(0.5)) return "positive";
            if (x.isLessEqual(-0.5)) return "negative";
            if (x.isLess(0.5) && x.isGreater(-0.5)) return "zero";
            if (x.isNonNegative) return "non-negative";
            if (x.isNonPositive) return "non-positive";
            return void 0;
          },
          evaluate: ([x]) => apply(
            x,
            Math.round,
            (x2) => x2.round(),
            (x2) => x2.round(0)
          )
        },
        Sign: {
          complexity: 1200,
          broadcastable: true,
          signature: "(number) -> integer",
          sgn: ([x]) => x.sgn,
          evaluate: ([x], { engine }) => {
            if (x.is(0)) return engine.Zero;
            if (x.isPositive) return engine.One;
            if (x.isNegative) return engine.NegativeOne;
            return void 0;
          }
        },
        // {% def "GammaSgn" %}
        // [&quot;**GammaSgn**&quot;, _z_]{.signature}
        // {% latex "\\operatorname{sgn}(\\gamma(z))" %}
        // The gamma function can be computed as \\( \operatorname{sgn}\Gamma(x) \cdot
        // \expoentialE^{\operatorname{LogGamma}(x)} \\)
        // `["Multiply", ["GammaSgn", "x"], ["Exp", ["LogGamma", "x"]]]`.
        // This function is called `gammasgn` in SciPy.
        // **Reference**
        // - NIST: https://dlmf.nist.gov/5.2#E1
        // {% enddef %}
        //     GammaSgn: {
        //   description: 'The sign of the gamma function: -1 or +1',
        //   complexity: 7900,
        //   signature: {
        //     domain: ['FunctionOf', 'Numbers', ['Range', -1, 1]],
        //     evaluate: (ce, ops) => {
        //     },
        //   },
        //   // @todo
        // },
        Sqrt: {
          description: "Square Root",
          wikidata: "Q134237",
          complexity: 3e3,
          broadcastable: true,
          signature: "(number) -> number",
          type: ([x]) => {
            if (x.isNaN) return "number";
            if (x.isFinite === false) return "non_finite_number";
            if (x.isReal) return x.isNegative ? "complex" : "finite_real";
            return "finite_number";
          },
          // @fastpath: canonicalization is done in the function
          // makeNumericFunction().
          // canonical: (ops, { engine: ce }) => {
          //   ops = flatten(ops);
          //   if (ops.length !== 1) return ce._fn('Sqrt', ops);
          //   return ops[0].sqrt();
          // },
          sgn: ([x]) => {
            if (x.isPositive) return "positive";
            if (x.isNegative) return "unsigned";
            if (x.isNonNegative) return "non-negative";
            if (x.sgn === "not-zero") return "not-zero";
            return void 0;
          },
          evaluate: ([x], { numericApproximation, engine }) => {
            if (!numericApproximation) return x.sqrt();
            const [c, rest] = x.toNumericValue();
            if (rest.is(1)) return engine.number(c.sqrt().N());
            return engine.number(c.sqrt().N()).mul(rest);
          }
          // evalDomain: Square root of a prime is irrational
          // https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational
        },
        Square: {
          wikidata: "Q3075175",
          complexity: 3100,
          broadcastable: true,
          signature: "(number) -> number",
          sgn: ([x]) => {
            if (x.is(0)) return "zero";
            if (x.isReal) {
              const s = x.sgn;
              return s === "not-zero" || s === "positive" || s === "negative" ? "positive" : "non-negative";
            }
            if (x.type.matches("complex")) return "negative";
            if (x.isReal == false || x.isNaN) return "unsigned";
            return void 0;
          },
          canonical: (args, { engine }) => {
            const ce = engine;
            args = flatten(args);
            if (args.length !== 1) return ce._fn("Square", args);
            return ce._fn("Power", [args[0], ce.number(2)]).canonical;
          }
        },
        Subtract: {
          wikidata: "Q40754",
          complexity: 1350,
          broadcastable: true,
          // We accept from 1 to n arguments (see https://github.com/cortex-js/compute-engine/issues/171)
          // left-associative: a - b - c -> (a - b) - c
          signature: "(number+) -> number",
          canonical: (args, { engine }) => {
            args = checkNumericArgs(engine, args);
            if (args.length === 0) return engine.error("missing");
            const first = args[0];
            const rest = args.slice(1);
            return canonicalAdd(engine, [first, ...rest.map((x) => x.neg())]);
          }
        }
      },
      {
        //
        // Constants
        // Note: constants are put in a separate section because
        // some of the values (CatalanConstant) reference some function names
        // (Add...) that are defined above. This avoid circular references.
        //
        ImaginaryUnit: {
          type: "imaginary",
          isConstant: true,
          holdUntil: "never",
          wikidata: "Q193796",
          value: (engine) => engine.I
        },
        // Alias of 'ImaginaryUnit'
        i: {
          type: "imaginary",
          isConstant: true,
          holdUntil: "never",
          value: (engine) => engine.I
        },
        ExponentialE: {
          type: "finite_real",
          wikidata: "Q82435",
          isConstant: true,
          holdUntil: "N",
          value: (engine) => engine.number(
            bignumPreferred(engine) ? engine._BIGNUM_ONE.exp() : Math.exp(1)
          )
        },
        e: {
          type: "finite_real",
          isConstant: true,
          holdUntil: "never",
          value: "ExponentialE"
        },
        ComplexInfinity: {
          type: "complex",
          isConstant: true,
          holdUntil: "never",
          value: (engine) => engine.ComplexInfinity
        },
        PositiveInfinity: {
          type: "non_finite_number",
          isConstant: true,
          holdUntil: "never",
          value: Infinity
        },
        NegativeInfinity: {
          type: "non_finite_number",
          isConstant: true,
          holdUntil: "never",
          value: -Infinity
        },
        NaN: {
          type: "number",
          isConstant: true,
          holdUntil: "never",
          value: (engine) => engine.NaN
        },
        ContinuationPlaceholder: {
          description: "This symbol indicates that some elements in a collection have been omitted, for example in a long list of numbers, or in an infinite set",
          type: "unknown",
          isConstant: true
        },
        MachineEpsilon: {
          /**
           * The difference between 1 and the next larger floating point number
           *
           *    2^{52}
           *
           * See https://en.wikipedia.org/wiki/Machine_epsilon
           */
          type: "finite_real",
          holdUntil: "N",
          isConstant: true,
          value: { num: Number.EPSILON.toString() }
        },
        Half: {
          type: "finite_rational",
          isConstant: true,
          holdUntil: "never",
          value: ["Rational", 1, 2]
        },
        GoldenRatio: {
          type: "finite_real",
          // Golden ratio is an algebraic number
          wikidata: "Q41690",
          isConstant: true,
          holdUntil: "N",
          value: ["Divide", ["Add", 1, ["Sqrt", 5]], 2]
        },
        CatalanConstant: {
          type: "finite_real",
          wikidata: "Q855282",
          isConstant: true,
          holdUntil: "N",
          value: {
            // From http://www.fullbooks.com/Miscellaneous-Mathematical-Constants1.html
            num: `0.91596559417721901505460351493238411077414937428167
                  21342664981196217630197762547694793565129261151062
                  48574422619196199579035898803325859059431594737481
                  15840699533202877331946051903872747816408786590902
                  47064841521630002287276409423882599577415088163974
                  70252482011560707644883807873370489900864775113225
                  99713434074854075532307685653357680958352602193823
                  23950800720680355761048235733942319149829836189977
                  06903640418086217941101917532743149978233976105512
                  24779530324875371878665828082360570225594194818097
                  53509711315712615804242723636439850017382875977976
                  53068370092980873887495610893659771940968726844441
                  66804621624339864838916280448281506273022742073884
                  31172218272190472255870531908685735423498539498309
                  91911596738846450861515249962423704374517773723517
                  75440708538464401321748392999947572446199754961975
                  87064007474870701490937678873045869979860644874974
                  64387206238513712392736304998503539223928787979063
                  36440323547845358519277777872709060830319943013323
                  16712476158709792455479119092126201854803963934243
                  `
          }
        },
        EulerGamma: {
          // From http://www.fullbooks.com/Miscellaneous-Mathematical-Constants2.html
          type: "finite_real",
          wikidata: "Q273023",
          holdUntil: "N",
          isConstant: true,
          value: {
            num: `0.57721566490153286060651209008240243104215933593992359880576723488486772677766
          467093694706329174674951463144724980708248096050401448654283622417399764492353
          625350033374293733773767394279259525824709491600873520394816567085323315177661
          152862119950150798479374508570574002992135478614669402960432542151905877553526
          733139925401296742051375413954911168510280798423487758720503843109399736137255
          306088933126760017247953783675927135157722610273492913940798430103417771778088
          154957066107501016191663340152278935867965497252036212879226555953669628176388
          792726801324310104765059637039473949576389065729679296010090151251959509222435
          014093498712282479497471956469763185066761290638110518241974448678363808617494
          551698927923018773910729457815543160050021828440960537724342032854783670151773
          943987003023703395183286900015581939880427074115422278197165230110735658339673`
          }
        }
      },
      {
        PreIncrement: {
          signature: "(number) -> number"
        },
        PreDecrement: {
          signature: "(number) -> number"
        }
      },
      //
      // Property predicates
      //
      {
        IsPrime: {
          description: "`IsPrime(n)` returns `True` if `n` is a prime number",
          wikidata: "Q49008",
          complexity: 1200,
          broadcastable: true,
          signature: "(number) -> boolean",
          evaluate: ([n], { engine }) => {
            const result = isPrime2(n);
            if (result === void 0) return void 0;
            return engine.symbol(result ? "True" : "False");
          }
        },
        IsComposite: {
          description: "`IsComposite(n)` returns `True` if `n` is not a prime number",
          complexity: 1200,
          broadcastable: true,
          signature: "(number) -> boolean",
          canonical: (ops, { engine }) => engine.box(["Not", ["IsPrime", ...ops]])
        },
        IsOdd: {
          description: "`IsOdd(n)` returns `True` if `n` is an odd number",
          complexity: 1200,
          broadcastable: true,
          signature: "(number) -> boolean",
          evaluate: (ops, { engine }) => {
            let fail = false;
            const result = ops.every((op) => {
              if (op.im !== 0) return false;
              const b = asBigint(op);
              if (b !== null) return b % BigInt(2) !== BigInt(0);
              const n = op.re;
              if (Number.isInteger(n)) return n % 2 !== 0;
              fail = true;
              return false;
            });
            if (fail) return void 0;
            return engine.symbol(result ? "True" : "False");
          }
        },
        IsEven: {
          description: "Even Number",
          complexity: 1200,
          broadcastable: true,
          signature: "(number) -> boolean",
          canonical: (ops, { engine }) => engine.box(["Not", ["IsOdd", ...ops]])
        }
        // @todo: Divisor:
      },
      {
        GCD: {
          description: "Greatest Common Divisor",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(any*) -> integer",
          sgn: () => "positive",
          evaluate: (xs) => evaluateGcdLcm(xs, "GCD")
        },
        LCM: {
          description: "Least Common Multiple",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(any*) -> integer",
          sgn: () => "positive",
          evaluate: (xs) => evaluateGcdLcm(xs, "LCM")
        },
        Numerator: {
          description: "Numerator of an expression",
          complexity: 1200,
          broadcastable: true,
          lazy: true,
          signature: "(number) -> number | nothing",
          canonical: (ops, { engine }) => {
            if (ops.length === 0) return engine.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return op.op1;
            return engine._fn("Numerator", canonical(engine, ops));
          },
          sgn: ([x]) => x.sgn,
          evaluate: (ops, { engine }) => {
            const ce = engine;
            if (ops.length === 0) return ce.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return op.op1.evaluate();
            return op.numerator;
          }
        },
        Denominator: {
          description: "Denominator of an expression",
          complexity: 1200,
          broadcastable: true,
          lazy: true,
          signature: "(number) -> number | nothing",
          canonical: (ops, { engine }) => {
            if (ops.length === 0) return engine.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return op.op2;
            const num = asRational(op);
            if (num !== void 0) return engine.number(num[1]);
            return engine._fn("Denominator", canonical(engine, ops));
          },
          sgn: () => "positive",
          evaluate: (ops, { engine }) => {
            const ce = engine;
            if (ops.length === 0) return ce.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return op.op2.evaluate();
            return op.denominator;
          }
        },
        NumeratorDenominator: {
          description: "Sequence of Numerator and Denominator of an expression",
          complexity: 1200,
          broadcastable: true,
          lazy: true,
          signature: "(number) -> tuple<number, number> | nothing",
          canonical: (ops, { engine }) => {
            if (ops.length === 0) return engine.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return engine.tuple(...op.ops);
            const num = asRational(op.evaluate());
            if (num !== void 0)
              return engine.tuple(engine.number(num[0]), engine.number(num[1]));
            return engine._fn(
              "NumeratorDenominator",
              ops.map((x) => x.evaluate())
            );
          },
          evaluate: (ops, { engine }) => {
            const ce = engine;
            if (ops.length === 0) return ce.Nothing;
            const op = ops[0];
            if (op.operator === "Rational" || op.operator === "Divide")
              return ce.tuple(...op.ops);
            return ce.tuple(...op.numeratorDenominator);
          }
        }
      },
      //
      // Arithmetic on collections: Min, Max, Sum, Product
      //
      {
        Max: {
          description: "Maximum of two or more numbers",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(value*) -> number | list",
          sgn: (ops) => {
            if (ops.some((x) => x.isReal == false || x.isNaN)) return "unsigned";
            if (ops.some((x) => x.isReal == false || x.isNaN !== false))
              return void 0;
            if (ops.some((x) => x.isPositive)) return "positive";
            if (ops.every((x) => x.isNonPositive))
              return ops.some((x) => x.is(0)) ? "zero" : "non-positive";
            if (ops.some((x) => x.isNonNegative)) return "non-negative";
            if (ops.every((x) => x.isNegative)) return "negative";
            if (ops.some((x) => !x.is(0))) return "not-zero";
            return void 0;
          },
          evaluate: (xs, { engine }) => evaluateMinMax(engine, xs, "Max")
        },
        Min: {
          description: "Minimum of two or more numbers",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(value+) -> number | list",
          sgn: (ops) => {
            if (ops.some((x) => x.isReal == false || x.isNaN)) return "unsigned";
            if (ops.some((x) => x.isReal == false || x.isNaN !== false))
              return void 0;
            if (ops.some((x) => x.isNegative)) return "negative";
            if (ops.every((x) => x.isNonNegative))
              return ops.some((x) => x.is(0)) ? "zero" : "non-negative";
            if (ops.some((x) => x.isNonPositive)) return "non-positive";
            if (ops.every((x) => x.isPositive)) return "positive";
            return void 0;
          },
          evaluate: (xs, { engine }) => evaluateMinMax(engine, xs, "Min")
        },
        Supremum: {
          description: "Like Max, but defined for open sets",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(value*) -> number | list",
          evaluate: (xs, { engine }) => evaluateMinMax(engine, xs, "Supremum")
        },
        Infimum: {
          description: "Like Min, but defined for open sets",
          complexity: 1200,
          broadcastable: false,
          // The function take a variable number of arguments,
          // including collections
          signature: "(value*) -> number | list",
          evaluate: (xs, { engine }) => evaluateMinMax(engine, xs, "Infimum")
        },
        Product: {
          description: "`Product(f, a, b)` computes the product of `f` from `a` to `b`",
          wikidata: "Q901718",
          complexity: 1e3,
          broadcastable: false,
          scoped: true,
          lazy: true,
          signature: "((number+) -> number, (tuple<integer>|tuple<integer, integer>)+) -> number",
          canonical: ([body, ...bounds], { scope }) => canonicalBigop("Product", body, bounds, scope),
          evaluate: (ops, options) => {
            const ce = options.engine;
            const result = run(
              reduceBigOp(
                ops[0],
                ops.slice(1),
                (acc, x) => acc.mul(x.evaluate(options)),
                ce.One
              ),
              ce._timeRemaining
            );
            if (result === NON_ENUMERABLE_DOMAIN) {
              return void 0;
            }
            return result?.evaluate() ?? ce.NaN;
          },
          evaluateAsync: async (ops, options) => {
            const ce = options.engine;
            const result = await runAsync(
              reduceBigOp(
                ops[0],
                ops.slice(1),
                (acc, x) => acc.mul(x.evaluate(options)),
                ce.One
              ),
              ce._timeRemaining,
              options.signal
            );
            if (result === NON_ENUMERABLE_DOMAIN) {
              return void 0;
            }
            return result?.evaluate() ?? ce.NaN;
          }
        },
        Sum: {
          description: "`Sum(f, [a, b])` computes the sum of `f` from `a` to `b`",
          wikidata: "Q218005",
          complexity: 1e3,
          broadcastable: false,
          scoped: true,
          lazy: true,
          signature: "((number) -> number, bounds:tuple+) -> number",
          canonical: ([body, ...bounds], { scope }) => canonicalBigop("Sum", body, bounds, scope),
          evaluate: ([body, ...indexes], { engine }) => {
            const result = run(
              reduceBigOp(
                body,
                indexes,
                (acc, x) => acc.add(x.evaluate()),
                engine.Zero
              ),
              engine._timeRemaining
            );
            if (result === NON_ENUMERABLE_DOMAIN) {
              return void 0;
            }
            return result?.evaluate() ?? engine.NaN;
          },
          evaluateAsync: async (xs, { engine, signal }) => {
            const result = await runAsync(
              reduceBigOp(
                xs[0],
                xs.slice(1),
                (acc, x) => acc.add(x.evaluate()),
                engine.Zero
              ),
              engine._timeRemaining,
              signal
            );
            if (result === NON_ENUMERABLE_DOMAIN) {
              return void 0;
            }
            return result?.evaluate() ?? engine.NaN;
          }
        }
      }
    ];
  }
});

// src/compute-engine/index.ts
init_complex();
init_decimal();

// src/common/ansi-codes.ts
var RESET = "\x1B[0m";
var GREY = "\x1B[30;1m";
var YELLOW = "\x1B[33m";
var BLUE = "\x1B[34;1m";
var CYAN = "\x1B[36;1m";
var INVERSE_RED = "\x1B[101;97m";
var BOLD = "\x1B[1m";

// src/compute-engine/index.ts
init_symbols();
init_utils();
init_parse();
init_boxed_type();
init_serialize();

// src/common/utils.ts
var MAX_PERMUTATION_ELEMENTS = 6;
function permutations(xs, condition) {
  if (xs.length > MAX_PERMUTATION_ELEMENTS) {
    console.assert(
      false,
      `permutations(): input has ${xs.length} elements, which exceeds the limit of ${MAX_PERMUTATION_ELEMENTS}. This would generate ${factorial(xs.length)} permutations. Returning empty array to prevent memory exhaustion.`
    );
    return [];
  }
  const result = [];
  const permute = (arr, m = []) => {
    if (arr.length === 0) {
      if (!condition || condition(m)) {
        result.push([...m]);
      }
    } else {
      for (let i = 0; i < arr.length; i++) {
        const curr = arr.slice();
        const next = curr.splice(i, 1);
        permute(curr.slice(), m.concat(next));
      }
    }
  };
  permute(xs);
  return result;
}
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
function hidePrivateProperties(obj) {
  for (const key in obj) {
    if (key.startsWith("_") && obj.hasOwnProperty(key)) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        // Allows redefinition if necessary
        writable: true,
        // Allows modification
        value: obj[key]
      });
    }
  }
}

// src/common/configuration-change.ts
var ConfigurationChangeTracker = class {
  // A list of weak references to registered listeners
  _listeners = new Array(300);
  _pending = false;
  _version = 0;
  /**
   * Registers a listener for configuration changes.
   * Returns a function to unsubscribe the listener.
   * Prevents duplicate subscriptions: if the listener is already registered,
   * returns the existing unsubscribe logic without adding a duplicate.
   */
  listen(listener) {
    for (const ref2 of this._listeners) {
      const l = ref2.deref();
      if (l === listener) {
        return () => this._unsubscribe(listener);
      }
    }
    const ref = new WeakRef(listener);
    this._listeners.push(ref);
    return () => this._unsubscribe(listener);
  }
  _unsubscribe(listener) {
    this._listeners = this._listeners.filter((r) => {
      const l = r.deref();
      return l !== void 0 && l !== listener;
    });
  }
  /**
   * Notifies all live listeners of a configuration change.
   * Also prunes any dead references from the list.
   * Prevents infinite loops from recursive notify() calls.
   */
  notify() {
    if (this._pending) return;
    this._pending = true;
    const currentVersion = this._version + 1;
    queueMicrotask(() => {
      if (currentVersion !== this._version + 1) {
        this._pending = false;
        return;
      }
      this.notifyNow();
    });
  }
  /**
   * Immediately notifies all live listeners of a configuration change.
   * Also prunes any dead references from the list.
   * Increments the version and clears the pending flag.
   */
  notifyNow() {
    this._version++;
    this._listeners = this._listeners.filter((ref) => {
      const listener = ref.deref();
      try {
        listener?.onConfigurationChange?.();
      } catch (err) {
        console.error("Listener error:", err);
      }
      return listener !== void 0;
    });
    this._pending = false;
  }
};

// src/compute-engine/index.ts
init_numeric();

// src/compute-engine/latex-syntax/dictionary/definitions.ts
init_symbols();
init_utils2();
init_tokenizer();
init_types();

// src/compute-engine/latex-syntax/dictionary/definitions-algebra.ts
var DEFINITIONS_ALGEBRA = [
  {
    name: "To",
    latexTrigger: ["\\to"],
    kind: "infix",
    precedence: 270
    // MathML rightwards arrow
  }
];

// src/compute-engine/latex-syntax/dictionary/definitions-arithmetic.ts
init_utils2();
init_types();
init_serializer_style();
init_tokenizer();
function numeratorDenominator(expr) {
  if (operator(expr) !== "Multiply") return [[], []];
  const numerator = [];
  const denominator = [];
  for (const arg of operands(expr)) {
    if (operator(arg) === "Power") {
      const op1 = operand(arg, 1);
      const op2 = operand(arg, 2);
      if (operator(op2) === "Negate") {
        const b = operand(op2, 1);
        if (op1 && b) denominator.push(["Power", op1, b]);
      } else {
        const exponentVal = machineValue(op2) ?? NaN;
        if (exponentVal === -1) {
          if (op1) denominator.push(op1);
        } else if (exponentVal < 0) {
          if (op1) denominator.push(["Power", op1, -exponentVal]);
        } else {
          numerator.push(arg);
        }
      }
    } else if (operator(arg) === "Rational" && nops(arg) === 2 || operator(arg) === "Divide") {
      const op1 = operand(arg, 1);
      const op2 = operand(arg, 2);
      if (machineValue(op1) !== 1) numerator.push(op1);
      if (machineValue(op2) !== 1) denominator.push(op2);
    } else {
      const r = rationalValue(arg);
      if (r !== null) {
        if (r[0] !== 1) numerator.push(r[0]);
        denominator.push(r[1]);
      } else numerator.push(arg);
    }
  }
  return [numerator, denominator];
}
function parseRoot(parser) {
  const degree = parser.parseOptionalGroup();
  const base = parser.parseGroup() ?? parser.parseToken();
  if (isEmptySequence(base)) {
    if (degree !== null) return ["Root", MISSING, missingIfEmpty(degree)];
    return ["Sqrt", MISSING];
  }
  if (degree !== null) return ["Root", base, degree];
  return ["Sqrt", base];
}
function serializeRoot(serializer, style, base, degree) {
  if (base === null || base === void 0) return "\\sqrt{}";
  degree = degree ?? 2;
  if (style === "solidus") {
    return serializer.wrapShort(base) + "^{1/" + serializer.serialize(degree) + "}";
  } else if (style === "quotient") {
    return serializer.wrapShort(base) + "^{\\frac{1}{" + serializer.serialize(degree) + "}}";
  }
  const degreeValue = machineValue(degree);
  if (degreeValue === 2) return "\\sqrt{" + serializer.serialize(base) + "}";
  return "\\sqrt[" + serializer.serialize(degree) + "]{" + serializer.serialize(base) + "}";
}
function serializeAdd(serializer, expr) {
  serializer.level -= 1;
  const name = operator(expr);
  let result = "";
  let arg = operand(expr, 1);
  if (name === "Negate") {
    result = "-" + serializer.wrap(arg, ADDITION_PRECEDENCE + 1);
  } else if (name === "Subtract") {
    result = serializer.wrap(arg, ADDITION_PRECEDENCE);
    const arg2 = operand(expr, 2);
    if (arg2 !== null) {
      const term = serializer.wrap(arg2, ADDITION_PRECEDENCE);
      if (term[0] === "-") result += "+" + term.slice(1);
      else if (term[0] === "+") result += "-" + term.slice(1);
      else result = result + "-" + term;
    }
  } else if (name === "Add") {
    if (serializer.options.prettify && nops(expr) === 2 && serializer.options.invisiblePlus !== "+") {
      const [op1, op2] = [operand(expr, 1), operand(expr, 2)];
      let [lhs, rhs] = [op1, op2];
      let lhsValue = machineValue(lhs);
      let rhsValue = rationalValue(rhs);
      if (lhsValue === null || rhsValue === null) {
        [lhs, rhs] = [op2, op1];
        lhsValue = machineValue(lhs);
        rhsValue = rationalValue(rhs);
      }
      if (lhsValue !== null && rhsValue !== null) {
        if (isFinite(lhsValue) && Number.isInteger(lhsValue) && lhsValue >= 0 && lhsValue <= 1e3 && isFinite(rhsValue[0]) && isFinite(rhsValue[1]) && rhsValue[0] > 0 && rhsValue[0] <= 100 && rhsValue[1] <= 100) {
          result = latexTemplate(
            serializer.options.invisiblePlus,
            serializer.serialize(lhs),
            serializer.serialize(rhs)
          );
          serializer.level += 1;
          return result;
        }
      }
    }
    if (serializer.options.prettify && nops(expr) === 2) {
      const [first, firstSign] = unsign(arg);
      const [second, secondSign] = unsign(operand(expr, 2));
      if (firstSign < 0 && secondSign > 0) {
        result = serializer.wrap(second, ADDITION_PRECEDENCE) + "-" + serializer.wrap(first, ADDITION_PRECEDENCE);
        serializer.level += 1;
        return result;
      }
    }
    result = serializer.serialize(arg);
    const last = nops(expr) + 1;
    const ops = operands(expr);
    for (let i = 2; i < last; i++) {
      arg = ops[i - 1];
      if (serializer.options.prettify) {
        const [newArg, sign3] = unsign(arg);
        const term = serializer.wrap(newArg, ADDITION_PRECEDENCE);
        if (sign3 > 0) {
          if (term.startsWith("+") || term.startsWith("-")) result += term;
          else result += "+" + term;
        } else {
          if (term.startsWith("+")) result += "-" + term.slice(1);
          else if (term.startsWith("-")) result += "+" + term.slice(1);
          else result += "-" + term;
        }
      } else {
        const term = serializer.wrap(arg, ADDITION_PRECEDENCE);
        if (term[0] === "-" || term[0] === "+") result += term;
        else result += "+" + term;
      }
    }
  }
  serializer.level += 1;
  return result;
}
function serializeMultiply(serializer, expr) {
  if (expr === null) return "";
  serializer.level -= 1;
  let result = "";
  if (serializer.options.prettify === true) {
    const [numer, denom] = numeratorDenominator(expr);
    if (denom.length > 0) {
      if (denom.length === 1 && denom[0] === 1) {
        if (numer.length === 0) result = "1";
        else if (numer.length === 1) result = serializer.serialize(numer[0]);
        else result = serializeMultiply(serializer, ["Multiply", ...numer]);
      } else {
        result = serializer.serialize([
          "Divide",
          numer.length === 1 ? numer[0] : ["Multiply", ...numer],
          denom.length === 1 ? denom[0] : ["Multiply", ...denom]
        ]);
      }
    }
  }
  if (result) {
    serializer.level += 1;
    return result;
  }
  let isNegative2 = false;
  let arg = null;
  const count = nops(expr) + 1;
  let xs = operands(expr);
  if (serializer.options.prettify === true) {
    if (xs.length === 2) {
      if (isNumberExpression(xs[1]) && !isNumberExpression(xs[0])) {
        xs = [xs[1], xs[0]];
      }
    }
  }
  let prevWasNumber = false;
  for (let i = 1; i < count; i++) {
    arg = xs[i - 1];
    if (arg === null) continue;
    let term;
    if (isNumberExpression(arg)) {
      term = serializer.serialize(arg);
      if (term === "-1" && !result) {
        result = "";
        isNegative2 = !isNegative2;
      } else {
        if (term[0] === "-") {
          term = term.slice(1);
          isNegative2 = !isNegative2;
        }
        if (!result) result = term;
        else result = latexTemplate(serializer.options.multiply, result, term);
      }
      prevWasNumber = true;
      continue;
    }
    if (operator(arg) === "Power") {
      const r = rationalValue(operand(arg, 2));
      if (r !== void 0 && r !== null) {
        const [n, d] = r;
        if (n === 1 && d !== null) {
          result += serializeRoot(
            serializer,
            serializer.rootStyle(arg, serializer.level),
            operand(arg, 1),
            d
          );
          prevWasNumber = false;
          continue;
        }
      }
    }
    if (operator(arg) === "Power" && !isNaN(machineValue(operand(arg, 1)) ?? NaN)) {
      term = serializer.serialize(arg);
      if (!result) result = term;
      else result = latexTemplate(serializer.options.multiply, result, term);
      prevWasNumber = true;
      continue;
    }
    if (operator(arg) === "Negate") {
      arg = operand(arg, 1);
      isNegative2 = !isNegative2;
    }
    term = serializer.wrap(arg, MULTIPLICATION_PRECEDENCE);
    if (!result) {
      result = term;
    } else {
      const h = operator(arg);
      if (prevWasNumber && (h === "Divide" || h === "Rational")) {
        result = latexTemplate(serializer.options.multiply, result, term);
      } else if (!serializer.options.invisibleMultiply) {
        result = joinLatex([result, term]);
      } else {
        result = latexTemplate(
          serializer.options.invisibleMultiply,
          result,
          term
        );
      }
    }
    prevWasNumber = false;
  }
  serializer.level += 1;
  return isNegative2 ? "-" + result : result;
}
function parseFraction(parser) {
  let numer = parser.parseGroup();
  let denom = null;
  if (numer === null) {
    numer = parser.parseToken();
    denom = parser.parseToken();
  } else {
    denom = parser.parseGroup();
  }
  numer = missingIfEmpty(numer);
  denom = missingIfEmpty(denom);
  if (operator(numer) === "PartialDerivative" && (operator(denom) === "PartialDerivative" || operator(denom) === "Multiply" && operator(operand(denom, 1)) === "PartialDerivative")) {
    const degree = operand(numer, 3) ?? null;
    let fn = operand(numer, 1);
    if (fn === null || fn === void 0)
      fn = missingIfEmpty(parser.parseExpression());
    let vars = [];
    if (operator(denom) === "Multiply") {
      for (const arg of operands(denom)) {
        if (operator(arg) === "PartialDerivative") {
          const v = operand(arg, 2);
          if (v) vars.push(v);
        }
      }
    } else {
      const v = operand(denom, 2);
      if (v) vars.push(v);
    }
    if (vars.length > 1) {
      vars = ["List", ...vars];
    }
    return ["PartialDerivative", fn, ...vars, degree === null ? 1 : degree];
  }
  const numerSym = symbol(numer);
  const isDifferential = numerSym === "d" || numerSym === "d_upright" || numerSym === "differentialD";
  if (isDifferential) {
    const vars = [];
    const collectVars = (expr) => {
      if (!expr) return;
      const s = symbol(expr);
      if (s && s !== "d" && s !== "d_upright" && s !== "differentialD") {
        vars.push(expr);
        return;
      }
      const h = operator(expr);
      if (h === "Sequence" || h === "Multiply" || h === "InvisibleOperator") {
        for (const op of operands(expr)) collectVars(op);
      }
    };
    collectVars(denom);
    if (vars.length === 0) {
      const denomSym = symbol(denom);
      if (denomSym && denomSym.length > 1 && denomSym[0] === "d") {
        vars.push(denomSym.slice(1));
      }
    }
    if (vars.length > 0) {
      const fn = missingIfEmpty(parser.parseExpression());
      return ["D", fn, ...vars];
    }
  }
  return ["Divide", numer, denom];
}
function serializeFraction(serializer, expr) {
  if (expr === null) return "";
  const numer = missingIfEmpty(operand(expr, 1));
  const denom = missingIfEmpty(operand(expr, 2));
  const style = serializer.options.prettify ? serializer.fractionStyle(expr, serializer.level) : "quotient";
  if (style === "inline-solidus" || style === "nice-solidus") {
    const numerStr = serializer.wrapShort(numer);
    const denomStr = serializer.wrapShort(denom);
    if (style === "inline-solidus") return `${numerStr}/${denomStr}`;
    return `{}^{${numerStr}}\\!\\!/\\!{}_{${denomStr}}`;
  } else if (style === "reciprocal") {
    if (machineValue(numer) === 1) return serializer.wrap(denom) + "^{-1}";
    return serializer.wrap(numer) + serializer.wrap(denom) + "^{-1}";
  } else if (style === "factor") {
    if (machineValue(denom) === 1) return serializer.wrap(numer);
    return "\\frac{1}{" + serializer.serialize(denom) + "}" + serializer.wrapString(
      serializer.serialize(numer),
      serializer.groupStyle(expr, 1)
    );
  }
  let cmd = "\\frac";
  if (style === "block-quotient") cmd = "\\dfrac";
  else if (style === "inline-quotient") cmd = "\\tfrac";
  const numerLatex = serializer.serialize(numer);
  const denomLatex = serializer.serialize(denom);
  return `${cmd}{${numerLatex}}{${denomLatex}}`;
}
function serializePower(serializer, expr) {
  if (!expr) return "";
  const name = operator(expr);
  const base = missingIfEmpty(operand(expr, 1));
  if (name === "Sqrt") {
    return serializeRoot(
      serializer,
      serializer.rootStyle(expr, serializer.level - 1),
      base,
      2
    );
  }
  const exp3 = missingIfEmpty(operand(expr, 2));
  if (name === "Root")
    return serializeRoot(
      serializer,
      serializer.rootStyle(expr, serializer.level - 1),
      base,
      exp3
    );
  if (serializer.options.prettify) {
    const val2 = machineValue(exp3) ?? 1;
    if (val2 === -1) {
      return serializer.serialize(["Divide", "1", base]);
    } else if (val2 < 0) {
      return serializer.serialize(["Divide", "1", ["Power", base, -val2]]);
    } else if (operator(exp3) === "Divide" || operator(exp3) === "Rational") {
      const num = machineValue(operand(exp3, 1));
      const denom = machineValue(operand(exp3, 2));
      if (num === 1) {
        const style = serializer.rootStyle(expr, serializer.level);
        return serializeRoot(serializer, style, base, operand(exp3, 2));
      }
      if (num === -1) {
        if (denom === 2) {
          return serializer.serialize(["Divide", "1", ["Sqrt", base]]);
        }
        return serializer.serialize([
          "Divide",
          "1",
          ["Root", base, operand(exp3, 2)]
        ]);
      }
      if (denom === 2) {
        return `${serializer.serialize(["Sqrt", base])}^{${serializer.serialize(
          operand(exp3, 1)
        )}}`;
      }
    } else if (operator(exp3) === "Power") {
      if (machineValue(operand(exp3, 2)) === -1) {
        const style = serializer.rootStyle(expr, serializer.level);
        return serializeRoot(serializer, style, base, operand(exp3, 1));
      }
    }
  }
  const wrapNegativeBase = (latex) => latex.startsWith("-") ? serializer.wrapString(latex, "normal") : latex;
  if (operator(base) === "Power") {
    const baseBody = operand(base, 1);
    const baseExponent = operand(base, 2);
    const baseBodyLatex = wrapNegativeBase(serializer.wrapShort(baseBody));
    const baseExponentLatex = serializer.wrapShort(baseExponent);
    return `
      ${baseBodyLatex}^{${supsub("^", baseExponentLatex, serializer.serialize(exp3))}}`;
  }
  return supsub(
    "^",
    wrapNegativeBase(serializer.wrapShort(base)),
    serializer.serialize(exp3)
  );
}
var DEFINITIONS_ARITHMETIC = [
  // Constants
  { name: "CatalanConstant", symbolTrigger: "G" },
  { name: "GoldenRatio", latexTrigger: "\\varphi" },
  { name: "EulerGamma", latexTrigger: "\\gamma" },
  {
    name: "Degrees",
    latexTrigger: ["\\degree"],
    kind: "postfix",
    precedence: 880,
    parse: (_parser, lhs) => ["Degrees", lhs],
    serialize: (serializer, expr) => {
      return joinLatex([serializer.serialize(operand(expr, 1)), "\\degree"]);
    }
  },
  {
    latexTrigger: ["\\degree"],
    kind: "postfix",
    precedence: 880,
    parse: (_parser, lhs) => ["Degrees", lhs]
  },
  {
    latexTrigger: ["^", "<{>", "\\circ", "<}>"],
    kind: "postfix",
    parse: (_parser, lhs) => ["Degrees", lhs]
  },
  {
    latexTrigger: ["^", "\\circ"],
    kind: "postfix",
    parse: (_parser, lhs) => ["Degrees", lhs]
  },
  {
    latexTrigger: ["\xB0"],
    kind: "postfix",
    precedence: 880,
    parse: (_parser, lhs) => ["Degrees", lhs]
  },
  {
    latexTrigger: ["\\ang"],
    parse: (parser) => {
      const arg = parser.parseGroup();
      return arg === null ? ["Degrees"] : ["Degrees", arg];
    }
  },
  {
    latexTrigger: ["\\infty"],
    parse: "PositiveInfinity"
  },
  {
    name: "PositiveInfinity",
    serialize: (serializer) => serializer.options.positiveInfinity
  },
  {
    name: "NegativeInfinity",
    serialize: (serializer) => serializer.options.negativeInfinity
  },
  {
    name: "ComplexInfinity",
    latexTrigger: ["\\tilde", "\\infty"],
    serialize: "\\tilde\\infty"
  },
  {
    latexTrigger: ["\\tilde", "<{>", "\\infty", "<}>"],
    parse: "ComplexInfinity"
  },
  { name: "Pi", kind: "symbol", latexTrigger: ["\\pi"] },
  { latexTrigger: ["\u03C0"], parse: "Pi" },
  {
    name: "ExponentialE",
    latexTrigger: ["\\exponentialE"],
    parse: "ExponentialE",
    serialize: "\\exponentialE"
  },
  {
    latexTrigger: "\\operatorname{e}",
    parse: "ExponentialE"
  },
  {
    latexTrigger: "\\mathrm{e}",
    parse: "ExponentialE"
  },
  {
    kind: "function",
    symbolTrigger: "exp",
    parse: (parser) => {
      const args = parser.parseArguments("implicit");
      if (args === null) return "Exp";
      return ["Exp", ...args];
    }
  },
  {
    latexTrigger: "\\exp",
    parse: (parser) => {
      const args = parser.parseArguments("implicit");
      if (args === null) return "Exp";
      return ["Exp", ...args];
    }
  },
  {
    name: "ImaginaryUnit",
    latexTrigger: ["\\imaginaryI"]
  },
  {
    latexTrigger: "\\operatorname{i}",
    parse: "ImaginaryUnit"
  },
  {
    latexTrigger: "\\mathrm{i}",
    parse: "ImaginaryUnit"
  },
  // Operations
  {
    /** Could be the determinant if the argument is a matrix */
    /** @todo: domain check */
    /** If a literal matrix, the `serialize` should be custom, the parens are
     * replaced with bars */
    name: "Abs",
    kind: "matchfix",
    openTrigger: "|",
    closeTrigger: "|",
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Abs", body]
  },
  {
    kind: "matchfix",
    openTrigger: ["\\vert"],
    closeTrigger: ["\\vert"],
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Abs", body]
  },
  {
    symbolTrigger: "abs",
    kind: "function",
    parse: "Abs"
  },
  {
    name: "Add",
    latexTrigger: ["+"],
    kind: "infix",
    associativity: "any",
    precedence: ADDITION_PRECEDENCE,
    parse: (parser, lhs, until) => {
      const rhs = parser.parseExpression({
        ...until,
        minPrec: ADDITION_PRECEDENCE
      });
      if (rhs === null) return null;
      return foldAssociativeOperator("Add", lhs, rhs);
    },
    serialize: serializeAdd
  },
  {
    kind: "prefix",
    latexTrigger: ["+"],
    precedence: ADDITION_PRECEDENCE,
    parse: (parser, until) => {
      return parser.parseExpression({ ...until, minPrec: 400 });
    }
  },
  {
    name: "Ceil",
    kind: "matchfix",
    openTrigger: "\\lceil",
    closeTrigger: "\\rceil",
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Ceil", body]
  },
  {
    kind: "matchfix",
    openTrigger: ["\u2308"],
    //  U+2308 LEFT CEILING
    closeTrigger: ["\u2309"],
    //  U+2309 RIGHT CEILING
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Ceil", body]
  },
  {
    symbolTrigger: "ceil",
    kind: "function",
    parse: "Ceil"
  },
  { name: "Chop", symbolTrigger: "chop", kind: "function", parse: "Chop" },
  {
    name: "Complex",
    precedence: ADDITION_PRECEDENCE - 1,
    // One less than precedence of `Add`: used for correct wrapping
    serialize: (serializer, expr) => {
      const rePart = serializer.serialize(operand(expr, 1));
      const im = machineValue(operand(expr, 2));
      if (im === 0) return rePart;
      const imPart = im === 1 ? "\\imaginaryI" : im === -1 ? "-\\imaginaryI" : joinLatex([
        serializer.serialize(operand(expr, 2)),
        "\\imaginaryI"
      ]);
      const re = machineValue(operand(expr, 1));
      if (re === 0) return imPart;
      if (im !== null && im < 0) return joinLatex([rePart, imPart]);
      return joinLatex([rePart, "+", imPart]);
    }
  },
  {
    name: "Divide",
    latexTrigger: "\\frac",
    precedence: DIVISION_PRECEDENCE,
    // For \frac specifically, not for \div, etc..
    // handles Leibnitz notation for partial derivatives
    parse: parseFraction,
    serialize: serializeFraction
  },
  {
    kind: "infix",
    latexTrigger: "\\over",
    associativity: "none",
    // In LaTeX, the \over command is not associative
    precedence: DIVISION_PRECEDENCE,
    parse: "Divide"
  },
  {
    // The \/ command is recognized by MathLive, but not by KaTeX, so we
    // try to avoid generating it.
    latexTrigger: ["\\/"],
    kind: "infix",
    associativity: "left",
    precedence: DIVISION_PRECEDENCE,
    // ??? MathML has 265, but it's wrong.
    // It has to be at least higher than multiply
    // e.g. `1/2+3*x` -> `1/2 + 3*x` , not `1/(2+3*x)`
    parse: "Divide"
  },
  {
    latexTrigger: ["/"],
    kind: "infix",
    associativity: "left",
    precedence: DIVISION_PRECEDENCE,
    parse: "Divide"
  },
  {
    latexTrigger: ["\\div"],
    kind: "infix",
    associativity: "left",
    precedence: DIVISION_PRECEDENCE,
    // ??? according to MathML
    parse: "Divide"
  },
  {
    name: "Exp",
    serialize: (serializer, expr) => {
      const op1 = operand(expr, 1);
      if (symbol(op1) || machineValue(op1) !== null)
        return joinLatex(["\\exponentialE^{", serializer.serialize(op1), "}"]);
      return joinLatex(["\\exp", serializer.wrap(missingIfEmpty(op1))]);
    }
  },
  {
    name: "Factorial",
    latexTrigger: ["!"],
    kind: "postfix",
    precedence: POSTFIX_PRECEDENCE
  },
  {
    name: "Factorial2",
    latexTrigger: ["!", "!"],
    kind: "postfix",
    precedence: POSTFIX_PRECEDENCE
  },
  {
    name: "Floor",
    kind: "matchfix",
    openTrigger: "\\lfloor",
    closeTrigger: "\\rfloor",
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Floor", body]
  },
  {
    kind: "matchfix",
    openTrigger: ["\u230A"],
    //  U+230A LEFT FLOOR
    closeTrigger: ["\u230B"],
    //  U+230B RIGHT FLOOR
    parse: (_parser, body) => isEmptySequence(body) ? null : ["Floor", body]
  },
  {
    symbolTrigger: "floor",
    kind: "function",
    parse: "Floor"
  },
  {
    latexTrigger: ["\\Gamma"],
    parse: "Gamma"
  },
  // Riemann zeta function - \zeta parses to Zeta function when followed by arguments
  // Note: \zeta without arguments is handled by definitions-symbols.ts as Greek letter
  {
    latexTrigger: ["\\zeta"],
    kind: "function",
    parse: "Zeta"
  },
  // Beta function - \Beta parses to Beta function when followed by arguments
  // Note: \Beta without arguments is handled by definitions-symbols.ts as Greek letter
  {
    latexTrigger: ["\\Beta"],
    kind: "function",
    parse: "Beta"
  },
  // Lambert W function (product logarithm)
  {
    name: "LambertW",
    latexTrigger: ["\\operatorname{W}"],
    kind: "function",
    serialize: (serializer, expr) => "\\operatorname{W}" + serializer.wrapArguments(expr)
  },
  // Bessel functions - order is first argument, value is second
  // BesselJ(n, x) represents J_n(x)
  {
    name: "BesselJ",
    latexTrigger: ["\\operatorname{J}"],
    kind: "function",
    serialize: (serializer, expr) => {
      const order3 = operand(expr, 1);
      const x = operand(expr, 2);
      if (order3 !== void 0 && x !== void 0) {
        return "\\operatorname{J}_{" + serializer.serialize(order3) + "}" + serializer.wrapArguments(["BesselJ", x]);
      }
      return "\\operatorname{J}" + serializer.wrapArguments(expr);
    }
  },
  {
    name: "BesselY",
    latexTrigger: ["\\operatorname{Y}"],
    kind: "function",
    serialize: (serializer, expr) => {
      const order3 = operand(expr, 1);
      const x = operand(expr, 2);
      if (order3 !== void 0 && x !== void 0) {
        return "\\operatorname{Y}_{" + serializer.serialize(order3) + "}" + serializer.wrapArguments(["BesselY", x]);
      }
      return "\\operatorname{Y}" + serializer.wrapArguments(expr);
    }
  },
  {
    name: "BesselI",
    latexTrigger: ["\\operatorname{I}"],
    kind: "function",
    serialize: (serializer, expr) => {
      const order3 = operand(expr, 1);
      const x = operand(expr, 2);
      if (order3 !== void 0 && x !== void 0) {
        return "\\operatorname{I}_{" + serializer.serialize(order3) + "}" + serializer.wrapArguments(["BesselI", x]);
      }
      return "\\operatorname{I}" + serializer.wrapArguments(expr);
    }
  },
  {
    name: "BesselK",
    latexTrigger: ["\\operatorname{K}"],
    kind: "function",
    serialize: (serializer, expr) => {
      const order3 = operand(expr, 1);
      const x = operand(expr, 2);
      if (order3 !== void 0 && x !== void 0) {
        return "\\operatorname{K}_{" + serializer.serialize(order3) + "}" + serializer.wrapArguments(["BesselK", x]);
      }
      return "\\operatorname{K}" + serializer.wrapArguments(expr);
    }
  },
  // Airy functions
  {
    name: "AiryAi",
    latexTrigger: ["\\operatorname{Ai}"],
    kind: "function",
    serialize: (serializer, expr) => "\\operatorname{Ai}" + serializer.wrapArguments(expr)
  },
  {
    name: "AiryBi",
    latexTrigger: ["\\operatorname{Bi}"],
    kind: "function",
    serialize: (serializer, expr) => "\\operatorname{Bi}" + serializer.wrapArguments(expr)
  },
  {
    name: "GCD",
    latexTrigger: ["\\gcd"],
    // command from amsmath package
    kind: "function"
  },
  {
    symbolTrigger: "gcd",
    kind: "function",
    parse: "GCD"
  },
  {
    symbolTrigger: "GCD",
    kind: "function",
    parse: "GCD"
  },
  {
    name: "Half",
    serialize: "\\frac12"
  },
  {
    name: "Lg",
    latexTrigger: ["\\lg"],
    serialize: (serializer, expr) => "\\log_{10}" + serializer.wrapArguments(expr),
    parse: (parser) => {
      const args = parser.parseArguments("implicit");
      if (args === null) return "Lg";
      return ["Log", ...args, 10];
    }
  },
  {
    name: "Lb",
    latexTrigger: "\\lb",
    parse: (parser) => {
      const args = parser.parseArguments("implicit");
      if (args === null) return "Log";
      return ["Log", args[0], 2];
    }
  },
  {
    name: "Ln",
    latexTrigger: ["\\ln"],
    parse: (parser) => parseLog("Ln", parser),
    serialize: (serializer, expr) => "\\ln" + serializer.wrapArguments(expr)
  },
  {
    name: "Log",
    latexTrigger: ["\\log"],
    parse: (parser) => parseLog("Log", parser),
    serialize: (serializer, expr) => {
      const [body, base] = operands(expr);
      if (!base) return "\\log" + serializer.wrapArguments(expr);
      return joinLatex([
        "\\log_{",
        serializer.serialize(base),
        "}",
        serializer.wrap(body)
      ]);
    }
  },
  {
    name: "LCM",
    latexTrigger: ["\\lcm"],
    kind: "function"
  },
  {
    symbolTrigger: "lcm",
    kind: "function",
    parse: "LCM"
  },
  {
    symbolTrigger: "LCM",
    kind: "function",
    parse: "LCM"
  },
  { symbolTrigger: "max", kind: "function", parse: "Max" },
  { symbolTrigger: "min", kind: "function", parse: "Min" },
  { name: "Max", latexTrigger: "\\max", kind: "function" },
  { name: "Min", latexTrigger: "\\min", kind: "function" },
  { name: "Supremum", latexTrigger: "\\sup", kind: "function" },
  { name: "Infimum", latexTrigger: "\\inf", kind: "function" },
  {
    name: "Limit",
    latexTrigger: "\\lim",
    kind: "expression",
    parse: (parser) => {
      if (!parser.match("_")) return null;
      const base = parser.parseGroup();
      if (operator(base) !== "To") return null;
      const expr = parser.parseArguments("implicit");
      if (!expr) return null;
      return [
        "Limit",
        ["Function", expr[0], operand(base, 1)],
        operand(base, 2)
      ];
    },
    serialize: (serializer, expr) => {
      const fn = operand(expr, 1);
      const fnVar = operand(fn, 2);
      const to = operand(expr, 2);
      return joinLatex([
        "\\lim_{",
        serializer.serialize(fnVar),
        "\\to",
        serializer.serialize(to),
        "}",
        serializer.serialize(operand(fn, 1))
      ]);
    }
  },
  {
    name: "MinusPlus",
    latexTrigger: ["\\mp"],
    kind: "infix",
    associativity: "any",
    precedence: ARROW_PRECEDENCE
  },
  {
    name: "Multiply",
    latexTrigger: ["\\times"],
    kind: "infix",
    associativity: "any",
    precedence: MULTIPLICATION_PRECEDENCE,
    serialize: serializeMultiply
  },
  {
    latexTrigger: ["\\cdot"],
    kind: "infix",
    associativity: "any",
    precedence: MULTIPLICATION_PRECEDENCE,
    parse: (parser, lhs, terminator) => {
      const rhs = parser.parseExpression({
        ...terminator,
        minPrec: MULTIPLICATION_PRECEDENCE + 2
      });
      if (rhs === null) return null;
      return foldAssociativeOperator("Multiply", lhs, rhs);
    }
  },
  {
    latexTrigger: ["*"],
    kind: "infix",
    associativity: "any",
    precedence: MULTIPLICATION_PRECEDENCE,
    parse: (parser, lhs, terminator) => {
      const rhs = parser.parseExpression({
        ...terminator,
        minPrec: MULTIPLICATION_PRECEDENCE + 2
      });
      if (rhs === null) return ["Multiply", lhs, MISSING];
      return foldAssociativeOperator("Multiply", lhs, rhs);
    }
  },
  // Infix modulo, as in `26 \bmod 5`
  {
    name: "Mod",
    latexTrigger: "\\bmod",
    kind: "infix",
    precedence: DIVISION_PRECEDENCE,
    serialize: (serializer, expr) => {
      if (nops(expr) !== 2) return "";
      const lhs = serializer.serialize(operand(expr, 1));
      const rhs = serializer.serialize(operand(expr, 2));
      return joinLatex([lhs, "\\bmod", rhs]);
    }
  },
  // Synonym to \\bmod
  {
    latexTrigger: "\\mod",
    kind: "infix",
    precedence: DIVISION_PRECEDENCE,
    parse: "Mod"
  },
  {
    latexTrigger: "\\pmod",
    kind: "prefix",
    precedence: COMPARISON_PRECEDENCE,
    parse: (parser) => {
      const rhs = parser.parseGroup() ?? parser.parseToken();
      return ["Mod", missingIfEmpty(rhs)];
    }
  },
  {
    name: "Congruent",
    serialize: (serializer, expr) => {
      const lhs = serializer.serialize(operand(expr, 1));
      const rhs = serializer.serialize(operand(expr, 2));
      if (operand(expr, 3) === null) return joinLatex([lhs, "\\equiv", rhs]);
      const modulus = serializer.serialize(operand(expr, 3));
      return joinLatex([lhs, "\\equiv", rhs, "\\pmod{", modulus, "}"]);
    }
  },
  {
    name: "Negate",
    latexTrigger: ["-"],
    kind: "prefix",
    precedence: EXPONENTIATION_PRECEDENCE + 1,
    parse: (parser, terminator) => {
      parser.skipSpace();
      const rhs = parser.parseExpression({
        ...terminator,
        minPrec: EXPONENTIATION_PRECEDENCE + 3
      });
      if (rhs === null) return null;
      return ["Negate", rhs];
    }
  },
  // {
  //   /** If the argument is a vector */
  //   /** @todo: domain check */
  //   name: 'Norm',
  //   kind: 'matchfix',
  //   openDelimiter: '|',
  //   closeDelimiter: '|',
  // },
  // {
  //   /** If the argument is a set */
  //   /** @todo: domain check */
  //   name: 'Cardinality',
  //   kind: 'matchfix',
  //   openDelimiter: '|',
  //   closeDelimiter: '|',
  // },
  {
    //   /** If the argument is a vector */
    /** @todo: domain check */
    kind: "matchfix",
    openTrigger: "||",
    closeTrigger: "||",
    parse: (_parser, expr) => isEmptySequence(expr) ? null : ["Norm", expr]
  },
  {
    //   /** If the argument is a vector */
    /** @todo: domain check */
    name: "Norm",
    kind: "matchfix",
    openTrigger: ["\\left", "\\Vert"],
    closeTrigger: ["\\right", "\\Vert"],
    parse: (_parser, expr) => isEmptySequence(expr) ? null : ["Norm", expr]
  },
  {
    name: "PlusMinus",
    latexTrigger: ["\\pm"],
    kind: "infix",
    associativity: "any",
    precedence: ARROW_PRECEDENCE,
    serialize: (serializer, expr) => {
      const op1 = operand(expr, 1);
      if (op1 === null) return "\\pm";
      if (nops(expr) === 1)
        return joinLatex(["\\pm", serializer.serialize(op1)]);
      const op2 = operand(expr, 2);
      return joinLatex([
        serializer.serialize(op1),
        "\\pm",
        serializer.serialize(op2)
      ]);
    }
  },
  {
    latexTrigger: ["\\pm"],
    kind: "prefix",
    precedence: ARROW_PRECEDENCE,
    parse: (parser, terminator) => {
      const rhs = parser.parseExpression({ ...terminator, minPrec: 400 });
      return ["PlusMinus", 0, missingIfEmpty(rhs)];
    }
  },
  {
    latexTrigger: ["\\plusmn"],
    kind: "infix",
    associativity: "any",
    precedence: ARROW_PRECEDENCE,
    parse: (parser, lhs, terminator) => {
      const rhs = parser.parseExpression({ ...terminator, minPrec: 400 });
      return ["PlusMinus", lhs, missingIfEmpty(rhs)];
    }
  },
  {
    latexTrigger: ["\\plusmn"],
    kind: "prefix",
    precedence: ARROW_PRECEDENCE,
    parse: (parser, terminator) => {
      const rhs = parser.parseExpression({ ...terminator, minPrec: 400 });
      return ["PlusMinus", missingIfEmpty(rhs)];
    }
  },
  {
    name: "Power",
    latexTrigger: ["^"],
    kind: "infix",
    serialize: serializePower
    // Parsing is done as a special case in `parseSupsub`
  },
  {
    latexTrigger: "\\prod",
    precedence: MULTIPLICATION_PRECEDENCE,
    name: "Product",
    parse: parseBigOp("Product", "Multiply", MULTIPLICATION_PRECEDENCE),
    serialize: serializeBigOp("\\prod")
  },
  // {
  //   trigger: ['*', '*'],
  //   kind: 'infix',
  //   associativity: 'none',
  //   precedence: 720,
  // },
  {
    name: "Rational",
    precedence: DIVISION_PRECEDENCE,
    serialize: (serializer, expr) => {
      if (expr && nops(expr) === 1)
        return "\\operatorname{Rational}" + serializer.wrapArguments(expr);
      return serializeFraction(serializer, expr);
    }
  },
  {
    name: "Reduce",
    serialize: (serializer, expr) => {
      const collection = operand(expr, 1);
      if (!collection) return "";
      const f = operand(expr, 2);
      if (symbol(f) === "Add") {
        return `\\sum ${serializer.serialize(collection)}`;
      } else if (symbol(f) === "Multiply") {
        return `\\prod ${serializer.serialize(collection)}`;
      }
      return `\\operatorname{Reduce}\\left(${serializer.serialize(collection)}, ${serializer.serialize(operand(expr, 2))}\\right)`;
    }
  },
  {
    name: "Root",
    serialize: serializePower
  },
  {
    name: "Round",
    symbolTrigger: "round",
    kind: "function"
  },
  {
    name: "Square",
    precedence: 720,
    serialize: (serializer, expr) => {
      const base = serializer.wrapShort(operand(expr, 1));
      const wrapped = base.startsWith("-") ? serializer.wrapString(base, "normal") : base;
      return wrapped + "^2";
    }
  },
  {
    latexTrigger: ["\\sum"],
    precedence: ADDITION_PRECEDENCE,
    name: "Sum",
    parse: parseBigOp("Sum", "Add", MULTIPLICATION_PRECEDENCE),
    serialize: serializeBigOp("\\sum")
  },
  {
    name: "Sign",
    // As per ISO 80000-2, "signum" is 'sgn'
    symbolTrigger: "sgn",
    kind: "function"
  },
  {
    name: "Sqrt",
    latexTrigger: ["\\sqrt"],
    parse: parseRoot,
    serialize: serializePower
  },
  {
    name: "Subtract",
    latexTrigger: ["-"],
    kind: "infix",
    associativity: "left",
    precedence: ADDITION_PRECEDENCE + 2,
    parse: (parser, lhs, terminator) => {
      parser.index -= 1;
      const rhs = parser.parseExpression({
        ...terminator,
        minPrec: ADDITION_PRECEDENCE + 3
      });
      if (rhs === null) return null;
      return ["Add", lhs, rhs];
    },
    serialize: (serializer, expr) => {
      const lhs = serializer.wrap(operand(expr, 1), ADDITION_PRECEDENCE + 2);
      const rhs = serializer.wrap(operand(expr, 2), ADDITION_PRECEDENCE + 3);
      return joinLatex([lhs, "-", rhs]);
    }
  }
];
function getIndexAssignment(expr, upper) {
  if (expr === null) return void 0;
  if (symbol(expr)) return { index: symbol(expr) ?? "Nothing", upper };
  if (operator(expr) === "GreaterEqual") {
    const index = symbol(operand(expr, 1)) ?? "Nothing";
    const lower = operand(expr, 2) ?? 1;
    return { index, lower, upper };
  }
  if (operator(expr) === "Equal") {
    const index = symbol(operand(expr, 1)) ?? "Nothing";
    const rhs = operand(expr, 2);
    if (operator(rhs) === "Range") {
      const lower2 = operand(rhs, 1) ?? 1;
      const upper2 = operand(rhs, 2) ?? void 0;
      return { index, lower: lower2, upper: upper2 };
    }
    const lower = rhs ?? 1;
    return { index, lower, upper };
  }
  if (operator(expr) === "Element") {
    const index = symbol(operand(expr, 1)) ?? "Nothing";
    return { index, element: expr };
  }
  return void 0;
}
function isConditionExpression(expr) {
  const op = operator(expr);
  if (!op) return false;
  const conditionOperators = /* @__PURE__ */ new Set([
    "Less",
    "LessEqual",
    "Greater",
    "GreaterEqual",
    "NotEqual",
    "And",
    "Or",
    "Not"
    // Also allow function applications as conditions (e.g., IsPrime(n))
  ]);
  return conditionOperators.has(op);
}
function getSequenceOrTuple(expr) {
  if (expr === null) return [];
  const seq = getSequence(expr);
  if (seq) return [...seq];
  if (operator(expr) === "Tuple") {
    const ops = operands(expr);
    return ops ? [...ops] : [expr];
  }
  return [expr];
}
function getIndexes(sub3, sup) {
  if (isEmptySequence(sub3)) sub3 = null;
  if (isEmptySequence(sup)) sup = null;
  const subs = getSequenceOrTuple(sub3);
  const sups = getSequenceOrTuple(sup);
  const results = [];
  let i = 0;
  while (i < subs.length) {
    const subExpr = subs[i];
    const assignment = getIndexAssignment(subExpr, sups[i]);
    if (assignment) {
      if (assignment.element && i + 1 < subs.length) {
        const nextExpr = subs[i + 1];
        if (isConditionExpression(nextExpr) && operator(nextExpr) !== "Element" && operator(nextExpr) !== "Equal") {
          const elementExpr = assignment.element;
          if (Array.isArray(elementExpr) && elementExpr.length >= 3) {
            const newElement = [
              elementExpr[0],
              ...elementExpr.slice(1),
              nextExpr
            ];
            assignment.element = newElement;
          }
          i++;
        }
      }
      results.push(assignment);
    }
    i++;
  }
  return results;
}
function parseBigOp(name, reduceOp, minPrec) {
  return (parser) => {
    parser.skipSpace();
    parser.pushSymbolTable();
    let sup = null;
    let sub3 = null;
    while (!(sub3 && sup) && (parser.peek === "_" || parser.peek === "^")) {
      if (parser.match("_")) sub3 = parser.parseGroup() ?? parser.parseToken();
      else if (parser.match("^"))
        sup = parser.parseGroup() ?? parser.parseToken();
      parser.skipSpace();
    }
    if (!sup && !sub3) {
      const collection = parser.parseExpression({ minPrec });
      parser.popSymbolTable();
      if (collection) return ["Reduce", collection, reduceOp];
      return null;
    }
    const indexes = getIndexes(sub3, sup);
    const fn = parser.parseExpression({ minPrec });
    parser.popSymbolTable();
    if (fn === null) return [name];
    const indexingSetArguments = [];
    for (const indexingSet of indexes) {
      if (indexingSet.element) {
        indexingSetArguments.push(indexingSet.element);
        continue;
      }
      const lower = indexingSet.lower;
      const upper = indexingSet.upper;
      const index = indexingSet.index ?? "Nothing";
      if (upper !== null && upper !== void 0)
        indexingSetArguments.push(["Tuple", index, lower ?? 1, upper]);
      else if (lower !== null && lower !== void 0)
        indexingSetArguments.push(["Tuple", index, lower]);
      else indexingSetArguments.push(["Tuple", index]);
    }
    return [name, fn, ...indexingSetArguments];
  };
}
var INDEXING_SET_HEADS = /* @__PURE__ */ new Set([
  "Tuple",
  "Triple",
  "Pair",
  "Single",
  "Limits",
  "Element"
]);
function sanitizeLimitOperand(expr) {
  if (expr === null || expr === void 0) return null;
  if (symbol(expr) === "Nothing") return null;
  return expr;
}
function collectIndexingSets(expr) {
  const result = [];
  const args = operands(expr);
  if (args.length <= 1) return result;
  for (const candidate of args.slice(1)) {
    const head = operator(candidate);
    if (head && INDEXING_SET_HEADS.has(head)) {
      result.push(candidate);
      continue;
    }
    break;
  }
  return result;
}
function serializeIndexingSet(serializer, indexingSet) {
  if (operator(indexingSet) === "Element") {
    const indexLatex2 = serializer.serialize(operand(indexingSet, 1));
    const collectionLatex = serializer.serialize(operand(indexingSet, 2));
    return { sub: `${indexLatex2}\\in ${collectionLatex}` };
  }
  let indexExpr = operand(indexingSet, 1);
  if (indexExpr !== null && operator(indexExpr) === "Hold")
    indexExpr = operand(indexExpr, 1);
  const lowerExpr = sanitizeLimitOperand(operand(indexingSet, 2));
  const upperExpr = sanitizeLimitOperand(operand(indexingSet, 3));
  const result = {};
  const indexName = indexExpr ? symbol(indexExpr) : null;
  const hasIndex = indexName !== null && indexName !== "Nothing";
  const indexLatex = hasIndex && indexExpr ? serializer.serialize(indexExpr) : void 0;
  if (hasIndex && lowerExpr !== null && indexLatex)
    result.sub = `${indexLatex}=${serializer.serialize(lowerExpr)}`;
  else if (hasIndex && indexLatex) result.sub = indexLatex;
  else if (lowerExpr !== null) result.sub = serializer.serialize(lowerExpr);
  if (upperExpr !== null) result.sup = serializer.serialize(upperExpr);
  return result;
}
function serializeBigOp(command) {
  return (serializer, expr) => {
    const body = operand(expr, 1);
    if (!body) return command;
    const indexingSets = collectIndexingSets(expr);
    let decoratedCommand = command;
    if (indexingSets.length > 0) {
      const subs = [];
      const sups = [];
      for (const set of indexingSets) {
        const parts = serializeIndexingSet(serializer, set);
        if (parts.sub) subs.push(parts.sub);
        if (parts.sup) sups.push(parts.sup);
      }
      if (subs.length > 0)
        decoratedCommand = supsub("_", decoratedCommand, subs.join(", "));
      if (sups.length > 0)
        decoratedCommand = supsub("^", decoratedCommand, sups.join(", "));
    }
    return joinLatex([decoratedCommand, serializer.serialize(body)]);
  };
}
function parseLog(command, parser) {
  let sub3 = null;
  if (parser.match("_")) sub3 = parser.parseGroup() ?? parser.parseToken();
  const args = parser.parseArguments("implicit");
  if (args === null && sub3 === null) return [command];
  if (args === null) return [command, sub3];
  if (sub3 === null) return [command, ...args];
  if (sub3 === 10) return ["Log", args[0]];
  if (sub3 === 2) return ["Lb", ...args];
  return ["Log", args[0], sub3];
}
function unsign(expr) {
  let sign3 = 1;
  let newExpr = expr;
  do {
    expr = newExpr;
    const fnName = operator(expr);
    if (fnName === "Negate") {
      sign3 *= -1;
      newExpr = operand(expr, 1);
    } else if (fnName === "Multiply") {
      const [first, firstSign] = unsign(operand(expr, 1));
      if (firstSign < 0) {
        sign3 *= -1;
        if (first === 1) newExpr = ["Multiply", ...operands(expr).slice(1)];
        else newExpr = ["Multiply", first, ...operands(expr).slice(1)];
      }
    } else if (fnName === "Divide" || fnName === "Rational") {
      const [numer, numerSign] = unsign(operand(expr, 1));
      if (numerSign < 0) {
        sign3 *= -1;
        newExpr = [fnName, numer, operand(expr, 2)];
      }
    } else {
      const val = machineValue(expr);
      if (val !== null && val < 0) {
        sign3 *= -1;
        newExpr = -val;
      }
    }
  } while (newExpr !== expr);
  return [expr, sign3];
}

// src/compute-engine/latex-syntax/dictionary/definitions.ts
init_definitions_core();
init_definitions_relational_operators();

// src/compute-engine/latex-syntax/dictionary/definitions-linear-algebra.ts
init_utils2();
init_tokenizer();
init_definitions_core();
var DEFINITIONS_LINEAR_ALGEBRA = [
  // The first argument is the matrix data.
  // The second, optional, argument are the delimiters.
  // The third, optional, argument is the column specification.
  {
    name: "Matrix",
    serialize: (serializer, expr) => {
      const rows = operands(operand(expr, 1));
      return serializeTabular(
        serializer,
        rows,
        stringValue(operand(expr, 2)),
        stringValue(operand(expr, 3))
      );
    }
  },
  // Vector is a specialized collection to represent a column vector.
  {
    name: "Vector",
    serialize: (serializer, expr) => {
      const columns = operands(expr);
      return serializeTabular(
        serializer,
        columns.map((column) => ["List", column]),
        stringValue(operand(expr, 2)),
        stringValue(operand(expr, 3))
      );
    }
  },
  {
    kind: "environment",
    symbolTrigger: "pmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "()" }, { str: columns }];
      return [operator2, cells];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "bmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "[]" }, { str: columns }];
      return [operator2, cells, { str: "[]" }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "Bmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "{}" }, { str: columns }];
      return [operator2, cells, { str: "{}" }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "vmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "||" }, { str: columns }];
      return [operator2, cells, { str: "||" }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "Vmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "\u2016\u2016" }, { str: columns }];
      return [operator2, cells, { str: "\u2016\u2016" }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "smallmatrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: "()" }, { str: columns }];
      return [operator2, cells];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "array",
    parse: (parser) => {
      const columns = parseColumnFormat(parser, false);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: ".." }, { str: columns }];
      return [operator2, cells, { str: ".." }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "matrix",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: ".." }, { str: columns }];
      return [operator2, cells, { str: ".." }];
    }
  },
  {
    kind: "environment",
    symbolTrigger: "matrix*",
    parse: (parser) => {
      const columns = parseColumnFormat(parser);
      const [operator2, cells] = parseCells(parser);
      if (columns)
        return [operator2, cells, { str: ".." }, { str: columns }];
      return [operator2, cells, { str: ".." }];
    }
  },
  {
    name: "ConjugateTranspose",
    kind: "postfix",
    latexTrigger: ["^", "\\star"]
  },
  {
    kind: "postfix",
    latexTrigger: ["^", "\\H"],
    parse: "ConjugateTranspose"
  },
  {
    kind: "postfix",
    latexTrigger: ["^", "\\dagger"],
    parse: (_parser, lhs) => {
      return ["ConjugateTranspose", lhs];
    }
  },
  {
    kind: "postfix",
    latexTrigger: ["^", "\\ast"],
    parse: (_parser, lhs) => {
      return ["ConjugateTranspose", lhs];
    }
  },
  {
    kind: "postfix",
    latexTrigger: ["^", "\\top"],
    parse: (parser, lhs) => {
      return ["Transpose", lhs];
    }
  },
  {
    kind: "postfix",
    latexTrigger: ["^", "\\intercal"],
    parse: (parser, lhs) => {
      return ["Transpose", lhs];
    }
  },
  {
    name: "Transpose",
    kind: "postfix",
    latexTrigger: ["^", "T"]
  },
  {
    name: "PseudoInverse",
    kind: "postfix",
    latexTrigger: ["^", "+"]
  },
  {
    name: "Trace",
    kind: "function",
    symbolTrigger: "tr"
  },
  {
    name: "Determinant",
    kind: "function",
    symbolTrigger: "det"
  },
  // MatrixMultiply serializes as multiplication with \cdot
  {
    name: "MatrixMultiply",
    serialize: (serializer, expr) => {
      const lhs = serializer.serialize(operand(expr, 1));
      const rhs = serializer.serialize(operand(expr, 2));
      return `${lhs} \\cdot ${rhs}`;
    }
  }
];
function parseCells(parser) {
  const tabular = parser.parseTabular();
  if (!tabular) return ["", null];
  return [
    "Matrix",
    [
      "List",
      ...tabular.map((row) => ["List", ...row])
    ]
  ];
}
function parseColumnFormat(parser, optional = true) {
  const colFormat = parser.parseStringGroup(optional)?.trim();
  if (!colFormat) return "";
  let result = "";
  for (const c of colFormat) {
    if (c === "c") result += "=";
    if (c === "l") result += "<";
    if (c === "r") result += ">";
    if (c === "|") result += "|";
    if (c === ":") result += ":";
  }
  return result;
}
function serializeTabular(serializer, rows, delims, colSpec) {
  delims ??= "()";
  let [open, close] = ["", ""];
  if (typeof delims === "string" && delims.length === 2) [open, close] = delims;
  let columns = "";
  if (colSpec) {
    for (const c of colSpec) {
      if (c === "<") columns += "l";
      else if (c === ">") columns += "r";
      else if (c === "=") columns += "c";
      else if (c === "|") columns += "|";
      else if (c === ":") columns += ":";
    }
  }
  const serializedRows = [];
  for (const row of rows ?? []) {
    const cells = [];
    for (const cell of operands(row)) cells.push(serializer.serialize(cell));
    serializedRows.push(cells.join(" & "));
  }
  const tabular = serializedRows.join("\\\\\n");
  const optColumns = columns.length > 0 ? `[${columns}]` : "";
  if (open === "(" && close === ")")
    return joinLatex([
      "\\begin{pmatrix}",
      optColumns,
      tabular,
      "\\end{pmatrix}"
    ]);
  if (open === "[" && close === "]")
    return joinLatex([
      "\\begin{bmatrix}",
      optColumns,
      tabular,
      "\\end{bmatrix}"
    ]);
  if (open === "{" && close === "}")
    return joinLatex([
      "\\begin{Bmatrix}",
      optColumns,
      tabular,
      "\\end{Bmatrix}"
    ]);
  if (open === "|" && close === "|")
    return joinLatex([
      "\\begin{vmatrix}",
      optColumns,
      tabular,
      "\\end{vmatrix}"
    ]);
  if (open === "\u2016" && close === "\u2016")
    return joinLatex([
      "\\begin{Vmatrix}",
      optColumns,
      tabular,
      "\\end{Vmatrix}"
    ]);
  if (open === "{" && close === ".")
    return joinLatex(["\\begin{dcases}", optColumns, tabular, "\\end{dcases}"]);
  if (open === "." && close === "}")
    return joinLatex(["\\begin{rcases}", optColumns, tabular, "\\end{rcases}"]);
  if (columns || open !== "." || close !== ".") {
    return joinLatex([
      "\\left",
      DELIMITERS_SHORTHAND[open] ?? open,
      "\\begin{array}",
      `{${columns}}`,
      tabular,
      "\\end{array}",
      "\\right",
      DELIMITERS_SHORTHAND[close] ?? close
    ]);
  }
  return joinLatex(["\\begin{matrix}", tabular, "\\end{matrix}"]);
}

// src/compute-engine/latex-syntax/dictionary/definitions-logic.ts
init_utils2();
init_definitions_relational_operators();
var DEFINITIONS_LOGIC = [
  // Constants
  {
    name: "True",
    kind: "symbol",
    latexTrigger: ["\\top"]
    //  U+22A4
  },
  {
    kind: "symbol",
    latexTrigger: "\\mathrm{True}",
    parse: "True"
  },
  {
    kind: "symbol",
    latexTrigger: "\\operatorname{True}",
    parse: "True"
  },
  {
    kind: "symbol",
    latexTrigger: "\\mathsf{T}",
    parse: "True"
  },
  {
    name: "False",
    kind: "symbol",
    latexTrigger: ["\\bot"]
    //  U+22A5
  },
  {
    kind: "symbol",
    latexTrigger: "\\operatorname{False}",
    parse: "False"
  },
  {
    kind: "symbol",
    latexTrigger: "\\mathsf{F}",
    parse: "False"
  },
  // Operators
  // Logic operators have lower precedence than comparisons (245)
  // so that `x = 1 \lor x = 2` parses as `(x = 1) \lor (x = 2)`
  // See https://github.com/cortex-js/compute-engine/issues/243
  {
    name: "And",
    kind: "infix",
    latexTrigger: ["\\land"],
    precedence: 235
    // serialize: '\\land',
  },
  { kind: "infix", latexTrigger: ["\\wedge"], parse: "And", precedence: 235 },
  { kind: "infix", latexTrigger: "\\&", parse: "And", precedence: 235 },
  {
    kind: "infix",
    latexTrigger: "\\operatorname{and}",
    parse: "And",
    precedence: 235
  },
  {
    name: "Or",
    kind: "infix",
    latexTrigger: ["\\lor"],
    precedence: 230
  },
  { kind: "infix", latexTrigger: ["\\vee"], parse: "Or", precedence: 230 },
  { kind: "infix", latexTrigger: "\\parallel", parse: "Or", precedence: 230 },
  {
    kind: "infix",
    latexTrigger: "\\operatorname{or}",
    parse: "Or",
    precedence: 230
  },
  {
    name: "Xor",
    kind: "infix",
    latexTrigger: ["\\veebar"],
    precedence: 232
  },
  // Possible alt: \oplus  U+2295
  {
    name: "Not",
    kind: "prefix",
    latexTrigger: ["\\lnot"],
    precedence: 880
  },
  {
    kind: "prefix",
    latexTrigger: ["\\neg"],
    parse: "Not",
    precedence: 880
  },
  {
    name: "Nand",
    kind: "infix",
    latexTrigger: ["\\barwedge"],
    precedence: 232
    // serialize: '\\mid',
  },
  {
    name: "Nor",
    kind: "infix",
    latexTrigger: ["\u22BD"],
    // bar vee
    precedence: 232
    // serialize: '\\downarrow',
  },
  // Functions
  {
    kind: "function",
    symbolTrigger: "and",
    parse: "And"
  },
  {
    kind: "function",
    symbolTrigger: "or",
    parse: "Or"
  },
  {
    kind: "function",
    symbolTrigger: "not",
    parse: "Not"
  },
  // Relations
  {
    name: "Implies",
    kind: "infix",
    precedence: 220,
    associativity: "right",
    latexTrigger: ["\\implies"],
    serialize: "\\implies"
  },
  {
    latexTrigger: ["\\Rightarrow"],
    kind: "infix",
    precedence: 220,
    associativity: "right",
    parse: "Implies"
  },
  {
    latexTrigger: ["\\rightarrow"],
    kind: "infix",
    precedence: 220,
    associativity: "right",
    parse: "Implies"
  },
  {
    latexTrigger: ["\\Longrightarrow"],
    kind: "infix",
    precedence: 220,
    associativity: "right",
    parse: "Implies"
  },
  {
    latexTrigger: ["\\longrightarrow"],
    kind: "infix",
    precedence: 220,
    associativity: "right",
    parse: "Implies"
  },
  {
    name: "Equivalent",
    // MathML: identical to, Mathematica: Congruent
    latexTrigger: ["\\iff"],
    kind: "infix",
    associativity: "right",
    precedence: 219
  },
  {
    latexTrigger: ["\\Leftrightarrow"],
    kind: "infix",
    associativity: "right",
    precedence: 219,
    parse: "Equivalent"
  },
  {
    latexTrigger: ["\\leftrightarrow"],
    kind: "infix",
    associativity: "right",
    precedence: 219,
    parse: "Equivalent"
  },
  {
    latexTrigger: ["\\Longleftrightarrow"],
    kind: "infix",
    associativity: "right",
    precedence: 219,
    parse: "Equivalent"
  },
  {
    latexTrigger: ["\\longleftrightarrow"],
    kind: "infix",
    associativity: "right",
    precedence: 219,
    parse: "Equivalent"
  },
  {
    latexTrigger: ["\\equiv"],
    kind: "infix",
    associativity: "right",
    precedence: 219,
    parse: (parser, lhs, terminator) => {
      const rhs = parser.parseExpression({ ...terminator, minPrec: 219 });
      const index = parser.index;
      const modulus = parser.parseExpression({ ...terminator, minPrec: 219 });
      if (modulus !== null && operator(modulus) === "Mod")
        return ["Congruent", lhs, rhs, missingIfEmpty(operand(modulus, 1))];
      parser.index = index;
      return ["Equivalent", lhs, missingIfEmpty(rhs)];
    }
  },
  {
    name: "Proves",
    kind: "infix",
    latexTrigger: ["\\vdash"],
    precedence: 220,
    associativity: "right",
    serialize: "\\vdash"
  },
  {
    name: "Entails",
    kind: "infix",
    latexTrigger: ["\\vDash"],
    precedence: 220,
    associativity: "right",
    serialize: "\\vDash"
  },
  {
    name: "Satisfies",
    kind: "infix",
    latexTrigger: ["\\models"],
    precedence: 220,
    associativity: "right",
    serialize: "\\models"
  },
  // Quantifiers: for all, exists
  {
    name: "ForAll",
    kind: "prefix",
    latexTrigger: ["\\forall"],
    precedence: 200,
    // Has to be lower than COMPARISON_PRECEDENCE
    serialize: serializeQuantifier("\\forall"),
    parse: parseQuantifier("ForAll")
  },
  {
    name: "Exists",
    kind: "prefix",
    latexTrigger: ["\\exists"],
    precedence: 200,
    // Has to be lower than COMPARISON_PRECEDENCE,
    serialize: serializeQuantifier("\\exists"),
    parse: parseQuantifier("Exists")
  },
  {
    name: "ExistsUnique",
    kind: "prefix",
    latexTrigger: ["\\exists", "!"],
    precedence: 200,
    // Has to be lower than COMPARISON_PRECEDENCE,
    serialize: serializeQuantifier("\\exists!"),
    parse: parseQuantifier("ExistsUnique")
  },
  {
    name: "NotForAll",
    kind: "prefix",
    latexTrigger: ["\\lnot", "\\forall"],
    precedence: 200,
    // Has to be lower than COMPARISON_PRECEDENCE
    serialize: serializeQuantifier("\\lnot\\forall"),
    parse: parseQuantifier("NotForAll")
  },
  {
    name: "NotExists",
    kind: "prefix",
    latexTrigger: ["\\lnot", "\\exists"],
    precedence: 200,
    // Has to be lower than COMPARISON_PRECEDENCE,
    serialize: serializeQuantifier("\\lnot\\exists"),
    parse: parseQuantifier("NotExists")
  },
  {
    name: "KroneckerDelta",
    kind: "prefix",
    latexTrigger: ["\\delta", "_"],
    precedence: 200,
    serialize: (serializer, expr) => {
      const args = operands(expr);
      if (args.length === 0) return "\\delta";
      if (args.every((x) => symbol(x)))
        return `\\delta_{${args.map((arg) => serializer.serialize(arg)).join("")}}`;
      return `\\delta_{${args.map((arg) => serializer.serialize(arg)).join(", ")}}`;
    },
    parse: (parser) => {
      const group = parser.parseGroup();
      if (group === null) {
        const token = parser.parseToken();
        if (!token) return null;
        return ["KroneckerDelta", token];
      }
      const seq = getSequence(group);
      if (seq && seq.length <= 2) return ["KroneckerDelta", ...seq];
      if (operator(group) === "InvisibleOperator")
        return ["KroneckerDelta", ...operands(group)];
      if (group !== null) return ["KroneckerDelta", group];
      return null;
    }
  },
  // Iverson brackets. Also called the "indicator function"
  // Must have a single argument, a relational expression, i.e.
  // `[ a = b ]` or `[ x \leq 0 ]`
  // Otherwise, it gets rejected, it could be something else, like a list or
  // tuple.
  {
    name: "Boole",
    kind: "matchfix",
    openTrigger: "[",
    closeTrigger: "]",
    // serialize: (serializer: Serializer, expr: Expression) => {
    //   const args = ops(expr);
    //   return `[${serializer.serialize(arg)}]`;
    // },
    parse: (_parser, body) => {
      const h = operator(body);
      if (!h) return null;
      if (!DEFINITIONS_INEQUALITIES.some((x) => x.name === h)) return null;
      return ["Boole", body];
    }
  },
  {
    kind: "matchfix",
    openTrigger: "\\llbracket",
    closeTrigger: "\\rrbracket",
    parse: (_parser, body) => {
      const h = operator(body);
      if (!h) return null;
      if (!DEFINITIONS_INEQUALITIES.some((x) => x.name === h)) return null;
      return ["Boole", body];
    }
  },
  // Predicate application in First-Order Logic.
  // ["Predicate", "P", "x", "y"] serializes to "P(x, y)"
  {
    name: "Predicate",
    serialize: (serializer, expr) => {
      const args = operands(expr);
      if (args.length === 0) return "";
      const pred = args[0];
      const predStr = typeof pred === "string" ? pred : serializer.serialize(pred);
      if (args.length === 1) return predStr;
      const argStrs = args.slice(1).map((arg) => serializer.serialize(arg));
      return `${predStr}(${argStrs.join(", ")})`;
    }
  }
];
function serializeQuantifier(quantifierSymbol) {
  return (serializer, expr) => {
    const args = operands(expr);
    if (args.length === 0) return quantifierSymbol;
    if (args.length === 1)
      return `${quantifierSymbol} ${serializer.serialize(args[0])}`;
    const boundVar = serializer.serialize(args[0]);
    const body = serializer.serialize(args[1]);
    return `${quantifierSymbol} ${boundVar}, ${body}`;
  };
}
function tightBindingCondition(p, terminator) {
  return p.peek === "\\to" || p.peek === "\\rightarrow" || p.peek === "\\implies" || p.peek === "\\Rightarrow" || p.peek === "\\iff" || p.peek === "\\Leftrightarrow" || p.peek === "\\land" || p.peek === "\\wedge" || p.peek === "\\lor" || p.peek === "\\vee" || (terminator.condition?.(p) ?? false);
}
function parseQuantifier(kind) {
  return (parser, terminator) => {
    const index = parser.index;
    const useTightBinding = parser.options.quantifierScope !== "loose";
    const symbol2 = parser.parseSymbol(terminator);
    if (symbol2) {
      parser.skipSpace();
      if (parser.match(",") || parser.match("\\mid") || parser.match(".") || parser.match(":") || parser.match("\\colon")) {
        const bodyTerminator = useTightBinding ? {
          ...terminator,
          condition: (p) => tightBindingCondition(p, terminator)
        } : terminator;
        parser.enterQuantifierScope();
        const body2 = parser.parseExpression(bodyTerminator);
        parser.exitQuantifierScope();
        return [kind, symbol2, missingIfEmpty(body2)];
      }
      parser.enterQuantifierScope();
      const body = parser.parseEnclosure();
      parser.exitQuantifierScope();
      if (body) return [kind, symbol2, missingIfEmpty(body)];
    }
    parser.index = index;
    const condition = parser.parseExpression(terminator);
    if (condition === null) return null;
    parser.skipSpace();
    if (parser.matchAny([",", "\\mid", ":", "\\colon"])) {
      const bodyTerminator = useTightBinding ? {
        ...terminator,
        condition: (p) => tightBindingCondition(p, terminator)
      } : terminator;
      parser.enterQuantifierScope();
      const body = parser.parseExpression(bodyTerminator);
      parser.exitQuantifierScope();
      return [kind, condition, missingIfEmpty(body)];
    }
    if (parser.match("(")) {
      parser.enterQuantifierScope();
      const body = parser.parseExpression(terminator);
      parser.exitQuantifierScope();
      if (!parser.match(")")) return null;
      return [kind, condition, missingIfEmpty(body)];
    }
    return null;
  };
}

// src/compute-engine/latex-syntax/dictionary/definitions-other.ts
init_utils2();
init_tokenizer();
function parseSingleArg(cmd) {
  return (parser) => {
    const arg = parser.parseGroup();
    return arg === null ? [cmd] : [cmd, arg];
  };
}
var DEFINITIONS_OTHERS = [
  {
    name: "Overscript",
    latexTrigger: ["\\overset"],
    kind: "infix",
    precedence: 700
    // @todo: not in MathML
  },
  {
    name: "Underscript",
    latexTrigger: ["\\underset"],
    kind: "infix",
    precedence: 700
    // @todo: not in MathML
  },
  {
    name: "Increment",
    latexTrigger: ["+", "+"],
    kind: "postfix",
    precedence: 880,
    parse: (_parser, lhs) => {
      if (symbol(lhs) === null) return null;
      return ["Increment", lhs];
    }
  },
  {
    name: "Decrement",
    latexTrigger: ["-", "-"],
    kind: "postfix",
    precedence: 880,
    parse: (_parser, lhs) => {
      if (symbol(lhs) === null) return null;
      return ["Decrement", lhs];
    }
  },
  {
    name: "PreIncrement",
    latexTrigger: ["+", "+"],
    kind: "prefix",
    precedence: 880,
    parse: (parser, until) => {
      const rhs = parser.parseExpression(until);
      if (symbol(rhs) === null) return null;
      return ["PreIncrement", rhs];
    }
  },
  {
    name: "PreDecrement",
    latexTrigger: ["-", "-"],
    kind: "prefix",
    precedence: 880,
    parse: (parser, until) => {
      const rhs = parser.parseExpression(until);
      if (symbol(rhs) === null) return null;
      return ["PreDecrement", rhs];
    }
  },
  {
    name: "Ring",
    // Aka 'Composition', i.e. function composition
    latexTrigger: ["\\circ"],
    kind: "infix",
    precedence: 265
    // @todo: MathML is 950
    // @todo: check lhs and rhs are functions
  },
  {
    name: "StringJoin",
    // @todo From Mathematica...?
    latexTrigger: ["\\lt", "\\gt"],
    kind: "infix",
    precedence: 780
  },
  {
    name: "Starstar",
    latexTrigger: ["\\star", "\\star"],
    kind: "infix",
    precedence: 780
  },
  {
    // Partial derivative using a variation of the Euler notation: `_xf(x)`
    // (the Euler notation uses `D_1f(x)` where "1" is for the first variable
    // For the Leibniz notation see 'Divide' that handles `f/x`
    name: "PartialDerivative",
    // PartialDerivative(expr, {lists of vars}, degree)
    latexTrigger: ["\\partial"],
    kind: "prefix",
    parse: (parser) => {
      let done = false;
      let sup = "Nothing";
      let sub3 = "Nothing";
      while (!done) {
        parser.skipSpace();
        if (parser.match("_")) {
          sub3 = parser.parseGroup() ?? parser.parseToken();
        } else if (parser.match("^")) {
          sup = parser.parseGroup() ?? parser.parseToken();
        } else {
          done = true;
        }
      }
      const seq = getSequence(sub3);
      if (seq) sub3 = ["List", ...seq];
      if (sub3 === null || sup === null) return null;
      let rhs = parser.parseGroup() ?? "Nothing";
      if (!isEmptySequence(rhs)) {
        const args = parser.parseArguments() ?? ["Nothing"];
        rhs = [rhs, ...args];
      }
      return ["PartialDerivative", rhs, sub3, sup];
    },
    serialize: (serializer, expr) => {
      let result = "\\partial";
      const fn = operand(expr, 1);
      const vars = operand(expr, 2);
      const degree = operand(expr, 3);
      if (vars !== null && vars !== "Nothing") {
        if (operator(vars) === "List") {
          result += "_{" + serializer.serialize(["Sequence", ...operands(vars)]) + "}";
        } else {
          result += "_{" + serializer.serialize(vars) + "}";
        }
      }
      if (degree !== null && degree !== "Nothing")
        result += "^{" + serializer.serialize(degree) + "}";
      if (fn !== null && fn !== "Nothing") result += serializer.serialize(fn);
      return result;
    },
    precedence: 740
  },
  {
    name: "OverBar",
    latexTrigger: ["\\overline"],
    parse: parseSingleArg("OverBar")
  },
  {
    name: "UnderBar",
    latexTrigger: ["\\underline"],
    parse: parseSingleArg("UnderBar")
  },
  {
    name: "OverVector",
    latexTrigger: ["\\vec"],
    parse: parseSingleArg("OverVector")
  },
  {
    name: "OverTilde",
    latexTrigger: ["\\tilde"],
    parse: parseSingleArg("OverTilde")
  },
  {
    name: "OverHat",
    latexTrigger: ["\\hat"],
    parse: parseSingleArg("OverHat")
  },
  {
    name: "OverRightArrow",
    latexTrigger: ["\\overrightarrow"],
    parse: parseSingleArg("OverRightArrow")
  },
  {
    name: "OverLeftArrow",
    latexTrigger: ["\\overleftarrow"],
    parse: parseSingleArg("OverLeftArrow")
  },
  {
    name: "OverRightDoubleArrow",
    latexTrigger: ["\\Overrightarrow"],
    parse: parseSingleArg("OverRightDoubleArrow")
  },
  {
    name: "OverLeftHarpoon",
    latexTrigger: ["\\overleftharpoon"],
    parse: parseSingleArg("OverLeftHarpoon")
  },
  {
    name: "OverRightHarpoon",
    latexTrigger: ["\\overrightharpoon"],
    parse: parseSingleArg("OverRightHarpoon")
  },
  {
    name: "OverLeftRightArrow",
    latexTrigger: ["\\overleftrightarrow"],
    parse: parseSingleArg("OverLeftRightArrow")
  },
  {
    name: "OverBrace",
    latexTrigger: ["\\overbrace"],
    parse: parseSingleArg("OverBrace")
  },
  {
    name: "OverLineSegment",
    latexTrigger: ["\\overlinesegment"],
    parse: parseSingleArg("OverLineSegment")
  },
  {
    name: "OverGroup",
    latexTrigger: ["\\overgroup"],
    parse: parseSingleArg("OverGroup")
  },
  {
    latexTrigger: ["\\textcolor"],
    parse: (parser) => {
      const pos = parser.index;
      const color = parser.parseStringGroup();
      const body = parser.parseGroup();
      if (color !== null) {
        if (body !== null) return ["Annotated", body, { dict: { color } }];
        return "Nothing";
      }
      parser.index = pos;
      return "Nothing";
    }
  },
  {
    latexTrigger: ["\\displaystyle"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\textstyle"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\scriptstyle"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\scriptscriptstyle"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\tiny"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\scriptsize"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\footnotesize"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\small"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\normalsize"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\large"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\Large"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\LARGE"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\huge"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    latexTrigger: ["\\Huge"],
    parse: () => "Nothing"
    // @todo: parse as ['Annotated'...]
  },
  {
    name: "Annotated",
    serialize: (serializer, expr) => {
      let result = serializer.serialize(operand(expr, 1));
      const dict = dictionaryFromExpression(operand(expr, 2));
      if (dict === null || dict === void 0) return result;
      if (dict.dict.mathStyle === "normal")
        result = joinLatex(["{\\displaystyle", result, "}"]);
      else if (dict.dict.mathStyle === "compact")
        result = joinLatex(["{\\textstyle", result, "}"]);
      const v = dict.dict.size;
      if (v !== null && v >= 1 && v <= 10) {
        result = joinLatex([
          "{",
          {
            1: "\\tiny",
            2: "\\scriptsize",
            3: "\\footnotesize",
            4: "\\small",
            5: "\\normalsize",
            6: "\\large",
            7: "\\Large",
            8: "\\LARGE",
            9: "\\huge",
            10: "\\Huge"
          }[v],
          result,
          "}"
        ]);
      }
      return result;
    }
  },
  {
    latexTrigger: ["\\!"],
    parse: () => ["HorizontalSpacing", -3]
  },
  {
    latexTrigger: ["\\ "],
    parse: () => ["HorizontalSpacing", 6]
  },
  {
    latexTrigger: ["\\:"],
    parse: () => ["HorizontalSpacing", 4]
  },
  {
    latexTrigger: ["\\enskip"],
    parse: () => ["HorizontalSpacing", 9]
  },
  {
    latexTrigger: ["\\quad"],
    parse: () => ["HorizontalSpacing", 18]
  },
  {
    latexTrigger: ["\\qquad"],
    parse: () => ["HorizontalSpacing", 36]
  },
  {
    latexTrigger: ["\\,"],
    parse: () => ["HorizontalSpacing", 3]
  },
  {
    latexTrigger: ["\\;"],
    parse: () => ["HorizontalSpacing", 5]
  },
  {
    latexTrigger: ["\\enspace"],
    parse: () => ["HorizontalSpacing", 9]
  },
  {
    latexTrigger: ["\\phantom"],
    parse: (parser) => {
      parser.parseGroup();
      return "Nothing";
    }
  },
  {
    latexTrigger: ["\\vphantom"],
    parse: (parser) => {
      parser.parseGroup();
      return "Nothing";
    }
  },
  {
    latexTrigger: ["\\hphantom"],
    parse: (parser) => {
      parser.parseGroup();
      return "Nothing";
    }
  },
  {
    latexTrigger: ["\\placeholder"],
    parse: (parser) => {
      parser.parseOptionalGroup();
      return parser.parseGroup() ?? "Nothing";
    }
  },
  {
    latexTrigger: ["\\smash"],
    parse: (parser) => {
      parser.parseGroup();
      return "Nothing";
    }
  },
  {
    latexTrigger: ["\\strut"],
    parse: (parser) => "Nothing"
  },
  {
    latexTrigger: ["\\mathstrut"],
    parse: (parser) => "Nothing"
  },
  {
    name: "HorizontalSpacing",
    // The `HorizontalSpacing` function has two forms
    // `["HorizontalSpacing", number]` -> indicate a space of mu units
    // `["HorizontalSpacing", expr, 'op'|'bin'|rel]` -> indicate a spacing around and expression, i.e. `\mathbin{x}`, etc...
    serialize: (serializer, expr) => {
      if (operand(expr, 2) !== null) {
        return serializer.serialize(operand(expr, 1));
      }
      const v = machineValue(operand(expr, 1));
      if (v === null) return "";
      return {
        "-3": "\\!",
        6: "\\ ",
        3: "\\,",
        4: "\\:",
        5: "\\;",
        9: "\\enspace",
        18: "\\quad",
        36: "\\qquad"
      }[v] ?? "";
    }
  }
  // if (
  //   [
  //     '\\!',
  //     '\\:',
  //     '\\enskip',
  //     '\\quad',
  //     '\\,',
  //     '\\;',
  //     '\\enspace',
  //     '\\qquad',
  //     '\\selectfont',
  //   ].includes(token)
  // ) {
  //   return 'skip';
  // }
  // {
  //     name: '',
  //     trigger: '\\mathring',
  // },
  // {
  //     name: '',
  //     trigger: '\\check',
  // },
];

// src/compute-engine/latex-syntax/dictionary/definitions-trigonometry.ts
init_types();
function parseTrig(op) {
  return (parser, until) => {
    const trigCommands = {
      "\\arcsin": "Arcsin",
      "\\arccos": "Arccos",
      "\\arctan": "Arctan",
      "\\arctg": "Arctan",
      "\\arcctg": "Arccot",
      "\\arcsec": "Arcsec",
      // Non-standard
      "\\arccsc": "Arccsc",
      // Non-standard
      // Inverse hyperbolic functions use ISO 80000-2 standard names (ar- prefix)
      // We accept both ar- (standard) and arc- (common) spellings
      "\\arsinh": "Arsinh",
      "\\arcsinh": "Arsinh",
      "\\arcosh": "Arcosh",
      "\\arccosh": "Arcosh",
      "\\artanh": "Artanh",
      "\\arctanh": "Artanh",
      "\\arsech": "Arsech",
      "\\arcsech": "Arsech",
      "\\arcsch": "Arcsch",
      "\\arccsch": "Arcsch",
      "\\arcoth": "Arcoth",
      "\\arccoth": "Arcoth",
      "\\ch": "Cosh",
      // Non-standard
      "\\cos": "Cos",
      "\\cosh": "Cosh",
      "\\cosec": "Csc",
      // Non-standard
      "\\cot": "Cot",
      "\\cotg": "Cot",
      // Non-standard
      "\\ctg": "Cot",
      // Non-standard
      "\\csc": "Csc",
      "\\csch": "Csch",
      // Non-standard
      "\\coth": "Coth",
      "\\cth": "Coth",
      // Non-standard
      "\\sec": "Sec",
      "\\sech": "Sech",
      // Non-standard
      "\\sin": "Sin",
      "\\sinh": "Sinh",
      "\\sh": "Sinh",
      // Non-standard
      "\\tan": "Tan",
      "\\tg": "Tan",
      // Non-standard
      "\\tanh": "Tanh",
      "\\th": "Tanh"
      // Non-standard
    };
    const operator2 = trigCommands[op ?? ""] ?? op ?? "";
    if (parser.atTerminator(until)) return operator2;
    let fn = operator2;
    do {
      const pf = parser.parsePostfixOperator(fn, until);
      if (pf === null) break;
      fn = pf;
    } while (true);
    parser.skipSpace();
    let sup = null;
    if (parser.match("^")) sup = parser.parseGroup() ?? parser.parseToken();
    parser.skipSpace();
    const args = parser.parseArguments("implicit", {
      minPrec: MULTIPLICATION_PRECEDENCE,
      condition: (parser2) => trigCommands[parser2.peek] || (until?.condition?.(parser2) ?? false)
    });
    const appliedFn = args === null ? fn : typeof fn === "string" ? [fn, ...args] : ["Apply", fn, ...args];
    return sup === null ? appliedFn : ["Power", appliedFn, sup];
  };
}
var DEFINITIONS_TRIGONOMETRY = [
  {
    name: "Arcsin",
    latexTrigger: ["\\arcsin"],
    parse: parseTrig("Arcsin")
  },
  {
    name: "Arccos",
    latexTrigger: ["\\arccos"],
    parse: parseTrig("Arccos")
  },
  {
    name: "Arctan",
    latexTrigger: ["\\arctan"],
    parse: parseTrig("Arctan")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\arctg"],
    parse: parseTrig("Arctan")
  },
  {
    // Variant, symbol
    symbolTrigger: "arctg",
    parse: parseTrig("Arctan")
  },
  {
    name: "Arccot",
    symbolTrigger: "arcctg",
    parse: parseTrig("Arccot")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\arcctg"],
    parse: parseTrig("Arccot")
  },
  {
    name: "Arcoth",
    symbolTrigger: "arcoth",
    parse: parseTrig("Arcoth")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arccoth",
    parse: parseTrig("Arcoth")
  },
  {
    // Accept variant with LaTeX command
    latexTrigger: ["\\arcoth"],
    parse: parseTrig("Arcoth")
  },
  {
    // Accept variant with `arc-` prefix LaTeX command
    latexTrigger: ["\\arccoth"],
    parse: parseTrig("Arcoth")
  },
  {
    name: "Arcsec",
    symbolTrigger: "arcsec",
    parse: parseTrig("Arcsec")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\arcsec"],
    parse: parseTrig("Arcsec")
  },
  {
    name: "Arccsc",
    symbolTrigger: "arccsc",
    parse: parseTrig("Arccsc")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\arccsc"],
    parse: parseTrig("Arccsc")
  },
  {
    name: "Arsinh",
    symbolTrigger: "arsinh",
    parse: parseTrig("Arsinh")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arcsinh",
    parse: parseTrig("Arsinh")
  },
  {
    // LaTeX command with `ar-` prefix (ISO standard)
    latexTrigger: ["\\arsinh"],
    parse: parseTrig("Arsinh")
  },
  {
    // LaTeX command with `arc-` prefix (common variant)
    latexTrigger: ["\\arcsinh"],
    parse: parseTrig("Arsinh")
  },
  {
    name: "Arcosh",
    symbolTrigger: "arcosh",
    parse: parseTrig("Arcosh")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arccosh",
    parse: parseTrig("Arcosh")
  },
  {
    // LaTeX command with `ar-` prefix (ISO standard)
    latexTrigger: "\\arcosh",
    parse: parseTrig("Arcosh")
  },
  {
    // LaTeX command with `arc-` prefix (common variant)
    latexTrigger: "\\arccosh",
    parse: parseTrig("Arcosh")
  },
  {
    name: "Artanh",
    symbolTrigger: "artanh",
    parse: parseTrig("Artanh")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arctanh",
    parse: parseTrig("Artanh")
  },
  {
    // LaTeX command with `ar-` prefix (ISO standard)
    latexTrigger: "\\artanh",
    parse: parseTrig("Artanh")
  },
  {
    // LaTeX command with `arc-` prefix (common variant)
    latexTrigger: ["\\arctanh"],
    parse: parseTrig("Artanh")
  },
  {
    name: "Arsech",
    symbolTrigger: "arsech",
    parse: parseTrig("Arsech")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arcsech",
    parse: parseTrig("Arsech")
  },
  {
    // LaTeX command with `ar-` prefix (ISO standard)
    latexTrigger: ["\\arsech"],
    parse: parseTrig("Arsech")
  },
  {
    // LaTeX command with `arc-` prefix (common variant)
    latexTrigger: ["\\arcsech"],
    parse: parseTrig("Arsech")
  },
  {
    name: "Arcsch",
    symbolTrigger: "arcsch",
    parse: parseTrig("Arcsch")
  },
  {
    // Accept variant with `arc-` prefix
    symbolTrigger: "arccsch",
    parse: parseTrig("Arcsch")
  },
  {
    // LaTeX command with `ar-` prefix (ISO standard)
    latexTrigger: ["\\arcsch"],
    parse: parseTrig("Arcsch")
  },
  {
    // LaTeX command with `arc-` prefix (common variant)
    latexTrigger: ["\\arccsch"],
    parse: parseTrig("Arcsch")
  },
  {
    name: "Cosec",
    symbolTrigger: "cosec",
    parse: parseTrig("Cosec")
  },
  {
    // Variant with non-standard command
    latexTrigger: ["\\cosec"],
    parse: parseTrig("Cosec")
  },
  {
    name: "Cosh",
    latexTrigger: ["\\cosh"],
    parse: parseTrig("Cosh")
  },
  {
    // Rusian hyperbolic cosine
    latexTrigger: ["\\ch"],
    parse: parseTrig("Cosh")
  },
  {
    name: "Cot",
    latexTrigger: ["\\cot"],
    parse: parseTrig("Cot")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\cotg"],
    parse: parseTrig("Cot")
  },
  {
    // Rusian cotangent
    latexTrigger: ["\\ctg"],
    parse: parseTrig("Cot")
  },
  {
    name: "Csc",
    latexTrigger: ["\\csc"],
    parse: parseTrig("Csc")
  },
  {
    name: "Csch",
    latexTrigger: ["\\csch"],
    parse: parseTrig("Csch")
  },
  {
    name: "Coth",
    latexTrigger: ["\\coth"],
    parse: parseTrig("Coth")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\cth"],
    parse: parseTrig("Coth")
  },
  {
    // Variant
    symbolTrigger: "cth",
    parse: parseTrig("Coth")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\coth"],
    parse: parseTrig("Coth")
  },
  {
    name: "Sec",
    latexTrigger: ["\\sec"],
    parse: parseTrig("Sec")
  },
  {
    name: "Sech",
    symbolTrigger: "sech",
    parse: parseTrig("Sech")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\sech"],
    parse: parseTrig("Sech")
  },
  {
    name: "Sinh",
    latexTrigger: ["\\sinh"],
    parse: parseTrig("Sinh")
  },
  {
    // Russian variant
    latexTrigger: ["\\sh"],
    parse: parseTrig("Sinh")
  },
  {
    name: "Tan",
    latexTrigger: ["\\tan"],
    parse: parseTrig("Tan")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\tg"],
    parse: parseTrig("Tan")
  },
  {
    name: "Tanh",
    latexTrigger: ["\\tanh"],
    parse: parseTrig("Tanh")
  },
  {
    // Variant, non-standard command
    latexTrigger: ["\\th"],
    parse: parseTrig("Tanh")
  },
  {
    name: "Cos",
    latexTrigger: ["\\cos"],
    parse: parseTrig("Cos")
  },
  {
    name: "Sin",
    latexTrigger: ["\\sin"],
    parse: parseTrig("Sin")
  }
];

// src/compute-engine/latex-syntax/dictionary/definitions-sets.ts
init_utils2();
init_tokenizer();
init_types();
function parseIntervalBody(body, openLeft, openRight) {
  if (isEmptySequence(body)) return null;
  let elements;
  const h = operator(body);
  if (h === "Delimiter") {
    const delim = stringValue(operand(body, 2));
    if (delim !== "," && delim !== "(,)" && delim !== "[,]") return null;
    const inner = operand(body, 1);
    if (operator(inner) === "Sequence") {
      elements = [...operands(inner)];
    } else {
      elements = inner ? [inner] : [];
    }
  } else if (h === "Sequence") {
    elements = [...operands(body)];
  } else {
    return null;
  }
  if (elements.length !== 2) return null;
  const [lower, upper] = elements;
  const lowerExpr = openLeft ? ["Open", lower] : lower;
  const upperExpr = openRight ? ["Open", upper] : upper;
  return ["Interval", lowerExpr, upperExpr];
}
var DEFINITIONS_SETS = [
  //
  // Constants
  //
  { name: "AlgebraicNumbers", latexTrigger: "\\overline\\Q" },
  { latexTrigger: "\\bar\\Q", parse: "AlgebraicNumbers" },
  { name: "ComplexNumbers", latexTrigger: ["\\C"] },
  { latexTrigger: "\\mathbb{C}", parse: "ComplexNumbers" },
  { name: "ImaginaryNumbers", latexTrigger: ["\\imaginaryI", "\\R"] },
  { name: "EmptySet", latexTrigger: ["\\emptyset"] },
  { latexTrigger: ["\\varnothing"], parse: "EmptySet" },
  // Parsing only
  { name: "Integers", latexTrigger: ["\\Z"] },
  { latexTrigger: "\\mathbb{Z}", parse: "Integers" },
  { name: "RationalNumbers", latexTrigger: ["\\Q"] },
  { latexTrigger: "\\mathbb{Q}", parse: "RationalNumbers" },
  { name: "RealNumbers", latexTrigger: ["\\R"] },
  { latexTrigger: "\\mathbb{R}", parse: "RealNumbers" },
  { name: "TranscendentalNumbers", latexTrigger: "\\R-\\bar\\Q" },
  { latexTrigger: "\\R\\backslash\\bar\\Q", parse: "TranscendentalNumbers" },
  // Real numbers < 0
  { name: "NegativeNumbers", latexTrigger: "\\R_{<0}" },
  { latexTrigger: "\\R^-", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^{-}", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^-", parse: "NegativeNumbers" },
  { latexTrigger: "\\R_-", parse: "NegativeNumbers" },
  { latexTrigger: "\\R_{-}", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^{\\lt}", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^{<}", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^{\\lt0}", parse: "NegativeNumbers" },
  { latexTrigger: "\\R^{<0}", parse: "NegativeNumbers" },
  // Real numbers <= 0
  { name: "NonPositiveNumbers", latexTrigger: "\\R_{\\le0}" },
  { latexTrigger: "\\R^{\\leq0}", parse: "NonPositiveNumbers" },
  { latexTrigger: "\\R^{-0}", parse: "NonPositiveNumbers" },
  { latexTrigger: "\\R^{\\leq}", parse: "NonPositiveNumbers" },
  { latexTrigger: "\\R^{0-}", parse: "NonPositiveNumbers" },
  // Real numbers > 0
  { name: "PositiveNumbers", latexTrigger: "\\R_{>0}" },
  { latexTrigger: "\\R^+", parse: "PositiveNumbers" },
  { latexTrigger: "\\R^{+}", parse: "PositiveNumbers" },
  { latexTrigger: "\\R_+", parse: "PositiveNumbers" },
  { latexTrigger: "\\R_{+}", parse: "PositiveNumbers" },
  { latexTrigger: "\\R^{\\gt}", parse: "PositiveNumbers" },
  { latexTrigger: "\\R^{\\gt 0}", parse: "PositiveNumbers" },
  { latexTrigger: "\\R^{>}", parse: "PositiveNumbers" },
  { latexTrigger: "\\R^{>0}", parse: "PositiveNumbers" },
  // Real numbers >= 0
  { name: "NonNegativeNumbers", latexTrigger: "\\R_{\\geq0}" },
  { latexTrigger: "\\R^{0+}", parse: "NonNegativeNumbers" },
  { latexTrigger: "\\R^{\\geq}", parse: "NonNegativeNumbers" },
  // Extended Real numbers = \R \cup \{-\infty, +\infty\}
  { name: "ExtendedRealNumbers", latexTrigger: "\\overline\\R" },
  { latexTrigger: "\\bar\\R", parse: "ExtendedRealNumbers" },
  // Integers < 0
  { name: "NegativeIntegers", latexTrigger: "\\Z_{<0}" },
  { latexTrigger: "\\Z_{\\lt0}", parse: "NegativeIntegers" },
  { latexTrigger: "\\Z^-", parse: "NegativeIntegers" },
  { latexTrigger: "\\Z^{-}", parse: "NegativeIntegers" },
  { latexTrigger: "\\Z_-", parse: "NegativeIntegers" },
  { latexTrigger: "\\Z_{-}", parse: "NegativeIntegers" },
  { latexTrigger: "\\Z^{\\lt}", parse: "NegativeIntegers" },
  // Integers <= 0
  { name: "NonPositiveIntegers", latexTrigger: "\\Z_{\\le0}" },
  { latexTrigger: "\\Z_{\\leq0}", parse: "NonPositiveIntegers" },
  { latexTrigger: "\\Z_{<0}", parse: "NonPositiveIntegers" },
  // Integers >  0
  { name: "PositiveIntegers", latexTrigger: "\\N^*" },
  { latexTrigger: "\\Z_{>0}", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z_{\\gt0}", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z^{+}", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z_+", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z_{+}", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z^{\\gt}", parse: "PositiveIntegers" },
  { latexTrigger: "\\Z^{\\gt0}", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^+", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^{+}", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^*", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^{*}", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^\\star", parse: "PositiveIntegers" },
  { latexTrigger: "\\N^{\\star}", parse: "PositiveIntegers" },
  { latexTrigger: "\\N_1", parse: "PositiveIntegers" },
  { latexTrigger: "\\N_{1}", parse: "PositiveIntegers" },
  // https://mathvault.ca/hub/higher-math/math-symbols/algebra-symbols/
  // Integers >=  0
  // Note that 0 is included in $\N$, following the convention from
  // [ISO/IEC 80000](https://en.wikipedia.org/wiki/ISO_80000-2)
  { name: "NonNegativeIntegers", latexTrigger: ["\\N"] },
  { latexTrigger: "\\Z^{+0}", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\Z^{\\geq}", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\Z^{\\geq0}", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\Z^{0+}", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\mathbb{N}", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\N_0", parse: "NonNegativeIntegers" },
  { latexTrigger: "\\N_{0}", parse: "NonNegativeIntegers" },
  // Extended Integers = \Z \cup \{-\infty, +\infty\}
  { name: "ExtendedIntegers", latexTrigger: "\\overline\\Z" },
  { latexTrigger: "\\bar\\Z", parse: "ExtendedIntegers" },
  // Extended Rationals = \Q \cup \{-\infty, +\infty\}
  { name: "ExtendedRationalNumbers", latexTrigger: "\\overline\\Q" },
  { latexTrigger: "\\bar\\Q", parse: "ExtendedRationalNumbers" },
  // Extended Complex Numbers = \C \cup \{-\infty, +\infty\}
  { name: "ExtendedComplexNumbers", latexTrigger: "\\overline\\C" },
  { latexTrigger: "\\bar\\C", parse: "ExtendedComplexNumbers" },
  //
  // Set Expressions
  //
  // @todo: could also have a `CartesianPower` function with a number `rhs`
  // {
  //   name: 'CartesianProduct',
  //   latexTrigger: ['\\times'],
  //   kind: 'infix',
  //   associativity: 'right', // Caution: cartesian product is not associative
  //   precedence: 390, // Same as Multiply?
  //   parse: (parser, lhs, until) => {
  //     if (390 < until.minPrec) return null;
  //     // Since this is triggered on `\times` we have to be careful we only
  //     // accept arguments that are `Set`
  //     const ce = parser.computeEngine!;
  //     if (!ce || !ce.box(lhs).domain?.isCompatible('Sets')) return null;
  //     const index = parser.index;
  //     const rhs = parser.parseExpression({ ...until, minPrec: 390 });
  //     // If the rhs argument is not a set, bail
  //     if (rhs === null || ce.box(lhs).domain?.isCompatible('Sets') !== true) {
  //       parser.index = index;
  //       return null;
  //     }
  //     return ['CartesianProduct', lhs, rhs];
  //   },
  // },
  {
    latexTrigger: ["^", "\\complement"],
    kind: "postfix",
    parse: (_parser, lhs) => {
      return ["Complement", lhs];
    }
    // precedence: 240,
    // @todo: serialize for the multiple argument case
  },
  {
    name: "Complement",
    latexTrigger: ["^", "<{>", "\\complement", "<}>"],
    kind: "postfix"
    // precedence: 240,
    // @todo: serialize for the multiple argument case
  },
  {
    name: "Intersection",
    latexTrigger: ["\\cap"],
    kind: "infix",
    precedence: 350
  },
  {
    name: "Interval",
    serialize: serializeSet
  },
  //
  // Interval Parsing - Half-open intervals with mismatched brackets
  //
  // These matchfix entries handle interval notations where the opening and closing
  // delimiters differ, indicating open vs closed endpoints.
  //
  // [a, b) - Closed-open interval (American notation)
  {
    kind: "matchfix",
    openTrigger: ["["],
    closeTrigger: [")"],
    parse: (_parser, body) => parseIntervalBody(body, false, true)
  },
  {
    kind: "matchfix",
    openTrigger: ["\\lbrack"],
    closeTrigger: ["\\rparen"],
    parse: (_parser, body) => parseIntervalBody(body, false, true)
  },
  {
    kind: "matchfix",
    openTrigger: ["\\lbrack"],
    closeTrigger: [")"],
    parse: (_parser, body) => parseIntervalBody(body, false, true)
  },
  {
    kind: "matchfix",
    openTrigger: ["["],
    closeTrigger: ["\\rparen"],
    parse: (_parser, body) => parseIntervalBody(body, false, true)
  },
  // (a, b] - Open-closed interval (American notation)
  {
    kind: "matchfix",
    openTrigger: ["("],
    closeTrigger: ["]"],
    parse: (_parser, body) => parseIntervalBody(body, true, false)
  },
  {
    kind: "matchfix",
    openTrigger: ["\\lparen"],
    closeTrigger: ["\\rbrack"],
    parse: (_parser, body) => parseIntervalBody(body, true, false)
  },
  {
    kind: "matchfix",
    openTrigger: ["\\lparen"],
    closeTrigger: ["]"],
    parse: (_parser, body) => parseIntervalBody(body, true, false)
  },
  {
    kind: "matchfix",
    openTrigger: ["("],
    closeTrigger: ["\\rbrack"],
    parse: (_parser, body) => parseIntervalBody(body, true, false)
  },
  // ]a, b[ - Open interval (ISO/European reversed bracket notation)
  {
    kind: "matchfix",
    openTrigger: ["]"],
    closeTrigger: ["["],
    parse: (_parser, body) => parseIntervalBody(body, true, true)
  },
  {
    kind: "matchfix",
    openTrigger: ["\\rbrack"],
    closeTrigger: ["\\lbrack"],
    parse: (_parser, body) => parseIntervalBody(body, true, true)
  },
  // Note: ISO notation ]a, b] (open-closed) and [a, b[ (closed-open) are NOT
  // supported with plain brackets because they conflict with nested list parsing.
  // Use the American notation (a, b] and [a, b) instead, or use explicit
  // commands like \rbrack a, b \rbrack which are unambiguous.
  {
    name: "Multiple",
    // @todo: parse
    serialize: serializeSet
  },
  {
    name: "Union",
    latexTrigger: ["\\cup"],
    kind: "infix",
    precedence: 350
  },
  {
    name: "Set",
    kind: "matchfix",
    openTrigger: "{",
    closeTrigger: "}",
    // @todo: the set syntax can also include conditions...
    parse: (_parser, body) => {
      if (isEmptySequence(body)) return "EmptySet";
      if (operator(body) == "Delimiter" && stringValue(operand(body, 2)) === ",") {
        body = operand(body, 1);
      }
      if (operator(body) !== "Sequence") return ["Set", body];
      return ["Set", ...operands(body)];
    },
    serialize: (serializer, expr) => {
      return joinLatex([
        "\\lbrace",
        operands(expr).map((x) => serializer.serialize(x)).join(", "),
        "\\rbrace"
      ]);
    }
  },
  {
    name: "SetMinus",
    latexTrigger: ["\\setminus"],
    kind: "infix",
    precedence: 650
  },
  {
    name: "SymmetricDifference",
    latexTrigger: ["\\triangle"],
    // or \\ominus
    kind: "infix",
    // @todo: parser could check that lhs and rhs are sets
    precedence: COMPARISON_PRECEDENCE
  },
  // Predicates/Relations
  {
    latexTrigger: ["\\ni"],
    kind: "infix",
    associativity: "none",
    precedence: 160,
    // As per MathML, lower precedence
    parse: (parser, lhs, terminator) => {
      const rhs = parser.parseExpression(terminator);
      return rhs === null ? null : ["Element", rhs, lhs];
    }
  },
  {
    name: "Element",
    latexTrigger: ["\\in"],
    kind: "infix",
    precedence: 240
  },
  {
    name: "NotElement",
    latexTrigger: ["\\notin"],
    kind: "infix",
    precedence: 240
  },
  {
    name: "NotSubset",
    latexTrigger: ["\\nsubset"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    name: "NotSuperset",
    latexTrigger: ["\\nsupset"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    name: "NotSubsetNotEqual",
    latexTrigger: ["\\nsubseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    name: "NotSupersetNotEqual",
    latexTrigger: ["\\nsupseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    name: "SquareSubset",
    // MathML: square image of
    latexTrigger: ["\\sqsubset"],
    kind: "infix",
    associativity: "none",
    precedence: 265
  },
  {
    name: "SquareSubsetEqual",
    // MathML: square image of or equal to
    latexTrigger: ["\\sqsubseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 265
  },
  {
    name: "SquareSuperset",
    // MathML: square original of
    latexTrigger: ["\\sqsupset"],
    kind: "infix",
    associativity: "none",
    precedence: 265
  },
  {
    name: "SquareSupersetEqual",
    // MathML: square original of or equal
    latexTrigger: ["\\sqsupseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 265
  },
  {
    name: "Subset",
    latexTrigger: ["\\subset"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    latexTrigger: ["\\subsetneq"],
    kind: "infix",
    associativity: "none",
    precedence: 240,
    parse: "Subset"
  },
  {
    latexTrigger: ["\\varsubsetneqq"],
    kind: "infix",
    associativity: "none",
    precedence: 240,
    parse: "Subset"
  },
  {
    name: "SubsetEqual",
    latexTrigger: ["\\subseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    name: "Superset",
    latexTrigger: ["\\supset"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  },
  {
    latexTrigger: ["\\supsetneq"],
    kind: "infix",
    associativity: "none",
    precedence: 240,
    parse: "Superset"
  },
  {
    latexTrigger: ["\\varsupsetneq"],
    kind: "infix",
    associativity: "none",
    precedence: 240,
    parse: "Superset"
  },
  {
    name: "SupersetEqual",
    latexTrigger: ["\\supseteq"],
    kind: "infix",
    associativity: "none",
    precedence: 240
  }
];
function serializeSet(serializer, expr) {
  if (expr === null) return "";
  const h = operator(expr);
  if (!h) return "";
  if (h === "Set") {
    if (nops(expr) === 0) return "\\emptyset";
    if (nops(expr) === 2 && operator(operand(expr, 2)) === "Condition") {
      return joinLatex([
        "\\left\\lbrace",
        serializer.serialize(operand(expr, 1)),
        "\\middle\\mid",
        serializer.serialize(operand(expr, 2)),
        "\\right\\rbrace"
      ]);
    }
    return joinLatex([
      "\\left\\lbrace",
      ...operands(expr).map((x) => serializer.serialize(x) + " ,"),
      "\\right\\rbrace"
    ]);
  }
  if (h === "Multiple") {
  }
  if (h === "Range") {
    return joinLatex([
      "\\mathopen\\lbrack",
      serializer.serialize(operand(expr, 1)),
      ", ",
      serializer.serialize(operand(expr, 2)),
      "\\mathclose\\rbrack"
    ]);
  }
  if (h === "Interval") {
    let op1 = operand(expr, 1);
    let op2 = operand(expr, 2);
    let openLeft = false;
    let openRight = false;
    if (operator(op1) === "Open") {
      op1 = operand(op1, 1);
      openLeft = true;
    }
    if (operator(op2) === "Open") {
      op2 = operand(op2, 1);
      openRight = true;
    }
    return joinLatex([
      openLeft ? "\\lparen" : "\\lbrack",
      serializer.serialize(op1),
      ", ",
      serializer.serialize(op2),
      openRight ? "\\rparen" : "\\rbrack"
    ]);
  }
  const style = serializer.numericSetStyle(expr, serializer.level);
  if (style === "compact") {
  } else if (style === "interval") {
  } else if (style === "regular") {
  } else if (style === "set-builder") {
  }
  return "";
}

// src/compute-engine/latex-syntax/dictionary/definitions-calculus.ts
init_utils2();
function parseIntegral(command) {
  return (parser) => {
    let done = false;
    const subs = [];
    const sups = [];
    while (!done) {
      parser.skipVisualSpace();
      parser.match("\\limits");
      parser.skipSpace();
      let sup = null;
      let sub3 = null;
      while (!(sub3 !== null && sup !== null) && (parser.peek === "_" || parser.peek === "^")) {
        if (parser.match("_")) sub3 = parser.parseGroup() ?? parser.parseToken();
        else if (parser.match("^")) {
          sup = parser.parseGroup() ?? parser.parseToken();
        }
        parser.skipSpace();
      }
      if (isEmptySequence(sub3)) sub3 = null;
      if (isEmptySequence(sup)) sup = null;
      subs.push(sub3 ?? "Nothing");
      sups.push(sup ?? "Nothing");
      parser.skipVisualSpace();
      done = !parser.match(command);
    }
    let [fn, indexes] = parseIntegralBody(parser);
    if (fn && indexes.length === 0) {
      if (operator(fn) === "Add" || operator(fn) === "Subtract") {
        const newOp = [];
        const rest = [];
        for (const op of operands(fn)) {
          if (indexes) rest.push(op);
          else {
            let op2;
            [op2, indexes] = parseSubintegrand(op);
            newOp.push(op2 ?? op);
          }
        }
        if (indexes !== null && rest.length > 0) {
          return [
            "Add",
            makeIntegral(command, ["Add", ...newOp], {
              indexes,
              subs,
              sups
            }) ?? "Nothing",
            ...rest
          ];
        }
      } else if (operator(fn) === "Divide") {
        let altNumerator;
        [altNumerator, indexes] = parseSubintegrand(operand(fn, 1));
        if (altNumerator !== null && indexes !== null) {
          fn = ["Divide", altNumerator, operand(fn, 2)];
        }
      }
    }
    return makeIntegral(command, fn, { indexes, subs, sups });
  };
}
function makeIntegral(command, fn, limits) {
  if (!fn) return null;
  if (limits.sups.length === 0 && limits.subs.length === 0) {
    return [command, fn, ...limits.indexes];
  }
  const indexes = limits.indexes.length === 0 ? operator(fn) === "Function" ? operands(fn).slice(1) : [] : limits.indexes;
  const count = Math.max(
    limits.sups.length,
    limits.subs.length,
    indexes.length
  );
  if (indexes.length === 0) {
    for (let i = 0; i < count; i++) indexes.push("Nothing");
  } else if (indexes.length !== count) {
    for (let i = indexes.length; i < count; i++)
      indexes.push(["Error", "'missing'"]);
  }
  if (limits.subs.length !== count) {
    for (let i = limits.subs.length; i < count; i++)
      limits.subs.push("Nothing");
  }
  if (limits.sups.length !== count) {
    for (let i = limits.sups.length; i < count; i++)
      limits.sups.push("Nothing");
  }
  const tuples = indexes.map((idx, i) => {
    const sup = limits.sups[i];
    const sub3 = limits.subs[i];
    if (sub3 === "Nothing" && sup === "Nothing") return idx;
    return ["Tuple", idx, sub3, sup];
  });
  return [command, fn, ...tuples];
}
function parseIntegralBody(parser) {
  let found = false;
  const fn = parser.parseExpression({
    minPrec: 266,
    condition: () => {
      const start = parser.index;
      found = matchDifferentialOperator(parser);
      parser.index = start;
      return found;
    }
  });
  if (fn !== null && !found) return parseSubintegrand(fn);
  return [fn, parseIndexes(parser)];
}
function parseIndexes(parser) {
  const indexes = [];
  while (matchDifferentialOperator(parser)) {
    parser.skipVisualSpace();
    const index = symbol(parser.parseSymbol());
    if (index === null) return indexes;
    indexes.push(index);
  }
  return indexes;
}
function parseSubintegrand(expr) {
  const h = operator(expr);
  const op1 = operand(expr, 1);
  if (!op1) return [expr, []];
  if (h === "Sequence" && nops(expr) === 1) return parseSubintegrand(op1);
  if (h === "Multiply" || h === "InvisibleOperator") {
    const args = operands(expr);
    if (args) {
      const [rest, indexes] = parseFinalDiffOperators(args);
      if (rest.length > 0) return [[h, ...rest], indexes];
      return [null, indexes];
    }
  } else if (h === "Delimiter") {
    const [fn2, indexes] = parseSubintegrand(op1);
    if (indexes) {
      if (!fn2) {
        return [null, indexes];
      }
      return [
        ["Delimiter", ["Sequence", fn2], ...operands(expr).slice(1)],
        indexes
      ];
    }
  } else if (h === "Add") {
    const args = operands(expr);
    if (args.length > 0) {
      const [fn2, indexes] = parseSubintegrand(args[args.length - 1]);
      if (indexes.length > 0) {
        if (fn2) return [["Add", ...args.slice(0, -1), fn2], indexes];
        if (args.length > 2) return [["Add", ...args.slice(0, -1)], indexes];
        if (args.length > 2) return [args[0], indexes];
      }
    }
  } else if (h === "Negate") {
    const [fn2, indexes] = parseSubintegrand(op1);
    if (indexes.length > 0) return [fn2 ? ["Negate", fn2] : null, indexes];
  } else if (h === "Divide") {
    const [fn2, indexes] = parseSubintegrand(op1);
    if (indexes.length > 0)
      return [["Divide", fn2 ?? 1, operand(expr, 2)], indexes];
  } else {
    const args = operands(expr);
    if (args.length === 1) {
      const [arg2, indexes] = parseSubintegrand(args[0]);
      if (indexes.length > 0)
        return [[operator(expr), arg2], indexes];
    }
  }
  return [expr, []];
}
function serializeIntegral(command) {
  return (serializer, expr) => {
    if (!operand(expr, 1)) return command;
    let body = operand(expr, 1);
    let args = [];
    if (operator(body) === "BuiltInFunction") {
      args = ["x"];
      body = [operand(body, 1), "x"];
    } else if (operator(body) === "Function") {
      args = operands(body).slice(1);
      body = operand(body, 1);
    } else if (symbol(body)) {
      args = [];
    } else {
      args = [];
    }
    const limits = operands(expr).slice(1);
    const indexes = [];
    const prefix = limits.map((limit2, i) => {
      if (symbol(limit2) === "Nothing") {
        indexes.push(symbol(args[i]) ?? "Nothing");
        return "";
      }
      if (symbol(limit2)) {
        indexes.push(symbol(limit2) ?? "Nothing");
        return "";
      }
      const h = operator(limit2);
      if (h === "Tuple" || h === "Pair" || h === "Limits" || h === "Range") {
        if (nops(limit2) === 3) {
          const index = operand(limit2, 1);
          indexes.push(symbol(index) ?? "Nothing");
          let lower = operand(limit2, 2);
          let upper = operand(limit2, 3);
          if (symbol(lower) === "Nothing") lower = null;
          if (symbol(upper) === "Nothing") upper = null;
          if (lower !== null && upper !== null)
            return `_{${serializer.serialize(lower)}}^{${serializer.serialize(upper)}}`;
          if (lower !== null) return `_{${serializer.serialize(lower)}}`;
          if (upper !== null) return `^{${serializer.serialize(upper)}}`;
          return "";
        }
        return `_{${serializer.serialize(limit2)}}`;
      }
      if (nops(limit2) === 2) {
        if (symbol(operand(limit2, 1))) {
          indexes.push(symbol(operand(limit2, 1)) ?? "Nothing");
          const lower2 = operand(limit2, 2);
          if (symbol(lower2) === "Nothing") return "";
          return `_{${serializer.serialize(lower2)}}`;
        }
        indexes.push(symbol(args[i]) ?? "Nothing");
        let lower = operand(limit2, 1);
        let upper = operand(limit2, 2);
        if (symbol(lower) === "Nothing") lower = null;
        if (symbol(upper) === "Nothing") upper = null;
        if (lower !== null && upper !== null)
          return `_{${serializer.serialize(lower)}}^{${serializer.serialize(upper)}}`;
        if (lower !== null) return `_{${serializer.serialize(lower)}}`;
        if (upper !== null) return `^{${serializer.serialize(upper)}}`;
      } else {
        indexes.push(symbol(args[i]) ?? "Nothing");
      }
    });
    let suffix = indexes.filter((x) => symbol(x) !== "Nothing").map((arg) => `\\mathrm{d}${serializer.serialize(symbol(arg) ?? "x")}`);
    if (suffix.length > 0) suffix = ["\\,", ...suffix];
    if (prefix.length === 0)
      return `${command}\\,${serializer.serialize(body)}\\!${suffix.join(" ")}`;
    return prefix.reverse().map((x) => `${command}${x}`).join("") + "\\!" + serializer.serialize(body) + suffix.join(" ");
  };
}
var DEFINITIONS_CALCULUS = [
  {
    kind: "expression",
    name: "Integrate",
    latexTrigger: ["\\int"],
    parse: parseIntegral("Integrate"),
    serialize: serializeIntegral("\\int")
  },
  {
    kind: "expression",
    latexTrigger: ["\\iint"],
    parse: parseIntegral("Integrate")
  },
  {
    kind: "expression",
    latexTrigger: ["\\iiint"],
    parse: parseIntegral("Integrate")
  },
  {
    kind: "expression",
    name: "CircularIntegrate",
    latexTrigger: ["\\oint"],
    parse: parseIntegral("CircularIntegrate"),
    serialize: serializeIntegral("\\oint")
  },
  {
    kind: "expression",
    latexTrigger: ["\\oiint"],
    parse: parseIntegral("CircularIntegrate")
  },
  {
    kind: "expression",
    latexTrigger: ["\\oiiint"],
    parse: parseIntegral("CircularIntegrate")
  }
];
function matchDifferentialOperator(parser) {
  const start = parser.index;
  while (parser.match("\\cdot") || parser.skipVisualSpace()) {
  }
  if (parser.matchAll(["\\mathrm", "<{>", "d", "<}>"]) || parser.matchAll(["\\operatorname", "<{>", "d", "<}>"]) || parser.match("d") || parser.match("\\differentialD")) {
    return true;
  }
  parser.index = start;
  return false;
}
function parseFinalDiffOperators(xs) {
  let rest = [...xs];
  const indexes = [];
  while (rest.length > 0) {
    let index;
    [rest, index] = parseFinalDiffOperator(rest);
    if (!index) break;
    indexes.push(index);
  }
  return [rest, indexes];
}
function parseFinalDiffOperator(expr) {
  if (expr.length < 2) return [expr, ""];
  const op = expr[expr.length - 2];
  if (op === "d" || op === "d_upright") {
    const index = symbol(expr[expr.length - 1]);
    if (index) return [expr.slice(0, -2), index];
  }
  return [expr, ""];
}

// src/compute-engine/latex-syntax/dictionary/definitions.ts
init_definitions_symbols();

// src/compute-engine/latex-syntax/dictionary/definitions-complex.ts
var DEFINITIONS_COMPLEX = [
  {
    name: "Real",
    kind: "function",
    latexTrigger: ["\\Re"]
  },
  {
    name: "Imaginary",
    kind: "function",
    latexTrigger: ["\\Im"]
  },
  {
    name: "Argument",
    kind: "function",
    latexTrigger: ["\\arg"]
  },
  {
    name: "Conjugate",
    latexTrigger: ["^", "\\star"],
    kind: "postfix"
  }
];

// src/compute-engine/latex-syntax/dictionary/definitions-statistics.ts
init_utils2();
var DEFINITIONS_STATISTICS = [
  {
    name: "Mean",
    kind: "function",
    symbolTrigger: "mean"
  },
  {
    name: "Median",
    kind: "function",
    symbolTrigger: "median"
  },
  {
    name: "StandarDeviation",
    kind: "function",
    symbolTrigger: "stddev"
  },
  {
    latexTrigger: ["\\bar"],
    kind: "expression",
    parse: (parser, _until) => {
      const expr = parser.parseGroup() ?? parser.parseToken();
      if (!expr || !symbol(expr)) return null;
      return ["Mean", expr];
    }
  }
];

// src/compute-engine/latex-syntax/dictionary/definitions.ts
var DELIMITER_SHORTHAND = {
  "(": ["\\lparen", "("],
  ")": ["\\rparen", ")"],
  "[": ["\\lbrack", "\\[", "["],
  "]": ["\\rbrack", "\\]", "]"],
  "<": ["<", "\\langle"],
  ">": [">", "\\rangle"],
  "{": ["\\{", "\\lbrace"],
  "}": ["\\}", "\\rbrace"],
  ":": [":", "\\colon"],
  "|": ["|", "\\|", "\\lvert", "\\rvert"],
  "||": ["||", "\\Vert", "\\lVert", "\\rVert"]
};
function isIndexedMatchfixEntry(entry) {
  return "kind" in entry && entry.kind === "matchfix";
}
var DEFAULT_DELIMITER = {
  "(": "(",
  ")": ")",
  "[": "\\lbrack",
  "]": "\\rbrack",
  "{": "\\lbrace",
  "}": "\\rbrace",
  "<": "\\langle",
  ">": "\\rangle",
  "|": "\\vert",
  "||": "\\Vert",
  "\\lceil": "\\lceil",
  "\\lfloor": "\\lfloor",
  "\\rceil": "\\rceil",
  "\\rfloor": "\\rfloor"
};
function addEntry(result, entry, onError) {
  const indexedEntry = makeIndexedEntry(entry, onError);
  if (indexedEntry === null) return;
  const kind = "kind" in entry ? entry.kind : "expression";
  const latexTrigger = indexedEntry.latexTrigger;
  if (typeof latexTrigger === "string")
    result.lookahead = Math.max(result.lookahead, countTokens(latexTrigger));
  const tokensTrigger = tokenize(latexTrigger ?? "");
  if (tokensTrigger.length === 2 && /[_^]/.test(tokensTrigger[0]) && tokensTrigger[1] !== "<{>" && kind !== "function" && kind !== "environment" && kind !== "matchfix") {
    let parse3 = entry.parse;
    if (!parse3 && entry.name) {
      if (kind === "postfix" || kind === "prefix")
        parse3 = (_parser, expr) => [entry.name, expr];
      else parse3 = entry.name;
    }
    addEntry(
      result,
      {
        ...entry,
        kind,
        name: void 0,
        serialize: void 0,
        parse: parse3,
        latexTrigger: [tokensTrigger[0], "<{>", tokensTrigger[1], "<}>"]
      },
      onError
    );
  }
  result.defs.push(indexedEntry);
  if (isIndexedMatchfixEntry(indexedEntry)) {
    const openTrigger = indexedEntry.openTrigger;
    const openTokens = [];
    if (typeof openTrigger === "string") {
      const variants = DELIMITER_SHORTHAND[openTrigger];
      if (variants) {
        openTokens.push(...variants);
      } else {
        openTokens.push(openTrigger);
      }
      if (openTrigger === "||") {
        openTokens.push("|");
      }
    } else if (Array.isArray(openTrigger) && openTrigger.length > 0) {
      openTokens.push(openTrigger[0]);
    }
    for (const token of openTokens) {
      const existing = result.matchfixByOpen.get(token);
      if (existing) {
        existing.unshift(indexedEntry);
      } else {
        result.matchfixByOpen.set(token, [indexedEntry]);
      }
    }
  }
  if (indexedEntry.latexTrigger && indexedEntry.latexTrigger !== "") {
    const trigger = indexedEntry.latexTrigger;
    let index;
    switch (indexedEntry.kind) {
      case "infix":
        index = result.infixByTrigger;
        break;
      case "prefix":
        index = result.prefixByTrigger;
        break;
      case "postfix":
        index = result.postfixByTrigger;
        break;
      case "function":
        index = result.functionByTrigger;
        break;
      case "symbol":
        index = result.symbolByTrigger;
        break;
      case "expression":
        index = result.expressionByTrigger;
        break;
    }
    if (index) {
      const existing = index.get(trigger);
      if (existing) {
        existing.unshift(indexedEntry);
      } else {
        index.set(trigger, [indexedEntry]);
      }
    }
  }
  if (indexedEntry.name !== void 0) {
    if (result.ids.has(indexedEntry.name)) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          indexedEntry.name,
          "Duplicate definition. The name (MathJSON symbol) must be unique, but triggers can be shared by multiple definitions."
        ]
      });
    }
    result.ids.set(indexedEntry.name, indexedEntry);
  }
}
function indexLatexDictionary(dic, onError) {
  const result = {
    lookahead: 1,
    ids: /* @__PURE__ */ new Map(),
    defs: [],
    matchfixByOpen: /* @__PURE__ */ new Map(),
    infixByTrigger: /* @__PURE__ */ new Map(),
    prefixByTrigger: /* @__PURE__ */ new Map(),
    postfixByTrigger: /* @__PURE__ */ new Map(),
    functionByTrigger: /* @__PURE__ */ new Map(),
    symbolByTrigger: /* @__PURE__ */ new Map(),
    expressionByTrigger: /* @__PURE__ */ new Map()
  };
  for (const entry of dic)
    addEntry(result, entry, onError);
  const COMPLEMENTARY_PAIRS = {
    "(": [")", "\\rparen"],
    "\\lparen": [")", "\\rparen"],
    "[": ["]", "\\rbrack", "\\]"],
    "\\lbrack": ["]", "\\rbrack", "\\]"],
    "\\[": ["]", "\\rbrack", "\\]"],
    "{": ["}", "\\rbrace"],
    "\\lbrace": ["}", "\\rbrace"],
    "\\{": ["}", "\\rbrace"],
    "<": [">", "\\rangle"],
    "\\langle": [">", "\\rangle"],
    "|": ["|", "\\|", "\\rvert", "\\lvert"],
    "\\|": ["|", "\\|", "\\rvert", "\\lvert"],
    "\\lvert": ["|", "\\|", "\\rvert", "\\lvert"],
    "||": ["||", "\\Vert", "\\lVert", "\\rVert"],
    "\\Vert": ["||", "\\Vert", "\\lVert", "\\rVert"],
    "\\lVert": ["||", "\\Vert", "\\lVert", "\\rVert"]
  };
  for (const [token, defs] of result.matchfixByOpen.entries()) {
    result.matchfixByOpen.set(
      token,
      defs.sort((a, b) => {
        const getOpenToken = (trigger) => typeof trigger === "string" ? trigger : trigger[0] || "";
        const getCloseToken = (trigger) => typeof trigger === "string" ? trigger : trigger[0] || "";
        const aOpen = getOpenToken(a.openTrigger);
        const aClose = getCloseToken(a.closeTrigger);
        const aIsStandard = COMPLEMENTARY_PAIRS[aOpen]?.includes(aClose) ?? false;
        const bOpen = getOpenToken(b.openTrigger);
        const bClose = getCloseToken(b.closeTrigger);
        const bIsStandard = COMPLEMENTARY_PAIRS[bOpen]?.includes(bClose) ?? false;
        if (aIsStandard && !bIsStandard) return -1;
        if (!aIsStandard && bIsStandard) return 1;
        return 0;
      })
    );
  }
  return result;
}
function makeIndexedEntry(entry, onError) {
  if (!isValidEntry(entry, onError)) return null;
  const result = {
    kind: "kind" in entry ? entry.kind : "expression"
  };
  let tokensTrigger = null;
  if ("latexTrigger" in entry) {
    if (typeof entry.latexTrigger === "string")
      tokensTrigger = tokenize(entry.latexTrigger);
    else tokensTrigger = entry.latexTrigger;
  }
  let idTrigger = null;
  if ("symbolTrigger" in entry) {
    idTrigger = entry.symbolTrigger;
  }
  if (tokensTrigger !== null)
    result.latexTrigger = tokensToString(tokensTrigger);
  if (idTrigger !== null) result.symbolTrigger = idTrigger;
  if (entry.name) {
    result.name = entry.name;
    result.serialize = makeSerializeHandler(entry, tokensTrigger, idTrigger);
  }
  if (result.kind === "matchfix" && isMatchfixEntry(entry)) {
    result.openTrigger = entry.openTrigger;
    result.closeTrigger = entry.closeTrigger;
  }
  if (result.kind === "symbol" && isSymbolEntry(entry)) {
    result.precedence = entry.precedence ?? 1e4;
  }
  if (result.kind === "expression" && isExpressionEntry(entry)) {
    result.precedence = entry.precedence ?? 1e4;
  }
  if ((result.kind === "prefix" || result.kind === "postfix") && (isPrefixEntry(entry) || isPostfixEntry(entry))) {
    if (tokensTrigger && (tokensTrigger[0] === "^" || tokensTrigger[0] === "_")) {
      result.precedence = 720;
      console.assert(
        entry.precedence === void 0,
        "'precedence' is fixed and cannot be modified with ^ and _ triggers"
      );
    } else result.precedence = entry.precedence ?? 1e4;
  }
  if (result.kind === "infix" && isInfixEntry(entry)) {
    console.assert(
      !tokensTrigger || tokensTrigger[0] !== "^" && tokensTrigger[0] !== "_" || !entry.associativity || entry.associativity === "none"
    );
    result.associativity = entry.associativity ?? "none";
    result.precedence = entry.precedence ?? 1e4;
  }
  const parse3 = makeParseHandler(entry, tokensTrigger, idTrigger);
  if (parse3) result.parse = parse3;
  return result;
}
function makeSerializeHandler(entry, latexTrigger, idTrigger) {
  if (typeof entry.serialize === "function") return entry.serialize;
  const kind = entry["kind"] ?? "expression";
  if (kind === "environment") {
    const envName = entry["symbolTrigger"] ?? entry.name ?? "unknown";
    return (serializer, expr) => joinLatex([
      `\\begin{${envName}}`,
      serializer.serialize(operand(expr, 1)),
      `\\end{${envName}}`
    ]);
  }
  if (isMatchfixEntry(entry)) {
    const openDelim = typeof entry.openTrigger === "string" ? DEFAULT_DELIMITER[entry.openTrigger] : tokensToString(entry.openTrigger);
    const closeDelim = typeof entry.closeTrigger === "string" ? DEFAULT_DELIMITER[entry.closeTrigger] : tokensToString(entry.closeTrigger);
    return (serializer, expr) => joinLatex([
      openDelim,
      serializer.serialize(operand(expr, 1)),
      closeDelim
    ]);
  }
  let latex = entry.serialize;
  if (latex === void 0 && latexTrigger) latex = tokensToString(latexTrigger);
  if (latex) {
    const prec2 = entry["precedence"] ?? 1e4;
    if (kind === "postfix")
      return (serializer, expr) => joinLatex([serializer.wrap(operand(expr, 1), prec2), latex]);
    if (kind === "prefix")
      return (serializer, expr) => joinLatex([latex, serializer.wrap(operand(expr, 1), prec2)]);
    if (kind === "infix") {
      return (serializer, expr) => {
        const n = nops(expr);
        if (n === 0) return "";
        const prec3 = entry["precedence"] ?? 1e4;
        return joinLatex(
          operands(expr).flatMap((val, i) => {
            const arg = serializer.wrap(val, prec3 + 1);
            return i < n - 1 ? [arg, latex] : [arg];
          })
        );
      };
    }
    return (serializer, expr) => operator(expr) ? joinLatex([latex, serializer.wrapArguments(expr)]) : latex;
  }
  const id = idTrigger ?? entry.name ?? "unknown";
  const prec = entry["precedence"] ?? 1e4;
  if (kind === "postfix")
    return (serializer, expr) => joinLatex([
      serializer.wrap(operand(expr, 1), prec),
      serializer.serializeSymbol(id)
    ]);
  if (kind === "prefix")
    return (serializer, expr) => joinLatex([
      serializer.serializeSymbol(id),
      serializer.wrap(operand(expr, 1), prec)
    ]);
  if (kind === "infix")
    return (serializer, expr) => joinLatex([
      serializer.wrap(operand(expr, 1), prec + 1),
      serializer.serializeSymbol(id),
      serializer.wrap(operand(expr, 2), prec + 1)
    ]);
  return (serializer, expr) => operator(expr) ? joinLatex([
    serializer.serializeSymbol(id),
    serializer.wrapArguments(expr)
  ]) : serializer.serializeSymbol(id);
}
function makeParseHandler(entry, latexTrigger, idTrigger) {
  if ("parse" in entry && typeof entry.parse === "function") return entry.parse;
  const kind = ("kind" in entry ? entry.kind : "expression") ?? "expression";
  if (kind === "environment") {
    const envName = entry.parse ?? entry.name ?? idTrigger;
    if (envName)
      return (parser, _until) => {
        const array = parser.parseTabular();
        if (array === null) return null;
        return [envName, ["List", array.map((row) => ["List", ...row])]];
      };
  }
  if (kind === "function") {
    const fnName = entry.parse ?? entry.name ?? idTrigger;
    if (fnName)
      return (parser, until) => {
        const args = parser.parseArguments("enclosure", until);
        return args === null ? fnName : [fnName, ...args];
      };
  }
  if (kind === "symbol") {
    const symName = entry.parse ?? entry.name ?? idTrigger;
    if (symName) return (_parser, _terminator) => symName;
  }
  if (kind === "prefix") {
    const h = entry.parse ?? entry.name ?? idTrigger;
    if (h) {
      const prec = entry["precedence"] ?? 1e4;
      return (parser, until) => {
        const rhs = parser.parseExpression({
          ...until ?? [],
          minPrec: prec
        });
        return rhs === null ? null : [h, rhs];
      };
    }
  }
  if (kind === "postfix") {
    const h = entry.parse ?? entry.name;
    if (h) return (_parser, lhs) => lhs === null ? null : [h, lhs];
  }
  if (kind === "infix") {
    if (/[_^]/.test(latexTrigger?.[0] ?? "")) {
      const h2 = entry.name ?? entry.parse;
      return (_parser, arg) => [
        h2,
        missingIfEmpty(operand(arg, 1)),
        missingIfEmpty(operand(arg, 2))
      ];
    }
    const h = entry.parse ?? entry.name ?? idTrigger;
    if (h) {
      const prec = entry["precedence"] ?? 1e4;
      const associativity = entry["associativity"] ?? "none";
      if (associativity === "none") {
        return (parser, lhs, until) => {
          if (lhs === null) return null;
          const rhs = missingIfEmpty(
            parser.parseExpression({ ...until, minPrec: prec })
          );
          return [h, lhs, rhs];
        };
      }
      if (associativity === "left") {
        return (parser, lhs, until) => {
          if (lhs === null) return null;
          const rhs = missingIfEmpty(
            parser.parseExpression({ ...until, minPrec: prec + 1 })
          );
          if (typeof h !== "string") return [h, lhs, rhs];
          return [h, lhs, rhs];
        };
      }
      if (associativity === "right") {
        return (parser, lhs, until) => {
          if (lhs === null) return null;
          const rhs = missingIfEmpty(
            parser.parseExpression({ ...until, minPrec: prec })
          );
          if (typeof h !== "string") return [h, lhs, rhs];
          return [h, lhs, rhs];
        };
      }
      return (parser, lhs, until) => {
        if (lhs === null) return null;
        const rhs = missingIfEmpty(
          parser.parseExpression({ ...until, minPrec: prec })
        );
        if (typeof h !== "string") return [h, lhs, rhs];
        return foldAssociativeOperator(h, lhs, rhs);
      };
    }
  }
  if (kind === "matchfix") {
    const h = entry.parse ?? entry.name;
    if (h)
      return (_parser, body) => {
        if (isEmptySequence(body)) return null;
        return [h, body];
      };
  }
  if (kind === "expression") {
    const parseResult = entry.parse ?? entry.name ?? idTrigger;
    if (parseResult) return () => parseResult;
  }
  if ("parse" in entry) {
    const parseResult = entry.parse;
    return () => parseResult;
  }
  return void 0;
}
function isValidEntry(entry, onError) {
  let subject = entry.name ?? entry["latexTrigger"] ?? entry["symbolTrigger"] ?? entry["openTrigger"];
  if (!subject) {
    try {
      subject = JSON.stringify(entry);
    } catch (e) {
      subject = "???";
    }
  }
  if (Array.isArray(subject)) subject = tokensToString(subject);
  if ("trigger" in entry) {
    onError({
      severity: "warning",
      message: [
        "invalid-dictionary-entry",
        subject,
        `The 'trigger' property is deprecated. Use 'latexTrigger' or 'symbolTrigger' instead`
      ]
    });
  }
  if ("kind" in entry && ![
    "expression",
    "symbol",
    "function",
    "infix",
    "postfix",
    "prefix",
    "matchfix",
    "environment"
  ].includes(entry.kind)) {
    onError({
      severity: "warning",
      message: [
        "invalid-dictionary-entry",
        subject,
        `The 'kind' property must be one of 'expression', 'symbol', 'function', 'infix', 'postfix', 'prefix', 'matchfix', 'environment'`
      ]
    });
  }
  if (entry.serialize !== void 0 && !entry.name) {
    onError({
      severity: "warning",
      message: [
        "invalid-dictionary-entry",
        subject,
        `A 'name' property must be provided if a 'serialize' handler is provided`
      ]
    });
    return false;
  }
  if ("symbolTrigger" in entry && (!("kind" in entry) || entry.kind !== "environment")) {
    if (typeof entry.symbolTrigger !== "string" || !isValidSymbol(entry.symbolTrigger)) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          `The 'symbolTrigger' property must be a valid symbol`
        ]
      });
    }
  }
  if ("name" in entry) {
    if (typeof entry.name !== "string") {
      if (entry.name !== void 0)
        onError({
          severity: "warning",
          message: [
            "invalid-dictionary-entry",
            subject,
            `The 'name' property must be a string`
          ]
        });
    } else if (!isValidSymbol(entry.name)) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          entry.name,
          `The 'name' property must be a valid symbol`
        ]
      });
    }
  }
  if (isMatchfixEntry(entry)) {
    if ("latexTrigger" in entry || "symbolTrigger" in isPrefixEntry) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          `'matchfix' operators use a 'openTrigger' and 'closeTrigger' instead of a 'latexTrigger' or 'symbolTrigger'. `
        ]
      });
      return false;
    }
    if (!entry.openTrigger || !entry.closeTrigger) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          "Expected `openTrigger` and a `closeTrigger` for matchfix operator"
        ]
      });
      return false;
    }
    if (typeof entry.openTrigger !== typeof entry.closeTrigger) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          "Expected `openTrigger` and `closeTrigger` to both be strings or array of LatexToken"
        ]
      });
      return false;
    }
  }
  if (isInfixEntry(entry) || isPostfixEntry(entry) || isPrefixEntry(entry)) {
    if (Array.isArray(entry.latexTrigger) && (entry.latexTrigger[0] === "_" || entry.latexTrigger[0] === "^") || typeof entry.latexTrigger === "string" && (entry.latexTrigger.startsWith("^") || entry.latexTrigger.startsWith("_"))) {
      if (entry.precedence !== void 0 || entry["associativity"] !== void 0) {
        onError({
          severity: "warning",
          message: [
            "invalid-dictionary-entry",
            subject,
            `Unexpected "precedence" or "associativity" for superscript/subscript operator`
          ]
        });
        return false;
      }
    } else if (entry.precedence === void 0) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          `Expected a "precedence" for ${entry.kind} operator`
        ]
      });
      return false;
    }
  } else {
    if (entry["associativity"] !== void 0) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          'Unexpected "associativity" operator'
        ]
      });
      return false;
    }
  }
  if (!isMatchfixEntry(entry) && !isEnvironmentEntry(entry)) {
    if (!entry.latexTrigger && !entry.symbolTrigger && !entry.name) {
      onError({
        severity: "warning",
        message: [
          "invalid-dictionary-entry",
          subject,
          `Expected a 'name', a 'latexTrigger' or a 'symbolTrigger'`
        ]
      });
      return false;
    }
  }
  if (entry["parse"] === void 0 && entry.name === void 0) {
    onError({
      severity: "warning",
      message: [
        "invalid-dictionary-entry",
        subject,
        `Expected a 'parse' or 'name'`
      ]
    });
    return false;
  }
  return true;
}
var DEFAULT_LATEX_DICTIONARY = {
  "symbols": DEFINITIONS_SYMBOLS,
  "algebra": DEFINITIONS_ALGEBRA,
  "arithmetic": DEFINITIONS_ARITHMETIC,
  "calculus": DEFINITIONS_CALCULUS,
  "complex": DEFINITIONS_COMPLEX,
  "core": DEFINITIONS_CORE,
  "linear-algebra": DEFINITIONS_LINEAR_ALGEBRA,
  "logic": DEFINITIONS_LOGIC,
  "relop": DEFINITIONS_INEQUALITIES,
  "other": DEFINITIONS_OTHERS,
  "physics": [
    {
      name: "mu0",
      kind: "symbol",
      latexTrigger: "\\mu_0"
    }
  ],
  "sets": DEFINITIONS_SETS,
  "statistics": DEFINITIONS_STATISTICS,
  "trigonometry": DEFINITIONS_TRIGONOMETRY
};
function getLatexDictionary(category = "all") {
  if (category === "all") {
    const result = [];
    for (const domain of Object.keys(DEFAULT_LATEX_DICTIONARY))
      if (DEFAULT_LATEX_DICTIONARY[domain])
        result.push(...DEFAULT_LATEX_DICTIONARY[domain]);
    return result;
  }
  if (!DEFAULT_LATEX_DICTIONARY[category]) return [];
  return Object.freeze([
    ...DEFAULT_LATEX_DICTIONARY[category]
  ]);
}

// src/compute-engine/latex-syntax/parse.ts
init_utils2();
init_types();
init_tokenizer();

// src/compute-engine/latex-syntax/parse-symbol.ts
init_symbols();
init_definitions_symbols();
var SYMBOL_PREFIX = {
  // Those are "grouping" prefix that also specify spacing
  // around the symbol. We ignore the spacing, though.
  "\\mathord": "",
  "\\mathop": "",
  "\\mathbin": "",
  "\\mathrel": "",
  "\\mathopen": "",
  "\\mathclose": "",
  "\\mathpunct": "",
  "\\mathinner": "",
  // This is the preferred way to specify a symbol
  // it defines both spacing and font. By default, symbols
  // are wrapped with `\\operatorname{}`.
  "\\operatorname": "",
  // Text commands - extract the text content as a symbol name
  // e.g., x_{\text{max}} -> x_max
  "\\text": "",
  // These styling commands are used to change the font of a symbol
  // They may be problematic, as adjacent symbols may be merged
  // into a single symbol when used in editors, such a MathLive.
  // For example `\mathrm{speed}\mathrm{sound}` can be confused with `\mathrm{speedsound}`
  "\\mathrm": "_upright",
  "\\mathit": "_italic",
  "\\mathbf": "_bold",
  "\\mathscr": "_script",
  "\\mathcal": "_calligraphic",
  "\\mathfrak": "_fraktur",
  "\\mathsf": "_sansserif",
  "\\mathtt": "_monospace",
  "\\mathbb": "_doublestruck"
};
var SYMBOL_MODIFIER = {
  "\\mathring": "_ring",
  "\\hat": "_hat",
  "\\tilde": "_tilde",
  "\\vec": "_vec",
  "\\overline": "_bar",
  "\\underline": "_underbar",
  "\\dot": "_dot",
  "\\ddot": "_ddot",
  "\\dddot": "_dddot",
  "\\ddddot": "_ddddot",
  "\\acute": "_acute",
  "\\grave": "_grave",
  "\\breve": "_breve",
  "\\check": "_check"
};
function parseSymbolToken(parser, options) {
  if (parser.atEnd) return null;
  const token = parser.peek;
  let special = {
    "\\_": "_",
    "\\#": "hash"
  }[token];
  if (!special && !options.toplevel) {
    special = {
      "+": "plus",
      "-": "minus",
      "\\plusmn": "pm",
      "\\pm": "pm",
      "\\ast": "ast",
      "\\dag": "dag",
      "\\ddag": "ddag",
      "\\bot": "bottom",
      "\\top": "top",
      "\\bullet": "bullet",
      "\\cir": "circle",
      "\\diamond": "diamond",
      "\\times": "times",
      "\\square": "square",
      "\\star": "star"
    }[token];
  }
  if (special) {
    parser.nextToken();
    return special;
  }
  const i = SYMBOLS.findIndex((x) => x[1] === token);
  if (i >= 0) {
    parser.nextToken();
    return SYMBOLS[i][0];
  }
  return parser.parseChar() ?? parser.nextToken();
}
function parseSymbolBody(parser) {
  let id = matchPrefixedSymbol(parser);
  const prefix = SYMBOL_MODIFIER[parser.peek] ?? null;
  if (prefix) {
    parser.nextToken();
    if (!parser.match("<{>")) return null;
    const body = parseSymbolBody(parser);
    if (body === null || !parser.match("<}>")) return null;
    id = `${body}${prefix}`;
  }
  if (id === null) {
    id = "";
    while (!parser.atEnd) {
      const token = parser.peek;
      if (token === "<}>" || token === "_" || token === "^") break;
      const next = parseSymbolToken(parser, { toplevel: false });
      if (next === null) return null;
      id += next;
    }
    while (!parser.atEnd && /\d/.test(parser.peek)) id += parser.nextToken();
  }
  while (!parser.atEnd) {
    if (parser.match("\\degree")) id += "_deg";
    else if (parser.matchAll(["^", "\\circ"])) id += "_deg";
    else if (parser.matchAll(["^", "\\prime"])) id += "_prime";
    else if (parser.matchAll(["^", "<{>", "\\prime", "<}>"])) id += "_prime";
    else if (parser.matchAll(["^", "<{>", "\\doubleprime", "<}>"]))
      id += "_dprime";
    else if (parser.matchAll(["^", "<{>", "\\prime", "\\prime", "<}>"]))
      id += "_dprime";
    else break;
  }
  const sups = [];
  const subs = [];
  while (!parser.atEnd) {
    if (parser.match("_")) {
      const hasBrace = parser.match("<{>");
      const sub3 = parseSymbolBody(parser);
      if (hasBrace && !parser.match("<}>") || sub3 === null) return null;
      subs.push(sub3);
    } else if (parser.match("^")) {
      const hasBrace = parser.match("<{>");
      const sup = parseSymbolBody(parser);
      if (hasBrace && !parser.match("<}>") || sup === null) return null;
      sups.push(sup);
    } else break;
  }
  if (sups.length > 0) id += "__" + sups.join("");
  if (subs.length > 0) id += "_" + subs.join("");
  return id;
}
function matchPrefixedSymbol(parser) {
  const prefix = SYMBOL_PREFIX[parser.peek] ?? null;
  if (prefix === null) return null;
  parser.nextToken();
  if (parser.match("<{>")) {
    let body = "";
    const digit = {
      0: "zero",
      1: "one",
      2: "two",
      3: "three",
      4: "four",
      5: "five",
      6: "six",
      7: "seven",
      8: "eight",
      9: "nine"
    }[parser.peek] ?? "";
    if (digit) {
      body = digit;
      parser.nextToken();
    }
    body += parseSymbolBody(parser);
    if (body === null || !parser.match("<}>")) return null;
    if (prefix === "_upright" && body.length > 1) return body;
    return body + prefix;
  }
  return null;
}
function parseInvalidSymbol(parser) {
  const start = parser.index;
  const id = matchPrefixedSymbol(parser);
  if (id === null || isValidSymbol(id)) return null;
  return parser.error(["invalid-symbol", { str: validateSymbol(id) }], start);
}
function parseSymbol(parser) {
  if (/^[a-zA-Z]$/.test(parser.peek) || /^\p{XIDS}$/u.test(parser.peek)) {
    let id2 = parser.nextToken();
    const symbolType = parser.getSymbolType(id2);
    const isCollection2 = symbolType.matches("indexed_collection");
    const hasSubscriptEval = parser.hasSubscriptEvaluate(id2);
    while (!parser.atEnd && !isCollection2 && !hasSubscriptEval) {
      const currentPeek = parser.peek;
      if (currentPeek !== "_") break;
      const underscoreIndex = parser.index;
      parser.nextToken();
      const hasBrace = parser.match("<{>");
      if (hasBrace) {
        const firstToken = parser.peek;
        if (firstToken === "(" || firstToken === "\\lparen" || firstToken === "\\left") {
          parser.index = underscoreIndex;
          break;
        }
        const sub3 = parseSymbolBody(parser);
        const hasOperators = sub3 !== null && /plus|minus|times|ast/.test(sub3);
        if (sub3 === null || sub3.includes(",") || hasOperators || parser.peek !== "<}>") {
          parser.index = underscoreIndex;
          break;
        }
        parser.match("<}>");
        id2 += "_" + sub3;
      } else {
        const subToken = parser.peek;
        if (/^[a-zA-Z0-9]$/.test(subToken) || /^\p{XIDS}$/u.test(subToken)) {
          parser.nextToken();
          id2 += "_" + subToken;
        } else {
          parser.index = underscoreIndex;
          break;
        }
      }
    }
    return id2;
  }
  let id = matchPrefixedSymbol(parser);
  if (!id) {
    id = "";
    while (!parser.atEnd && EMOJIS.test(id + parser.peek))
      id += parser.nextToken();
    if (!id) id = null;
  }
  const index = parser.index;
  id ??= parseSymbolToken(parser, { toplevel: true });
  if (id) {
    id = id.normalize();
    if (isValidSymbol(id)) return id;
  }
  parser.index = index;
  return null;
}

// src/compute-engine/latex-syntax/parse.ts
init_numeric();
init_boxed_type();
var DELIMITER_SHORTHAND2 = {
  "(": ["\\lparen", "("],
  ")": ["\\rparen", ")"],
  "[": ["\\lbrack", "\\[", "["],
  "]": ["\\rbrack", "\\]", "]"],
  "<": ["<", "\\langle"],
  ">": [">", "\\rangle"],
  "{": ["\\{", "\\lbrace"],
  "}": ["\\}", "\\rbrace"],
  ":": [":", "\\colon"],
  "|": ["|", "\\|", "\\lvert", "\\rvert"],
  //special: '\lvert` when open, `\rvert` when close
  "||": ["||", "\\Vert", "\\lVert", "\\rVert"]
  // special: `\lVert` when open, `\rVert` when close
  // '\\lfloor': ['\\lfloor'],
  // '\\rfloor': ['\\rfloor'],
  // '\\lceil': ['\\lceil'],
  // '\\rceil': ['\\rceil'],
  // '\\ulcorner': ['\\ulcorner'],
  // '\\urcorner': ['\\urcorner'],
  // '\\llcorner': ['\\llcorner'],
  // '\\lrcorner': ['\\lrcorner'],
  // '\\lgroup': ['\\lgroup'],
  // '\\rgroup': ['\\rgroup'],
  // '\\lmoustache': ['\\lmoustache'],
  // '\\rmoustache': ['\\rmoustache'],
  // '\\llbracket': ['\\llbracket'],
  // '\\rrbracket': ['\\rrbracket'],
};
var OPEN_DELIMITER_PREFIX = {
  "\\left": "\\right",
  "\\bigl": "\\bigr",
  "\\Bigl": "\\Bigr",
  "\\biggl": "\\biggr",
  "\\Biggl": "\\Biggr",
  "\\big": "\\big",
  "\\Big": "\\Big",
  "\\bigg": "\\bigg",
  "\\Bigg": "\\Bigg",
  "\\mathopen": "\\mathclose"
};
var CLOSE_DELIMITER = {
  "(": ")",
  "[": "]",
  "|": "|",
  "\\{": "\\}",
  "\\[": "\\]",
  "\\lbrace": "\\rbrace",
  "\\lparen": "\\rparen",
  "\\langle": "\\rangle",
  "\\lfloor": "\\rfloor",
  "\\lceil": "\\rceil",
  "\\vert": "\\vert",
  "\\lvert": "\\rvert",
  "\\Vert": "\\Vert",
  "\\lVert": "\\rVert",
  "\\lbrack": "\\rbrack",
  "\\ulcorner": "\\urcorner",
  "\\llcorner": "\\lrcorner",
  "\\lgroup": "\\rgroup",
  "\\lmoustache": "\\rmoustache",
  "\\llbracket": "\\rrbracket"
};
var _Parser = class {
  options;
  _index = 0;
  symbolTable = {
    parent: null,
    ids: {}
  };
  pushSymbolTable() {
    this.symbolTable = { parent: this.symbolTable, ids: {} };
  }
  popSymbolTable() {
    this.symbolTable = this.symbolTable.parent ?? this.symbolTable;
  }
  addSymbol(id, type2) {
    if (typeof type2 === "string") type2 = new BoxedType(type2);
    if (id in this.symbolTable.ids && this.symbolTable.ids[id].is(type2.type))
      throw new Error(`Symbol ${id} already declared as a different type`);
    this.symbolTable.ids[id] = type2;
  }
  // Track whether we're inside a quantifier body (ForAll, Exists, etc.)
  // When true, single uppercase letters followed by () are parsed as predicates
  _quantifierScopeDepth = 0;
  get inQuantifierScope() {
    return this._quantifierScopeDepth > 0;
  }
  enterQuantifierScope() {
    this._quantifierScopeDepth++;
  }
  exitQuantifierScope() {
    if (this._quantifierScopeDepth > 0) this._quantifierScopeDepth--;
  }
  get index() {
    return this._index;
  }
  set index(val) {
    this._index = val;
    this._lastPeek = "";
    this._peekCounter = 0;
  }
  _tokens;
  _positiveInfinityTokens;
  _negativeInfinityTokens;
  _notANumberTokens;
  _decimalSeparatorTokens;
  _wholeDigitGroupSeparatorTokens;
  _fractionalDigitGroupSeparatorTokens;
  _exponentProductTokens;
  _beginExponentMarkerTokens;
  _endExponentMarkerTokens;
  _truncationMarkerTokens;
  _imaginaryUnitTokens;
  _dictionary;
  // A parsing boundary is a sequence of tokens that indicate that a
  // recursive parsing operation should stop.
  // In a traditional parser, keeping track of parsing boundaries would
  // not be necessary. However, because we attempt to deliver the best
  // interpretation of a partial expression, boundaries allow us to fail
  // parsing more locally.
  // For example, in `\begin{cases} | \end{cases}`, without boundary
  // detection, the parsing of `|` would attempt to goble up `\end{cases}`
  // which would be interpreted as an unexpected command, and the whole `\begin`
  // would be rejected as an unbalanced environment. With `\end{cases}` as a
  // boundary, the parsing of the `|` argument stops as soon as it encounters
  // the `\end{cases}` and can properly report an unexpected token on the `|`
  // only while correctly interpreting the `\begin{cases}...\end{cases}`
  _boundaries = [];
  // Those two properties are used to detect infinite loops while parsing
  _lastPeek = "";
  _peekCounter = 0;
  constructor(tokens, dictionary, options) {
    this._tokens = tokens;
    this.options = options;
    this._dictionary = dictionary;
    this._positiveInfinityTokens = tokenize(this.options.positiveInfinity);
    this._negativeInfinityTokens = tokenize(this.options.negativeInfinity);
    this._notANumberTokens = tokenize(this.options.notANumber);
    this._decimalSeparatorTokens = tokenize(this.options.decimalSeparator);
    this._wholeDigitGroupSeparatorTokens = [];
    this._fractionalDigitGroupSeparatorTokens = [];
    if (this.options.digitGroupSeparator) {
      if (typeof this.options.digitGroupSeparator === "string") {
        this._wholeDigitGroupSeparatorTokens = tokenize(
          this.options.digitGroupSeparator
        );
        this._fractionalDigitGroupSeparatorTokens = this._wholeDigitGroupSeparatorTokens;
      } else if (Array.isArray(this.options.digitGroupSeparator)) {
        this._wholeDigitGroupSeparatorTokens = tokenize(
          this.options.digitGroupSeparator[0]
        );
        this._fractionalDigitGroupSeparatorTokens = tokenize(
          this.options.digitGroupSeparator[1]
        );
      }
    }
    this._exponentProductTokens = tokenize(this.options.exponentProduct);
    this._beginExponentMarkerTokens = tokenize(
      this.options.beginExponentMarker
    );
    this._endExponentMarkerTokens = tokenize(this.options.endExponentMarker);
    this._truncationMarkerTokens = tokenize(this.options.truncationMarker);
    this._imaginaryUnitTokens = tokenize(this.options.imaginaryUnit);
  }
  getSymbolType(id) {
    let table = this.symbolTable;
    while (table) {
      if (id in table.ids) return table.ids[id];
      table = table.parent;
    }
    if (this.options.getSymbolType) return this.options.getSymbolType(id);
    return BoxedType.unknown;
  }
  hasSubscriptEvaluate(id) {
    if (this.options.hasSubscriptEvaluate)
      return this.options.hasSubscriptEvaluate(id);
    return false;
  }
  get peek() {
    const peek = this._tokens[this.index];
    if (peek === this._lastPeek) this._peekCounter += 1;
    else this._peekCounter = 0;
    if (this._peekCounter >= 1024) {
      const msg = `Infinite loop detected while parsing "${this.latex(
        0
      )}" at "${this._lastPeek}" (index ${this.index})`;
      console.error(msg);
      throw new Error(msg);
    }
    this._lastPeek = peek;
    return peek;
  }
  nextToken() {
    return this._tokens[this.index++];
  }
  get atEnd() {
    return this.index >= this._tokens.length;
  }
  /**
   * Return true if
   * - at end of the token stream
   * - the `t.condition` function returns true
   * Note: the `minPrec` condition is not checked. It should be checked separately.
   */
  atTerminator(t) {
    return this.atBoundary || ((t?.condition && t.condition(this)) ?? false);
  }
  /**
   * True if the current token matches any of the boundaries we are
   * waiting for.
   */
  get atBoundary() {
    if (this.atEnd) return true;
    const start = this.index;
    for (const boundary of this._boundaries) {
      if (this.matchAll(boundary.tokens)) {
        this.index = start;
        return true;
      }
    }
    return false;
  }
  addBoundary(boundary) {
    this._boundaries.push({ index: this.index, tokens: boundary });
  }
  removeBoundary() {
    this._boundaries.pop();
  }
  matchBoundary() {
    const currentBoundary = this._boundaries[this._boundaries.length - 1];
    const match2 = currentBoundary && this.matchAll(currentBoundary.tokens);
    if (match2) this._boundaries.pop();
    return match2;
  }
  boundaryError(msg) {
    const currentBoundary = this._boundaries[this._boundaries.length - 1];
    this._boundaries.pop();
    return this.error(msg, currentBoundary.index);
  }
  /**
   * Performance optimization: determines if we can skip expensive re-parsing
   * for matchfix boundary mismatches.
   *
   * We skip re-parsing only for specific non-ambiguous cases where we know
   * the boundary mismatch is due to trying interval notation on regular parens.
   * For example, trying (] on input () - we can safely skip without re-parsing.
   *
   * All other cases (including |, [, and other delimiters) require re-parsing
   * to handle nested delimiters correctly.
   */
  canSkipMatchfixReparsing(openTrigger, boundary, sameTrigger) {
    return !sameTrigger && // Not same open/close (e.g., not ||)
    boundary.length === 1 && // No prefix like \right
    (openTrigger === "(" || openTrigger === "\\lparen") && // Only for (
    (boundary[0] === "]" || boundary[0] === "\\rbrack");
  }
  latex(start, end) {
    return tokensToString(this._tokens.slice(start, end));
  }
  latexAhead(n) {
    return this.latex(this.index, this.index + n);
  }
  // latexBefore(): string {
  //   return this.latex(0, this.index);
  // }
  // latexAfter(): string {
  //   return this.latex(this.index);
  // }
  /**
   * Return at most `this._dictionary.lookahead` LaTeX tokens.
   *
   * The index in the returned array correspond to the number of tokens.
   * Note that since a token can be longer than one char ('\\pi', but also
   * some astral plane unicode characters), the length of the string
   * does not match that index. However, knowing the index is important
   * to know by how many tokens to advance.
   *
   * For example:
   *
   * `[empty, '\\sqrt', '\\sqrt{', '\\sqrt{2', '\\sqrt{2}']`
   *
   */
  lookAhead() {
    let n = Math.min(
      this._dictionary.lookahead,
      this._tokens.length - this.index
    );
    if (n <= 0) return [];
    const result = [];
    while (n > 0) result.push([n, this.latexAhead(n--)]);
    return result;
  }
  peekDefinitions(kind) {
    if (this.atEnd) return [];
    const result = [];
    let triggerIndex;
    switch (kind) {
      case "infix":
        triggerIndex = this._dictionary.infixByTrigger;
        break;
      case "prefix":
        triggerIndex = this._dictionary.prefixByTrigger;
        break;
      case "postfix":
        triggerIndex = this._dictionary.postfixByTrigger;
        break;
      case "function":
        triggerIndex = this._dictionary.functionByTrigger;
        break;
      case "symbol":
        triggerIndex = this._dictionary.symbolByTrigger;
        break;
      case "expression":
        triggerIndex = this._dictionary.expressionByTrigger;
        break;
      case "operator":
        triggerIndex = void 0;
        break;
    }
    if (triggerIndex) {
      const defsNeedingIteration = [];
      for (const def of this.getDefs(kind)) {
        if (def.latexTrigger === "" || def.symbolTrigger) {
          defsNeedingIteration.push(def);
        }
      }
      for (const def of defsNeedingIteration) {
        if (def.latexTrigger === "") result.push([def, 0]);
      }
      for (const [n, tokens] of this.lookAhead()) {
        const defs = triggerIndex.get(tokens);
        if (defs) {
          for (const def of defs) result.push([def, n]);
        }
      }
      for (const def of defsNeedingIteration) {
        if (def.symbolTrigger) {
          const n = parseComplexId(this, def.symbolTrigger);
          if (n > 0) result.push([def, n]);
        }
      }
    } else {
      const defs = [...this.getDefs(kind)];
      for (const def of defs)
        if (def.latexTrigger === "") result.push([def, 0]);
      for (const [n, tokens] of this.lookAhead()) {
        for (const def of defs)
          if (def.latexTrigger === tokens) result.push([def, n]);
      }
      for (const def of defs) {
        if (def.symbolTrigger) {
          const n = parseComplexId(this, def.symbolTrigger);
          if (n > 0) result.push([def, n]);
        }
      }
    }
    return result;
  }
  /** Skip strictly `<space>` tokens.
   * To also skip `{}` see `skipSpace()`.
   * To skip visual space (e.g. `\,`) see `skipVisualSpace()`.
   */
  skipSpaceTokens() {
    while (this.match("<space>")) {
    }
  }
  /** While parsing in math mode, skip applicable spaces, which includes `{}`.
   * Do not use to skip spaces while parsing a string. See  `skipSpaceTokens()`
   * instead.
   */
  skipSpace() {
    if (!this.atEnd && this.peek === "<{>") {
      const index = this.index;
      this.nextToken();
      while (this.match("<space>")) {
      }
      if (this.nextToken() === "<}>") {
        this.skipSpace();
        return true;
      }
      this.index = index;
    }
    if (!this.options.skipSpace) return false;
    let found = false;
    while (this.match("<space>")) found = true;
    if (found) this.skipSpace();
    return found;
  }
  skipVisualSpace() {
    if (!this.options.skipSpace) return;
    this.skipSpace();
    if ([
      "\\!",
      "\\,",
      "\\:",
      "\\;",
      "\\enskip",
      "\\enspace",
      "\\space",
      "\\quad",
      "\\qquad"
    ].includes(this.peek)) {
      this.nextToken();
      this.skipVisualSpace();
    }
    this.skipSpace();
  }
  match(token) {
    if (this._tokens[this.index] !== token) return false;
    this.index++;
    return true;
  }
  matchAll(tokens) {
    if (tokens.length === 0) return false;
    let matched;
    let i = 0;
    do {
      matched = this._tokens[this.index + i] === tokens[i++];
    } while (matched && i < tokens.length);
    if (matched) this.index += i;
    return matched;
  }
  matchAny(tokens) {
    if (tokens.includes(this._tokens[this.index]))
      return this._tokens[this.index++];
    return "";
  }
  /**
   * A Latex number can be a decimal, hex or octal number.
   * It is used in some Latex commands, such as `\char`
   *
   * From TeX:8695 (scan_int):
   * > An integer number can be preceded by any number of spaces and `+' or
   * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
   * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
   * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
   * > an internal variable.
   */
  parseLatexNumber(isInteger2 = true) {
    let negative = false;
    let token = this.peek;
    while (token === "<space>" || token === "+" || token === "-") {
      if (token === "-") negative = !negative;
      this.nextToken();
      token = this.peek;
    }
    let radix = 10;
    let digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    if (this.match("'")) {
      radix = 8;
      digits = ["0", "1", "2", "3", "4", "5", "6", "7"];
      isInteger2 = true;
    } else if (this.match('"') || this.match("x")) {
      radix = 16;
      digits = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F"
      ];
      isInteger2 = true;
    } else if (this.match("`")) {
      token = this.nextToken();
      if (token) {
        if (token.startsWith("\\") && token.length === 2) {
          return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
        }
        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }
      return null;
    }
    let value = "";
    while (digits.includes(this.peek)) {
      value += this.nextToken();
    }
    if (!isInteger2 && this.match(".")) {
      value += ".";
      while (digits.includes(this.peek)) {
        value += this.nextToken();
      }
    }
    const result = isInteger2 ? Number.parseInt(value, radix) : Number.parseFloat(value);
    if (Number.isNaN(result)) return null;
    return negative ? -result : result;
  }
  // Match a LaTeX char, which can be a char literal, or a Unicode codepoint
  // in hexadecimal or decimal notation  with the `\char` or `\unicode` command,
  // or the `^` character repeated twice followed by a hexadecimal codepoint.
  parseChar() {
    const index = this.index;
    let caretCount = 0;
    while (this.match("^")) caretCount += 1;
    if (caretCount < 2) this.index = index;
    if (caretCount >= 2) {
      let digits = "";
      let n = 0;
      while (n != caretCount) {
        const digit = this.matchAny([
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f"
        ]);
        if (!digit) break;
        digits += digit;
        n += 1;
      }
      if (digits.length === caretCount)
        return String.fromCodePoint(Number.parseInt(digits, 16));
    } else if (this.match("\\char")) {
      let codepoint = Math.floor(this.parseLatexNumber() ?? Number.NaN);
      if (!Number.isFinite(codepoint) || codepoint < 0 || codepoint > 1114111) {
        codepoint = 10067;
      }
      return String.fromCodePoint(codepoint);
    } else if (this.match("\\unicode")) {
      this.skipSpaceTokens();
      if (this.match("<{>")) {
        const codepoint = this.parseLatexNumber();
        if (this.match("<}>") && codepoint !== null && codepoint >= 0 && codepoint <= 1114111) {
          return String.fromCodePoint(codepoint);
        }
      } else {
        const codepoint = this.parseLatexNumber();
        if (codepoint !== null && codepoint >= 0 && codepoint <= 1114111)
          return String.fromCodePoint(codepoint);
      }
    }
    this.index = index;
    return null;
  }
  /**
   *
   * If the next token matches the open delimiter, set a boundary with
   * the close token and return true.
   *
   * This method handles prefixes like `\left` and `\bigl`.
   *
   * It also handles "shorthand" delimiters, i.e. '(' will match both
   * `(` and `\lparen`. If a shorthand is used for the open delimiter, the
   * corresponding shorthand will be used for the close delimiter.
   * See DELIMITER_SHORTHAND.
   *
   */
  matchDelimiter(open, close) {
    const start = this.index;
    const closePrefix = OPEN_DELIMITER_PREFIX[this.peek];
    if (closePrefix) this.nextToken();
    const hasBracedDelimiter = closePrefix && this.peek === "<{>";
    if (hasBracedDelimiter) this.nextToken();
    if (Array.isArray(open)) {
      console.assert(Array.isArray(close));
      if (open.length === 1) {
        const possibleTokens = DELIMITER_SHORTHAND2[open[0]] ?? [open[0]];
        if (!possibleTokens.includes(this.peek)) {
          this.index = start;
          return false;
        }
        const matchedToken = this.nextToken();
        const useLatexCommand = matchedToken.startsWith("\\");
        if (hasBracedDelimiter && !this.match("<}>")) {
          this.index = start;
          return false;
        }
        const closeTokens = DELIMITER_SHORTHAND2[close[0]] ?? [
          close[0]
        ];
        const closeToken = closeTokens.find(
          (t) => useLatexCommand ? t.startsWith("\\") : !t.startsWith("\\")
        ) ?? closeTokens[0];
        const closeBoundary3 = closePrefix ? hasBracedDelimiter ? [closePrefix, "<{>", closeToken, "<}>"] : [closePrefix, closeToken] : [closeToken];
        this.addBoundary(closeBoundary3);
        return true;
      }
      if (!this.matchAll(open)) {
        this.index = start;
        return false;
      }
      const closeBoundary2 = closePrefix ? [closePrefix, ...close] : close;
      this.addBoundary(closeBoundary2);
      return true;
    }
    console.assert(!Array.isArray(close));
    if (open === "||" && this.matchAll(["|", "|"])) {
      this.addBoundary(["|", "|"]);
      return true;
    }
    if (!(DELIMITER_SHORTHAND2[open] ?? [open]).includes(this.peek)) {
      this.index = start;
      return false;
    }
    open = this.nextToken();
    if (hasBracedDelimiter && !this.match("<}>")) {
      this.index = start;
      return false;
    }
    close = CLOSE_DELIMITER[open] ?? close;
    const closeBoundary = closePrefix ? hasBracedDelimiter ? [closePrefix, "<{>", close, "<}>"] : [closePrefix, close] : [close];
    this.addBoundary(closeBoundary);
    return true;
  }
  parseGroup() {
    const start = this.index;
    this.skipSpaceTokens();
    if (this.match("<{>")) {
      this.addBoundary(["<}>"]);
      const expr = this.parseExpression();
      this.skipSpace();
      if (this.matchBoundary()) return expr ?? "Nothing";
      while (!this.matchBoundary() && !this.atEnd) this.nextToken();
      if (operator(expr) === "Error") return expr;
      const err = this.error("expected-closing-delimiter", start);
      return expr !== null ? ["InvisibleOperator", expr, err] : err;
    }
    this.index = start;
    return null;
  }
  parseOptionalGroup() {
    const index = this.index;
    this.skipSpaceTokens();
    if (this.match("[")) {
      this.addBoundary(["]"]);
      const expr = this.parseExpression();
      this.skipSpace();
      if (this.matchBoundary()) return expr;
      return this.boundaryError("expected-closing-delimiter");
    }
    this.index = index;
    return null;
  }
  // Some LaTeX commands (but not all) can accept an argument without braces,
  // for example `^` , `\sqrt` or `\frac`.
  // This argument will usually be a single token, but can be a sequence of
  // tokens (e.g. `\sqrt\frac12` or `\sqrt\operatorname{speed}`).
  parseToken() {
    this.skipSpace();
    const excluding = [
      ...'!"#$%&(),/;:?@[]\\`|~'.split(""),
      "\\left",
      "\\bigl"
    ];
    if (excluding.includes(this.peek)) return null;
    if (/^[0-9]$/.test(this.peek)) return parseInt(this.nextToken(), 10);
    return this.parseGenericExpression() ?? this.parseSymbol();
  }
  /**
   * Parse an expression in a tabular format, where rows are separated by `\\`
   * and columns by `&`.
   *
   * Return rows of sparse columns: empty rows are indicated with `Nothing`,
   * and empty cells are also indicated with `Nothing`.
   */
  parseTabular() {
    const result = [];
    let row = [];
    let expr = null;
    while (!this.atBoundary) {
      this.skipSpace();
      if (this.match("&")) {
        row.push(expr ?? "Nothing");
        expr = null;
      } else if (this.match("\\\\") || this.match("\\cr")) {
        this.skipSpace();
        this.parseOptionalGroup();
        if (expr !== null) row.push(expr);
        result.push(row);
        row = [];
        expr = null;
      } else {
        const cell = [];
        let peek = this.peek;
        while (peek !== "&" && peek !== "\\\\" && peek !== "\\cr" && !this.atBoundary) {
          expr = this.parseExpression({
            minPrec: 0,
            condition: (p) => {
              const peek2 = p.peek;
              return peek2 === "&" || peek2 === "\\\\" || peek2 === "\\cr";
            }
          });
          if (expr !== null) cell.push(expr);
          else {
            cell.push([
              "Error",
              "'unexpected-token'",
              { str: tokensToString(peek) }
            ]);
            this.nextToken();
          }
          this.skipSpace();
          peek = this.peek;
        }
        if (cell.length > 1) expr = ["Sequence", ...cell];
        else expr = cell[0] ?? "Nothing";
      }
    }
    if (expr !== null) row.push(expr);
    if (row.length > 0) result.push(row);
    return result;
  }
  /** Match a string used as a LaTeX symbol, for example an environment
   * name.
   * Not suitable for general purpose text, e.g. argument of a `\text{}
   * command. See `matchChar()` instead.
   */
  parseStringGroupContent() {
    const start = this.index;
    let result = "";
    let level = 0;
    while (!this.atBoundary || level > 0) {
      const token = this.nextToken();
      if (token === "<$>" || token === "<$$>") {
        this.index = start;
        return "";
      }
      if (token === "<{>") {
        level += 1;
        result += "\\{";
      } else if (token === "<}>") {
        level -= 1;
        result += "\\}";
      } else if (token === "<space>") {
        result += " ";
      } else if (token[0] === "\\") {
        result += token;
      } else {
        result += token;
      }
    }
    return result;
  }
  /** Parse a group as a a string, for example for `\operatorname` or `\begin` */
  parseStringGroup(optional) {
    if (optional === void 0) optional = false;
    const start = this.index;
    while (this.match("<space>")) {
    }
    if (this.match(optional ? "[" : "<{>")) {
      this.addBoundary([optional ? "]" : "<}>"]);
      const arg = this.parseStringGroupContent();
      if (this.matchBoundary()) return arg;
      this.removeBoundary();
    }
    this.index = start;
    return null;
  }
  /** Parse an environment: `\begin{env}...\end{end}`
   */
  parseEnvironment(until) {
    const index = this.index;
    if (!this.match("\\begin")) return null;
    const name = this.parseStringGroup()?.trim();
    if (!name) return this.error("expected-environment-name", index);
    this.addBoundary(["\\end", "<{>", ...name.split(""), "<}>"]);
    for (const def of this.getDefs("environment"))
      if (def.symbolTrigger === name) {
        const expr = def.parse(this, until);
        this.skipSpace();
        if (!this.matchBoundary())
          return this.boundaryError("unbalanced-environment");
        if (expr !== null) return this.decorate(expr, index);
        this.index = index;
        return null;
      }
    this.parseTabular();
    this.skipSpace();
    if (!this.matchBoundary())
      return this.boundaryError("unbalanced-environment");
    return this.error(["unknown-environment", { str: name }], index);
  }
  /** If the next token matches a `-` sign, return '-', otherwise return '+'
   *
   */
  parseOptionalSign() {
    let isNegative2 = !!this.matchAny(["-", "\u2212"]);
    while (this.matchAny(["+", "\uFE62"]) || this.skipSpace())
      if (this.matchAny(["-", "\u2212"])) isNegative2 = !isNegative2;
    return isNegative2 ? "-" : "+";
  }
  /** Parse a sequence of decimal digits. The part indicates which
   * grouping separator should be expected.
   */
  parseDecimalDigits(part = "whole") {
    const result = [];
    let done = false;
    while (!done) {
      while (/^[0-9]$/.test(this.peek)) {
        result.push(this.nextToken());
        this.skipVisualSpace();
      }
      done = true;
      const group = part === "whole" ? this._wholeDigitGroupSeparatorTokens : this._fractionalDigitGroupSeparatorTokens;
      if (part !== "none" && group.length > 0) {
        const savedIndex = this.index;
        this.skipVisualSpace();
        if (this.matchAll(group)) {
          this.skipVisualSpace();
          if (/^[0-9]$/.test(this.peek)) done = false;
          else this.index = savedIndex;
        }
      }
    }
    return result.join("");
  }
  /** The 'part' argument is used to dermine what grouping separator
   *  should be expected.
   */
  parseSignedInteger(part) {
    const start = this.index;
    const sign3 = this.parseOptionalSign();
    const result = this.parseDecimalDigits(part);
    if (result) return sign3 === "-" ? "-" + result : result;
    this.index = start;
    return "";
  }
  parseExponent() {
    const start = this.index;
    this.skipVisualSpace();
    if (this.matchAny(["e", "E"])) {
      const exponent = this.parseSignedInteger("none");
      if (exponent) return exponent;
    }
    this.index = start;
    if (this.match("\\times")) {
      this.skipVisualSpace();
      if (this.matchAll(["1", "0"])) {
        this.skipVisualSpace();
        if (this.match("^")) {
          this.skipVisualSpace();
          if (/^[0-9]$/.test(this.peek)) return this.nextToken();
          if (this.match("<{>")) {
            this.skipVisualSpace();
            const exponent = this.parseSignedInteger("whole");
            this.skipVisualSpace();
            if (exponent && this.match("<}>")) return exponent;
          }
        }
      }
    }
    this.index = start;
    this.skipVisualSpace();
    if (this.match("\\%")) return `-2`;
    this.index = start;
    if (this.matchAll(this._exponentProductTokens)) {
      this.skipVisualSpace();
      if (this.matchAll(this._beginExponentMarkerTokens)) {
        this.skipVisualSpace();
        const exponent = this.parseSignedInteger("none");
        this.skipVisualSpace();
        if (exponent && this.matchAll(this._endExponentMarkerTokens))
          return exponent;
      }
    }
    this.index = start;
    return "";
  }
  parseRepeatingDecimal() {
    const start = this.index;
    const format = this.options.repeatingDecimal;
    let repeatingDecimals = "";
    if ((format === "auto" || format === "parentheses") && this.match("(")) {
      repeatingDecimals = this.parseDecimalDigits("fraction");
      if (repeatingDecimals && this.match(")")) return `(${repeatingDecimals})`;
      this.index = start;
      return "";
    }
    this.index = start;
    if ((format === "auto" || format === "parentheses") && this.matchAll([`\\left`, "("])) {
      repeatingDecimals = this.parseDecimalDigits("fraction");
      if (repeatingDecimals && this.matchAll([`\\right`, ")"]))
        return `(${repeatingDecimals})`;
      this.index = start;
      return "";
    }
    this.index = start;
    if ((format === "auto" || format === "vinculum") && this.matchAll([`\\overline`, "<{>"])) {
      repeatingDecimals = this.parseDecimalDigits("fraction");
      if (repeatingDecimals && this.match("<}>"))
        return `(${repeatingDecimals})`;
      this.index = start;
      return "";
    }
    this.index = start;
    if ((format === "auto" || format === "arc") && (this.matchAll([`\\wideparen`, "<{>"]) || this.matchAll([`\\overarc`, "<{>"]))) {
      repeatingDecimals = this.parseDecimalDigits("fraction");
      if (repeatingDecimals && this.match("<}>"))
        return `(${repeatingDecimals})`;
      this.index = start;
      return "";
    }
    this.index = start;
    if (format === "auto" || format === "dots") {
      const first = dotOverDigit(this);
      if (first !== null) {
        repeatingDecimals = this.parseDecimalDigits("fraction");
        if (!repeatingDecimals) return `(${first})`;
        const last = dotOverDigit(this);
        if (last !== null) {
          return `(${first}${repeatingDecimals}${last})`;
        }
      }
    }
    this.index = start;
    return "";
  }
  /**
   * Parse a number, with an optional sign, exponent, decimal marker,
   * repeating decimals, etc...
   */
  parseNumber() {
    if (this.options.parseNumbers === false || this.options.parseNumbers === "never")
      return null;
    const start = this.index;
    this.skipVisualSpace();
    let sign3 = 1;
    while (this.peek === "-" || this.peek === "+") {
      if (this.match("-")) sign3 = -sign3;
      else this.match("+");
      this.skipVisualSpace();
    }
    let wholePart = "";
    let fractionalPart = "";
    let startsWithdecimalSeparator = false;
    if (this.match(".") || this.matchAll(this._decimalSeparatorTokens)) {
      const peek = this.peek;
      if (/^[\d]$/.test(peek) || mayBeRepeatingDigits(this)) {
        startsWithdecimalSeparator = true;
        wholePart = "0";
      }
    } else wholePart = this.parseDecimalDigits("whole");
    if (!wholePart) {
      this.index = start;
      return null;
    }
    const fractionalIndex = this.index;
    let hasFractionalPart = false;
    if (startsWithdecimalSeparator || this.match(".") || this.matchAll(this._decimalSeparatorTokens)) {
      fractionalPart = this.parseDecimalDigits("fraction");
      hasFractionalPart = true;
    }
    let hasRepeatingPart = false;
    if (hasFractionalPart) {
      const repeat2 = this.parseRepeatingDecimal();
      if (repeat2) {
        fractionalPart += repeat2;
        hasRepeatingPart = true;
      }
      if (this.match("\\ldots") || this.matchAll(this._truncationMarkerTokens)) {
      }
    }
    if (hasFractionalPart && !fractionalPart) {
      this.index = fractionalIndex;
      if (wholePart.length < 10)
        return numberExpression(sign3 * parseInt(wholePart, 10));
      return { num: sign3 < 0 ? "-" + wholePart : wholePart };
    }
    const exponent = this.parseExponent();
    if (!hasFractionalPart && !exponent && wholePart.length < 10)
      return numberExpression(sign3 * parseInt(wholePart, 10));
    if (!hasRepeatingPart && this.options.parseNumbers === "rational") {
      const isLargeInteger = wholePart.length > 16 || wholePart.length === 16 && wholePart > "9007199254740991";
      if (!fractionalPart) {
        if (isLargeInteger) {
          const numStr = sign3 < 0 ? "-" + wholePart : wholePart;
          if (exponent)
            return ["Multiply", { num: numStr }, ["Power", 10, exponent]];
          return { num: numStr };
        }
        const whole2 = parseInt(wholePart, 10);
        if (exponent)
          return ["Multiply", sign3 * whole2, ["Power", 10, exponent]];
        return numberExpression(sign3 * whole2);
      }
      const n = fractionalPart.length;
      const numeratorDigits = wholePart.length + n;
      if (numeratorDigits > 15) {
        const wholeBig = BigInt(wholePart);
        const fractionBig = BigInt(fractionalPart);
        const denominatorBig = BigInt(10) ** BigInt(n);
        const numeratorBig = wholeBig * denominatorBig + fractionBig;
        const signedNumerator = sign3 < 0 ? -numeratorBig : numeratorBig;
        if (exponent) {
          return [
            "Multiply",
            [
              "Rational",
              { num: signedNumerator.toString() },
              Number(denominatorBig)
            ],
            ["Power", 10, exponent]
          ];
        }
        return [
          "Rational",
          { num: signedNumerator.toString() },
          Number(denominatorBig)
        ];
      }
      const whole = parseInt(wholePart, 10);
      const fraction = parseInt(fractionalPart, 10);
      const numerator = whole * 10 ** n + fraction;
      const denominator = 10 ** n;
      if (exponent) {
        return [
          "Multiply",
          ["Rational", sign3 * numerator, denominator],
          ["Power", 10, exponent]
        ];
      }
      return ["Rational", sign3 * numerator, denominator];
    }
    return {
      num: (sign3 < 0 ? "-" : "") + wholePart + (hasFractionalPart ? "." + fractionalPart : "") + (exponent ? "e" + exponent : "")
    };
  }
  parsePrefixOperator(until) {
    if (!until) until = { minPrec: 0 };
    if (!until.minPrec) until = { ...until, minPrec: 0 };
    const start = this.index;
    for (const [def, n] of this.peekDefinitions("prefix")) {
      this.index = start + n;
      const rhs = def.parse(this, { ...until, minPrec: def.precedence + 1 });
      if (rhs !== null) return rhs;
    }
    this.index = start;
    return null;
  }
  parseInfixOperator(lhs, until) {
    until ??= { minPrec: 0 };
    console.assert(until.minPrec !== void 0);
    if (until.minPrec === void 0) until = { ...until, minPrec: 0 };
    const start = this.index;
    for (const [def, n] of this.peekDefinitions("infix")) {
      if (def.precedence >= until.minPrec) {
        this.index = start + n;
        const rhs = def.parse(this, lhs, until);
        if (rhs !== null) return rhs;
      }
    }
    this.index = start;
    return null;
  }
  /**
   * This returns an array of arguments (as in a function application),
   * or null if there is no match.
   *
   * - 'enclosure' : will look for an argument inside an enclosure
   *   (open/close fence)
   * - 'implicit': either an expression inside a pair of `()`, or just a product
   *  (i.e. we interpret `\cos 2x + 1` as `\cos(2x) + 1`)
   *
   */
  parseArguments(kind = "enclosure", until) {
    if (this.atTerminator(until)) return null;
    const savedIndex = this.index;
    const group = this.parseEnclosure();
    if (kind === "enclosure") {
      if (group === null) return null;
      return getSequence(group) ?? [];
    }
    if (kind === "implicit") {
      if (operator(group) === "Delimiter") {
        const op1 = operand(group, 1);
        if (operator(op1) === "Sequence") return operands(op1);
        return op1 === null ? [] : [op1];
      }
      if (group !== null) return [group];
      const primary = this.parseExpression({
        ...until,
        minPrec: MULTIPLICATION_PRECEDENCE
      });
      return primary === null ? null : [primary];
    }
    this.index = savedIndex;
    return null;
  }
  /**
   * An enclosure is an opening matchfix operator, an optional expression,
   * optionally followed multiple times by a separator and another expression,
   * and finally a closing matching operator.
   */
  parseEnclosure() {
    const start = this.index;
    const currentToken = this.peek;
    const hasPrefix = OPEN_DELIMITER_PREFIX[currentToken];
    let lookupToken = hasPrefix ? this._tokens[this.index + 1] : currentToken;
    if (hasPrefix && lookupToken === "<{>")
      lookupToken = this._tokens[this.index + 2];
    let defs = this._dictionary.matchfixByOpen.get(lookupToken) ?? [];
    if (defs.length === 0 && !lookupToken) {
      defs = [...this.getDefs("matchfix")];
    }
    for (const def of defs) {
      this.index = start;
      const matched = this.matchDelimiter(def.openTrigger, def.closeTrigger);
      if (!matched) continue;
      const bodyStart = this.index;
      this.skipSpace();
      let body = this.parseExpression();
      this.skipSpace();
      const boundary = this._boundaries[this._boundaries.length - 1]?.tokens;
      const matchedBoundary = this.matchBoundary();
      const sameTrigger = typeof def.openTrigger === "string" && typeof def.closeTrigger === "string" && def.openTrigger === def.closeTrigger || Array.isArray(def.openTrigger) && Array.isArray(def.closeTrigger) && def.openTrigger.length === def.closeTrigger.length && def.openTrigger.every((tok, i) => tok === def.closeTrigger[i]);
      if (matchedBoundary && isEmptySequence(body) && sameTrigger && boundary) {
        this.index = bodyStart;
        this.skipSpace();
        body = this.parseExpression();
        this.skipSpace();
        if (!this.matchAll(boundary)) {
          this.index = start;
          if (!this.atEnd) continue;
          return null;
        }
      } else if (!matchedBoundary) {
        const boundary2 = this._boundaries[this._boundaries.length - 1]?.tokens;
        if (!boundary2) {
          this.index = start;
          continue;
        }
        if (!this.canSkipMatchfixReparsing(lookupToken, boundary2, sameTrigger)) {
          this.removeBoundary();
          this.index = bodyStart;
          this.skipSpace();
          body = this.parseExpression();
          this.skipSpace();
          if (!this.matchAll(boundary2)) {
            this.index = start;
            if (!this.atEnd) continue;
            return null;
          }
        } else {
          this.removeBoundary();
          this.index = start;
          continue;
        }
      }
      const result = def.parse(this, body ?? "Nothing");
      if (result !== null) return result;
    }
    this.index = start;
    return null;
  }
  /**
   * A generic expression is used for dictionary entries that do
   * some complex (non-standard) parsing. This includes trig functions (to
   * parse implicit arguments), and integrals (to parse the integrand and
   * limits and the "dx" terminator).
   */
  parseGenericExpression(until) {
    if (this.atTerminator(until)) return null;
    const start = this.index;
    let expr = null;
    const fnDefs = this.peekDefinitions("expression") ?? [];
    for (const [def, tokenCount] of fnDefs) {
      this.index = start + tokenCount;
      if (typeof def.parse === "function") {
        expr = def.parse(this, until);
        if (expr !== null) return expr;
      } else {
        return def.name;
      }
    }
    this.index = start;
    return null;
  }
  /**
   * A function is an symbol followed by postfix operators
   * (`\prime`...) and some arguments.
   */
  parseFunction(until) {
    if (this.atTerminator(until)) return null;
    const start = this.index;
    let fn = null;
    for (const [def, tokenCount] of this.peekDefinitions("function")) {
      this.index = start + tokenCount;
      if (typeof def.parse === "function") {
        fn = def.parse(this, until);
        if (fn !== null) return fn;
      } else {
        fn = def.name;
        break;
      }
    }
    let isPredicate = false;
    if (fn === null) {
      this.index = start;
      fn = parseSymbol(this);
      if (!this.isFunctionOperator(fn)) {
        if (!this.looksLikePredicate(fn)) {
          this.index = start;
          return null;
        }
        isPredicate = true;
      }
    }
    do {
      const pf = this.parsePostfixOperator(fn, until);
      if (pf === null) break;
      fn = pf;
    } while (true);
    const args = this.parseArguments("enclosure", until);
    if (args === null) return fn;
    if (isPredicate && typeof fn === "string") {
      if (this.inQuantifierScope || fn === "D" || fn === "N")
        return ["Predicate", fn, ...args];
    }
    return typeof fn === "string" ? [fn, ...args] : ["Apply", fn, ...args];
  }
  parseSymbol(until) {
    if (this.atTerminator(until)) return null;
    const start = this.index;
    for (const [def, tokenCount] of this.peekDefinitions("symbol")) {
      this.index = start + tokenCount;
      if (typeof def.parse === "function") {
        const result = def.parse(this, until);
        if (result !== null) return result;
      } else return def.name;
    }
    this.index = start;
    const id = parseSymbol(this);
    if (id !== null && !this.getSymbolType(id).matches("error")) return id;
    this.index = start;
    return null;
  }
  /**
   * In non-strict mode, try to parse a bare function name followed by parentheses.
   * This allows syntax like `sin(x)` instead of requiring `\sin(x)`.
   *
   * Returns the parsed function call or null if not a bare function.
   */
  tryParseBareFunction(until) {
    if (this.options.strict !== false) return null;
    const start = this.index;
    let name = "";
    while (!this.atEnd && /^[a-zA-Z]$/.test(this.peek)) {
      name += this.peek;
      this.index++;
    }
    if (!name) {
      this.index = start;
      return null;
    }
    this.skipSpace();
    if (this.peek !== "(") {
      this.index = start;
      return null;
    }
    const BARE_FUNCTION_MAP = {
      // Trigonometric
      sin: "Sin",
      cos: "Cos",
      tan: "Tan",
      cot: "Cot",
      sec: "Sec",
      csc: "Csc",
      // Hyperbolic
      sinh: "Sinh",
      cosh: "Cosh",
      tanh: "Tanh",
      coth: "Coth",
      sech: "Sech",
      csch: "Csch",
      // Inverse trigonometric
      arcsin: "Arcsin",
      arccos: "Arccos",
      arctan: "Arctan",
      arccot: "Arccot",
      arcsec: "Arcsec",
      arccsc: "Arccsc",
      asin: "Arcsin",
      acos: "Arccos",
      atan: "Arctan",
      // Inverse hyperbolic
      arcsinh: "Arsinh",
      arccosh: "Arcosh",
      arctanh: "Artanh",
      arccoth: "Arcoth",
      arcsech: "Arsech",
      arccsch: "Arcsch",
      asinh: "Arsinh",
      acosh: "Arcosh",
      atanh: "Artanh",
      // Logarithms and exponentials
      log: "Log",
      ln: "Ln",
      exp: "Exp",
      lg: "Lg",
      lb: "Lb",
      // Other common functions
      sqrt: "Sqrt",
      abs: "Abs",
      sgn: "Sgn",
      sign: "Sgn",
      floor: "Floor",
      ceil: "Ceil",
      round: "Round",
      max: "Max",
      min: "Min",
      gcd: "Gcd",
      lcm: "Lcm"
    };
    const fnName = BARE_FUNCTION_MAP[name];
    if (!fnName) {
      this.index = start;
      return null;
    }
    const args = this.parseArguments("enclosure", until);
    if (args === null) {
      this.index = start;
      return null;
    }
    return [fnName, ...args];
  }
  /**
   * Parse a sequence superfix/subfix operator, e.g. `^{*}`
   *
   * Superfix and subfix need special handling:
   *
   * - they act mostly like an infix operator, but they are commutative, i.e.
   * `x_a^b` should be parsed identically to `x^b_a`.
   *
   * - furthermore, in LaTeX `x^a^b` parses the same as `x^a{}^b`.
   *
   */
  parseSupsub(lhs) {
    if (this.atEnd) return lhs;
    console.assert(lhs !== null);
    const index = this.index;
    this.skipSpace();
    const superscripts = [];
    const subscripts = [];
    let subIndex = index;
    while (this.peek === "_" || this.peek === "^") {
      if (this.match("_")) {
        subIndex = this.index;
        if (this.match("_") || this.match("^"))
          subscripts.push(this.error("syntax-error", subIndex));
        else {
          let sub3 = this.parseGroup() ?? this.parseToken();
          if (sub3 === null && this.options.strict === false && this.peek === "(")
            sub3 = this.parseEnclosure();
          sub3 ??= this.parseStringGroup();
          if (sub3 === null) return this.error("missing", index);
          subscripts.push(sub3);
        }
      } else if (this.match("^")) {
        subIndex = this.index;
        if (this.match("_") || this.match("^"))
          superscripts.push(this.error("syntax-error", subIndex));
        else {
          let sup = this.parseGroup() ?? this.parseToken();
          if (sup === null && this.options.strict === false && this.peek === "(")
            sup = this.parseEnclosure();
          if (sup === null) return this.error("missing", index);
          superscripts.push(sup);
        }
      }
      subIndex = this.index;
      this.skipSpace();
    }
    if (superscripts.length === 0 && subscripts.length === 0) {
      this.index = index;
      return lhs;
    }
    let result = lhs;
    if (subscripts.length > 0) {
      const defs = [...this.getDefs("infix")].filter(
        (x) => x.latexTrigger === "_"
      );
      if (defs) {
        const arg = [
          "Subscript",
          result,
          subscripts.length === 1 ? subscripts[0] : ["List", ...subscripts]
        ];
        for (const def of defs) {
          if (typeof def.parse === "function")
            result = def.parse(this, arg, { minPrec: 0 });
          else result = arg;
          if (result !== null) break;
        }
      }
    }
    if (superscripts.length > 0) {
      const defs = [...this.getDefs("infix")].filter(
        (x) => x.latexTrigger === "^"
      );
      if (defs) {
        const nonEmptySuperscripts = superscripts.filter(
          (x) => !isEmptySequence(x)
        );
        if (nonEmptySuperscripts.length !== 0) {
          const superscriptExpression = nonEmptySuperscripts.length === 1 ? nonEmptySuperscripts[0] : ["List", ...nonEmptySuperscripts];
          const arg = [
            "Superscript",
            result,
            superscriptExpression
          ];
          for (const def of defs) {
            if (typeof def.parse === "function")
              result = def.parse(this, arg, { minPrec: 0 });
            else result = arg;
            if (result !== null) break;
          }
        }
      }
    }
    if (result === null) this.index = index;
    return result;
  }
  parsePostfixOperator(lhs, until) {
    console.assert(lhs !== null);
    if (lhs === null || this.atEnd) return null;
    const start = this.index;
    for (const [def, n] of this.peekDefinitions("postfix")) {
      this.index = start + n;
      const result = def.parse(this, lhs, until);
      if (result !== null) return result;
    }
    this.index = start;
    return null;
  }
  /**
   * This method can be invoked when we know we're in an error situation,
   * for example when there are tokens remaining after we've finished parsing.
   *
   * In general, if a context does not apply, we return `null` to give
   * the chance to some other option to be considered. However, in some cases
   * we know we've exhausted all possibilities, and in this case this method
   * will return an error expression as informative as possible.
   *
   * We've encountered a LaTeX command or symbol but were not able to match it
   * to any entry in the LaTeX dictionary, or ran into it in an unexpected
   * context (postfix operator lacking an argument, for example)
   */
  parseSyntaxError() {
    const start = this.index;
    if (this.peek === "^") {
      this.index += 1;
      return [
        "Superscript",
        this.error("missing", start),
        missingIfEmpty(this.parseGroup())
      ];
    }
    let opDefs = this.peekDefinitions("operator");
    if (opDefs.length > 0) {
      opDefs = this.peekDefinitions("postfix");
      if (opDefs.length > 0) {
        const [def, n] = opDefs[0];
        this.index += n;
        if (typeof def.parse === "function") {
          const result = def.parse(this, this.error("missing", start));
          if (result !== null) return result;
        }
        return this.error("unexpected-operator", start);
      }
      opDefs = this.peekDefinitions("prefix");
      if (opDefs.length > 0) {
        const [def, n] = opDefs[0];
        this.index += n;
        if (typeof def.parse === "function") {
          const result = def.parse(this, { minPrec: 0 });
          if (result !== null) return result;
        }
        if (def.name)
          return [
            def.name,
            // @todo: pass a precedence?
            this.parseExpression() ?? this.error("missing", start)
          ];
        return this.error("unexpected-operator", start);
      }
      opDefs = this.peekDefinitions("infix");
      if (opDefs.length > 0) {
        const [def, n] = opDefs[0];
        this.index += n;
        const result = def.parse(this, this.error("missing", start), {
          minPrec: 0
        });
        if (result !== null) return result;
        return this.error("unexpected-operator", start);
      }
    }
    const index = this.index;
    let id = parseInvalidSymbol(this);
    if (id !== null) return id;
    id = parseSymbol(this);
    if (id !== null)
      return this.error(["unexpected-symbol", { str: id }], index);
    const command = this.peek;
    if (!command) return this.error("syntax-error", start);
    if (isDelimiterCommand(this))
      return this.error("unexpected-delimiter", start);
    if (command[0] !== "\\") {
      return this.error(
        ["unexpected-token", { str: tokensToString(command) }],
        start
      );
    }
    const errorToken = this.nextToken();
    this.skipSpaceTokens();
    if (errorToken === "\\end") {
      const name = this.parseStringGroup();
      return name === null ? this.error("expected-environment-name", start) : this.error(["unbalanced-environment", { str: name }], start);
    }
    while (this.match("[")) {
      let level = 0;
      while (!this.atEnd && level === 0 && this.peek !== "]") {
        if (this.peek === "[") level += 1;
        if (this.peek === "]") level -= 1;
        this.nextToken();
      }
      this.match("]");
    }
    while (this.match("<{>")) {
      let level = 0;
      while (!this.atEnd && level === 0 && this.peek !== "<}>") {
        if (this.peek === "<{>") level += 1;
        if (this.peek === "<}>") level -= 1;
        this.nextToken();
      }
      this.match("<}>");
    }
    return this.error(
      ["unexpected-command", { str: tokensToString(errorToken) }],
      start
    );
  }
  /**
   * <primary> :=
   *  (<number> | <symbol> | <environment> | <matchfix-expr>)
   *    <subsup>* <postfix-operator>*
   *
   * <symbol> ::=
   *  (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
   *
   * <matchfix-expr> :=
   *  <matchfix-op-open>
   *  <expression>
   *  (<matchfix-op-separator> <expression>)*
   *  <matchfix-op-close>
   *
   */
  parsePrimary(until) {
    if (this.atBoundary) return null;
    if (this.atTerminator(until)) return null;
    let result = null;
    const start = this.index;
    if (this.match("<}>"))
      return this.error("unexpected-closing-delimiter", start);
    result ??= this.parseGroup();
    result ??= this.parseNumber();
    result ??= this.parseEnclosure();
    result ??= this.parseEnvironment(until);
    if (result === null && this.matchAll(this._positiveInfinityTokens))
      result = "PositiveInfinity";
    if (result === null && this.matchAll(this._negativeInfinityTokens))
      result = "NegativeInfinity";
    if (result === null && this.matchAll(this._notANumberTokens))
      result = "NaN";
    if (result === null && this.matchAll(this._imaginaryUnitTokens))
      result = "ImaginaryUnit";
    result ??= this.tryParseBareFunction(until);
    result ??= this.parseGenericExpression(until) ?? this.parseFunction(until) ?? this.parseSymbol(until) ?? parseInvalidSymbol(this);
    if (result !== null && isEmptySequence(result))
      return this.parsePrimary(until);
    if (result !== null) {
      result = this.decorate(result, start);
      let postfix = null;
      let index = this.index;
      do {
        postfix = this.parsePostfixOperator(result, until);
        result = postfix ?? result;
        if (this.index === index && postfix !== null) {
          console.assert(this.index !== index, "No token consumed");
          break;
        }
        index = this.index;
      } while (postfix !== null);
    }
    if (result !== null) result = this.parseSupsub(result);
    if (result === null) {
      result = this.options.parseUnexpectedToken?.(null, this) ?? null;
      if (result === null && this.peek.startsWith("\\")) {
        this.nextToken();
        result = this.error("unexpected-command", start);
      }
    }
    return this.decorate(result, start);
  }
  /**
   *  Parse an expression:
   *
   * <expression> ::=
   *  | <primary>
   *  | <prefix-op> <primary>
   *  | <primary> <infix-op> <expression>
   *
   * Stop when an operator of precedence less than `until.minPrec`
   * is encountered
   */
  parseExpression(until) {
    this.skipSpace();
    const start = this.index;
    if (this.atBoundary) {
      this.index = start;
      return null;
    }
    until ??= { minPrec: 0 };
    console.assert(until.minPrec !== void 0);
    if (until.minPrec === void 0) until = { ...until, minPrec: 0 };
    let lhs = this.parsePrefixOperator({ ...until, minPrec: 0 });
    lhs ??= this.parsePrimary(until);
    if (lhs !== null) {
      let done = false;
      while (!done && !this.atTerminator(until)) {
        this.skipSpace();
        let result = this.parseInfixOperator(lhs, until);
        if (result === null && until.minPrec <= INVISIBLE_OP_PRECEDENCE) {
          if (this.peekDefinitions("operator").length === 0) {
            const rhs = this.parseExpression({
              ...until,
              minPrec: INVISIBLE_OP_PRECEDENCE + 1
            });
            if (rhs !== null) {
              if (operator(lhs) === "InvisibleOperator") {
                if (operator(rhs) === "InvisibleOperator")
                  result = [
                    "InvisibleOperator",
                    ...operands(lhs),
                    ...operands(rhs)
                  ];
                else result = ["InvisibleOperator", ...operands(lhs), rhs];
              } else if (operator(rhs) === "InvisibleOperator") {
                result = ["InvisibleOperator", lhs, ...operands(rhs)];
              } else result = ["InvisibleOperator", lhs, rhs];
            } else {
              if (result === null) {
                result = this.options.parseUnexpectedToken?.(lhs, this) ?? null;
              }
            }
          }
        }
        if (result !== null) {
          lhs = result;
        } else {
          done = true;
        }
      }
    }
    return this.decorate(lhs, start);
  }
  /**
   * Add LaTeX or other requested metadata to the expression
   */
  decorate(expr, start) {
    if (expr === null) return null;
    if (!this.options.preserveLatex) return expr;
    const latex = this.latex(start, this.index);
    if (Array.isArray(expr)) {
      expr = { latex, fn: expr };
    } else if (typeof expr === "number") {
      expr = { latex, num: Number(expr).toString() };
    } else if (typeof expr === "string") {
      if (expr.startsWith("'")) {
        expr = { latex, str: expr.slice(1, -1) };
      } else {
        expr = { latex, sym: expr };
      }
    } else if (typeof expr === "object" && expr !== null) {
      expr.latex = latex;
    }
    return expr;
  }
  error(code, fromToken) {
    let msg;
    if (typeof code === "string") {
      console.assert(!code.startsWith("'"));
      msg = { str: code };
    } else {
      console.assert(!code[0].startsWith("'"));
      msg = ["ErrorCode", { str: code[0] }, ...code.slice(1)];
    }
    const latex = this.latex(fromToken, this.index);
    return latex ? ["Error", msg, ["LatexString", { str: latex }]] : ["Error", msg];
  }
  isFunctionOperator(id) {
    if (id === null) return false;
    if (id === "D" || id === "N") return false;
    if (this.getSymbolType(id).matches("function")) return true;
    return false;
  }
  /**
   * Check if a symbol looks like a predicate in First-Order Logic.
   * A predicate is typically a single uppercase letter (P, Q, R, etc.)
   * followed by parentheses containing arguments.
   *
   * This enables automatic inference of predicates without explicit declaration,
   * so `\forall x. P(x)` works without having to declare `P` as a function.
   */
  looksLikePredicate(id) {
    if (id === null || typeof id !== "string") return false;
    if (!/^[A-Z]$/.test(id)) return false;
    this.skipSpace();
    return this.peek === "(" || this.peek === "\\left";
  }
  /** Return all defs of the specified kind.
   * The defs at the end of the dictionary have priority, since they may
   * override previous definitions. (For example, there is a core definition
   * for matchfix[], which maps to a List, and a logic definition which
   * matches to Boole. The logic definition should take precedence.)
   */
  *getDefs(kind) {
    if (kind === "operator") {
      for (let i = this._dictionary.defs.length - 1; i >= 0; i--) {
        const def = this._dictionary.defs[i];
        if (/^prefix|infix|postfix/.test(def.kind)) yield def;
      }
    } else {
      for (let i = this._dictionary.defs.length - 1; i >= 0; i--) {
        const def = this._dictionary.defs[i];
        if (def.kind === kind) yield def;
      }
    }
  }
};
function parseComplexId(parser, id) {
  const start = parser.index;
  const candidate = parseSymbol(parser)?.trim();
  if (candidate === null) return 0;
  const result = candidate !== id ? 0 : parser.index - start;
  parser.index = start;
  return result;
}
function isDelimiterCommand(parser) {
  const command = parser.peek;
  if (Object.values(CLOSE_DELIMITER).includes(command) || CLOSE_DELIMITER[command]) {
    parser.nextToken();
    return true;
  }
  if (OPEN_DELIMITER_PREFIX[command] || Object.values(OPEN_DELIMITER_PREFIX).includes(command)) {
    parser.nextToken();
    parser.nextToken();
    return true;
  }
  return false;
}
function dotOverDigit(parser) {
  const start = parser.index;
  if (parser.matchAll([`\\overset`, "<{>"])) {
    if (parser.match(".") || parser.match("\\cdots")) {
      if (parser.matchAll([`<}>`, "<{>"])) {
        const digit = parser.nextToken();
        if (digit && /^\d$/.test(digit)) {
          if (parser.match("<}>")) {
            return digit;
          }
        }
      }
    }
  }
  parser.index = start;
  return null;
}
function mayBeRepeatingDigits(parser) {
  const peek = parser.peek;
  if (peek === "\\overline") return true;
  if (peek === "\\overset") return true;
  if (peek === "\\wideparent" || peek === "\\overarc") return true;
  if (peek === "(") return true;
  if (peek === "\\left") return true;
  return false;
}
function parse2(latex, dictionary, options) {
  const parser = new _Parser(tokenize(latex), dictionary, options);
  let expr = parser.parseExpression();
  if (!parser.atEnd) {
    const error = parser.parseSyntaxError();
    expr = expr !== null ? ["Sequence", expr, error] : error;
  }
  expr ??= "Nothing";
  if (options.preserveLatex) {
    if (Array.isArray(expr)) return { latex, fn: expr };
    if (typeof expr === "number")
      return { latex, num: Number(expr).toString() };
    if (typeof expr === "string") {
      if (matchesString(expr)) return { latex, str: stringValue(expr) };
      if (matchesSymbol(expr)) return { latex, sym: expr };
      if (matchesNumber(expr)) return { latex, num: expr };
    }
    if (typeof expr === "object" && expr !== null)
      expr.latex = latex;
  }
  return expr;
}
function numberExpression(n) {
  if (n === 0) return { num: "0" };
  if (Number.isInteger(n) && Math.abs(n) < SMALL_INTEGER) return n;
  return { num: n.toString() };
}

// src/compute-engine/index.ts
init_utils3();

// src/compute-engine/library/library.ts
init_arithmetic();

// src/compute-engine/library/calculus.ts
init_validate();
init_utils5();
init_function_utils();

// src/compute-engine/numerics/monte-carlo.ts
function roundEstimateToError(estimate, error) {
  if (error === 0) return { estimate, error };
  const absError = Math.abs(error);
  const order3 = Math.floor(Math.log10(absError));
  const errorSigDigits = 2;
  const factor3 = Math.pow(10, order3 - (errorSigDigits - 1));
  const roundedError = Math.round(error / factor3) * factor3;
  const decimals = Math.max(0, -(order3 - (errorSigDigits - 1)));
  const roundedEstimate = Number(estimate.toFixed(decimals));
  return { estimate: roundedEstimate, error: roundedError };
}
function monteCarloEstimate(f, a, b, n = 1e5) {
  let sum2 = 0;
  let sumSq = 0;
  if (a === -Infinity && b === Infinity) {
    for (let i = 0; i < n; i++) {
      const u = Math.random();
      const x = Math.tan(Math.PI * (u - 0.5));
      const jacobian = Math.PI * (1 + x * x);
      const val = f(x) / jacobian;
      sum2 += val;
      sumSq += val * val;
    }
  } else if (a === -Infinity) {
    for (let i = 0; i < n; i++) {
      const u = Math.random();
      const x = b - Math.log(1 - u);
      const jacobian = 1 / (1 - u);
      const val = f(x) / jacobian;
      sum2 += val;
      sumSq += val * val;
    }
  } else if (b === Infinity) {
    for (let i = 0; i < n; i++) {
      const u = Math.random();
      const x = a + Math.log(u);
      const jacobian = 1 / u;
      const val = f(x) / jacobian;
      sum2 += val;
      sumSq += val * val;
    }
  } else {
    for (let i = 0; i < n; i++) {
      const val = f(a + Math.random() * (b - a));
      sum2 += val;
      sumSq += val * val;
    }
  }
  const mean2 = sum2 / n;
  const variance2 = (sumSq - n * mean2 * mean2) / (n - 1);
  const stdError = Math.sqrt(variance2 / n);
  const scale = b - a;
  const estimate = mean2 * scale;
  const error = stdError * scale;
  const rounded = roundEstimateToError(estimate, error);
  return rounded;
}

// src/compute-engine/library/calculus.ts
init_numeric();

// src/compute-engine/symbolic/derivative.ts
init_function_utils();
init_arithmetic_mul_div();
init_arithmetic_add();
var MAX_DIFFERENTIATION_DEPTH = 100;
function simplifyDerivative(expr) {
  return expr;
}
var DERIVATIVES_TABLE = {
  Sin: ["Cos", "_"],
  Cos: ["Negate", ["Sin", "_"]],
  Tan: ["Power", ["Sec", "_"], 2],
  Sec: ["Multiply", ["Tan", "_"], ["Sec", "_"]],
  Csc: ["Multiply", ["Negate", ["Cot", "_"]], ["Csc", "_"]],
  Cot: ["Negate", ["Power", ["Csc", "_"], 2]],
  Arcsin: ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]],
  Arccos: [
    "Negate",
    ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]]
  ],
  Arctan: ["Power", ["Add", 1, ["Power", "_", 2]], -1],
  Arcsec: [
    "Multiply",
    ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]],
    ["Negate", ["Power", "_", 2]]
  ],
  Arccsc: [
    "Multiply",
    ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]],
    ["Negate", ["Power", "_", 2]]
  ],
  Arccot: ["Negate", ["Power", ["Add", 1, ["Power", "_", 2]], -1]],
  Sinh: ["Cosh", "_"],
  Cosh: ["Sinh", "_"],
  Tanh: ["Power", ["Sech", "_"], 2],
  // d/dx sech(x) = -tanh(x)*sech(x)
  Sech: ["Negate", ["Multiply", ["Tanh", "_"], ["Sech", "_"]]],
  // d/dx csch(x) = -coth(x)*csch(x)
  Csch: ["Negate", ["Multiply", ["Coth", "_"], ["Csch", "_"]]],
  Coth: ["Negate", ["Power", ["Csch", "_"], 2]],
  Arsinh: ["Power", ["Add", ["Power", "_", 2], 1], ["Negate", "Half"]],
  Arcosh: ["Power", ["Subtract", ["Power", "_", 2], 1], ["Negate", "Half"]],
  Artanh: ["Power", ["Subtract", 1, ["Power", "_", 2]], -1],
  // d/dx arsech(x) = -1 / (x * sqrt(1 - x^2))
  Arsech: [
    "Negate",
    [
      "Divide",
      1,
      ["Multiply", "_", ["Sqrt", ["Subtract", 1, ["Power", "_", 2]]]]
    ]
  ],
  // d/dx arcsch(x) = -1 / (|x| * sqrt(1 + x^2))
  Arcsch: [
    "Negate",
    [
      "Divide",
      1,
      ["Multiply", ["Abs", "_"], ["Sqrt", ["Add", 1, ["Power", "_", 2]]]]
    ]
  ],
  Arcoth: ["Negate", ["Power", ["Subtract", 1, ["Power", "_", 2]], -1]],
  // Exp: ['Exp', '_'],   // Gets canonicalized to Power
  Ln: ["Divide", 1, "_"],
  Log: ["Power", ["Multiply", "_", ["Ln", "10"]], -1],
  Sqrt: ["Multiply", ["Power", "_", ["Negate", "Half"]], "Half"],
  // d/dx |x| = x/|x| = sign(x) for x  0 (undefined at x = 0)
  Abs: ["Sign", "_"],
  // Step functions: derivative is 0 almost everywhere (undefined at discontinuities)
  Floor: 0,
  Ceil: 0,
  Round: 0,
  // https://proofwiki.org/wiki/Derivative_of_Error_Function
  Erf: [
    "Multiply",
    ["Divide", "2", ["Sqrt", "Pi"]],
    ["Exp", ["Negate", ["Square", "_"]]]
  ],
  // https://proofwiki.org/wiki/Derivative_of_Gamma_Function
  // https://en.wikipedia.org/wiki/Gamma_function
  // d/dx (x) = (x)(x) where  is the digamma function
  Gamma: ["Multiply", ["Gamma", "_"], ["Digamma", "_"]],
  // d/dx erfc(x) = -d/dx erf(x) = -2/ * e^(-x)
  Erfc: [
    "Negate",
    [
      "Multiply",
      ["Divide", 2, ["Sqrt", "Pi"]],
      ["Exp", ["Negate", ["Square", "_"]]]
    ]
  ],
  // d/dx ln((x)) = (x) (digamma function)
  LogGamma: ["Digamma", "_"],
  // d/dx (x) = (x) (trigamma function)
  // https://en.wikipedia.org/wiki/Trigamma_function
  Digamma: ["Trigamma", "_"],
  // d/dx W(x) = W(x)/(x(1+W(x))) where W is the Lambert W function
  // https://en.wikipedia.org/wiki/Lambert_W_function#Derivative
  LambertW: [
    "Divide",
    ["LambertW", "_"],
    ["Multiply", "_", ["Add", 1, ["LambertW", "_"]]]
  ],
  // d/dx S(x) = sin(x/2) where S is the Fresnel sine integral
  FresnelS: ["Sin", ["Multiply", ["Divide", "Pi", 2], ["Square", "_"]]],
  // d/dx C(x) = cos(x/2) where C is the Fresnel cosine integral
  FresnelC: ["Cos", ["Multiply", ["Divide", "Pi", 2], ["Square", "_"]]],
  // d/dx erfi(x) = (2/)e^(x) where erfi is the imaginary error function
  Erfi: ["Multiply", ["Divide", 2, ["Sqrt", "Pi"]], ["Exp", ["Square", "_"]]]
  // Note: Bessel functions (BesselJ, BesselY, BesselI, BesselK) and Airy functions
  // (AiryAi, AiryBi) have been omitted because their derivatives involve functions
  // of different orders or related derivative functions that are not in the standard
  // function set. For example, d/dx J_n(x) = (J_{n-1}(x) - J_{n+1}(x))/2.
  //
  // Similarly, Zeta, PolyGamma, and Beta derivatives are omitted because
  // they either don't have simple closed forms or involve the polygamma function
  // with varying orders.
};
function derivative(fn, order3) {
  if (order3 === 0) return fn;
  const ce = fn.engine;
  let v = "_";
  if (fn.symbol && fn.operatorDefinition) {
    fn = apply3(ce.symbol(fn.symbol), [ce.symbol("_")]);
  }
  if (fn.operator === "Function") {
    v = fn.ops[1]?.symbol ?? "_";
    fn = fn.ops[0];
  }
  let result = fn;
  while (order3-- > 0 && result) result = differentiate(result, v);
  return result;
}
function differentiate(expr, v, depth = 0) {
  if (depth > MAX_DIFFERENTIATION_DEPTH) {
    console.assert(
      false,
      `Differentiation depth limit (${MAX_DIFFERENTIATION_DEPTH}) exceeded`
    );
    return void 0;
  }
  const ce = expr.engine;
  if (expr.string) return void 0;
  if (expr.isNumberLiteral) return expr.engine.Zero;
  if (expr.symbol === v) return expr.engine.One;
  if (expr.symbol) return expr.engine.Zero;
  if (!expr.operator) return void 0;
  if (expr.operator === "Negate") {
    const gPrime2 = differentiate(expr.op1, v, depth + 1);
    if (gPrime2) return gPrime2.neg();
    return ce._fn("D", [expr.op1, ce.symbol(v)]).neg();
  }
  if (expr.operator === "Block") {
    return differentiate(expr.op1, v, depth + 1);
  }
  if (expr.operator === "D") {
    const evaluated = expr.evaluate();
    if (evaluated.operator === "D") return void 0;
    return differentiate(evaluated, v, depth + 1);
  }
  if (expr.operator === "Add") {
    const terms = expr.ops.map((op) => differentiate(op, v, depth + 1));
    if (terms.some((term) => term === void 0)) return void 0;
    return simplifyDerivative(add3(...terms));
  }
  if (expr.operator === "Multiply") {
    const terms = expr.ops.map((op, i) => {
      const otherTerms = expr.ops.slice();
      otherTerms.splice(i, 1);
      const otherProduct = mul3(...otherTerms);
      const gPrime2 = differentiate(op, v, depth + 1) ?? ce._fn("D", [op, ce.symbol(v)]);
      return gPrime2.mul(otherProduct);
    });
    if (terms.some((term) => term === void 0)) return void 0;
    return simplifyDerivative(add3(...terms));
  }
  if (expr.operator === "Root") {
    const [base, n] = expr.ops;
    if (!base.has(v)) return ce.Zero;
    const exponent = ce.One.div(n);
    const basePrime = differentiate(base, v, depth + 1) ?? ce._fn("D", [base, ce.symbol(v)]);
    const newExponent = exponent.sub(ce.One);
    const power = ce.function("Power", [base, newExponent], {
      structural: true
    });
    return simplifyDerivative(exponent.mul(power).mul(basePrime));
  }
  if (expr.operator === "Power") {
    const [base, exponent] = expr.ops;
    const baseHasV = base.has(v);
    const expHasV = exponent.has(v);
    if (!baseHasV && !expHasV) {
      return ce.Zero;
    }
    if (baseHasV && !expHasV) {
      const fPrime2 = differentiate(base, v, depth + 1) ?? ce._fn("D", [base, ce.symbol(v)]);
      return simplifyDerivative(
        exponent.mul(base.pow(exponent.add(ce.NegativeOne))).mul(fPrime2)
      );
    }
    if (!baseHasV && expHasV) {
      const gPrime3 = differentiate(exponent, v, depth + 1) ?? ce._fn("D", [exponent, ce.symbol(v)]);
      const lnBase = ce._fn("Ln", [base]);
      return simplifyDerivative(expr.mul(lnBase).mul(gPrime3));
    }
    const f = base;
    const g2 = exponent;
    const fPrime = differentiate(f, v, depth + 1) ?? ce._fn("D", [f, ce.symbol(v)]);
    const gPrime2 = differentiate(g2, v, depth + 1) ?? ce._fn("D", [g2, ce.symbol(v)]);
    const lnF = ce._fn("Ln", [f]);
    const term1 = gPrime2.mul(lnF);
    const term2 = g2.mul(fPrime).div(f);
    return simplifyDerivative(expr.mul(term1.add(term2)));
  }
  if (expr.operator === "Divide") {
    const [numerator, denominator] = expr.ops;
    const gPrime2 = differentiate(numerator, v, depth + 1) ?? ce._fn("D", [numerator, ce.symbol(v)]);
    const hPrime = differentiate(denominator, v, depth + 1) ?? ce._fn("D", [denominator, ce.symbol(v)]);
    return simplifyDerivative(
      gPrime2.mul(denominator).sub(hPrime.mul(numerator)).div(denominator.pow(2))
    );
  }
  if (expr.operator === "Log" && expr.nops === 2) {
    const [x, base] = expr.ops;
    const xHasV = x.has(v);
    const baseHasV = base.has(v);
    if (!xHasV && !baseHasV) {
      return ce.Zero;
    }
    if (xHasV && !baseHasV) {
      const xPrime = differentiate(x, v, depth + 1) ?? ce._fn("D", [x, ce.symbol(v)]);
      const lnBase2 = ce._fn("Ln", [base]);
      return simplifyDerivative(xPrime.div(x.mul(lnBase2)));
    }
    const lnX = ce._fn("Ln", [x]);
    const lnBase = ce._fn("Ln", [base]);
    return differentiate(lnX.div(lnBase), v, depth + 1);
  }
  if (["Mod", "GCD", "LCM"].includes(expr.operator)) {
    return ce.Zero;
  }
  if (["BesselJ", "BesselY", "BesselI", "BesselK"].includes(expr.operator) && expr.nops === 2) {
    const [order3, x] = expr.ops;
    const xHasV = x.has(v);
    const orderHasV = order3.has(v);
    if (!xHasV && !orderHasV) {
      return ce.Zero;
    }
    if (orderHasV) {
      return void 0;
    }
    const xPrime = differentiate(x, v, depth + 1) ?? ce._fn("D", [x, ce.symbol(v)]);
    const op = expr.operator;
    const nMinus1 = order3.sub(ce.One);
    const nPlus1 = order3.add(ce.One);
    let derivative2;
    if (op === "BesselJ" || op === "BesselY") {
      const fNMinus1 = ce._fn(op, [nMinus1, x]);
      const fNPlus1 = ce._fn(op, [nPlus1, x]);
      derivative2 = fNMinus1.sub(fNPlus1).div(2);
    } else if (op === "BesselI") {
      const fNMinus1 = ce._fn(op, [nMinus1, x]);
      const fNPlus1 = ce._fn(op, [nPlus1, x]);
      derivative2 = fNMinus1.add(fNPlus1).div(2);
    } else {
      const fNMinus1 = ce._fn(op, [nMinus1, x]);
      const fNPlus1 = ce._fn(op, [nPlus1, x]);
      derivative2 = fNMinus1.add(fNPlus1).div(2).neg();
    }
    return simplifyDerivative(derivative2.mul(xPrime));
  }
  const h = DERIVATIVES_TABLE[expr.operator];
  if (h === void 0) {
    if (expr.nops > 1) return void 0;
    const fPrime = ce._fn("Derivative", [ce.symbol(expr.operator), ce.One]);
    if (!fPrime.isValid) return void 0;
    const g2 = expr.ops[0];
    const gPrime2 = differentiate(g2, v, depth + 1) ?? ce._fn("D", [g2, ce.symbol(v)]);
    if (!gPrime2.isValid) return void 0;
    return ce._fn("Apply", [fPrime, g2]).mul(gPrime2);
  }
  if (expr.nops > 1) return ce._fn("D", [expr, ce.symbol(v)]);
  const g = expr.ops[0];
  const gPrime = differentiate(g, v, depth + 1) ?? ce._fn("D", [g, ce.symbol(v)]);
  const derivFormula = ce.box(h).subs({ _: g });
  return simplifyDerivative(derivFormula.mul(gPrime));
}

// src/compute-engine/symbolic/antiderivative.ts
init_arithmetic_mul_div();
init_arithmetic_add();
init_rules();
init_expand();
init_solve();
init_polynomials();
function liatePriority(expr, index) {
  if (!expr.has(index)) return 0;
  const op = expr.operator;
  if (op === "Ln" || op === "Log" || op === "Log2" || op === "Log10") return 5;
  if (op === "Arcsin" || op === "Arccos" || op === "Arctan" || op === "Arcsec" || op === "Arccsc" || op === "Arccot")
    return 4;
  if (expr.symbol === index) return 3;
  if (op === "Power" && expr.op1.symbol === index && !expr.op2.has(index))
    return 3;
  if (op === "Sqrt" && expr.op1.has(index)) return 3;
  if (op === "Sin" || op === "Cos" || op === "Tan" || op === "Sec" || op === "Csc" || op === "Cot")
    return 2;
  if (op === "Exp") return 1;
  if (op === "Power" && !expr.op1.has(index) && expr.op2.has(index)) return 1;
  return 3;
}
function tryIntegrationByParts(factors, index, depth = 0) {
  if (factors.length < 2 || depth > 2) return null;
  const ce = factors[0].engine;
  const sorted = [...factors].sort(
    (a, b) => liatePriority(b, index) - liatePriority(a, index)
  );
  const u = sorted[0];
  const dvFactors = sorted.slice(1);
  const dv = dvFactors.length === 1 ? dvFactors[0] : mul3(...dvFactors);
  const du = differentiate(u, index);
  if (!du) return null;
  const v = antiderivativeSimple(dv, index);
  if (!v || v.operator === "Integrate") return null;
  const uv = u.mul(v);
  const vdu = v.mul(du);
  const integralVdu = antiderivativeWithByParts(vdu, index, depth + 1);
  if (!integralVdu || integralVdu.operator === "Integrate") return null;
  return uv.sub(integralVdu).simplify();
}
function antiderivativeSimple(fn, index) {
  const ce = fn.engine;
  if (fn.symbol === index)
    return ce.box(["Divide", ["Power", fn, 2], 2]).simplify();
  if (!fn.has(index))
    return ce.box(["Multiply", fn, ce.symbol(index)]).simplify();
  if (fn.operator === "Sin" && fn.op1.symbol === index)
    return ce.box(["Negate", ["Cos", index]]);
  if (fn.operator === "Cos" && fn.op1.symbol === index)
    return ce.box(["Sin", index]);
  if (fn.operator === "Exp" && fn.op1.symbol === index) return fn;
  if (fn.operator === "Power" && fn.op1.symbol === "ExponentialE" && fn.op2.symbol === index)
    return fn;
  if (fn.operator === "Power" && fn.op1.symbol === index) {
    const exponent = fn.op2;
    if (!exponent.has(index) && !exponent.is(-1)) {
      return ce.box([
        "Divide",
        ["Power", index, ["Add", exponent, 1]],
        ["Add", exponent, 1]
      ]).simplify();
    }
  }
  return null;
}
function antiderivativeWithByParts(fn, index, depth) {
  const simple = antiderivativeSimple(fn, index);
  if (simple) return simple;
  if (fn.operator === "Multiply") {
    const variableFactors = fn.ops.filter((op) => op.has(index));
    if (variableFactors.length >= 2) {
      const result = tryIntegrationByParts(variableFactors, index, depth);
      if (result) {
        const constantFactors = fn.ops.filter((op) => !op.has(index));
        if (constantFactors.length > 0) {
          return mul3(...constantFactors).mul(result);
        }
        return result;
      }
    }
  }
  return antiderivative(fn, index);
}
function tryUSubstitution(fn, index) {
  if (fn.operator !== "Multiply") return null;
  const ce = fn.engine;
  const factors = fn.ops;
  for (let i = 0; i < factors.length; i++) {
    const factor3 = factors[i];
    const innerFunc = getInnerFunction(factor3, index);
    if (!innerFunc) continue;
    const { outer, inner } = innerFunc;
    const innerDerivative = differentiate(inner, index);
    if (!innerDerivative) continue;
    const otherFactors = factors.filter((_, j) => j !== i);
    const otherProduct = otherFactors.length === 1 ? otherFactors[0] : mul3(...otherFactors);
    const ratio = tryGetConstantRatio(otherProduct, innerDerivative, index);
    if (ratio === null) continue;
    const dummy = ce.symbol("_u_");
    const outerAtDummy = applyOuter(outer, dummy, ce);
    const outerAntideriv = antiderivativeSimple(outerAtDummy, "_u_");
    if (!outerAntideriv) continue;
    const result = outerAntideriv.subs({ _u_: inner });
    if (!ratio.is(1)) {
      return ratio.mul(result).simplify();
    }
    return result.simplify();
  }
  return null;
}
function getInnerFunction(expr, index) {
  const op = expr.operator;
  if (!op) return null;
  const compositeFunctions = [
    "Sin",
    "Cos",
    "Tan",
    "Sec",
    "Csc",
    "Cot",
    "Exp",
    "Ln",
    "Sinh",
    "Cosh",
    "Tanh",
    "Sqrt"
  ];
  if (compositeFunctions.includes(op) && expr.nops === 1) {
    const inner = expr.op1;
    if (inner.symbol === index) return null;
    if (inner.has(index)) {
      return { outer: op, inner };
    }
  }
  if (op === "Power" && expr.op1.symbol === "ExponentialE") {
    const inner = expr.op2;
    if (inner.symbol === index) return null;
    if (inner.has(index)) {
      return { outer: "Exp", inner };
    }
  }
  return null;
}
function applyOuter(outer, arg, ce) {
  if (outer === "Exp") {
    return ce.box(["Power", "ExponentialE", arg]);
  }
  return ce.box([outer, arg]);
}
function tryLinearSubstitution(fn, index) {
  const ce = fn.engine;
  const innerInfo = getInnerFunction(fn, index);
  if (!innerInfo) return null;
  const { outer, inner } = innerInfo;
  let coefficient = null;
  if (inner.operator === "Multiply") {
    const factors = inner.ops;
    const varFactor = factors.find((f) => f.symbol === index);
    if (varFactor) {
      const constFactors = factors.filter((f) => f !== varFactor);
      if (constFactors.every((f) => !f.has(index))) {
        coefficient = constFactors.length === 1 ? constFactors[0] : ce.box(["Multiply", ...constFactors]);
      }
    }
  } else if (inner.operator === "Add") {
    const terms = inner.ops;
    let linearTerm = null;
    const constantTerms = [];
    for (const term of terms) {
      if (!term.has(index)) {
        constantTerms.push(term);
      } else if (term.symbol === index) {
        linearTerm = ce.One;
      } else if (term.operator === "Multiply") {
        const factors = term.ops;
        const varFactor = factors.find((f) => f.symbol === index);
        if (varFactor) {
          const constFactors = factors.filter((f) => f !== varFactor);
          if (constFactors.every((f) => !f.has(index))) {
            linearTerm = constFactors.length === 1 ? constFactors[0] : ce.box(["Multiply", ...constFactors]);
          }
        }
      } else {
        return null;
      }
    }
    if (linearTerm) {
      coefficient = linearTerm;
    }
  }
  if (!coefficient) return null;
  const dummy = ce.symbol("_u_");
  const outerAtDummy = applyOuter(outer, dummy, ce);
  const outerAntideriv = antiderivativeSimple(outerAtDummy, "_u_");
  if (!outerAntideriv) return null;
  const result = outerAntideriv.subs({ _u_: inner });
  return result.div(coefficient).simplify();
}
function tryGetConstantRatio(expr1, expr2, index) {
  const ce = expr1.engine;
  if (expr1.isSame(expr2)) return ce.One;
  const ratio = expr1.div(expr2).simplify();
  if (!ratio.has(index)) {
    return ratio;
  }
  return null;
}
function tryCyclicExpTrigIntegral(factors, index) {
  if (factors.length !== 2) return null;
  const ce = factors[0].engine;
  let expFactor = null;
  let trigFactor = null;
  for (const f of factors) {
    if (f.operator === "Exp" && f.op1.symbol === index) {
      expFactor = f;
    } else if (f.operator === "Power" && f.op1.symbol === "ExponentialE" && f.op2.symbol === index) {
      expFactor = f;
    } else if (f.operator === "Sin" || f.operator === "Cos") {
      trigFactor = f;
    }
  }
  if (!expFactor || !trigFactor) return null;
  const trigOp = trigFactor.operator;
  const trigArg = trigFactor.op1;
  if (trigArg.symbol === index) {
    if (trigOp === "Sin") {
      return ce.box([
        "Multiply",
        ["Rational", 1, 2],
        ["Exp", index],
        ["Subtract", ["Sin", index], ["Cos", index]]
      ]).simplify();
    } else {
      return ce.box([
        "Multiply",
        ["Rational", 1, 2],
        ["Exp", index],
        ["Add", ["Sin", index], ["Cos", index]]
      ]).simplify();
    }
  }
  if (trigArg.operator === "Multiply" && trigArg.ops) {
    let coefficient = null;
    let hasIndex = false;
    for (const op of trigArg.ops) {
      if (op.symbol === index) {
        hasIndex = true;
      } else if (!op.has(index)) {
        coefficient = coefficient ? coefficient.mul(op) : op;
      }
    }
    if (hasIndex && coefficient) {
      const a = coefficient;
      const expX = ce.box(["Exp", index]);
      const denominator = ce.box(["Add", ["Power", a.json, 2], 1]);
      const coeff = expX.div(denominator);
      if (trigOp === "Sin") {
        const sinPart = trigFactor;
        const cosPart = ce.box(["Cos", trigArg.json]);
        const result = coeff.mul(sinPart.sub(a.mul(cosPart)));
        return result.simplify();
      } else {
        const sinPart = ce.box(["Sin", trigArg.json]);
        const cosPart = trigFactor;
        const result = coeff.mul(a.mul(sinPart).add(cosPart));
        return result.simplify();
      }
    }
  }
  const linearCoeffs = getLinearCoefficients(trigArg, index);
  if (linearCoeffs) {
    const { a } = linearCoeffs;
    const expX = ce.box(["Exp", index]);
    const denominator = ce.box(["Add", ["Power", a.json, 2], 1]);
    const coeff = expX.div(denominator);
    if (trigOp === "Sin") {
      const sinPart = trigFactor;
      const cosPart = ce.box(["Cos", trigArg.json]);
      const result = coeff.mul(sinPart.sub(a.mul(cosPart)));
      return result.simplify();
    } else {
      const sinPart = ce.box(["Sin", trigArg.json]);
      const cosPart = trigFactor;
      const result = coeff.mul(a.mul(sinPart).add(cosPart));
      return result.simplify();
    }
  }
  return null;
}
function filter2(sub3) {
  for (const [k, v] of Object.entries(sub3)) {
    if (k !== "x" && k !== "_x" && v.has("_x")) return false;
  }
  return true;
}
var INTEGRATION_RULES = [
  // (ax+b)^n -> \frac{(ax + b)^{n + 1}}{a(n + 1)}
  {
    match: ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], "_n"],
    replace: [
      "Divide",
      ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], ["Add", "_n", 1]],
      ["Multiply", "_a", ["Add", "_n", 1]]
    ],
    condition: (sub3) => filter2(sub3) && !sub3._n.is(-1)
  },
  // \sqrt{ax + b} -> \frac{2}{3a} (ax + b)^{3/2}
  {
    match: ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 1 / 2],
    replace: [
      "Divide",
      ["Multiply", 2, ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 3]],
      ["Multiply", 3, "_a"]
    ],
    condition: (sub3) => filter2(sub3) && sub3._a.isNumberLiteral
  },
  // \sqrt[3]{ax + b} -> \frac{3}{4a} (ax + b)^{4/3}
  {
    match: ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 1 / 3],
    replace: [
      "Divide",
      ["Multiply", 3, ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 4]],
      ["Multiply", 4, "_a"]
    ],
    condition: (sub3) => filter2(sub3) && sub3._a.isNumberLiteral
  },
  // a^x -> \frac{a^x}{\ln(a)} where a is a constant (doesn't contain x)
  {
    match: ["Power", "_a", "_x"],
    replace: ["Divide", ["Power", "_a", "_x"], ["Ln", "_a"]],
    condition: (sub3) => filter2(sub3) && !sub3._a.has("_x")
  },
  // (ax+b)^{-1} -> \ln(ax + b) / a
  {
    match: ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], -1],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // (x+b)^{-1} -> \ln|x + b| (coefficient of x is implicitly 1)
  {
    match: ["Power", ["Add", "_x", "__b"], -1],
    replace: ["Ln", ["Abs", ["Add", "_x", "__b"]]],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // 1/(ax + b) -> \ln(ax + b) / a
  {
    match: ["Divide", 1, ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // 1/(x + b) -> \ln|x + b| (coefficient of x is implicitly 1)
  {
    match: ["Divide", 1, ["Add", "_x", "__b"]],
    replace: ["Ln", ["Abs", ["Add", "_x", "__b"]]],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // \ln(ax + b) -> (ax + b) \ln(ax + b) - ax - b
  {
    match: ["Ln", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Subtract",
      ["Multiply", ["Add", ["Multiply", "_a", "_x"], "__b"], ["Ln", "_x"]],
      ["Subtract", ["Multiply", "_a", "_x"], "__b"]
    ],
    condition: filter2
  },
  // \exp(ax + b) -> \frac{1}{a} \exp(ax + b)
  {
    match: ["Exp", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Exp", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // \sech^2(ax + b) -> \tanh(ax + b) / a
  {
    match: ["Power", ["Sech", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Tanh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // \sin^2(ax + b) -> \frac{1}{2} \left( x - \frac{\sin(2(ax + b))}{2a} \right)
  {
    match: ["Power", ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Add", "_x", ["Divide", ["Sin", ["Multiply", 2, "_a", "_x"]], 2]],
      2
    ],
    condition: filter2
  },
  // \cos^2(ax + b) -> \frac{1}{2} \left( x + \frac{\sin(2(ax + b))}{2a} \right)
  {
    match: ["Power", ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Add", "_x", ["Divide", ["Sin", ["Multiply", 2, "_a", "_x"]], 2]],
      2
    ],
    condition: filter2
  },
  // \sin(ax + b) -> -\cos(ax + b) / a
  {
    match: ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Negate", ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // \cos(ax + b) -> \sin(ax + b) / a
  {
    match: ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // \tan(ax + b) -> \ln(\sec(ax + b)) / a
  {
    match: ["Tan", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]]]],
      "_a"
    ],
    condition: filter2
  },
  // \sec(ax + b) -> \ln(\sec(ax + b) + \tan(ax + b)) / a
  {
    match: ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Ln",
        [
          "Abs",
          [
            "Add",
            ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]],
            ["Tan", ["Add", ["Multiply", "_a", "_x"], "__b"]]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \csc(ax + b) -> -\ln(\csc(ax + b) + \cot(ax + b)) / a
  {
    match: ["Csc", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        [
          "Ln",
          [
            "Abs",
            [
              "Add",
              ["Csc", ["Add", ["Multiply", "_a", "_x"], "__b"]],
              ["Cot", ["Add", ["Multiply", "_a", "_x"], "__b"]]
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \cot(ax + b) -> -\ln(\sin(ax + b)) / a
  {
    match: ["Cot", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        ["Ln", ["Abs", ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]]]]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \sec^2(ax + b) -> \tan(ax + b) / a
  {
    match: ["Power", ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Tan", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // \csc^2(ax + b) -> -\cot(ax + b) / a
  {
    match: ["Power", ["Csc", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Negate", ["Cot", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // \sec(ax + b) \tan(ax + b) -> \sec(ax + b) / a
  {
    match: [
      "Multiply",
      ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Tan", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Divide",
      ["Sec", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // \csc(ax + b) \cot(ax + b) -> -\csc(ax + b) / a
  {
    match: [
      "Multiply",
      ["Csc", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Cot", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Divide",
      ["Negate", ["Csc", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // \sinh(ax + b) -> \frac{1}{a} \ln(\cosh(ax + b))
  {
    match: ["Sinh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Cosh", ["Add", ["Multiply", "_a", "_x"], "__b"]]]],
      "_a"
    ],
    condition: filter2
  },
  // \cosh(ax + b) -> \frac{1}{a} \ln(\sinh(ax + b))
  {
    match: ["Cosh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Sinh", ["Add", ["Multiply", "_a", "_x"], "__b"]]]],
      "_a"
    ],
    condition: filter2
  },
  // \tanh(ax + b) -> \frac{1}{a} \ln(\sech(ax + b))
  {
    match: ["Tanh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Sech", ["Add", ["Multiply", "_a", "_x"], "__b"]]]],
      "_a"
    ],
    condition: filter2
  },
  // \sech(ax + b) -> \frac{1}{a} \ln(\tanh(ax + b))
  {
    match: ["Sech", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      ["Ln", ["Abs", ["Tanh", ["Add", ["Multiply", "_a", "_x"], "__b"]]]],
      "_a"
    ],
    condition: filter2
  },
  // \csch(ax + b) -> -\frac{1}{a} \ln(\coth(ax + b))
  {
    match: ["Csch", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        ["Ln", ["Abs", ["Coth", ["Add", ["Multiply", "_a", "_x"], "__b"]]]]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \coth(ax + b) -> -\frac{1}{a} \ln(\csch(ax + b))
  {
    match: ["Coth", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        ["Ln", ["Abs", ["Csch", ["Add", ["Multiply", "_a", "_x"], "__b"]]]]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arcsinh(ax + b) -> \frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 + 1})
  {
    match: ["Arsinh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Ln",
        [
          "Add",
          ["Add", ["Multiply", "_a", "_x"], "__b"],
          [
            "Sqrt",
            ["Add", ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2], 1]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arccosh(ax + b) -> \frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 - 1})
  {
    match: ["Arcosh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Ln",
        [
          "Add",
          ["Add", ["Multiply", "_a", "_x"], "__b"],
          [
            "Sqrt",
            [
              "Subtract",
              ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2],
              1
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arctanh(ax + b) -> \frac{1}{2a} \ln(\frac{1 + ax + b}{1 - ax - b})
  {
    match: ["Artanh", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Ln",
        [
          "Divide",
          ["Add", 1, ["Add", ["Multiply", "_a", "_x"], "__b"]],
          ["Subtract", 1, ["Add", ["Multiply", "_a", "_x"], "__b"]]
        ]
      ],
      ["Multiply", 2, "_a"]
    ],
    condition: filter2
  },
  // \arcsech(ax + b) -> -\frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 - 1})
  {
    match: ["Arsech", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        [
          "Ln",
          [
            "Add",
            ["Add", ["Multiply", "_a", "_x"], "__b"],
            [
              "Sqrt",
              [
                "Subtract",
                ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2],
                1
              ]
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arccsch(ax + b) -> -\frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 + 1})
  {
    match: ["Arcsch", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        [
          "Ln",
          [
            "Add",
            ["Add", ["Multiply", "_a", "_x"], "__b"],
            [
              "Sqrt",
              [
                "Add",
                ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2],
                1
              ]
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arccoth(ax + b) -> \frac{1}{2a} \ln(\frac{ax + b + 1}{ax + b - 1})
  {
    match: ["Arcoth", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Ln",
        [
          "Divide",
          ["Add", ["Add", ["Multiply", "_a", "_x"], "__b"], 1],
          ["Subtract", ["Add", ["Multiply", "_a", "_x"], "__b"], 1]
        ]
      ],
      ["Multiply", 2, "_a"]
    ],
    condition: filter2
  },
  // \arccsch(ax + b) -> -\frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 + 1})
  {
    match: ["Arcsch", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        [
          "Ln",
          [
            "Add",
            ["Add", ["Multiply", "_a", "_x"], "__b"],
            [
              "Sqrt",
              [
                "Add",
                ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2],
                1
              ]
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arccoth(ax + b) -> -\frac{1}{a} \ln(ax + b + \sqrt{(ax + b)^2 - 1})
  {
    match: ["Arcoth", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Negate",
        [
          "Ln",
          [
            "Add",
            ["Add", ["Multiply", "_a", "_x"], "__b"],
            [
              "Sqrt",
              [
                "Subtract",
                ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2],
                1
              ]
            ]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arctan(ax + b) -> (1/a) * [(ax+b)*arctan(ax+b) - (1/2)*ln(1+(ax+b)^2)]
  {
    match: ["Arctan", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Subtract",
        [
          "Multiply",
          ["Add", ["Multiply", "_a", "_x"], "__b"],
          ["Arctan", ["Add", ["Multiply", "_a", "_x"], "__b"]]
        ],
        [
          "Multiply",
          ["Rational", 1, 2],
          [
            "Ln",
            ["Add", 1, ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2]]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arccos(ax + b) -> (1/a) * [(ax+b)*arccos(ax+b) - sqrt(1-(ax+b)^2)]
  {
    match: ["Arccos", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Subtract",
        [
          "Multiply",
          ["Add", ["Multiply", "_a", "_x"], "__b"],
          ["Arccos", ["Add", ["Multiply", "_a", "_x"], "__b"]]
        ],
        [
          "Sqrt",
          [
            "Subtract",
            1,
            ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  // \arcsin(ax + b) -> (1/a) * [(ax+b)*arcsin(ax+b) + sqrt(1-(ax+b)^2)]
  {
    match: ["Arcsin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
    replace: [
      "Divide",
      [
        "Add",
        [
          "Multiply",
          ["Add", ["Multiply", "_a", "_x"], "__b"],
          ["Arcsin", ["Add", ["Multiply", "_a", "_x"], "__b"]]
        ],
        [
          "Sqrt",
          [
            "Subtract",
            1,
            ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2]
          ]
        ]
      ],
      "_a"
    ],
    condition: filter2
  },
  //
  // Inverse trig integrals (producing inverse trig functions)
  //
  // 1/(1 + (ax+b)^2) -> arctan(ax+b) / a
  // Canonical form: ['Divide', 1, ['Add', ['Power', ...], 1]]
  {
    match: [
      "Divide",
      1,
      ["Add", ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2], 1]
    ],
    replace: [
      "Divide",
      ["Arctan", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  // Also try with 1 first (non-canonical)
  {
    match: [
      "Divide",
      1,
      ["Add", 1, ["Power", ["Add", ["Multiply", "_a", "_x"], "__b"], 2]]
    ],
    replace: [
      "Divide",
      ["Arctan", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      "_a"
    ],
    condition: filter2
  },
  //
  // Additional hyperbolic integrals
  //
  // \csch^2(ax + b) -> -\coth(ax + b) / a
  {
    match: ["Power", ["Csch", ["Add", ["Multiply", "_a", "_x"], "__b"]], 2],
    replace: [
      "Divide",
      ["Negate", ["Coth", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // \sech(ax + b) \tanh(ax + b) -> -\sech(ax + b) / a
  {
    match: [
      "Multiply",
      ["Sech", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Tanh", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Divide",
      ["Negate", ["Sech", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  // \csch(ax + b) \coth(ax + b) -> -\csch(ax + b) / a
  {
    match: [
      "Multiply",
      ["Csch", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Coth", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Divide",
      ["Negate", ["Csch", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
      "_a"
    ],
    condition: filter2
  },
  //
  // Cyclic integration patterns (e^x with trig functions)
  // These require the "solve for the integral" technique
  //
  // e^x * sin(x) -> (e^x/2)(sin(x) - cos(x))
  {
    match: ["Multiply", ["Exp", "_x"], ["Sin", "_x"]],
    replace: [
      "Multiply",
      ["Rational", 1, 2],
      ["Exp", "_x"],
      ["Subtract", ["Sin", "_x"], ["Cos", "_x"]]
    ],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // e^x * cos(x) -> (e^x/2)(sin(x) + cos(x))
  {
    match: ["Multiply", ["Exp", "_x"], ["Cos", "_x"]],
    replace: [
      "Multiply",
      ["Rational", 1, 2],
      ["Exp", "_x"],
      ["Add", ["Sin", "_x"], ["Cos", "_x"]]
    ],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // sin(x) * e^x -> (e^x/2)(sin(x) - cos(x)) (commuted order)
  {
    match: ["Multiply", ["Sin", "_x"], ["Exp", "_x"]],
    replace: [
      "Multiply",
      ["Rational", 1, 2],
      ["Exp", "_x"],
      ["Subtract", ["Sin", "_x"], ["Cos", "_x"]]
    ],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // cos(x) * e^x -> (e^x/2)(sin(x) + cos(x)) (commuted order)
  {
    match: ["Multiply", ["Cos", "_x"], ["Exp", "_x"]],
    replace: [
      "Multiply",
      ["Rational", 1, 2],
      ["Exp", "_x"],
      ["Add", ["Sin", "_x"], ["Cos", "_x"]]
    ],
    condition: (sub3) => filter2(sub3) && sub3._x.symbol !== null
  },
  // e^x * sin(ax) -> (e^x/(a + 1))(sin(ax) - a*cos(ax)) (no constant term)
  {
    match: ["Multiply", ["Exp", "_x"], ["Sin", ["Multiply", "_a", "_x"]]],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Subtract",
        ["Sin", ["Multiply", "_a", "_x"]],
        ["Multiply", "_a", ["Cos", ["Multiply", "_a", "_x"]]]
      ]
    ],
    condition: filter2
  },
  // e^x * cos(ax) -> (e^x/(a + 1))(a*sin(ax) + cos(ax)) (no constant term)
  {
    match: ["Multiply", ["Exp", "_x"], ["Cos", ["Multiply", "_a", "_x"]]],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Add",
        ["Multiply", "_a", ["Sin", ["Multiply", "_a", "_x"]]],
        ["Cos", ["Multiply", "_a", "_x"]]
      ]
    ],
    condition: filter2
  },
  // sin(ax) * e^x -> (e^x/(a + 1))(sin(ax) - a*cos(ax)) (commuted)
  {
    match: ["Multiply", ["Sin", ["Multiply", "_a", "_x"]], ["Exp", "_x"]],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Subtract",
        ["Sin", ["Multiply", "_a", "_x"]],
        ["Multiply", "_a", ["Cos", ["Multiply", "_a", "_x"]]]
      ]
    ],
    condition: filter2
  },
  // cos(ax) * e^x -> (e^x/(a + 1))(a*sin(ax) + cos(ax)) (commuted)
  {
    match: ["Multiply", ["Cos", ["Multiply", "_a", "_x"]], ["Exp", "_x"]],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Add",
        ["Multiply", "_a", ["Sin", ["Multiply", "_a", "_x"]]],
        ["Cos", ["Multiply", "_a", "_x"]]
      ]
    ],
    condition: filter2
  },
  // General case: e^x * sin(ax + b) -> (e^x/(a + 1))(sin(ax+b) - a*cos(ax+b))
  {
    match: [
      "Multiply",
      ["Exp", "_x"],
      ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Subtract",
        ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
        ["Multiply", "_a", ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]]
      ]
    ],
    condition: filter2
  },
  // General case: e^x * cos(ax + b) -> (e^x/(a + 1))(a*sin(ax+b) + cos(ax+b))
  {
    match: [
      "Multiply",
      ["Exp", "_x"],
      ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]
    ],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Add",
        ["Multiply", "_a", ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
        ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]
      ]
    ],
    condition: filter2
  },
  // Commuted order: sin(ax + b) * e^x
  {
    match: [
      "Multiply",
      ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Exp", "_x"]
    ],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Subtract",
        ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]],
        ["Multiply", "_a", ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]]
      ]
    ],
    condition: filter2
  },
  // Commuted order: cos(ax + b) * e^x
  {
    match: [
      "Multiply",
      ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]],
      ["Exp", "_x"]
    ],
    replace: [
      "Multiply",
      ["Divide", ["Exp", "_x"], ["Add", ["Power", "_a", 2], 1]],
      [
        "Add",
        ["Multiply", "_a", ["Sin", ["Add", ["Multiply", "_a", "_x"], "__b"]]],
        ["Cos", ["Add", ["Multiply", "_a", "_x"], "__b"]]
      ]
    ],
    condition: filter2
  }
];
function getLinearCoefficients(expr, index) {
  const ce = expr.engine;
  if (expr.symbol === index) {
    return { a: ce.One, b: ce.Zero };
  }
  if (expr.operator !== "Add") return null;
  const ops = expr.ops;
  let a = null;
  let b = ce.Zero;
  for (const op of ops) {
    if (!op.has(index)) {
      b = b.add(op);
    } else if (op.symbol === index) {
      a = a ? a.add(ce.One) : ce.One;
    } else if (op.operator === "Multiply") {
      const factors = op.ops;
      const varFactor = factors.find((f) => f.symbol === index);
      if (varFactor) {
        const constFactors = factors.filter((f) => f.symbol !== index);
        if (constFactors.every((f) => !f.has(index))) {
          const coeff = constFactors.length === 1 ? constFactors[0] : mul3(...constFactors);
          a = a ? a.add(coeff) : coeff;
        } else {
          return null;
        }
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  if (a === null) return null;
  return { a, b };
}
function getQuadraticCoefficients(expr, index) {
  const ce = expr.engine;
  if (expr.operator !== "Add") {
    if (expr.operator === "Power" && expr.op1.symbol === index && expr.op2.is(2)) {
      return { a: ce.One, b: ce.Zero, c: ce.Zero };
    }
    if (expr.operator === "Multiply") {
      const factors = expr.ops;
      const powerFactor = factors.find(
        (f) => f.operator === "Power" && f.op1.symbol === index && f.op2.is(2)
      );
      if (powerFactor) {
        const constFactors = factors.filter((f) => f !== powerFactor);
        const coeff = constFactors.length === 0 ? ce.One : constFactors.length === 1 ? constFactors[0] : ce.box(["Multiply", ...constFactors]);
        if (!coeff.has(index)) {
          return { a: coeff, b: ce.Zero, c: ce.Zero };
        }
      }
    }
    return null;
  }
  const ops = expr.ops;
  let a = ce.Zero;
  let b = ce.Zero;
  let c = ce.Zero;
  for (const op of ops) {
    if (!op.has(index)) {
      c = c.add(op);
    } else if (op.symbol === index) {
      b = b.add(ce.One);
    } else if (op.operator === "Power" && op.op1.symbol === index && op.op2.is(2)) {
      a = a.add(ce.One);
    } else if (op.operator === "Multiply") {
      const factors = op.ops;
      const powerFactor = factors.find(
        (f) => f.operator === "Power" && f.op1.symbol === index && f.op2.is(2)
      );
      if (powerFactor) {
        const constFactors = factors.filter((f) => f !== powerFactor);
        if (constFactors.every((f) => !f.has(index))) {
          const coeff = constFactors.length === 0 ? ce.One : constFactors.length === 1 ? constFactors[0] : ce.box(["Multiply", ...constFactors]);
          a = a.add(coeff);
          continue;
        }
      }
      const varFactor = factors.find((f) => f.symbol === index);
      if (varFactor) {
        const constFactors = factors.filter((f) => f.symbol !== index);
        if (constFactors.every((f) => !f.has(index))) {
          const coeff = constFactors.length === 0 ? ce.One : constFactors.length === 1 ? constFactors[0] : ce.box(["Multiply", ...constFactors]);
          b = b.add(coeff);
          continue;
        }
      }
      return null;
    } else {
      return null;
    }
  }
  if (a.is(0)) return null;
  return { a: a.simplify(), b: b.simplify(), c: c.simplify() };
}
function antiderivative(fn, index) {
  if (fn.operator === "Function") return antiderivative(fn.op1, index);
  if (fn.operator === "Block") return antiderivative(fn.op1, index);
  if (fn.operator === "Delimiter") return antiderivative(fn.op1, index);
  const ce = fn.engine;
  if (fn.symbol === index) return ce.box(["Divide", ["Power", fn, 2], 2]);
  if (!fn.has(index)) return ce.box(["Multiply", fn, ce.symbol(index)]);
  if (fn.operator === "Add") {
    const terms = fn.ops.map((op) => antiderivative(op, index));
    return add3(...terms).evaluate();
  }
  if (fn.operator === "Negate") return antiderivative(fn.op1, index).neg();
  if (fn.operator === "Multiply") {
    const constantFactors = [];
    const variableFactors = [];
    for (const op of fn.ops) {
      if (!op.has(index)) {
        constantFactors.push(op);
      } else {
        variableFactors.push(op);
      }
    }
    if (constantFactors.length > 0) {
      const constantProduct = mul3(...constantFactors);
      if (variableFactors.length === 0) {
        return constantProduct.mul(ce.symbol(index));
      }
      const variableProduct = variableFactors.length === 1 ? variableFactors[0] : mul3(...variableFactors);
      if (variableFactors.length > 1) {
        const uSubResult2 = tryUSubstitution(variableProduct, index);
        if (uSubResult2) return constantProduct.mul(uSubResult2).evaluate();
      }
      if (variableFactors.length === 2) {
        const cyclicResult2 = tryCyclicExpTrigIntegral(variableFactors, index);
        if (cyclicResult2) return constantProduct.mul(cyclicResult2).evaluate();
      }
      const antideriv = antiderivative(variableProduct, index);
      return constantProduct.mul(antideriv).evaluate();
    }
    const uSubResult = tryUSubstitution(fn, index);
    if (uSubResult) return uSubResult;
    const cyclicResult = tryCyclicExpTrigIntegral(fn.ops, index);
    if (cyclicResult) return cyclicResult;
    if (fn.ops.length >= 2) {
      const result2 = tryIntegrationByParts(fn.ops, index, 0);
      if (result2) return result2;
    }
  }
  if (fn.operator === "Divide") {
    const cancelled = cancelCommonFactors(fn, index);
    if (!cancelled.isSame(fn)) {
      return antiderivative(cancelled, index);
    }
    const numDeg = polynomialDegree(fn.op1, index);
    const denDeg = polynomialDegree(fn.op2, index);
    if (numDeg >= 0 && denDeg >= 0 && numDeg >= denDeg) {
      const divResult = polynomialDivide(fn.op1, fn.op2, index);
      if (divResult) {
        const [quotient, remainder] = divResult;
        const quotientIntegral = antiderivative(quotient, index);
        if (!remainder.is(0)) {
          const remainderFraction = remainder.div(fn.op2);
          const remainderIntegral = antiderivative(remainderFraction, index);
          return add3(quotientIntegral, remainderIntegral);
        }
        return quotientIntegral;
      }
    }
    if (!fn.op2.has(index)) {
      const antideriv = antiderivative(fn.op1, index);
      return fn.engine.box(["Divide", antideriv, fn.op2]);
    }
    if (fn.op1.is(1) && fn.op2.symbol === index) {
      return ce.box(["Ln", ["Abs", index]]);
    }
    if (!fn.op1.has(index) && fn.op2.symbol === index) {
      return ce.box(["Multiply", fn.op1, ["Ln", ["Abs", index]]]);
    }
    if (!fn.op1.has(index) && fn.op2.operator === "Add" && fn.op2.nops === 2) {
      const addOps = fn.op2.ops;
      const powerTerm = addOps.find(
        (op) => op.operator === "Power" && op.op1.symbol === index && op.op2.is(2)
      );
      const oneTerm = addOps.find((op) => op.is(1));
      if (powerTerm && oneTerm) {
        const arctan = ce.box(["Arctan", index]);
        if (fn.op1.is(1)) {
          return arctan;
        }
        return fn.op1.mul(arctan);
      }
    }
    if (fn.op1.is(1) && fn.op2.operator === "Multiply" && fn.op2.nops === 2) {
      const mulOps = fn.op2.ops;
      const xTerm = mulOps.find((op) => op.symbol === index);
      const sqrtTerm = mulOps.find((op) => op.operator === "Sqrt");
      if (xTerm && sqrtTerm) {
        const sqrtInner = sqrtTerm.op1;
        if (sqrtInner.operator === "Add" && sqrtInner.nops === 2) {
          const innerOps = sqrtInner.ops;
          const powerTerm = innerOps.find(
            (op) => op.operator === "Power" && op.op1.symbol === index && op.op2.is(2)
          );
          const negOneTerm = innerOps.find((op) => op.is(-1));
          if (powerTerm && negOneTerm) {
            return ce.box(["Arcsec", index]);
          }
        }
      }
    }
    if (fn.op1.has(index)) {
      const denomDeriv = differentiate(fn.op2, index);
      if (denomDeriv && !denomDeriv.is(0)) {
        const ratio = fn.op1.div(denomDeriv).simplify();
        if (!ratio.has(index)) {
          const lnExpr = ce.box(["Ln", ["Abs", fn.op2]]);
          if (ratio.is(1)) {
            return lnExpr;
          }
          return ratio.mul(lnExpr);
        }
      }
    }
    if ((fn.op1.is(1) || !fn.op1.has(index)) && fn.op2.operator === "Multiply") {
      const factors = fn.op2.ops;
      for (let i = 0; i < factors.length; i++) {
        const f = factors[i];
        const fDeriv = differentiate(f, index);
        if (!fDeriv || fDeriv.is(0)) continue;
        const otherFactors = factors.filter((_, j) => j !== i);
        const otherProduct = otherFactors.length === 1 ? otherFactors[0] : mul3(...otherFactors);
        const ratio = fn.op1.div(otherProduct.mul(fDeriv)).simplify();
        if (!ratio.has(index)) {
          const lnExpr = ce.box(["Ln", ["Abs", f]]);
          if (ratio.is(1)) {
            return lnExpr;
          }
          return ratio.mul(lnExpr);
        }
      }
    }
    if (fn.op1.is(1) || !fn.op1.has(index)) {
      const linearCoeffs = getLinearCoefficients(fn.op2, index);
      if (linearCoeffs) {
        const { a, b } = linearCoeffs;
        const lnExpr = ce.box(["Ln", ["Abs", fn.op2]]);
        if (a.is(1)) {
          if (!fn.op1.is(1)) {
            return fn.op1.mul(lnExpr);
          }
          return lnExpr;
        }
        const result2 = lnExpr.div(a);
        if (!fn.op1.is(1)) {
          return fn.op1.mul(result2);
        }
        return result2;
      }
    }
    if (fn.op1.is(1) || !fn.op1.has(index)) {
      const denom = fn.op2;
      if (denom.operator === "Power") {
        const base = denom.op1;
        const exp3 = denom.op2;
        const n = exp3.re;
        if (n !== null && Number.isInteger(n) && n > 1) {
          const linearCoeffs = getLinearCoefficients(base, index);
          if (linearCoeffs) {
            const { a } = linearCoeffs;
            const newExp = ce.number(-(n - 1));
            const coeff = ce.One.div(a.mul(ce.number(n - 1))).neg();
            let result2 = coeff.mul(ce.box(["Power", base, newExp]));
            if (!fn.op1.is(1)) {
              result2 = fn.op1.mul(result2);
            }
            return result2.simplify();
          }
        }
      }
    }
    if (fn.op1.is(1) || !fn.op1.has(index)) {
      const quadCoeffs = getQuadraticCoefficients(fn.op2, index);
      if (quadCoeffs) {
        const { a, b, c } = quadCoeffs;
        const discriminant = b.mul(b).sub(ce.number(4).mul(a).mul(c)).simplify();
        const discValue = discriminant.N().re;
        if (discValue !== null && discValue < 0) {
          const fourAcMinusB2 = ce.number(4).mul(a).mul(c).sub(b.mul(b)).simplify();
          const sqrtDisc = ce.box(["Sqrt", fourAcMinusB2]).simplify();
          const innerExpr = ce.number(2).mul(a).mul(ce.symbol(index)).add(b).simplify();
          const arctanArg = innerExpr.div(sqrtDisc).simplify();
          const arctanExpr = ce.box(["Arctan", arctanArg]);
          let result2 = ce.number(2).div(sqrtDisc).mul(arctanExpr).simplify();
          if (!fn.op1.is(1)) {
            result2 = fn.op1.mul(result2);
          }
          return result2;
        }
      }
    }
    if (fn.op1.is(1) || !fn.op1.has(index)) {
      const denom = fn.op2;
      if (denom.operator === "Power") {
        const base = denom.op1;
        const exp3 = denom.op2;
        const n = exp3.re;
        if (n !== null && Number.isInteger(n) && n > 1) {
          const quadCoeffs = getQuadraticCoefficients(base, index);
          if (quadCoeffs && quadCoeffs.b.is(0) && quadCoeffs.a.is(1)) {
            const a2 = quadCoeffs.c;
            const x = ce.symbol(index);
            const newPower = ce.box(["Power", base, ce.number(n - 1)]);
            const coeff1 = ce.One.div(
              ce.number(2).mul(a2).mul(ce.number(n - 1))
            );
            const term1 = coeff1.mul(x).div(newPower);
            const coeff2 = ce.number(2 * n - 3).div(
              ce.number(2).mul(a2).mul(ce.number(n - 1))
            );
            const lowerPowerExpr = n === 2 ? ce.One.div(base) : ce.One.div(ce.box(["Power", base, ce.number(n - 1)]));
            const recursiveIntegral = antiderivative(lowerPowerExpr, index);
            let result2 = add3(term1, coeff2.mul(recursiveIntegral)).simplify();
            if (!fn.op1.is(1)) {
              result2 = fn.op1.mul(result2);
            }
            return result2;
          }
        }
      }
    }
    if (fn.op1.is(1) || !fn.op1.has(index)) {
      const numerator = fn.op1;
      const denominator = fn.op2;
      if (denominator.operator === "Multiply" && denominator.nops === 2) {
        const factors = denominator.ops;
        let linearFactor = null;
        let quadFactor = null;
        let linearRoot = null;
        for (const factor3 of factors) {
          const linCoeffs = getLinearCoefficients(factor3, index);
          if (linCoeffs && linCoeffs.a.is(1)) {
            linearFactor = factor3;
            linearRoot = linCoeffs.b.neg();
            continue;
          }
          const quadCoeffs = getQuadraticCoefficients(factor3, index);
          if (quadCoeffs && quadCoeffs.a.is(1)) {
            const disc = quadCoeffs.b.mul(quadCoeffs.b).sub(ce.number(4).mul(quadCoeffs.c)).simplify();
            const discValue = disc.N().re;
            if (discValue !== null && discValue < 0) {
              quadFactor = factor3;
            }
          }
        }
        if (linearFactor && quadFactor && linearRoot) {
          const quadCoeffs = getQuadraticCoefficients(quadFactor, index);
          const { b: qb, c: qc } = quadCoeffs;
          const r = linearRoot;
          const quadAtR = r.mul(r).add(qb.mul(r)).add(qc).simplify();
          const A = ce.One.div(quadAtR);
          const B = A.neg();
          const bPlusR = qb.add(r).simplify();
          const C = A.neg().mul(bPlusR);
          const term1 = A.mul(ce.box(["Ln", ["Abs", linearFactor]]));
          const BHalf = B.div(ce.number(2));
          const term2 = BHalf.mul(ce.box(["Ln", ["Abs", quadFactor]]));
          const CMinusBbHalf = C.sub(B.mul(qb).div(ce.number(2))).simplify();
          const fourCMinusB2 = ce.number(4).mul(qc).sub(qb.mul(qb)).simplify();
          const sqrtDisc = ce.box(["Sqrt", fourCMinusB2]).simplify();
          const innerExpr = ce.number(2).mul(ce.symbol(index)).add(qb).simplify();
          const arctanArg = innerExpr.div(sqrtDisc).simplify();
          const arctanCoeff = ce.number(2).div(sqrtDisc).simplify();
          const term3 = CMinusBbHalf.mul(arctanCoeff).mul(
            ce.box(["Arctan", arctanArg])
          );
          let result2 = add3(term1, term2, term3).simplify();
          if (!numerator.is(1)) {
            result2 = numerator.mul(result2);
          }
          return result2;
        }
      }
      const roots = findUnivariateRoots(denominator, index);
      if (roots.length >= 2) {
        const numericRoots = roots.map((r) => r.N().re);
        const allDistinct = numericRoots.every(
          (r, i) => r !== null && isFinite(r) && numericRoots.every((r2, j) => i === j || Math.abs(r - r2) > 1e-10)
        );
        if (allDistinct) {
          const resultTerms = [];
          for (let i = 0; i < roots.length; i++) {
            let productOfDiffs = ce.One;
            for (let j = 0; j < roots.length; j++) {
              if (i !== j) {
                productOfDiffs = productOfDiffs.mul(roots[i].sub(roots[j]));
              }
            }
            const coefficient = ce.One.div(productOfDiffs);
            const lnTerm = ce.box([
              "Ln",
              ["Abs", ["Add", ce.symbol(index), roots[i].neg()]]
            ]);
            resultTerms.push(coefficient.mul(lnTerm));
          }
          let result2 = add3(...resultTerms);
          if (!numerator.is(1)) {
            result2 = numerator.mul(result2);
          }
          return result2.simplify();
        }
      }
      if (roots.length === 1) {
        const r = roots[0];
        const linearFactor = ce.symbol(index).sub(r);
        const quotient = polynomialDivide(denominator, linearFactor, index);
        if (quotient) {
          const [quad, remainder] = quotient;
          if (remainder.is(0)) {
            const quadCoeffs = getQuadraticCoefficients(quad, index);
            if (quadCoeffs) {
              const { a: qa, b: qb, c: qc } = quadCoeffs;
              const discriminant = qb.mul(qb).sub(ce.number(4).mul(qa).mul(qc)).simplify();
              const discValue = discriminant.N().re;
              if (discValue !== null && discValue < 0 && qa.is(1)) {
                const rVal = r;
                const quadAtR = rVal.mul(rVal).add(qb.mul(rVal)).add(qc).simplify();
                const A = ce.One.div(quadAtR);
                const B = A.neg();
                const bPlusR = qb.add(rVal).simplify();
                const C = A.neg().mul(bPlusR);
                const term1 = A.mul(ce.box(["Ln", ["Abs", linearFactor]]));
                const BHalf = B.div(ce.number(2));
                const term2 = BHalf.mul(ce.box(["Ln", ["Abs", quad]]));
                const CMinusBbHalf = C.sub(
                  B.mul(qb).div(ce.number(2))
                ).simplify();
                const fourCMinusB2 = ce.number(4).mul(qc).sub(qb.mul(qb)).simplify();
                const sqrtDisc = ce.box(["Sqrt", fourCMinusB2]).simplify();
                const innerExpr = ce.number(2).mul(ce.symbol(index)).add(qb).simplify();
                const arctanArg = innerExpr.div(sqrtDisc).simplify();
                const arctanCoeff = ce.number(2).div(sqrtDisc).simplify();
                const term3 = CMinusBbHalf.mul(arctanCoeff).mul(
                  ce.box(["Arctan", arctanArg])
                );
                let result2 = add3(term1, term2, term3).simplify();
                if (!numerator.is(1)) {
                  result2 = numerator.mul(result2);
                }
                return result2;
              }
            }
          }
        }
      }
    }
    return integrate(fn, index);
  }
  if (fn.operator === "Sqrt") {
    const inner = fn.op1;
    if (inner.operator === "Divide" && inner.op1.is(1)) {
      const denom = inner.op2;
      if (denom.operator === "Add" && denom.nops === 2) {
        const addOps = denom.ops;
        const oneTerm = addOps.find((op) => op.is(1));
        const negPowerTerm = addOps.find(
          (op) => op.operator === "Negate" && op.op1.operator === "Power" && op.op1.op1.symbol === index && op.op1.op2.is(2)
        );
        if (oneTerm && negPowerTerm) {
          return ce.box(["Arcsin", index]);
        }
        const powerTerm = addOps.find(
          (op) => op.operator === "Power" && op.op1.symbol === index && op.op2.is(2)
        );
        if (oneTerm && powerTerm) {
          return ce.box(["Arsinh", index]);
        }
        const negOneTerm = addOps.find((op) => op.is(-1));
        if (negOneTerm && powerTerm) {
          return ce.box(["Arcosh", index]);
        }
      }
    }
    if (inner.operator === "Add" && inner.nops === 2) {
      const addOps = inner.ops;
      const x2Term = addOps.find(
        (op) => op.operator === "Power" && op.op1.symbol === index && op.op2.is(2)
      );
      const negX2Term = addOps.find(
        (op) => op.operator === "Negate" && op.op1.operator === "Power" && op.op1.op1.symbol === index && op.op1.op2.is(2)
      );
      if (x2Term || negX2Term) {
        const constTerm = addOps.find(
          (op) => op !== x2Term && op !== negX2Term
        );
        if (constTerm && !constTerm.has(index)) {
          const constVal = constTerm.N().re;
          if (negX2Term && constVal !== null && constVal > 0) {
            const a2 = constTerm;
            const a = ce.box(["Sqrt", a2]).simplify();
            const sqrtExpr = fn;
            const xTimesRoot = ce.box(["Multiply", index, sqrtExpr]);
            const arcsinPart = a.is(1) ? ce.box(["Arcsin", index]) : ce.box(["Arcsin", ["Divide", index, a]]);
            const a2ArcsinPart = a2.mul(arcsinPart);
            return ce.box([
              "Multiply",
              ["Rational", 1, 2],
              ["Add", xTimesRoot, a2ArcsinPart]
            ]);
          } else if (x2Term && constVal !== null && constVal > 0) {
            const a2 = constTerm;
            const a = ce.box(["Sqrt", a2]).simplify();
            const sqrtExpr = fn;
            const xTimesRoot = ce.box(["Multiply", index, sqrtExpr]);
            const arcsinhPart = a.is(1) ? ce.box(["Arsinh", index]) : ce.box(["Arsinh", ["Divide", index, a]]);
            const a2ArcsinhPart = a2.mul(arcsinhPart);
            return ce.box([
              "Multiply",
              ["Rational", 1, 2],
              ["Add", xTimesRoot, a2ArcsinhPart]
            ]);
          } else if (x2Term && constVal !== null && constVal < 0) {
            const a2 = constTerm.neg();
            const a = ce.box(["Sqrt", a2]).simplify();
            const sqrtExpr = fn;
            const xTimesRoot = ce.box(["Multiply", index, sqrtExpr]);
            const arccoshPart = a.is(1) ? ce.box(["Arcosh", index]) : ce.box(["Arcosh", ["Divide", index, a]]);
            const a2ArccoshPart = a2.mul(arccoshPart);
            return ce.box([
              "Multiply",
              ["Rational", 1, 2],
              ["Subtract", xTimesRoot, a2ArccoshPart]
            ]);
          }
        }
      }
    }
  }
  if (fn.operator === "Exp" && fn.op1.symbol === index) {
    return fn;
  }
  if (fn.operator === "Sin" && fn.op1.symbol === index) {
    return ce.box(["Negate", ["Cos", index]]);
  }
  if (fn.operator === "Cos" && fn.op1.symbol === index) {
    return ce.box(["Sin", index]);
  }
  if (fn.operator === "Ln" && fn.op1.symbol === index) {
    return ce.box(["Subtract", ["Multiply", index, ["Ln", index]], index]);
  }
  if (fn.operator === "Power") {
    if (fn.op1.symbol === "ExponentialE" && fn.op2.symbol === index) {
      return fn;
    }
    if (fn.op1.symbol === index) {
      const exponent2 = fn.op2;
      if (exponent2.isNumberLiteral) {
        if (exponent2.is(-1)) {
          return ce.box(["Ln", ["Abs", index]]);
        }
        return ce.box([
          "Divide",
          ["Power", index, ["Add", exponent2, 1]],
          ["Add", exponent2, 1]
        ]);
      }
    }
    const exponent = fn.op2;
    const n = exponent.re;
    if (n !== null && Number.isInteger(n) && n < -1) {
      const base = fn.op1;
      const linearCoeffs = getLinearCoefficients(base, index);
      if (linearCoeffs) {
        const { a } = linearCoeffs;
        const newExp = ce.number(n + 1);
        const coeff = ce.One.div(a.mul(newExp));
        const result2 = coeff.mul(ce.box(["Power", base, newExp]));
        return result2.simplify();
      }
      const quadCoeffs = getQuadraticCoefficients(base, index);
      if (quadCoeffs && quadCoeffs.b.is(0) && quadCoeffs.a.is(1)) {
        const a2 = quadCoeffs.c;
        const absN = -n;
        const x = ce.symbol(index);
        const newPower = ce.box(["Power", base, ce.number(n + 1)]);
        const coeff1 = ce.One.div(
          ce.number(2).mul(a2).mul(ce.number(absN - 1))
        );
        const term1 = coeff1.mul(x).mul(newPower);
        const coeff2 = ce.number(2 * absN - 3).div(
          ce.number(2).mul(a2).mul(ce.number(absN - 1))
        );
        const lowerPowerExpr = ce.box(["Power", base, ce.number(n + 1)]);
        const recursiveIntegral = antiderivative(lowerPowerExpr, index);
        const result2 = add3(term1, coeff2.mul(recursiveIntegral)).simplify();
        return result2;
      }
    }
  }
  const linearResult = tryLinearSubstitution(fn, index);
  if (linearResult) return linearResult;
  const rules = ce.rules(INTEGRATION_RULES);
  const xfn = (expandAll(fn) ?? fn).subs(
    { [index]: "_x" },
    { canonical: true }
  );
  const result = matchAnyRules(
    xfn,
    rules,
    { _x: ce.symbol("_x") },
    { useVariations: true, canonical: true }
  );
  if (result && result[0]) return result[0].subs({ _x: index });
  return integrate(fn, index);
}
function integrate(expr, variable) {
  const ce = expr.engine;
  return ce.function("Integrate", [
    expr,
    ce.symbol(variable, { canonical: false })
  ]);
}

// src/compute-engine/library/calculus.ts
init_utils4();
var CALCULUS_LIBRARY = [
  {
    /* @todo
        ## Definite Integral
    `\int f dx` -> ["Integrate", "f", "x"]
    
    `\int\int f dxdy` -> ["Integrate", "f", "x", "y"]
    
    Note: `["Integrate", ["Integrate", "f" , "x"], "y"]` is equivalent to
    `["Integrate", "f" , "x", "y"]`
    
    
    `\int_{a}^{b} f dx` -> ["Integrate", f, [x, a, b]]
    `\int_{c}^{d} \int_{a}^{b} f dxdy` -> ["Integrate", "f", ["Triple", "x", "a",
    "b"], ["Triple", "y", "c", "d"]]
    
    `\int_{a}^{b}\frac{dx}{f}` -> ["Integrate", ["Power", "f", -1], ["Triple", "x",
    "a", "b"]]
    
    `\int_{a}^{b}dx f` -> ["Integrate", "f", ["Triple", "x", "a", "b"]]
    
    If `[a, b]` are numeric, numeric methods are used to approximate the integral.
    
    ## Domain Integral
    
    `\int_{x\in D}` -> ["Integrate", f, ["In", x, D]]
    
    ### Contour Integral
    
    `\oint f dx` -> `["ContourIntegral", "f", "x"]`
    
    `\varointclockwise f dx` -> `["ClockwiseContourIntegral", "f", "x"]`
    
    `\ointctrclockwise f dx` -> `["CounterclockwiseContourIntegral", "f", "x"]`
    
    `\oiint f ds` -> `["DoubleCountourIntegral", "f", "s"]` : integral over closed
    surfaces
    
    `\oiiint` f dv -> `["TripleCountourIntegral", "f", "v"]` : integral over closed
    volumes
    
    `\intclockwise`
    
    `\intctrclockwise`
    
    `\iint`
    
    `\iiint`
    */
    // @todo: review the following
    // - https://index.scala-lang.org/cascala/galileo
    // - https://symbolics.juliasymbolics.org/stable/
    // - https://github.com/symengine/SymEngine.jl
    //
    // Functions
    //
    //
    // **Derivative**
    //
    // Returns a function that represents the derivative of the
    // given function.
    //
    // In contrast to the `D` function, the `Derivative` function
    // returns a function that represents the derivative of the given
    // function, rather than the result of evaluating the derivative
    // at a given point.
    // `['Derivative', f]` < = > `["D", ["Apply", f, "x"], "x"]`
    //
    //
    // ["Derivative", "Sin"]
    //    -> "Cos"
    //
    // ["Derivative", ["Function", ["Square", "x"], "x"], 2]
    //    -> "2"
    //
    // The argument "2" of the `Derivative` function indicates the order
    // of the derivative.
    //
    //
    // @todo: consider Fractional Calculus, i.e. Louiville-Riemann derivative
    // https://en.wikipedia.org/wiki/Fractional_calculus
    // with values of the order that can be either fractional or negative
    //
    Derivative: {
      broadcastable: false,
      lazy: true,
      signature: "(function, order:number?) -> function",
      canonical: (ops, { engine }) => {
        const fn = canonicalFunctionLiteral(ops[0].canonical);
        if (!fn) return null;
        if (!ops[1]) return engine._fn("Derivative", [fn]);
        const order3 = checkType(engine, ops[1]?.canonical, "number");
        return engine._fn("Derivative", [fn, order3]);
      },
      evaluate: (ops) => {
        const op = ops[0].evaluate();
        const degree = Math.floor(ops[1]?.N().re);
        return derivative(op, isNaN(degree) ? 1 : degree);
      }
    },
    //
    // **D: Partial derivative**
    //
    // Returns the partial derivative of a function with respect to a
    // variable.
    //
    // ["D", "Sin", "x"]
    //    -> ["Cos", "x"]
    //
    // This is equivalent to `["Apply", ["Derivative", "Sin"], "x"]`
    D: {
      broadcastable: false,
      scoped: true,
      lazy: true,
      signature: "(expression, variable:symbol, variables:symbol+) -> expression",
      canonical: (ops, { engine: ce, scope }) => {
        const f = canonicalFunctionLiteralArguments(ce, ops);
        if (!f) return null;
        return ce._fn("D", [f, ...ops.slice(1)], { scope });
      },
      evaluate: (ops, { engine }) => {
        let f = ops[0].canonical;
        f = f.evaluate();
        const params = ops.slice(1);
        if (params.length === 0) f = void 0;
        for (const param of params) {
          if (!param.symbol) {
            f = void 0;
            break;
          }
          if (f && f.operator === "Function") f = f.op1;
          f = differentiate(f, param.symbol);
          if (f === void 0) break;
        }
        f = f?.canonical;
        if (f?.operator === "D") return f;
        if (f?.operator === "Apply" && f.op1?.operator === "Derivative")
          return f;
        if (f && hasSymbolicTranscendental(f)) return f;
        return f?.evaluate();
      }
    },
    // Evaluate a numerical approximation of a derivative at point x
    ND: {
      broadcastable: false,
      lazy: true,
      signature: "(function, at:number) -> number",
      canonical: (ops, { engine }) => {
        const fn = canonicalFunctionLiteral(ops[0]);
        if (!fn) return null;
        const x = checkType(engine, ops[1]?.canonical, "number");
        return engine._fn("ND", [fn, x]);
      },
      evaluate: ([body, x], { engine }) => {
        const xValue = x.N().re;
        if (isNaN(xValue)) return void 0;
        return engine.number(centeredDiff8thOrder(body.compile(), xValue));
      }
    },
    Integrate: {
      wikidata: "Q80091",
      broadcastable: false,
      lazy: true,
      signature: "(function, limits+) -> number",
      canonical: (ops, { engine: ce }) => {
        if (!ops[0]) return null;
        const f = canonicalFunctionLiteral(ops[0]);
        if (!f) return null;
        const limits = canonicalLimitsSequence(ops.slice(1), { engine: ce });
        return ce._fn("Integrate", [f, ...limits]);
      },
      evaluate: (ops, { engine: ce, numericApproximation }) => {
        if (numericApproximation) {
          const f = ops[0];
          const firstLimit = ops[1];
          const [lower, upper] = [firstLimit.op2.N().re, firstLimit.op3.N().re];
          if (isNaN(lower) || isNaN(upper)) return void 0;
          const variable = firstLimit.op1.symbol ?? "x";
          const fnExpr = f.operator === "Function" ? f : ce.box(["Function", f, variable]);
          const jsf = fnExpr.compile();
          const mce = monteCarloEstimate(
            jsf,
            lower,
            upper,
            jsf.isCompiled ? 1e7 : 1e4
          );
          return ce.box([
            "PlusMinus",
            ce.number(mce.estimate),
            ce.number(mce.error)
          ]);
        }
        let expr = ops[0];
        const argNames = expr.ops?.slice(1)?.map((x) => x.symbol) ?? [];
        const limitsSequence = ops.slice(1);
        if (limitsSequence.length === 0) {
          return void 0;
        }
        let isIndefinite = true;
        for (let i = limitsSequence.length - 1; i >= 0; i--) {
          const [varExpr, lower, upper] = limitsSequence[i].ops;
          let variable = varExpr.symbol;
          if ((!variable || variable === "Nothing") && i < argNames.length)
            variable = argNames[i];
          if (!variable) variable = "x";
          const antideriv = antiderivative(expr, variable);
          if (antideriv.operator !== "Integrate") {
            const fAntideriv = antideriv;
            if (lower.symbol === "Nothing" && upper.symbol === "Nothing") {
              expr = fAntideriv;
            } else {
              isIndefinite = false;
              const F = ce.box(["Function", antideriv, variable]);
              expr = ce.box(["EvaluateAt", F, lower, upper]);
            }
          } else {
            if (lower.symbol === "Nothing" && upper.symbol === "Nothing") {
              expr = antideriv;
            } else {
              isIndefinite = false;
              const F = ce.box(["Function", antideriv, variable]);
              expr = ce.box(["EvaluateAt", F, lower, upper]);
            }
          }
        }
        if (expr.operator !== "Integrate") {
          if (isIndefinite) {
            if (hasSymbolicTranscendental(expr)) return expr;
            return expr.simplify();
          }
          return expr.evaluate({ numericApproximation });
        }
        return expr;
      }
    },
    NIntegrate: {
      broadcastable: false,
      lazy: true,
      signature: "(function, limits:(tuple|symbol)?) -> number",
      canonical: (ops, { engine }) => {
        const [body, lower, upper] = ops;
        const fn = canonicalFunctionLiteral(body);
        if (!fn) return null;
        if (!lower || !upper) return null;
        return engine._fn("NIntegrate", [fn, lower.canonical, upper.canonical]);
      },
      evaluate: ([f, a, b], { engine }) => {
        const [lower, upper] = [a.N().re, b.N().re];
        if (isNaN(lower) || isNaN(upper)) return void 0;
        const jsf = f.compile();
        return engine.number(
          monteCarloEstimate(jsf, lower, upper, jsf.isCompiled ? 1e7 : 1e4).estimate
        );
      }
    },
    // This is used to represent the indexing set/limits (i.e.
    // an index, lower and upper bounds) of a function
    // (not to be confused with Limit, which calculates the limit of a
    // function at a point)
    // It is a convenient function that prevents the first argument (the index)
    // from being canonicalized
    Limits: {
      description: "Limits of a function",
      complexity: 5e3,
      broadcastable: false,
      lazy: true,
      signature: "(index:symbol, lower:value, upper:value) -> tuple",
      canonical: (ops, { engine }) => canonicalLimits(ops, { engine }) ?? null
    }
  },
  {
    // Limits
    Limit: {
      description: "Limit of a function",
      complexity: 5e3,
      broadcastable: false,
      lazy: true,
      signature: "(function, point:number, direction:number?) -> number",
      canonical: ([f, x, dir], { engine }) => {
        const fn = canonicalFunctionLiteral(f);
        if (!fn || !x) return null;
        if (dir === void 0) return engine._fn("Limit", [fn, x.canonical]);
        return engine._fn("Limit", [fn, x.canonical, dir.canonical]);
      },
      evaluate: ([f, x, dir], { engine, numericApproximation }) => {
        if (numericApproximation) {
          const target = x.N().re;
          if (Number.isNaN(target)) return void 0;
          const fn = f.compile();
          return engine.number(limit(fn, target, dir ? dir.re : 1));
        }
        return void 0;
      }
    },
    NLimit: {
      description: "Numerical approximation of the limit of a function",
      complexity: 5e3,
      broadcastable: false,
      lazy: true,
      signature: "(function, point:number, direction:number?) -> number",
      canonical: ([f, x, dir], { engine }) => {
        const fn = canonicalFunctionLiteral(f);
        if (!fn || !x) return null;
        if (dir === void 0) return engine._fn("NLimit", [fn, x.canonical]);
        return engine._fn("NLimit", [fn, x.canonical, dir.canonical]);
      },
      evaluate: ([f, x, dir], { engine }) => {
        const target = x.N().re;
        if (Number.isNaN(target)) return void 0;
        const fn = f.compile();
        return engine.number(limit(fn, target, dir ? dir.re : 1));
      }
    }
  }
];

// src/compute-engine/library/library.ts
init_collections();

// src/compute-engine/library/control-structures.ts
init_function_utils();
init_rules();
init_utils();
init_interruptible();
init_validate();
var CONTROL_STRUCTURES_LIBRARY = [
  {
    Block: {
      lazy: true,
      scoped: true,
      signature: "(unknown*) -> unknown",
      type: (args) => {
        if (args.length === 0) return "nothing";
        return args[args.length - 1].type;
      },
      canonical: canonicalBlock,
      evaluate: evaluateBlock
    },
    // A condition expression tests for one or more conditions of an expression
    // ['Condition', value, "positive"]
    Condition: {
      lazy: true,
      signature: "(value, symbol) -> boolean",
      evaluate: ([value, conds], { engine }) => {
        let conditions = [];
        if (conds.symbol) {
          conditions = [conds.symbol];
        } else if (conds.operator === "And") {
          conditions = conds.ops.map((op) => op.symbol ?? "");
        }
        if (checkConditions(value, conditions)) return engine.True;
        return engine.False;
      }
    },
    If: {
      lazy: true,
      signature: "(expression, expression, expression) -> any",
      type: ([cond, ifTrue, ifFalse]) => widen(ifTrue.type.type, ifFalse.type.type),
      canonical: ([cond, ifTrue, ifFalse], { engine }) => engine._fn("If", [cond.canonical, ifTrue.canonical, ifFalse.canonical]),
      evaluate: ([cond, ifTrue, ifFalse], { engine }) => {
        const evaluatedCond = cond.evaluate().symbol;
        if (evaluatedCond === "True")
          return ifTrue?.evaluate() ?? engine.Nothing;
        if (evaluatedCond === "False")
          return ifFalse?.evaluate() ?? engine.Nothing;
        throw new Error(
          `Condition must evaluate to "True" or "False". ${spellCheckMessage(cond)}`
        );
      }
    },
    Loop: {
      lazy: true,
      signature: "(body:expression, collection:expression) -> any",
      type: ([body]) => body.type,
      evaluate: ([body, collection], { engine: ce }) => run(runLoop(body, collection, ce), ce._timeRemaining),
      evaluateAsync: async ([body, collection], { engine: ce, signal }) => runAsync(runLoop(body, collection, ce), ce._timeRemaining, signal)
    },
    Which: {
      lazy: true,
      signature: "(expression+) -> unknown",
      type: (args) => {
        if (args.length % 2 !== 0) return "nothing";
        return widen(
          ...args.filter((_, i) => i % 2 === 1).map((x) => x.type.type)
        );
      },
      canonical: (args, options) => {
        if (args.length % 2 !== 0) return options.engine.Nothing;
        return options.engine._fn(
          "Which",
          args.map((x) => x.canonical)
        );
      },
      evaluate: (ops, options) => evaluateWhich(ops, options)
    },
    FixedPoint: { lazy: true, signature: "(any) -> unknown" }
  }
];
function evaluateWhich(args, options) {
  let i = 0;
  while (i < args.length - 1) {
    const cond = args[i].evaluate().symbol;
    if (cond === "True") {
      if (!args[i + 1]) return options.engine.symbol("Undefined");
      return args[i + 1].evaluate(options);
    } else if (cond !== "False") {
      throw new Error(
        `Condition must evaluate to "True" or "False". ${spellCheckMessage(args[i])}`
      );
    }
    i += 2;
  }
  return options.engine.symbol("Undefined");
}
function evaluateBlock(ops, { engine: ce }) {
  if (ops.length === 0) return ce.Nothing;
  let result = void 0;
  for (const op of ops) {
    const h = op.operator;
    if (h === "Return") {
      result = op.op1.evaluate();
      break;
    }
    if (h === "Break" || h === "Continue") {
      result = ce.box([h, op.op1.evaluate()]);
      break;
    }
    result = op.evaluate();
  }
  return result ?? ce.Nothing;
}
function canonicalBlock(ops, options) {
  const { engine: ce, scope } = options;
  if (ops.length === 0) return null;
  const result = ce._fn(
    "Block",
    ce._inScope(scope, () => ops.map((op) => op.canonical)),
    { scope }
  );
  return result;
}
function* runLoop(body, collection, ce) {
  body ??= ce.Nothing;
  if (body.symbol === "Nothing") return body;
  if (collection?.isCollection) {
    let result = void 0;
    const fn = applicable(body);
    let i2 = 0;
    for (const x of collection.each()) {
      result = fn([x]) ?? ce.Nothing;
      if (result.operator === "Break") return result.op1;
      if (result.operator === "Return") return result;
      i2 += 1;
      if (i2 % 1e3 === 0) yield result;
      if (i2 > ce.iterationLimit)
        throw new CancellationError({ cause: "iteration-limit-exceeded" });
    }
    return result;
  }
  let i = 0;
  while (true) {
    const result = body.evaluate();
    if (result.operator === "Break") return result.op1;
    if (result.operator === "Return") return result;
    i += 1;
    if (i % 1e3 === 0) yield result;
    if (i > ce.iterationLimit)
      throw new CancellationError({ cause: "iteration-limit-exceeded" });
  }
}

// src/compute-engine/library/combinatorics.ts
init_numerics();
init_expand();
var COMBINATORICS_LIBRARY = [
  {
    Choose: {
      complexity: 1200,
      signature: "(n:number, m:number) -> number",
      evaluate: (ops, { engine: ce }) => {
        const n = ops[0].re;
        const k = ops[1].re;
        if (!Number.isFinite(n) || !Number.isFinite(k)) return void 0;
        if (n < 0 || k < 0 || k > n) return ce.NaN;
        return ce.number(choose(n, k));
      }
    }
  },
  {
    Fibonacci: {
      description: "Compute the nth Fibonacci number.",
      wikidata: "Q47577",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null) return void 0;
        if (k < 0n) return ce.function("Negate", ["Fibonacci", ce.number(-k)]);
        if (k === 0n) return ce.Zero;
        if (k === 1n) return ce.One;
        let a = 0n;
        let b = 1n;
        for (let i = 2n; i <= k; i++) {
          const next = a + b;
          a = b;
          b = next;
        }
        return ce.number(b);
      }
    },
    Binomial: {
      description: "Compute the binomial coefficient C(n, k) = n! / (k! (n-k)!).",
      wikidata: "Q209875",
      signature: "(integer, integer) -> integer",
      evaluate: ([nExpr, kExpr], { engine: ce }) => {
        const n = toBigint(nExpr);
        const k = toBigint(kExpr);
        if (n === null || k === null) return void 0;
        if (k < 0n || k > n) return ce.number(0);
        if (k === 0n || k === n) return ce.number(1);
        let result = 1n;
        for (let i = 1n; i <= k; i++) {
          result *= n - (k - i);
          result /= i;
        }
        return ce.number(result);
      }
    },
    CartesianProduct: {
      description: "Return the Cartesian product of input sets.",
      // Aka the product set, the set direct product or cross product
      // Notation: \times
      wikidata: "Q173740",
      signature: "(set+) -> set",
      collection: {
        contains: (expr, x) => {
          const factors = expr.ops;
          if (!x.isCollection || x.ops.length !== factors.length) return false;
          return factors.every(
            (factor3, i) => factor3.contains(x.ops[i]) ?? false
          );
        },
        count: (expr) => {
          const sizes = expr.ops.map((op) => op.count);
          if (sizes.includes(Infinity)) return Infinity;
          return sizes.reduce((a, b) => a * b, 1);
        },
        iterator: cartesianProductIterator
      }
    },
    PowerSet: {
      description: "Return the power set of a set (set of all subsets).",
      wikidata: "Q205170",
      signature: "(set) -> set",
      collection: {
        contains: (expr, x) => {
          const base = expr.ops[0];
          if (!x.isCollection) return false;
          return x.ops.every((elem) => base.contains(elem) ?? false);
        },
        count: (expr) => {
          const xs = expr.ops[0];
          if (xs.isEmptyCollection) return 1;
          if (xs.isFiniteCollection === false) return Infinity;
          return 2 ** xs.count;
        },
        iterator: powerSetIterator
      }
    },
    Permutations: {
      description: "Return all permutations of length k (default full length) of a collection.",
      signature: "(collection, integer?) -> list<list>",
      evaluate: ([xs, kExpr], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const all = Array.from(xs.each());
        const k = kExpr ? toInteger(kExpr) : all.length;
        if (k === null || k < 0 || k > all.length) return void 0;
        function* permute(prefix, rest) {
          if (prefix.length === k) {
            yield prefix;
            return;
          }
          for (let i = 0; i < rest.length; i++) {
            const next = rest.slice();
            const [item] = next.splice(i, 1);
            yield* permute([...prefix, item], next);
          }
        }
        return ce.function(
          "List",
          [...permute([], all)].map((perm) => ce.function("List", perm))
        );
      }
    },
    Combinations: {
      description: "Return all k-element combinations of a collection.",
      wikidata: "Q193606",
      signature: "(collection, integer) -> list<list>",
      evaluate: ([xs, kExpr], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const all = Array.from(xs.each());
        const k = toInteger(kExpr);
        if (k === null || k < 0 || k > all.length) return void 0;
        function* combine(start, combo) {
          if (combo.length === k) {
            yield combo;
            return;
          }
          for (let i = start; i < all.length; i++) {
            yield* combine(i + 1, [...combo, all[i]]);
          }
        }
        return ce.function(
          "List",
          [...combine(0, [])].map((combo) => ce.function("List", combo))
        );
      }
    },
    Multinomial: {
      description: "Compute the multinomial coefficient for multiple integers.",
      wikidata: "Q20820114",
      signature: "(integer+) -> integer",
      evaluate: (ops, { engine: ce }) => {
        const ks = ops.map(toInteger);
        if (ks.some((k) => k === null || k < 0)) return void 0;
        const n = ks.reduce((a, b) => a + (b ?? 0), 0);
        let result = 1;
        for (let i = 1; i <= n; i++) {
          result *= i;
        }
        for (const k of ks) {
          for (let i = 1; i <= k; i++) {
            result /= i;
          }
        }
        return ce.number(result);
      }
    },
    Subfactorial: {
      description: "Compute the number of derangements (subfactorial) of n items.",
      wikidata: "Q2361661",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toInteger(n);
        if (k === null || k < 0) return void 0;
        let result = 1;
        for (let i = 1; i <= k; i++) {
          result = Math.round(result * i * (1 - 1 / i));
        }
        return ce.number(result);
      }
    },
    BellNumber: {
      description: "Compute the Bell number B(n), the number of partitions of a set of n elements.",
      wikidata: "Q816063",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toInteger(n);
        if (k === null || k < 0) return void 0;
        const bell = [1];
        for (let i = 1; i <= k; i++) {
          let b = 0;
          for (let j = 0; j < i; j++) {
            b += binomial(i - 1, j) * bell[j];
          }
          bell[i] = b;
        }
        return ce.number(bell[k]);
      }
    }
  }
];
function* cartesianProductIterator(expr) {
  const factors = expr.ops;
  const iterators = factors.map((f) => [...f.each()]);
  const lengths = iterators.map((it) => it.length);
  if (lengths.some((len) => len === 0)) return;
  const indices = Array(factors.length).fill(0);
  while (true) {
    const tuple = indices.map((i, j2) => iterators[j2][i]);
    yield expr.engine._fn("Tuple", tuple);
    let j = indices.length - 1;
    while (j >= 0) {
      indices[j]++;
      if (indices[j] < lengths[j]) break;
      indices[j] = 0;
      j--;
    }
    if (j < 0) break;
  }
}
function* powerSetIterator(expr) {
  const elements = [...expr.ops[0].each()];
  const n = elements.length;
  const ce = expr.engine;
  const total = 1 << n;
  for (let mask = 0; mask < total; mask++) {
    const subset2 = [];
    for (let i = 0; i < n; i++) {
      if ((mask & 1 << i) !== 0) {
        subset2.push(elements[i]);
      }
    }
    yield subset2.length === 0 ? ce.symbol("EmptySet") : ce._fn("Set", subset2);
  }
}
function binomial(n, k) {
  if (k < 0 || k > n) return 0;
  if (k === 0 || k === n) return 1;
  let result = 1;
  for (let i = 1; i <= k; i++) {
    result *= n - (k - i);
    result /= i;
  }
  return result;
}

// src/compute-engine/library/complex.ts
var COMPLEX_LIBRARY = [
  {
    Real: {
      // @todo: could be extended to return an expression, i.e. ["Real", ["Add", "x", ["Complex", 0, 5]]] -> "x". Not for any operator, but at least for Add, Multiply, Negate, etc.
      broadcastable: true,
      complexity: 1200,
      signature: "(number) -> real",
      sgn: ([op]) => {
        const re = op.re;
        if (isNaN(re)) return void 0;
        if (re === 0) return "zero";
        return re > 0 ? "positive" : "negative";
      },
      evaluate: (ops, { engine: ce }) => {
        const op = ops[0].numericValue;
        if (op === null) return void 0;
        if (typeof op === "number") return ops[0];
        return ce.number(op.bignumRe ?? op.re);
      }
    },
    Imaginary: {
      broadcastable: true,
      complexity: 1200,
      signature: "(number) -> real",
      sgn: ([op]) => {
        const im = op.im;
        if (isNaN(im)) return void 0;
        if (im === 0) return "zero";
        return im > 0 ? "positive" : "negative";
      },
      evaluate: (ops, { engine: ce }) => {
        const op = ops[0].numericValue;
        if (op === null) return void 0;
        if (typeof op === "number") return ce.Zero;
        return ce.number(op.im);
      }
    },
    Argument: {
      broadcastable: true,
      complexity: 1200,
      signature: "(number) -> real",
      evaluate: (ops, { engine: ce }) => {
        const op = ops[0].numericValue;
        if (op === null) return void 0;
        if (typeof op === "number") return op >= 0 ? ce.Zero : ce.Pi;
        if (op.im === 0) return op.re >= 0 ? ce.Zero : ce.Pi;
        return ce.function("ArcTan2", [op.im, op.re]).evaluate();
      }
    },
    // For Abs (magnitude) see src/compute-engine/library/processAbs
    AbsArg: {
      broadcastable: true,
      complexity: 1200,
      signature: "(number) -> tuple<real, real>",
      evaluate: (ops, { engine: ce }) => {
        if (ops[0].numericValue === null) return void 0;
        return ce.tuple(
          ce.function("Abs", ops).evaluate(),
          ce.function("Argument", ops).evaluate()
        );
      }
    },
    Conjugate: {
      broadcastable: true,
      complexity: 1200,
      signature: "(number) -> number",
      type: ([z]) => z.type,
      sgn: ([z]) => z.sgn,
      evaluate: (ops, { engine: ce }) => {
        const op = ops[0].numericValue;
        if (op === null) return void 0;
        if (typeof op === "number" || op.im === 0) return ops[0];
        return ce.number(ce.complex(op.re, -op.im));
      }
    },
    ComplexRoots: {
      broadcastable: true,
      complexity: 1200,
      signature: "(number, number) -> list<number>",
      evaluate: (ops, { engine: ce }) => {
        const re = ops[0].re;
        if (isNaN(re)) return void 0;
        const n = ops[1].re;
        if (!Number.isInteger(n) || n <= 0) return void 0;
        const roots = [];
        const im = ops[0].im ?? 0;
        const arg = Math.atan2(im, re);
        const mod3 = Math.sqrt(re * re + im * im);
        for (let k = 0; k < n; k++) {
          const theta = (arg + 2 * Math.PI * k) / n;
          const r = Math.pow(mod3, 1 / n);
          roots.push([r * Math.cos(theta), r * Math.sin(theta)]);
        }
        return ce.function(
          "List",
          roots.map(
            (r) => ce.number(r[1] !== 0 ? ce.complex(r[0], r[1]) : r[0])
          )
        );
      }
    }
  }
];

// src/compute-engine/library/core.ts
init_tokenizer();
init_validate();

// src/compute-engine/library/invisible-operator.ts
init_flatten();
init_utils5();
function canonicalInvisibleOperator(ops, { engine: ce }) {
  if (ops.length === 0) return null;
  const lhs = ops[0];
  if (ops.length === 1) return lhs.canonical;
  if (ops.length === 2) {
    const lhsInteger = asInteger(lhs);
    if (!Number.isNaN(lhsInteger)) {
      const rhs2 = ops[1];
      if (rhs2.operator === "Divide" || rhs2.operator === "Rational") {
        const [n, d] = [rhs2.op1.canonical.re, rhs2.op2.canonical.re];
        if (n > 0 && n <= 1e3 && d > 1 && d <= 1e3 && Number.isInteger(n) && Number.isInteger(d)) {
          let frac = rhs2.canonical;
          if (lhsInteger < 0) frac = frac.neg();
          return ce._fn("Add", [lhs.canonical, frac]);
        }
      }
    }
    const rhs = ops[1];
    if (!Number.isNaN(lhsInteger) && isImaginaryUnit(rhs)) {
      return ce.number(ce.complex(0, lhsInteger));
    }
    const lhsCanon = lhs.canonical;
    if (lhsCanon.symbol && rhs.operator === "Delimiter") {
      if (rhs.nops === 0) {
        const def2 = ce.lookupDefinition(lhsCanon.symbol);
        if (def2) {
          if (isOperatorDef(def2)) {
            return ce.box([lhsCanon.symbol]);
          }
          if (def2.value.type.isUnknown) {
            lhsCanon.infer("function");
            return ce.box([lhsCanon.symbol]);
          }
          if (def2.value.type.matches("function"))
            return ce.box([lhsCanon.symbol]);
          return ce.typeError("function", def2.value.type, lhsCanon);
        }
        ce.declare(lhsCanon.symbol, "function");
        return ce.box([lhsCanon.symbol]);
      }
      let args = rhs.op1.operator === "Sequence" ? rhs.op1.ops : [rhs.op1];
      args = flatten(args);
      const def = ce.lookupDefinition(lhsCanon.symbol);
      if (!def) {
        ce.declare(lhsCanon.symbol, "function");
        return ce.function(lhsCanon.symbol, args);
      }
      if (isOperatorDef(def) || def.value?.type?.matches("function")) {
        return ce.function(lhsCanon.symbol, args);
      }
      if (def.value?.type?.isUnknown) {
        lhsCanon.infer("function");
        return ce.function(lhsCanon.symbol, args);
      }
    }
    if (lhsCanon.symbol && rhs.operator === "Delimiter" && (rhs.op2.string === "[,]" || rhs.op2.string === "[;]")) {
      const args = rhs.op1.operator === "Sequence" ? rhs.op1.ops : [rhs.op1];
      return ce.function("At", [lhsCanon, ...args]);
    }
  }
  ops = flattenInvisibleOperator(ops);
  ops = flatten(ops);
  if (ops.every(
    (x) => x.isValid && (x.type.isUnknown || x.type.matches("number") || x.isIndexedCollection && !x.string)
  )) {
    return ce._fn("Multiply", ops);
  }
  return ce._fn("Tuple", ops);
}
function flattenInvisibleOperator(ops) {
  const ys = [];
  for (const x of ops) {
    if (x.operator === "InvisibleOperator")
      ys.push(...flattenInvisibleOperator(x.ops));
    else ys.push(x);
  }
  return ys;
}
function asInteger(expr) {
  if (expr.isNumberLiteral) {
    const n = expr.re;
    if (Number.isInteger(n)) return n;
  }
  if (expr.operator === "Negate") {
    const n = asInteger(expr.op1);
    if (!Number.isNaN(n)) return -n;
  }
  return Number.NaN;
}

// src/compute-engine/boxed-expression/canonical.ts
init_flatten();
init_arithmetic_add();
init_arithmetic_mul_div();
init_arithmetic_power();
init_order();
init_numerics();
init_utils5();
function canonicalForm(expr, forms, scope) {
  if (forms === false) return expr;
  if (forms === true) return expr.engine._inScope(scope, () => expr.canonical);
  if (typeof forms === "string") forms = [forms];
  expr = symbolForm(expr);
  for (const form of forms) {
    switch (form) {
      // @todo: consider additional forms: "Symbol", "Tensor"
      case "InvisibleOperator":
        expr = invisibleOperatorForm(expr);
        break;
      case "Number":
        expr = numberForm(expr);
        break;
      case "Multiply":
        expr = multiplyForm(expr);
        break;
      case "Add":
        expr = addForm(expr);
        break;
      case "Power":
        expr = powerForm(expr);
        break;
      case "Divide":
        expr = divideForm(expr);
        break;
      case "Flatten":
        expr = flattenForm(expr);
        break;
      case "Order":
        expr = canonicalOrder(expr, { recursive: true });
        break;
      default:
        throw Error("Invalid canonical form");
    }
  }
  if (expr.isFunctionExpression && expr.isCanonical) {
    expr = expr.engine.function(expr.operator, [...expr.ops], {
      canonical: false,
      structural: true
    });
  }
  return expr;
}
function flattenForm(expr) {
  if (!expr.operator) return expr;
  if (!expr.ops || expr.nops === 0) return expr;
  if (expr.operator === "Delimiter") return flattenForm(expr.op1);
  const ce = expr.engine;
  let isAssociative = expr.operator === "Add" || expr.operator === "Multiply";
  if (!isAssociative) {
    const def = ce.lookupDefinition(expr.operator);
    if (isOperatorDef(def) && def.operator.associative) isAssociative = true;
  }
  if (isAssociative)
    return ce.function(
      expr.operator,
      flattenOps(expr.ops.map(flattenForm), expr.operator)
    );
  return expr;
}
function invisibleOperatorForm(expr) {
  if (!expr.ops) return expr;
  if (expr.operator === "InvisibleOperator") {
    return canonicalInvisibleOperator(expr.ops.map(invisibleOperatorForm), {
      engine: expr.engine
    }) ?? expr;
  }
  return expr.engine._fn(expr.operator, expr.ops.map(invisibleOperatorForm));
}
function numberForm(expr) {
  if (expr.isNumberLiteral) return expr.canonical;
  if (isImaginaryUnit(expr)) return expr.engine.I;
  if (!expr.isFunctionExpression) return expr;
  const { engine: ce } = expr;
  const ops = expr.ops.map(numberForm);
  let { operator: name } = expr;
  if ((name === "Divide" || name === "Rational") && ops.length === 2) {
    const n = asBigint(ops[0]);
    if (n !== null) {
      const d = asBigint(ops[1]);
      if (d !== null) return ce.number([n, d]);
    }
    name = "Divide";
    return ce._fn("Divide", ops, { canonical: false });
  }
  if (name === "Complex") {
    if (ops.length === 1) {
      const op1 = ops[0];
      if (op1.isNumberLiteral) return ce.number(ce.complex(0, op1.re));
      return ce._fn("Multiply", [op1, ce.I], { canonical: false });
    }
    if (ops.length === 2) {
      const re = ops[0].re;
      const im = ops[1].re;
      if (im !== null && re !== null && !isNaN(im) && !isNaN(re)) {
        if (im === 0 && re === 0) return ce.Zero;
        if (im !== 0) return ce.number(ce._numericValue({ re, im }));
        return ops[0];
      }
      return ce._fn(
        "Add",
        [ops[0], ce._fn("Multiply", [ops[1], ce.I], { canonical: false })],
        { canonical: false }
      );
    }
    throw new Error("Expected one or two arguments with `Complex` expression");
  }
  if (name === "Negate" && ops.length === 1) {
    const op1 = ops[0];
    const { numericValue } = op1;
    if (numericValue !== null)
      return ce.number(
        typeof numericValue === "number" ? -numericValue : numericValue.neg()
      );
    if (isImaginaryUnit(op1)) return ce.number(ce.complex(0, -1));
  }
  return ops.every((op, index) => op === expr.ops[index]) ? expr : ce._fn(name, ops, { canonical: false });
}
function multiplyForm(expr) {
  if (!expr.ops) return expr;
  const ops = expr.ops.map(multiplyForm);
  if (expr.operator === "Multiply")
    return canonicalMultiply(expr.engine, ops);
  if (expr.operator === "Negate")
    return canonicalMultiply(expr.engine, [ops[0], expr.engine.NegativeOne]);
  return expr;
}
function addForm(expr) {
  if (!expr.ops) return expr;
  const ops = expr.ops.map(addForm);
  if (expr.operator === "Add") return canonicalAdd(expr.engine, ops);
  if (expr.operator === "Subtract")
    return canonicalAdd(expr.engine, [ops[0], ops[1].neg()]);
  return expr.engine._fn(expr.operator, ops);
}
function powerForm(expr) {
  if (!expr.ops) return expr;
  const ops = expr.ops.map((expr2) => powerForm(expr2));
  if (expr.operator === "Power") return canonicalPower(ops[0], ops[1]);
  return expr.engine._fn(expr.operator, ops, { canonical: false });
}
function symbolForm(expr) {
  if (expr.symbol !== null) return expr.canonical;
  if (!expr.isFunctionExpression) return expr;
  return expr.engine._fn(expr.operator, expr.ops.map(symbolForm), {
    canonical: false
  });
}
function divideForm(expr) {
  if (expr.operator === "Divide")
    return canonicalDivide(powerForm(expr.op1), powerForm(expr.op2));
  if (!expr.ops) return expr;
  return expr.engine._fn(expr.operator, expr.ops.map(divideForm));
}

// src/compute-engine/library/core.ts
init_numerics();

// src/compute-engine/sequence.ts
init_utils5();
var sequenceRegistry = /* @__PURE__ */ new WeakMap();
function getOrCreateRegistry(ce) {
  if (!sequenceRegistry.has(ce)) {
    sequenceRegistry.set(ce, /* @__PURE__ */ new Map());
  }
  return sequenceRegistry.get(ce);
}
function registerSequence(ce, metadata) {
  const registry = getOrCreateRegistry(ce);
  registry.set(metadata.name, metadata);
}
function parseBasePattern(key) {
  if (typeof key === "number") {
    return { type: "exact", values: [key] };
  }
  const parts = key.split(",").map((p) => p.trim());
  const values = parts.map((p) => {
    const num = Number(p);
    return isNaN(num) ? p : num;
  });
  const hasVariable = values.some((v) => typeof v === "string");
  return { type: hasVariable ? "pattern" : "exact", values };
}
function matchPattern(pattern, indices) {
  if (pattern.values.length !== indices.length) return false;
  const bindings = /* @__PURE__ */ new Map();
  for (let i = 0; i < pattern.values.length; i++) {
    const pv = pattern.values[i];
    const iv = indices[i];
    if (typeof pv === "number") {
      if (pv !== iv) return false;
    } else {
      if (bindings.has(pv)) {
        if (bindings.get(pv) !== iv) return false;
      } else {
        bindings.set(pv, iv);
      }
    }
  }
  return true;
}
function prepareBaseCases(base) {
  const cases = [];
  for (const [key, value] of base) {
    const pattern = parseBasePattern(key);
    const variableCount = pattern.values.filter(
      (v) => typeof v === "string"
    ).length;
    cases.push({ pattern, value, variableCount });
  }
  cases.sort((a, b) => {
    if (a.pattern.type !== b.pattern.type) {
      return a.pattern.type === "exact" ? -1 : 1;
    }
    return a.variableCount - b.variableCount;
  });
  return cases;
}
function findMatchingBaseCase(cases, indices) {
  for (const { pattern, value } of cases) {
    if (matchPattern(pattern, indices)) {
      return value;
    }
  }
  return void 0;
}
function validateMultiIndexDomain(indices, variables, domain) {
  for (let i = 0; i < variables.length; i++) {
    const variable = variables[i];
    const index = indices[i];
    const constraint = domain[variable];
    if (constraint) {
      if (constraint.min !== void 0 && index < constraint.min) return false;
      if (constraint.max !== void 0 && index > constraint.max) return false;
    }
  }
  return true;
}
function checkConstraints(ce, constraints, variables, indices) {
  const subs = {};
  for (let i = 0; i < variables.length; i++) {
    subs[variables[i]] = ce.number(indices[i]);
  }
  const substituted = constraints.subs(subs);
  const result = substituted.evaluate();
  if (result.symbol === "True") return true;
  if (result.symbol === "False") return false;
  if (result.isNumberLiteral) return result.re !== 0;
  return false;
}
function createSequenceHandler(ce, name, def) {
  const isMultiIndex = def.variables !== void 0 && def.variables.length > 1;
  const variables = def.variables ?? [def.variable ?? "n"];
  const variable = variables[0];
  const memoize = def.memoize ?? true;
  const memo = memoize ? /* @__PURE__ */ new Map() : null;
  const domain = def.domain ?? {};
  const recurrenceSource = def.recurrence;
  let recurrence = null;
  let constraintsExpr = null;
  if (def.constraints) {
    constraintsExpr = typeof def.constraints === "string" ? ce.parse(def.constraints) : def.constraints;
  }
  const base = /* @__PURE__ */ new Map();
  for (const [k, v] of Object.entries(def.base)) {
    const key = isMultiIndex ? String(k) : Number(k);
    base.set(key, typeof v === "number" ? ce.number(v) : v);
  }
  const preparedBaseCases = isMultiIndex ? prepareBaseCases(base) : null;
  registerSequence(ce, {
    name,
    variable: isMultiIndex ? void 0 : variable,
    variables: isMultiIndex ? variables : void 0,
    isMultiIndex,
    base,
    memoize,
    memo,
    domain,
    constraints: constraintsExpr ?? void 0
  });
  return (subscript, { engine, numericApproximation }) => {
    if (recurrence === null) {
      recurrence = typeof recurrenceSource === "string" ? engine.parse(recurrenceSource) : recurrenceSource;
    }
    let indices;
    if (subscript.operator === "Sequence" && subscript.ops) {
      indices = subscript.ops.map((op) => op.evaluate().re);
    } else if (subscript.operator === "Tuple" && subscript.ops) {
      indices = subscript.ops.map((op) => op.evaluate().re);
    } else if (subscript.operator === "Delimiter" && subscript.ops) {
      indices = subscript.ops.map((op) => op.evaluate().re);
    } else {
      indices = [subscript.evaluate().re];
    }
    if (!indices.every((n) => Number.isInteger(n))) return void 0;
    if (isMultiIndex) {
      const multiDomain = domain;
      if (Object.keys(multiDomain).length > 0 && !validateMultiIndexDomain(indices, variables, multiDomain)) {
        return void 0;
      }
    } else {
      const singleDomain = domain;
      const n = indices[0];
      if (singleDomain.min !== void 0 && n < singleDomain.min)
        return void 0;
      if (singleDomain.max !== void 0 && n > singleDomain.max)
        return void 0;
    }
    if (constraintsExpr && !checkConstraints(engine, constraintsExpr, variables, indices)) {
      return void 0;
    }
    const memoKey = isMultiIndex ? indices.join(",") : indices[0];
    if (memo?.has(memoKey)) return memo.get(memoKey);
    if (isMultiIndex) {
      const baseValue = findMatchingBaseCase(preparedBaseCases, indices);
      if (baseValue !== void 0) {
        if (memo) memo.set(memoKey, baseValue);
        return baseValue;
      }
    } else {
      const n = indices[0];
      if (base.has(n)) return base.get(n);
    }
    const subs = {};
    for (let i = 0; i < variables.length; i++) {
      subs[variables[i]] = engine.number(indices[i]);
    }
    const substituted = recurrence.subs(subs);
    const result = numericApproximation ? substituted.N() : substituted.evaluate();
    if (memo && result.isNumberLiteral) {
      memo.set(memoKey, result);
    }
    return result.isNumberLiteral ? result : void 0;
  };
}
function validateSequenceDefinition(ce, name, def) {
  if (!def.base || Object.keys(def.base).length === 0) {
    return {
      valid: false,
      error: `Sequence "${name}" requires at least one base case`
    };
  }
  if (!def.recurrence) {
    return {
      valid: false,
      error: `Sequence "${name}" requires a recurrence relation`
    };
  }
  const recurrence = typeof def.recurrence === "string" ? ce.parse(def.recurrence) : def.recurrence;
  if (!recurrence.isValid) {
    return {
      valid: false,
      error: `Invalid recurrence for "${name}": expression contains errors`
    };
  }
  return { valid: true };
}
var pendingSequences = /* @__PURE__ */ new WeakMap();
function getOrCreatePending(ce, name) {
  if (!pendingSequences.has(ce)) {
    pendingSequences.set(ce, /* @__PURE__ */ new Map());
  }
  const map = pendingSequences.get(ce);
  if (!map.has(name)) {
    map.set(name, { base: /* @__PURE__ */ new Map(), isMultiIndex: false });
  }
  return map.get(name);
}
function addSequenceBaseCase(ce, name, index, value) {
  const pending = getOrCreatePending(ce, name);
  pending.base.set(index, value);
  tryFinalizeSequence(ce, name);
}
function addMultiIndexBaseCase(ce, name, key, value) {
  const pending = getOrCreatePending(ce, name);
  pending.base.set(key, value);
  pending.isMultiIndex = true;
  tryFinalizeSequence(ce, name);
}
function addSequenceRecurrence(ce, name, variable, expr) {
  const pending = getOrCreatePending(ce, name);
  pending.recurrence = { variable, latex: expr.latex };
  tryFinalizeSequence(ce, name);
}
function addMultiIndexRecurrence(ce, name, variables, expr) {
  const pending = getOrCreatePending(ce, name);
  pending.recurrence = { variables, latex: expr.latex };
  pending.isMultiIndex = true;
  tryFinalizeSequence(ce, name);
}
function tryFinalizeSequence(ce, name) {
  const pending = getOrCreatePending(ce, name);
  if (pending.base.size === 0 || !pending.recurrence) return;
  const base = {};
  for (const [k, v] of pending.base) {
    base[k] = v;
  }
  const def = {
    base,
    recurrence: pending.recurrence.latex
    // Pass as string for fresh parsing
  };
  if (pending.isMultiIndex || pending.recurrence.variables) {
    def.variables = pending.recurrence.variables;
  } else {
    def.variable = pending.recurrence.variable;
  }
  const validation = validateSequenceDefinition(ce, name, def);
  if (!validation.valid) {
    throw new Error(validation.error);
  }
  const handler = createSequenceHandler(ce, name, def);
  const scope = ce.context.lexicalScope;
  const existingDef = scope.bindings.get(name);
  if (existingDef) {
    updateDef(ce, name, existingDef, {
      subscriptEvaluate: handler
    });
  } else {
    ce.declare(name, {
      subscriptEvaluate: handler
    });
  }
  pendingSequences.get(ce).delete(name);
}
function containsSelfReference(expr, seqName) {
  if (expr.operator === "Subscript" && expr.op1?.symbol === seqName) {
    return true;
  }
  if (expr.ops) {
    return expr.ops.some((op) => containsSelfReference(op, seqName));
  }
  return false;
}
function extractIndexVariable(subscript) {
  if (subscript.symbol) return subscript.symbol;
  const symbols = subscript.symbols;
  if (symbols.length === 1) return symbols[0];
  const commonVars = ["n", "k", "i", "j", "m"];
  for (const v of commonVars) {
    if (symbols.includes(v)) return v;
  }
  return void 0;
}
function getSequenceStatus(ce, name) {
  const pendingMap = pendingSequences.get(ce);
  const pending = pendingMap?.get(name);
  if (pending) {
    const baseIndices = Array.from(pending.base.keys());
    if (!pending.isMultiIndex) {
      baseIndices.sort((a, b) => a - b);
    }
    return {
      status: "pending",
      hasBase: pending.base.size > 0,
      hasRecurrence: !!pending.recurrence,
      baseIndices,
      variable: pending.recurrence?.variable,
      variables: pending.recurrence?.variables
    };
  }
  const def = ce.lookupDefinition(name);
  if (def && isValueDef(def) && def.value.subscriptEvaluate) {
    const registry = sequenceRegistry.get(ce);
    const metadata = registry?.get(name);
    if (metadata) {
      const baseIndices = Array.from(metadata.base.keys());
      if (!metadata.isMultiIndex) {
        baseIndices.sort((a, b) => a - b);
      }
      return {
        status: "complete",
        hasBase: true,
        hasRecurrence: true,
        baseIndices,
        variable: metadata.variable,
        variables: metadata.variables
      };
    }
    return {
      status: "complete",
      hasBase: true,
      hasRecurrence: true,
      baseIndices: []
    };
  }
  return {
    status: "not-a-sequence",
    hasBase: false,
    hasRecurrence: false,
    baseIndices: []
  };
}
function getSequenceInfo(ce, name) {
  const registry = sequenceRegistry.get(ce);
  const metadata = registry?.get(name);
  if (!metadata) return void 0;
  const baseIndices = Array.from(metadata.base.keys());
  if (!metadata.isMultiIndex) {
    baseIndices.sort((a, b) => a - b);
  }
  return {
    name: metadata.name,
    variable: metadata.variable,
    variables: metadata.variables,
    baseIndices,
    memoize: metadata.memoize,
    domain: metadata.domain,
    cacheSize: metadata.memo?.size ?? 0,
    isMultiIndex: metadata.isMultiIndex
  };
}
function listSequences(ce) {
  const registry = sequenceRegistry.get(ce);
  if (!registry) return [];
  return Array.from(registry.keys());
}
function isSequence(ce, name) {
  const registry = sequenceRegistry.get(ce);
  return registry?.has(name) ?? false;
}
function clearSequenceCache(ce, name) {
  const registry = sequenceRegistry.get(ce);
  if (!registry) return;
  if (name !== void 0) {
    const metadata = registry.get(name);
    if (metadata?.memo) {
      metadata.memo.clear();
    }
  } else {
    for (const metadata of registry.values()) {
      if (metadata.memo) {
        metadata.memo.clear();
      }
    }
  }
}
function getSequenceCache(ce, name) {
  const registry = sequenceRegistry.get(ce);
  const metadata = registry?.get(name);
  if (!metadata?.memo) return void 0;
  return new Map(metadata.memo);
}
function generateSequenceTerms(ce, name, start, end, step = 1) {
  if (!Number.isInteger(start) || !Number.isInteger(end)) {
    return void 0;
  }
  if (step <= 0 || !Number.isInteger(step)) {
    return void 0;
  }
  if (!isSequence(ce, name)) {
    return void 0;
  }
  const terms = [];
  for (let n = start; step > 0 ? n <= end : n >= end; n += step) {
    const expr = ce.parse(`${name}_{${n}}`);
    const value = expr.evaluate();
    if (value.isNumberLiteral) {
      terms.push(value);
    } else {
      return void 0;
    }
  }
  return terms;
}

// src/compute-engine/library/core.ts
init_function_utils();
init_flatten();
init_strings();

// src/compute-engine/library/random-expression.ts
function oneOf(xs) {
  return xs[Math.floor(Math.random() * xs.length)];
}
function randomExpressionWithHead(operator2, level) {
  if (operator2 === "Add" || operator2 === "Multiply") {
    const ops = [];
    let count = 1 + Math.floor(Math.random() * 12);
    while (count > 0) {
      ops.push(randomExpression(level + 1));
      count -= 1;
    }
    return [operator2, ...ops];
  }
  if (operator2 === "Divide" || operator2 === "Power") {
    return [operator2, randomExpression(level + 1), randomExpression(level + 1)];
  }
  if (operator2 === "Root") {
    return [operator2, randomExpression(level + 1), randomExpression(10)];
  }
  if (operator2 === "trig") return randomTrig();
  return [operator2, randomExpression(level + 1)];
}
function randomTrig() {
  return [
    oneOf(["Cos", "Sin", "Tan", "Sinh", "Arccos", "Arsinh"]),
    oneOf([
      "Pi",
      "-1",
      "0",
      "1",
      ["Divide", "Pi", -5],
      ["Multiply", -2, ["Divide", "Pi", 11]],
      ["Multiply", "Half", "Pi"],
      ["Multiply", 5, "Pi"],
      ["Multiply", 12, "Pi"],
      ["Divide", "Pi", 5],
      ["Divide", "Pi", 9],
      ["Multiply", 5, ["Divide", "Pi", 9]],
      ["Multiply", 2, ["Divide", "Pi", 11]],
      ["Multiply", 2, ["Divide", "Pi", 3]]
    ])
  ];
}
function randomExpression(level) {
  level ??= 1;
  if (level === 1) {
    const h = oneOf([
      [
        "Sqrt",
        [
          "Multiply",
          6,
          [
            "Sum",
            ["Divide", 1, ["Power", "n", 2]],
            ["Triple", ["Hold", "n"], 1, "PositiveInfinity"]
          ]
        ]
      ],
      "Add",
      "Add",
      "Add",
      "Add",
      "Add",
      "Multiply",
      "Multiply",
      "Multiply",
      "Multiply",
      "Divide",
      "Divide",
      "Divide",
      "Root",
      "Sqrt",
      "Subtract",
      "Negate",
      "trig"
    ]);
    if (typeof h === "string") return randomExpressionWithHead(h, 1);
    return h;
  }
  if (level === 2) {
    const r = Math.random();
    if (r > 0.75) return randomExpression(1);
    if (r > 0.5) return randomExpression(3);
    const h = oneOf([
      "Multiply",
      "Multiply",
      "Add",
      "Power",
      "trig",
      "Ln",
      "Exp"
    ]);
    return randomExpressionWithHead(h, 2);
  }
  return oneOf([
    -12345e-9,
    -2,
    -2,
    -2,
    -3,
    -5,
    -6,
    -12,
    -1654e-60,
    0,
    0,
    12345e-8,
    1654e-60,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    5,
    5,
    6,
    6,
    1234.5678,
    5678.1234,
    10,
    15,
    18,
    30,
    60,
    1234e54,
    "123456789.12345678912345e200",
    "987654321.12345678912345",
    ["Rational", -6, 10],
    ["Rational", -12, 15],
    ["Rational", -15, 12],
    ["Rational", 3, 5],
    ["Rational", 12, 15],
    ["Rational", 15, 12],
    "ExponentialE",
    // 'ImaginaryUnit',
    ["Sqrt", 3],
    ["Sqrt", 5],
    ["Sqrt", 15],
    ["Sqrt", 25],
    ["Complex", -1.1, 1.1],
    ["Complex", 4, 5],
    "x",
    "x",
    "x",
    "x",
    ["Add", "x", 1],
    ["Divide", "x", 3],
    ["Square", "x"],
    ["Power", "x", 3],
    ["Power", "x", 4],
    ["Subtract", "x", 1],
    ["Add", "x", 1],
    // 'a',
    // 'b',
    "Pi"
  ]);
}

// src/compute-engine/library/core.ts
init_utils();
init_parse();
init_arithmetic_mul_div();
init_canonical_utils();
init_utils5();
var CORE_LIBRARY = [
  {
    // The sole member of the unit type, `nothing`
    Nothing: { type: "nothing" }
  },
  //
  // Inert functions
  //
  {
    /**
     * ### THEORY OF OPERATIONS: SEQUENCES
     *
     * There are three similar functions used to represent sequences of
     * expressions:
     *
     * - `InvisibleOperator` represent a sequence of expressions
     *  that are syntactically juxtaposed without any separator or
     *  operators combining them.
     *
     *  For example, `2x` is represented as `["InvisibleOperator", 2, "x"]`.
     *  `InvisibleOperator` gets transformed into `Multiply` (or some other
     *  semantic operation) during canonicalization.
     *
     * - `Sequence` is used to represent a sequence of expressions
     *   at a semantic level. It is a collection, but it is handled
     *   specially when canonicalizing expressions, for example it
     *   is automatically flattened and hoisted to the top level of the
     *   argument list.
     *
     *   For example:
     *
     *     `["Add", "a", ["Sequence", "b", "c"]]`
     *
     *   is canonicalized to
     *
     *     `["Add", "a", "b", "c"]`.
     *
     *   The empty `Sequence` expression (i.e. `["Sequence"]`) is ignored
     *   but it can be used to represent an "empty" expression. It is a
     *   synonym for `Nothing`.
     *
     * - `Delimiter` is used to represent a group of expressions
     *   with an open and close delimiter and a separator.
     *
     *   They capture the input syntax, and can get transformed into other
     *   expressions during boxing and canonicalization.
     *
     *   The first argument is a function expression, such as `List`
     *   or `Sequence`. The arguments of that expression are represented
     *   with a separator between them and delimiters around the whole
     *   group.
     *
     *  If the first argument is a `Sequence` with a single element,
     *   the `Sequence` can be omitted.
     *
     *   The second argument specify the separator and delimiters. If not
     *   specified, the default is the string `"(,)"`
     *
     * Examples:
     * - `f(x)` ->
     *    `["InvisibleOperator",
     *        "f",
     *        ["Delimiter", "x"]
     *     ]`
     *
     * - `1, 2; 3, 4` ->
     *    `["Delimiter",
     *      ["Sequence",
     *        ["Delimiter", ["Sequence", 1, 2], "','"],
     *        ["Delimiter", ["Sequence", 3, 4], "','"],
     *      ],
     *     "';'"
     *    ]`
     *
     * - `2x` -> `["InvisibleOperator", 2, "x"]`
     *
     * - `2+` -> `["InvisibleOperator", 2,
     *              ["Error", "'unexpected-operator'", "+"]]`
     *
     *
     *
     *
     */
    InvisibleOperator: {
      complexity: 9e3,
      lazy: true,
      signature: "function",
      // Note: since the canonical form will be a different operator,
      // no need to calculate the result type
      canonical: (x, { engine }) => {
        const y = canonicalInvisibleOperator(x, { engine });
        if (!y) return engine.Nothing;
        if (y.operator === "Multiply") return canonicalMultiply(engine, y.ops);
        return y;
      }
    },
    /** See above for a theory of operations */
    Sequence: {
      lazy: true,
      signature: "function",
      type: (args) => {
        if (args.length === 0) return "nothing";
        if (args.length === 1) return args[0].type;
        return "any";
      },
      canonical: (args, { engine: ce }) => {
        const xs = flatten(args);
        if (xs.length === 0) return ce.Nothing;
        if (xs.length === 1) return xs[0];
        return ce._fn("Sequence", xs);
      }
    },
    /** See above for a theory of operations */
    Delimiter: {
      // Use to represent groups of expressions.
      // Named after https://en.wikipedia.org/wiki/Delimiter
      complexity: 9e3,
      lazy: true,
      signature: "(any, string?) -> any",
      type: (args) => {
        if (args.length === 0) return "nothing";
        return args[0].type;
      },
      canonical: (args, { engine: ce }) => {
        if (args.length === 0) return ce._fn("Tuple", []);
        if (args.length > 2)
          return ce._fn("Delimiter", checkArity(ce, args, 2));
        let body = args[0];
        if (body.operator === "Sequence")
          return ce._fn("Tuple", canonical(ce, body.ops));
        body = body.canonical;
        const delim = args[1]?.string;
        if (!delim || delim.startsWith("(") && delim.endsWith(")"))
          return body;
        if ((delim?.length ?? 0) > 3) {
          return ce._fn("Delimiter", [
            body,
            ce.error("invalid-delimiter", args[1].toString())
          ]);
        }
        return ce._fn("Delimiter", [args[0], checkType(ce, args[1], "string")]);
      },
      evaluate: (ops, options) => {
        const ce = options.engine;
        if (ops.length === 0) return ce.Nothing;
        const op1 = ops[0];
        if (op1.operator === "Sequence" || op1.operator === "Delimiter")
          ops = flattenSequence(ops[0].ops);
        if (ops.length === 1) return ops[0].evaluate(options);
        return ce._fn(
          "Tuple",
          ops.map((x) => x.evaluate(options))
        );
      }
    },
    Error: {
      /**
       * - The first argument is either a string or an `["ErrorCode"]`
       * expression indicating the nature of the error.
       * - The second argument, if present, indicates the context/location
       * of the error. If the error occur while parsing a LaTeX string,
       * for example, the argument will be a `Latex` expression.
       */
      lazy: true,
      complexity: 500,
      signature: "((string|expression<ErrorCode>), expression?) -> nothing",
      // To make a canonical expression, don't canonicalize the args
      canonical: (args, { engine: ce }) => ce._fn("Error", args)
    },
    ErrorCode: {
      complexity: 500,
      lazy: true,
      signature: "(string, any*) -> error",
      canonical: (args, { engine: ce }) => {
        const code = checkType(ce, args[0], "string").string;
        if (code === "incompatible-type") {
          return ce._fn("ErrorCode", [ce.string(code), args[1], args[2]]);
        }
        return ce._fn("ErrorCode", args);
      }
    },
    Unevaluated: {
      description: "Prevent an expression from being evaluated",
      // Unlike Hold, the argument is canonicalized
      lazy: true,
      signature: "(any) -> unknown",
      type: ([x]) => x.type,
      canonical: (args, { engine: ce, scope }) => ce._fn("Unevaluated", canonical(ce, args, scope)),
      evaluate: ([x], options) => x.evaluate(options)
    },
    Hold: {
      description: "Hold an expression, preventing it from being canonicalized or evaluated until `ReleaseHold` is applied to it",
      lazy: true,
      signature: "(any) -> unknown",
      // Note: the operator is lazy and doesn't have a canonical handler:
      // the argument is not canonicalized.
      type: ([x]) => {
        if (x.symbol) return "symbol";
        if (x.string) return "string";
        if (x.isNumberLiteral) return x.type;
        if (x.ops) return functionResult(x.type.type) ?? "unknown";
        return "unknown";
      },
      // When comparing hold expressions, consider them equal if their
      // arguments are structurally equal.
      eq: (a, b) => {
        if (b.operator === "Hold") b = b.ops[0];
        return a.ops[0].isSame(b);
      },
      evaluate: ([x], { engine }) => engine.hold(x)
    },
    ReleaseHold: {
      description: "Release an expression held by `Hold`",
      lazy: true,
      signature: "(any) -> unknown",
      type: ([x]) => x.operator === "Hold" ? x.op1.type : x.type,
      // Note: the operator is lazy and doesn't have a canonical handler:
      // the argument is not canonicalized.
      evaluate: ([x], options) => {
        if (x.operator === "Hold") x = x.op1;
        return x.canonical.evaluate(options);
      }
    },
    HorizontalSpacing: {
      signature: "(number) -> nothing",
      canonical: (args, { engine: ce }) => {
        if (args.length === 2) return args[0].canonical;
        return ce.Nothing;
      }
    },
    Annotated: {
      signature: "(expression, dictionary) -> expression",
      type: ([x]) => x.type,
      complexity: 9e3,
      lazy: true,
      canonical: ([x, style], { engine: ce }) => {
        x = x.canonical;
        style = style.canonical;
        if (!isDictionary(style) || style.keys.length === 0) return x;
        return ce._fn("Annotated", [x, style]);
      },
      evaluate: ([x, _style], options) => x.evaluate(options)
      // xcompile: (expr) => expr.op1.compile(),
    },
    Text: {
      description: "A sequence of strings, annotated expressions and other Text expressions",
      signature: "(any*) -> expression"
    }
  },
  {
    //
    // Structural operations that can be applied to non-canonical expressions
    //
    About: {
      description: "Return information about an expression",
      lazy: true,
      signature: "(any) -> string",
      evaluate: ([x], { engine: ce }) => {
        const s = [x.toString()];
        s.push("");
        if (x.string) s.push("string");
        else if (x.symbol) {
          if (x.valueDefinition) {
            const def = x.valueDefinition;
            if (def.isConstant) s.push("constant");
            if (typeof def.description === "string") s.push(def.description);
            else if (Array.isArray(def.description))
              s.push(def.description.join("\n"));
            if (def.wikidata) s.push(`WikiData: ${def.wikidata}`);
            if (def.url) s.push(`Read More: ${def.url}`);
          } else {
            s.push("symbol");
            s.push(`value: ${x.evaluate().toString()}`);
          }
        } else if (x.isNumberLiteral) s.push(x.type.toString());
        else if (x.ops) {
          s.push(x.type.toString());
          s.push(x.isCanonical ? "canonical" : "non-canonical");
        } else s.push("Unknown expression's type");
        return ce.string(s.join("\n"));
      }
    },
    Head: {
      description: "Return the head of an expression, the name of the operator",
      lazy: true,
      signature: "(any) -> symbol",
      canonical: (args, { engine: ce }) => {
        if (args.length !== 1) return null;
        const op1 = args[0];
        if (op1.operator) return ce.box(op1.operator);
        return ce._fn("Head", canonical(ce, args));
      },
      evaluate: (ops, { engine: ce }) => ce.symbol(ops[0]?.operator ?? "Undefined")
    },
    Tail: {
      description: "Return the tail of an expression, the operands of the expression",
      lazy: true,
      signature: "(any) -> collection",
      canonical: (args, { engine: ce }) => {
        if (args.length !== 1) return null;
        const op1 = args[0];
        if (op1.ops) return ce._fn("Sequence", op1.ops);
        return ce._fn("Tail", canonical(ce, args));
      },
      // **IMPORTANT** Tail should work on non-canonical expressions
      evaluate: ([x], { engine: ce }) => x?.ops ? ce._fn("Sequence", x.ops) : ce.Nothing
    },
    Identity: {
      description: "Return the argument unchanged",
      signature: "(any) -> unknown",
      type: ([x]) => x.type,
      evaluate: ([x]) => x
    }
  },
  {
    Apply: {
      description: "Apply a function to a list of arguments",
      signature: "(name:symbol, arguments:expression*) -> unknown",
      type: ([fn]) => functionResult(fn.type.type) ?? "unknown",
      canonical: (args, { engine: ce }) => {
        if (args[0].symbol) return ce.function(args[0].symbol, args.slice(1));
        return ce._fn("Apply", args);
      },
      evaluate: (ops) => apply3(ops[0], ops.slice(1))
    },
    Assign: {
      description: "Assign a value to a symbol or define a sequence",
      lazy: true,
      pure: false,
      signature: "(symbol | expression, any) -> any",
      type: ([_symbol, value]) => value.type,
      canonical: (args, { engine: ce }) => {
        if (args.length !== 2) return null;
        const lhs = args[0];
        if (lhs.operator === "Subscript") {
          return ce._fn("Assign", [lhs.canonical, args[1].canonical]);
        }
        let symbol2 = lhs;
        if (!symbol2.symbol) {
          symbol2 = checkType(ce, lhs, "symbol");
        }
        return ce._fn("Assign", [symbol2, args[1].canonical]);
      },
      evaluate: ([op1, op2], { engine: ce }) => {
        if (op1.symbol && op1.symbol.includes("_")) {
          const underscoreIndex = op1.symbol.indexOf("_");
          const seqName = op1.symbol.substring(0, underscoreIndex);
          const subscriptStr = op1.symbol.substring(underscoreIndex + 1);
          const subscriptNum = parseInt(subscriptStr, 10);
          if (!isNaN(subscriptNum) && String(subscriptNum) === subscriptStr) {
            const value = op2.evaluate();
            addSequenceBaseCase(ce, seqName, subscriptNum, value);
            return ce.Nothing;
          }
          if (containsSelfReference(op2, seqName)) {
            addSequenceRecurrence(ce, seqName, subscriptStr, op2);
            return ce.Nothing;
          }
          const fnDef = ce.function("Function", [op2, ce.symbol(subscriptStr)]);
          ce.assign(seqName, fnDef);
          return ce.Nothing;
        }
        if (op1.operator === "Subscript" && op1.op1?.symbol) {
          const seqName = op1.op1.symbol;
          const subscript = op1.op2;
          if (subscript?.operator === "Sequence" && subscript.ops) {
            const indices = subscript.ops;
            if (indices.every(
              (op) => op.isNumberLiteral && Number.isInteger(op.re)
            )) {
              const key = indices.map((op) => op.re).join(",");
              addMultiIndexBaseCase(ce, seqName, key, op2.evaluate());
              return ce.Nothing;
            }
            const indexVars = [];
            let hasSymbols = false;
            let allValid = true;
            for (const idx of indices) {
              if (idx.symbol) {
                indexVars.push(idx.symbol);
                hasSymbols = true;
              } else if (idx.isNumberLiteral && Number.isInteger(idx.re)) {
                indexVars.push(String(idx.re));
              } else {
                const v = extractIndexVariable(idx);
                if (v) {
                  indexVars.push(v);
                  hasSymbols = true;
                } else {
                  allValid = false;
                  break;
                }
              }
            }
            if (allValid && indexVars.length === indices.length) {
              if (containsSelfReference(op2, seqName)) {
                const recurrenceVars = indices.filter((idx) => idx.symbol).map((idx) => idx.symbol);
                if (recurrenceVars.length > 0) {
                  addMultiIndexRecurrence(ce, seqName, recurrenceVars, op2);
                  return ce.Nothing;
                }
              } else if (hasSymbols) {
                const key = indexVars.join(",");
                addMultiIndexBaseCase(ce, seqName, key, op2.evaluate());
                return ce.Nothing;
              }
            }
          }
          if (subscript?.isNumberLiteral && Number.isInteger(subscript.re)) {
            const index = subscript.re;
            const value = op2.evaluate();
            addSequenceBaseCase(ce, seqName, index, value);
            return ce.Nothing;
          }
          if (subscript?.symbol) {
            const indexVar = subscript.symbol;
            if (containsSelfReference(op2, seqName)) {
              addSequenceRecurrence(ce, seqName, indexVar, op2);
              return ce.Nothing;
            } else {
              const fnDef = ce.function("Function", [op2, ce.symbol(indexVar)]);
              ce.assign(seqName, fnDef);
              return ce.Nothing;
            }
          }
          if (containsSelfReference(op2, seqName)) {
            const indexVar = extractIndexVariable(subscript);
            if (indexVar) {
              addSequenceRecurrence(ce, seqName, indexVar, op2);
              return ce.Nothing;
            }
          }
        }
        const symbol2 = op1.evaluate();
        if (!symbol2.symbol) return void 0;
        const val = op2.evaluate();
        ce.assign(symbol2.symbol, val);
        return val;
      }
    },
    Assume: {
      description: "Assume a type for a symbol",
      lazy: true,
      pure: false,
      signature: "(any) -> symbol",
      evaluate: (ops, { engine: ce }) => ce.symbol(ce.assume(ops[0]))
    },
    Declare: {
      lazy: true,
      pure: false,
      signature: "(symbol, type: string | symbol) -> nothing",
      canonical: (args, { engine: ce }) => {
        let symbol2 = args[0];
        if (!symbol2.symbol) {
          symbol2 = checkType(ce, args[0], "symbol");
        }
        if (args.length === 1) return ce._fn("Declare", [symbol2]);
        if (args.length !== 2) return null;
        return ce._fn("Declare", [symbol2, args[1]]);
      },
      evaluate: (ops, { engine: ce }) => {
        const symbol2 = ops[0].evaluate().symbol;
        if (!symbol2) return void 0;
        if (!ops[1]) {
          ce.declare(symbol2, { inferred: true, type: "unknown" });
          return ce.Nothing;
        }
        const t = ops[1].canonical.evaluate();
        const type2 = parseType(t.string ?? t.symbol ?? void 0);
        if (!isValidType(type2)) return void 0;
        ce.declare(symbol2, type2);
        return ce.Nothing;
      }
    },
    /** Return the type of an expression */
    Type: {
      lazy: true,
      signature: "(any) -> string",
      evaluate: ([x], { engine: ce }) => ce.string(x.type.toString() ?? "unknown")
    },
    Evaluate: {
      lazy: true,
      signature: "(any) -> unknown",
      type: ([x]) => x.type,
      canonical: (ops, { engine: ce }) => ce._fn("Evaluate", checkArity(ce, ops, 1)),
      evaluate: ([x], options) => x.evaluate(options)
    },
    // Evaluate an expression at a specific point, potentially symbolically
    // i.e. it's the `f|_{a}` notation
    EvaluateAt: {
      lazy: true,
      signature: "(function, lower:number, upper:number) -> number",
      type: ([x]) => functionResult(x.type.type) ?? "number",
      canonical: (ops, { engine: ce }) => {
        if (ops.length === 0) return null;
        const fn = canonicalFunctionLiteral(ops[0]);
        if (!fn) return null;
        return ce._fn("EvaluateAt", [
          fn,
          ...ops.slice(1).map((x) => checkType(ce, x, "value"))
        ]);
      },
      evaluate: ([f, lower, upper], { engine: ce }) => {
        if (upper === void 0) {
          const result = apply3(f, [lower]);
          if (result && result.isNumberLiteral) return result;
          return ce._fn("EvaluateAt", [f, lower]);
        }
        const fLower = apply3(f, [lower]);
        const fUpper = apply3(f, [upper]);
        if (fLower && fUpper && fLower.N().isNumberLiteral && fUpper.N().isNumberLiteral) {
          return fUpper.sub(fLower);
        }
        return ce._fn("EvaluateAt", [f, lower, upper]);
      }
    },
    BuiltinFunction: {
      complexity: 9876,
      lazy: true,
      signature: "(symbol | string) -> symbol",
      canonical: ([symbol2], { engine: ce }) => ce.symbol(symbol2.symbol ?? symbol2.string ?? "Undefined")
    },
    Function: {
      description: "A function literal",
      complexity: 9876,
      lazy: true,
      signature: "(expression, symbol*) -> function",
      type: ([body, ...args]) => `(${args.map((x) => x.type.type)}) -> ${body.type.type}`,
      canonical: (args, { engine }) => canonicalFunctionLiteralArguments(engine, args) ?? null,
      evaluate: (_args) => {
        return void 0;
      }
    },
    Rule: {
      lazy: true,
      signature: "(match: expression, replace: expression, predicate: function?) -> expression",
      evaluate: ([match2, replace2, predicate2], { engine: ce }) => {
        return void 0;
      }
    },
    Simplify: {
      lazy: true,
      signature: "(any) -> expression",
      canonical: (ops, { engine: ce }) => ce._fn("Simplify", checkArity(ce, ops, 1)),
      evaluate: ([x]) => x.simplify() ?? void 0
    },
    CanonicalForm: {
      description: [
        "Return the canonical form of an expression",
        "Can be used to sort arguments of an expression.",
        'Sorting arguments of commutative functions is a weak form of canonicalization that can be useful in some cases, for example to accept "x+1" and "1+x" while rejecting "x+1" and "2x-x+1"'
      ],
      complexity: 8200,
      lazy: true,
      signature: "(any, symbol*) -> any",
      // Do not canonicalize the arguments, we want to preserve
      // the original form before modifying it
      canonical: (ops) => {
        if (ops.length === 1) return ops[0].canonical;
        const forms = ops.slice(1).map((x) => x.symbol ?? x.string).filter((x) => x !== void 0 && x !== null);
        return canonicalForm(ops[0], forms);
      }
    },
    N: {
      description: "Numerically evaluate an expression",
      lazy: true,
      signature: "(any) -> unknown",
      type: ([x]) => x.type,
      canonical: (ops, { engine: ce }) => {
        if (ops.length !== 1) return ce._fn("N", checkArity(ce, ops, 1));
        const h = ops[0].operator;
        if (h === "N" || h === "Evaluate") return ops[0].canonical;
        return ce._fn("N", ops);
      },
      evaluate: ([x]) => x.N()
    },
    Random: {
      description: [
        "Random(): Return a random number between 0 and 1",
        "Random(n): Return a random integer between 0 and n-1",
        "Random(m, n): Return a random integer between m and n-1"
      ],
      pure: false,
      signature: "(lower:integer?, upper:integer?) -> finite_number",
      type: ([lower, upper]) => {
        if (lower === void 0 && upper === void 0) return "finite_number";
        return "finite_integer";
      },
      sgn: () => "non-negative",
      evaluate: (ops, { engine: ce }) => {
        if (ops.length === 0) return ce.number(Math.random());
        const [lowerOp, upperOp] = ops;
        let lower;
        let upper;
        if (upperOp === void 0) {
          lower = 0;
          upper = Math.floor(lowerOp.re - 1);
          if (isNaN(upper)) upper = 0;
        } else {
          lower = Math.floor(lowerOp.re);
          upper = Math.floor(upperOp.re);
          if (isNaN(lower)) lower = 0;
          if (isNaN(upper)) upper = 0;
        }
        return ce.number(lower + Math.floor(Math.random() * (upper - lower)));
      }
    },
    // @todo: need review
    Signature: {
      lazy: true,
      signature: "(symbol) -> string | nothing",
      evaluate: ([x], { engine: ce }) => {
        if (!x.operatorDefinition) return ce.Nothing;
        return ce.string(x.operatorDefinition.signature.toString());
      }
    },
    Subscript: {
      /**
       * The `Subscript` function can take several forms:
       *
       * If `op1` is a string, the string is interpreted as a number in
       * base `op2` (2 to 36).
       *
       * If `op1` is an indexable collection, `x`:
       * - `x_*` -> `At(x, *)`
       *
       * Otherwise:
       * - `x_0` -> Symbol "x_0"
       * - `x_n` -> Symbol "x_n"
       * - `x_{\text{max}}` -> Symbol `x_max`
       * - `x_{(n+1)}` -> `At(x, n+1)`
       * - `x_{n+1}` ->  `Subscript(x, n+1)`
       */
      // The last (subscript) argument can include a delimiter that
      // needs to be interpreted. Without the hold, it would get
      // removed during canonicalization.
      lazy: true,
      signature: "(collection, any) -> any",
      type: ([op1, op2], { engine: ce }) => {
        if (op1.string && asSmallInteger(op2) !== null) return "integer";
        if (op1.isIndexedCollection)
          return collectionElementType(op1.type.type) ?? "any";
        if (op1.symbol) {
          const eltType = collectionElementType(op1.type.type);
          if (eltType) return eltType;
        }
        if (op1.symbol) {
          const symbolDef = ce.lookupDefinition(op1.symbol);
          if (isValueDef(symbolDef) && symbolDef.value.subscriptEvaluate) {
            return "number";
          }
          const sub3 = op2.string ?? op2.symbol ?? asSmallInteger(op2)?.toString();
          if (sub3) return "symbol";
          if (op2.operator === "InvisibleOperator" && op2.ops) {
            const parts = op2.ops.map(
              (x) => x.symbol ?? asSmallInteger(x)?.toString()
            );
            if (parts.every((p) => p !== void 0 && p !== null))
              return "symbol";
          }
          return "unknown";
        }
        return "expression";
      },
      canonical: ([op1, op2], { engine: ce }) => {
        op1 = op1.canonical;
        if (op1.string) {
          const base = asSmallInteger(op2.canonical);
          if (base !== null && base > 1 && base <= 36) {
            const [value, rest] = fromDigits(op1.string, base);
            if (rest) {
              return ce.error(["unexpected-digit", rest[0]], op1.toString());
            }
            return ce.number(value);
          }
          return ce._fn("Baseform", [
            op1,
            ce.error(["invalid-base", op2.toString()])
          ]);
        }
        if (op1.isIndexedCollection) return ce._fn("At", [op1, op2.canonical]);
        if (op1.symbol && collectionElementType(op1.type.type)) {
          if ((op2.operator === "Sequence" || op2.operator === "Tuple") && op2.ops)
            return ce._fn("At", [op1, ...op2.ops.map((x) => x.canonical)]);
          return ce._fn("At", [op1, op2.canonical]);
        }
        if (op1.symbol) {
          const symbolDef = ce.lookupDefinition(op1.symbol);
          if (isValueDef(symbolDef) && symbolDef.value.subscriptEvaluate) {
            return ce._fn("Subscript", [op1, op2.canonical]);
          }
        }
        if (op1.symbol) {
          const sub4 = op2.string ?? op2.symbol ?? asSmallInteger(op2)?.toString();
          if (sub4) return ce.symbol(op1.symbol + "_" + sub4);
          if (op2.operator === "InvisibleOperator" && op2.ops) {
            const parts = op2.ops.map(
              (x) => x.symbol ?? asSmallInteger(x)?.toString()
            );
            if (parts.every((p) => p !== void 0 && p !== null)) {
              return ce.symbol(op1.symbol + "_" + parts.join(""));
            }
          }
        }
        if (op2.operator === "Sequence")
          ce._fn("Subscript", [op1, ce._fn("List", op2.ops)]);
        let sub3 = op2;
        if (op2.operator === "Delimiter" && op2.op1) sub3 = op2.op1.canonical;
        return ce._fn("Subscript", [op1, sub3]);
      },
      evaluate: (ops, { engine: ce, numericApproximation }) => {
        const [base, subscript] = ops;
        if (base.symbol) {
          const def = base.valueDefinition;
          if (def?.subscriptEvaluate) {
            const evalSubscript = subscript.evaluate({ numericApproximation });
            const result = def.subscriptEvaluate(evalSubscript, {
              engine: ce,
              numericApproximation
            });
            if (result !== void 0) return result;
          }
        }
        return void 0;
      }
    },
    Symbol: {
      complexity: 500,
      description: "Construct a new symbol with a name formed by concatenating the arguments",
      broadcastable: true,
      lazy: true,
      signature: "function",
      type: (args) => {
        if (args.length === 0) return "nothing";
        return "symbol";
      },
      canonical: (ops, { engine: ce }) => {
        if (ops.length === 0) return ce.Nothing;
        return ce._fn(
          "Symbol",
          ops.map((x) => x.symbol ? x : x.canonical)
        );
      },
      evaluate: (ops, { engine: ce }) => {
        console.assert(ops.length > 0);
        const arg = ops.map(
          (x) => x.symbol ?? x.string ?? asSmallInteger(x)?.toString() ?? ""
        ).join("");
        return ce.symbol(arg);
      }
    },
    Timing: {
      description: "`Timing(expr)` evaluates `expr` and return a `Pair` of the number of second elapsed for the evaluation, and the value of the evaluation",
      signature: "(value, repeat: integer?) -> tuple<result:value, time:number>",
      evaluate: (ops, { engine: ce }) => {
        if (ops[1].symbol === "Nothing") {
          const start = globalThis.performance.now();
          const result2 = ops[0].evaluate();
          const timing = 1e3 * (globalThis.performance.now() - start);
          return ce.tuple(ce.number(timing), result2);
        }
        let n = Math.max(3, toInteger(ops[1]) ?? 3);
        let timings = [];
        let result;
        while (n > 0) {
          const start = globalThis.performance.now();
          result = ops[0].evaluate();
          timings.push(1e3 * (globalThis.performance.now() - start));
          n -= 1;
        }
        const max3 = Math.max(...timings);
        const min3 = Math.min(...timings);
        timings = timings.filter((x) => x > min3 && x < max3);
        const sum2 = timings.reduce((acc, v) => acc + v, 0);
        if (sum2 === 0) return ce.tuple(ce.number(max3), result);
        return ce.tuple(ce.number(sum2 / timings.length), result);
      }
    }
  },
  //
  // Wildcards
  //
  {
    Wildcard: {
      signature: "(symbol) -> symbol",
      canonical: (args, { engine: ce }) => {
        if (args.length !== 1) return ce.symbol("_");
        return ce.symbol("_" + args[0].symbol);
      }
    },
    WildcardSequence: {
      signature: "(symbol) -> symbol",
      canonical: (args, { engine: ce }) => {
        if (args.length !== 1) return ce.symbol("__");
        return ce.symbol("__" + args[0].symbol);
      }
    },
    WildcardOptionalSequence: {
      signature: "(symbol) -> symbol",
      canonical: (args, { engine: ce }) => {
        if (args.length !== 1) return ce.symbol("___");
        return ce.symbol("___" + args[0].symbol);
      }
    }
  },
  //
  // LaTeX-related
  //
  {
    LatexString: {
      description: "Value preserving type conversion/tag indicating the string is a LaTeX string",
      signature: "(string) -> string",
      evaluate: ([s]) => s
    },
    Latex: {
      description: "Serialize an expression to LaTeX",
      signature: "(any+) -> string",
      evaluate: (ops, { engine: ce }) => ce.box(["LatexString", ce.string(joinLatex(ops.map((x) => x.latex)))])
    },
    Parse: {
      description: "Parse a LaTeX string and evaluate to a corresponding expression",
      signature: "(string) -> any",
      evaluate: ([s], { engine: ce }) => ce.parse(s.string) ?? ce.Nothing
    }
  },
  //
  // String
  //
  {
    // This is a string interpolation function
    String: {
      description: "A string created by joining its arguments. The arguments are converted to their default string representation.",
      broadcastable: true,
      signature: "(any*) -> string",
      evaluate: (ops, { engine }) => {
        if (ops.length === 0) return engine.string("");
        return engine.string(ops.map((x) => x.toString()).join(""));
      }
    },
    // Converts arguments interpreted in a specified format to a string.
    StringFrom: {
      description: "Create a string by converting its arguments to a string and joining them.",
      broadcastable: true,
      signature: "(any, format:string?) -> string",
      evaluate: ([value, format], { engine }) => {
        if (value === void 0) return engine.string("");
        const fmt = format?.string ?? "default";
        if (fmt === "default") return engine.string(value.toString());
        if (fmt === "utf-8") {
          if (!value.isIndexedCollection) {
            return engine.typeError(
              parseType("indexed_collection<integer>"),
              value.type
            );
          }
          return engine.string(
            new TextDecoder("utf-8").decode(
              new Uint8Array(
                [...value.each()].map((x) => toInteger(x) ?? 65533)
              )
            )
          );
        }
        if (fmt === "utf-16") {
          if (!value.isIndexedCollection) {
            return engine.typeError(
              parseType("indexed_collection<integer>"),
              value.type
            );
          }
          return engine.string(
            new TextDecoder("utf-16").decode(
              new Uint16Array(
                [...value.each()].map((x) => toInteger(x) ?? 65533)
              )
            )
          );
        }
        if (fmt === "unicode-scalars") {
          const cp = toInteger(value);
          if (cp !== null) return engine.string(String.fromCodePoint(cp));
          if (!value.isIndexedCollection) {
            return engine.typeError(
              parseType("indexed_collection<integer>|integer"),
              value.type
            );
          }
          return engine.string(
            String.fromCodePoint(
              ...[...value.each()].map((x) => toInteger(x) ?? 65533)
            )
          );
        }
        return engine.string(value.toString());
      }
    },
    Utf8: {
      description: "A collection of UTF-8 code units from a string.",
      signature: "(string) -> list<integer>",
      evaluate: ([str], { engine }) => {
        if (!str.string) return void 0;
        const utf8Buffer = str.buffer;
        return engine.function(
          "List",
          Array.from(utf8Buffer, (code) => engine.number(code))
        );
      }
    },
    Utf16: {
      description: "A collection of UTF-16 code units from a string.",
      signature: "(string) -> list<integer>",
      evaluate: ([str], { engine }) => {
        if (!str.string) return void 0;
        const utf16Values = [];
        for (let i = 0; i < str.string.length; i++) {
          const codePoint = str.string.charCodeAt(i);
          utf16Values.push(codePoint);
        }
        return engine.function(
          "List",
          utf16Values.map((cp) => engine.number(cp))
        );
      }
    },
    UnicodeScalars: {
      description: "A collection of Unicode scalars from a string, same as UTF-32",
      signature: "(string) -> list<integer>",
      evaluate: ([str], { engine }) => {
        if (!str.string) return void 0;
        const codePoints = str.unicodeScalars;
        return engine.function(
          "List",
          codePoints.map((cp) => engine.number(cp))
        );
      }
    },
    GraphemeClusters: {
      description: "A collection of grapheme clusters from a string.",
      signature: "(string) -> list<string>",
      evaluate: ([str], { engine }) => {
        if (!str.string) return void 0;
        const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
        const graphemes = Array.from(
          segmenter.segment(str.string),
          (seg) => engine.string(seg.segment)
        );
        return engine.function("List", graphemes);
      }
    },
    BaseForm: {
      description: "`BaseForm(expr, base=10)`",
      complexity: 9e3,
      signature: "(number, (string|integer)?) -> string | nothing",
      type: ([x]) => x === void 0 ? "nothing" : x.type,
      evaluate: ([x]) => x
    },
    DigitsFrom: {
      description: `Return an integer representation of the string \`s\` in base \`base\`.`,
      // @todo could accept `0xcafe`, `0b01010` or `(deadbeef)_16` as string formats
      // @todo could accept "roman"... as base
      // @todo could accept optional third parameter as the (padded) length of the output
      signature: "(string, (string|integer)?) -> integer",
      evaluate: (ops, { engine }) => {
        let op1 = ops[0]?.string;
        const ce = engine;
        if (!op1) return ce.typeError("string", ops[0]?.type, ops[0]);
        op1 = op1.trim();
        if (op1.startsWith("0x")) return ce.number(parseInt(op1.slice(2), 16));
        if (op1.startsWith("0b")) return ce.number(parseInt(op1.slice(2), 2));
        const op2 = ops[1] ?? ce.Nothing;
        if (op2.symbol === "Nothing")
          return ce.number(Number.parseInt(op1, 10));
        const base = op2.re;
        if (!op2.isInteger || !Number.isFinite(base) || base < 2 || base > 36)
          return ce.error(["unexpected-base", base.toString()], op2.toString());
        const [value, rest] = fromDigits(op1, op2.string ?? op2.symbol ?? 10);
        if (rest) return ce.error(["unexpected-digit", rest[0]], rest);
        return ce.number(value);
      }
    },
    IntegerString: {
      description: `\`IntegerString(n, base=10)\`       return a string representation of the integer \`n\` in base \`base\`.`,
      // @todo could accept `0xcafe`, `0b01010` or `(deadbeef)_16` as string formats
      // @todo could accept "roman"... as base
      // @todo could accept optional third parameter as the (padded) length of the output
      broadcastable: true,
      signature: "(integer, integer?) -> string",
      evaluate: (ops, { engine }) => {
        const ce = engine;
        const op1 = ops[0];
        if (!op1.isInteger) return ce.typeError("integer", op1.type, op1);
        const val = op1.re;
        if (!Number.isFinite(val))
          return ce.typeError("integer", op1.type, op1);
        const op2 = ops[1] ?? ce.Nothing;
        if (op2.symbol === "Nothing") {
          if (op1.bignumRe !== void 0)
            return ce.string(op1.bignumRe.abs().toString());
          return ce.string(Math.abs(val).toString());
        }
        const base = asSmallInteger(op2);
        if (base === null) return ce.typeError("integer", op2.type, op2);
        if (base < 2 || base > 36)
          return ce.error(
            ["out-of-range", "2", "36", base.toString()],
            op2.toString()
          );
        return ce.string(Math.abs(val).toString(base));
      }
    }
  },
  {
    RandomExpression: {
      signature: "() -> expression",
      evaluate: (_ops, { engine }) => engine.box(randomExpression())
    }
  }
];

// src/compute-engine/library/linear-algebra.ts
init_parse();
init_subtype();
init_boxed_tensor();
init_validate();
init_collection_utils();
var LINEAR_ALGEBRA_LIBRARY = [
  {
    Matrix: {
      complexity: 9e3,
      lazy: true,
      signature: "(matrix, string?, string?) -> matrix",
      type: ([matrix]) => matrix.type,
      canonical: canonicalMatrix,
      evaluate: (ops, options) => ops[0].evaluate(options)
    },
    // Vector is a specialized collection to represent a column vector.
    // ["Vector", a, b, c] is a shorthand for ["List", ["List", a], ["List", b], ["List", c]]
    Vector: {
      complexity: 9e3,
      lazy: true,
      signature: "(number+) -> vector",
      type: (elements) => parseType(
        `vector<${elements.length}>`,
        elements[0].engine._typeResolver
      ),
      canonical: (ops, { engine: ce }) => {
        return ce._fn("Matrix", [
          ce.function(
            "List",
            ops.map((op) => ce.function("List", [op]))
          )
        ]);
      }
    }
  },
  {
    // Corresponds to monadic Shape `` in APL
    Shape: {
      complexity: 8200,
      signature: "(value) -> tuple",
      evaluate: ([xs], { engine: ce }) => ce.tuple(...xs.shape)
    },
    Rank: {
      description: "The length of the shape of the expression. Note this is not the matrix rank (the number of linearly independent rows or columns in the matrix)",
      complexity: 8200,
      signature: "(value) -> number",
      sgn: () => "positive",
      evaluate: ([xs], { engine: ce }) => ce.number(xs.rank)
    },
    // Corresponds to ArrayReshape in Mathematica
    // and dyadic Shape `` in APL
    Reshape: {
      complexity: 8200,
      signature: "(value, tuple) -> value",
      type: ([value, shape]) => {
        if (value.isNumber) {
          return parseType(
            `list<number^${shape.ops.map((x) => x.toString()).join("x")}>`
          );
        }
        if (!value.type.matches("list")) return "nothing";
        const col = value.type.type;
        if (!isSubtype(col.elements, "number")) return "nothing";
        return parseType(
          `list<number^${shape.ops.map((x) => x.toString()).join("x")}>`
        );
      },
      evaluate: (ops, { engine: ce }) => {
        let op1 = ops[0].evaluate();
        const targetShape = ops[1].ops?.map((op) => op.re) ?? [];
        if (targetShape.length === 0) {
          if (op1.isNumber) return op1;
          if (isBoxedTensor(op1)) {
            const flatData = op1.tensor.flatten();
            return flatData.length > 0 ? ce.box(flatData[0]) : ce.Zero;
          }
          return void 0;
        }
        if (op1.isNumber) {
          return reshapeWithCycling(ce, [op1], targetShape);
        }
        if (!isBoxedTensor(op1) && isFiniteIndexedCollection(op1))
          op1 = ce.function("List", [...op1.each()]);
        if (isBoxedTensor(op1)) {
          if (targetShape.join("x") === op1.shape.join("x")) return op1;
          const flatData = op1.tensor.flatten();
          const flatElements = flatData.map((x) => ce.box(x));
          return reshapeWithCycling(ce, flatElements, targetShape);
        }
        return void 0;
      }
    },
    // Corresponds to Ravel `,` in APL
    // Also Enlist ```` in APL
    Flatten: {
      complexity: 8200,
      signature: "(value) -> list",
      evaluate: (ops, { engine: ce }) => {
        const op1 = ops[0].evaluate();
        if (op1.isNumber) return ce.box(["List", op1]);
        if (isBoxedTensor(op1))
          return ce.box([
            "List",
            ...op1.tensor.flatten().map((x) => ce.box(x))
          ]);
        if (isFiniteIndexedCollection(op1))
          return ce.function("List", [...op1.each()]);
        return void 0;
      }
    },
    // Similar to Zip, but has a single argument, a matrix
    // Ex: Transpose([[a, b, c], [1, 2, 3]]) = [[a, 1], [b, 2], [c, 3]]
    // For rank > 2: Default swaps last two axes, or specify explicit axes
    Transpose: {
      complexity: 8200,
      signature: "(value, axis1: integer?, axis2: integer?) -> value",
      evaluate: (ops, { engine: ce }) => {
        let op1 = ops[0].evaluate();
        if (op1.isNumber) return op1;
        if (!isBoxedTensor(op1) && isFiniteIndexedCollection(op1))
          op1 = ce.function("List", [...op1.each()]);
        if (isBoxedTensor(op1)) {
          const rank2 = op1.shape.length;
          if (rank2 === 1) return op1;
          let axis1 = rank2 - 1;
          let axis2 = rank2;
          if (ops.length === 3) {
            axis1 = ops[1].re ?? axis1;
            axis2 = ops[2].re ?? axis2;
            console.assert(axis1 > 0 && axis2 > 0);
          }
          if (axis1 === axis2) return op1;
          if (axis1 <= 0 || axis1 > rank2) return void 0;
          if (axis2 <= 0 || axis2 > rank2) return void 0;
          return op1.tensor.transpose(axis1, axis2)?.expression;
        }
        return void 0;
      }
    },
    // Conjugate transpose (Hermitian adjoint): transpose + complex conjugate
    // For rank > 2: Default swaps last two axes, or specify explicit axes
    ConjugateTranspose: {
      complexity: 8200,
      signature: "(value, axis1: integer?, axis2: integer?) -> value",
      evaluate: (ops, { engine: ce }) => {
        const op1 = ops[0].evaluate();
        if (op1.isNumber) return ce.box(["Conjugate", op1]).evaluate();
        if (isBoxedTensor(op1)) {
          const rank2 = op1.shape.length;
          if (rank2 === 1) {
            const elements = [...op1.each()].map(
              (el) => ce.box(["Conjugate", el]).evaluate()
            );
            return ce.box(["List", ...elements]);
          }
          let axis1 = rank2 - 1;
          let axis2 = rank2;
          if (ops.length === 3) {
            axis1 = ops[1].re ?? axis1;
            axis2 = ops[2].re ?? axis2;
            console.assert(axis1 > 0 && axis2 > 0);
          }
          if (axis1 === axis2) return op1;
          if (axis1 <= 0 || axis1 > rank2) return void 0;
          if (axis2 <= 0 || axis2 > rank2) return void 0;
          return op1.tensor.conjugateTranspose(axis1, axis2)?.expression;
        }
        return void 0;
      }
    },
    Determinant: {
      complexity: 8200,
      signature: "(matrix) -> number",
      evaluate: (ops, { engine: ce }) => {
        const op1 = ops[0].evaluate();
        if (op1.isNumber) return op1;
        if (isBoxedTensor(op1)) {
          const shape = op1.shape;
          if (shape.length === 1)
            return ce.error("expected-square-matrix", op1.toString());
          if (shape.length > 2)
            return ce.error("expected-square-matrix", op1.toString());
          if (shape.length === 2 && shape[0] !== shape[1])
            return ce.error("expected-square-matrix", op1.toString());
          return op1.tensor.determinant();
        }
        return void 0;
      }
    },
    Inverse: {
      complexity: 8200,
      signature: "(matrix) -> matrix",
      type: ([matrix]) => matrix.type,
      evaluate: ([matrix], { engine: ce }) => {
        const op1 = matrix.evaluate();
        if (op1.isNumber) return ce.box(["Divide", 1, op1]).evaluate();
        if (isBoxedTensor(op1)) {
          const shape = op1.shape;
          if (shape.length === 1)
            return ce.error("expected-square-matrix", op1.toString());
          if (shape.length > 2)
            return ce.error("expected-square-matrix", op1.toString());
          if (shape.length === 2 && shape[0] !== shape[1])
            return ce.error("expected-square-matrix", op1.toString());
          return op1.tensor.inverse()?.expression;
        }
        return void 0;
      }
    },
    PseudoInverse: {
      complexity: 8200,
      signature: "(matrix) -> matrix",
      evaluate: ([matrix], { engine: ce }) => {
        const op1 = matrix.evaluate();
        if (op1.isNumber) {
          if (op1.isZero) return ce.Zero;
          return ce.box(["Divide", 1, op1]).evaluate();
        }
        if (isBoxedTensor(op1)) return op1.tensor.pseudoInverse()?.expression;
        return void 0;
      }
    },
    // Adjoint: {
    //   complexity: 8200,
    //   signature: {
    //     domain: ['FunctionOf', 'Values', 'Values'],
    //     evaluate: (ops) => {
    //       const op1 = ops[0];
    //       if (isBoxedTensor(op1)) return op1.adjoint()?.adjugateMatrix();
    //       return undefined;
    //     },
    //   },
    // },
    AdjugateMatrix: {
      complexity: 8200,
      signature: "(matrix) -> matrix",
      evaluate: (ops) => {
        const op1 = ops[0].evaluate();
        if (isBoxedTensor(op1)) return op1.tensor.adjugateMatrix()?.expression;
        return void 0;
      }
    },
    // Minor: {
    //   complexity: 8200,
    //   signature: {
    //     domain: ['FunctionOf', 'Values', 'Values', 'Values'],
    //     evaluate: (ops) => {
    //       const op1 = ops[0];
    //       // if (isBoxedTensor(op1)) return op1.minor();
    //       return undefined;
    //     },
    //   },
    // },
    // Trace: sum of diagonal elements
    // For matrices: returns scalar
    // For rank > 2 tensors: returns tensor of traces over last two axes (batch trace)
    // Optional axis1, axis2 to specify which axes to trace over (default: last two)
    Trace: {
      complexity: 8200,
      signature: "(value, axis1: integer?, axis2: integer?) -> value",
      evaluate: (ops, { engine: ce }) => {
        const op1 = ops[0].evaluate();
        if (op1.isNumber) return op1;
        if (isBoxedTensor(op1)) {
          const shape = op1.shape;
          if (shape.length === 1)
            return ce.error("expected-matrix-or-tensor", op1.toString());
          let axis1 = shape.length - 1;
          let axis2 = shape.length;
          if (ops.length >= 3) {
            axis1 = ops[1].re ?? axis1;
            axis2 = ops[2].re ?? axis2;
          }
          if (axis1 <= 0 || axis1 > shape.length)
            return ce.error("invalid-axis", axis1.toString());
          if (axis2 <= 0 || axis2 > shape.length)
            return ce.error("invalid-axis", axis2.toString());
          if (axis1 === axis2)
            return ce.error("invalid-axis", "axes must be different");
          if (shape[axis1 - 1] !== shape[axis2 - 1])
            return ce.error("expected-square-matrix", op1.toString());
          const result = op1.tensor.trace(axis1, axis2);
          if (result === void 0) return void 0;
          if (typeof result === "number" || typeof result === "boolean")
            return ce.box(result);
          if (!("expression" in result)) return ce.box(result);
          return result.expression;
        }
        return void 0;
      }
    },
    // Matrix multiplication: A (mn)  B (np)  result (mp)
    // Handles matrix  matrix, matrix  vector, vector  matrix
    MatrixMultiply: {
      complexity: 8300,
      signature: "(matrix|vector, matrix|vector) -> matrix|vector",
      evaluate: (ops, { engine: ce }) => {
        const A = ops[0].evaluate();
        const B = ops[1].evaluate();
        if (!isBoxedTensor(A) || !isBoxedTensor(B)) return void 0;
        const shapeA = A.shape;
        const shapeB = B.shape;
        if (shapeA.length === 1 && shapeB.length === 1) {
          if (shapeA[0] !== shapeB[0])
            return ce.error(
              "incompatible-dimensions",
              `${shapeA[0]} vs ${shapeB[0]}`
            );
          const n = shapeA[0];
          let sum2 = ce.Zero;
          for (let i = 0; i < n; i++) {
            const aVal = A.tensor.at(i + 1) ?? ce.Zero;
            const bVal = B.tensor.at(i + 1) ?? ce.Zero;
            sum2 = sum2.add(ce.box(aVal).mul(ce.box(bVal)));
          }
          return sum2.evaluate();
        }
        if (shapeA.length === 2 && shapeB.length === 1) {
          const [m, n] = shapeA;
          if (n !== shapeB[0])
            return ce.error("incompatible-dimensions", `${n} vs ${shapeB[0]}`);
          const result = [];
          for (let i = 0; i < m; i++) {
            let sum2 = ce.Zero;
            for (let k = 0; k < n; k++) {
              const aVal = A.tensor.at(i + 1, k + 1) ?? ce.Zero;
              const bVal = B.tensor.at(k + 1) ?? ce.Zero;
              sum2 = sum2.add(ce.box(aVal).mul(ce.box(bVal)));
            }
            result.push(sum2.evaluate());
          }
          return ce.box(["List", ...result]);
        }
        if (shapeA.length === 1 && shapeB.length === 2) {
          const [m, n] = shapeB;
          if (shapeA[0] !== m)
            return ce.error("incompatible-dimensions", `${shapeA[0]} vs ${m}`);
          const result = [];
          for (let j = 0; j < n; j++) {
            let sum2 = ce.Zero;
            for (let k = 0; k < m; k++) {
              const aVal = A.tensor.at(k + 1) ?? ce.Zero;
              const bVal = B.tensor.at(k + 1, j + 1) ?? ce.Zero;
              sum2 = sum2.add(ce.box(aVal).mul(ce.box(bVal)));
            }
            result.push(sum2.evaluate());
          }
          return ce.box(["List", ...result]);
        }
        if (shapeA.length === 2 && shapeB.length === 2) {
          const [m, n1] = shapeA;
          const [n2, p] = shapeB;
          if (n1 !== n2)
            return ce.error("incompatible-dimensions", `${n1} vs ${n2}`);
          const n = n1;
          const rows = [];
          for (let i = 0; i < m; i++) {
            const row = [];
            for (let j = 0; j < p; j++) {
              let sum2 = ce.Zero;
              for (let k = 0; k < n; k++) {
                const aVal = A.tensor.at(i + 1, k + 1) ?? ce.Zero;
                const bVal = B.tensor.at(k + 1, j + 1) ?? ce.Zero;
                sum2 = sum2.add(ce.box(aVal).mul(ce.box(bVal)));
              }
              row.push(sum2.evaluate());
            }
            rows.push(ce.box(["List", ...row]));
          }
          return ce.box(["List", ...rows]);
        }
        return void 0;
      }
    },
    // Diagonal can be used to:
    // 1. Create a diagonal matrix from a vector
    // 2. Extract the diagonal from a matrix as a vector
    // 3. For a scalar, return the scalar (or could create 1x1 matrix)
    Diagonal: {
      complexity: 8200,
      signature: "(value) -> value",
      evaluate: (ops, { engine: ce }) => {
        const op1 = ops[0].evaluate();
        if (op1.isNumber) return op1;
        if (isBoxedTensor(op1)) {
          const shape = op1.shape;
          if (shape.length === 1) {
            const n = shape[0];
            const rows = [];
            const elements = [...op1.each()];
            for (let i = 0; i < n; i++) {
              const row = [];
              for (let j = 0; j < n; j++) {
                row.push(i === j ? elements[i] : ce.Zero);
              }
              rows.push(ce.box(["List", ...row]));
            }
            return ce.box(["List", ...rows]);
          }
          if (shape.length === 2) {
            const [m, n] = shape;
            const minDim = Math.min(m, n);
            const diagonal = [];
            for (let i = 0; i < minDim; i++) {
              diagonal.push(op1.tensor.at(i + 1, i + 1) ?? ce.Zero);
            }
            return ce.box(["List", ...diagonal]);
          }
          return ce.error("expected-square-matrix", op1.toString());
        }
        return void 0;
      }
    },
    // Creates an nn identity matrix
    IdentityMatrix: {
      complexity: 8100,
      signature: "(integer) -> matrix",
      evaluate: (ops, { engine: ce }) => {
        const nExpr = ops[0].evaluate();
        const n = nExpr.re;
        if (n === void 0 || !Number.isInteger(n) || n < 1)
          return ce.error("expected-positive-integer", nExpr.toString());
        const rows = [];
        for (let i = 0; i < n; i++) {
          const row = [];
          for (let j = 0; j < n; j++) {
            row.push(i === j ? ce.One : ce.Zero);
          }
          rows.push(ce.box(["List", ...row]));
        }
        return ce.box(["List", ...rows]);
      }
    },
    // Creates an mn matrix of zeros
    ZeroMatrix: {
      complexity: 8100,
      signature: "(integer, integer?) -> matrix",
      evaluate: (ops, { engine: ce }) => {
        const mExpr = ops[0].evaluate();
        const m = mExpr.re;
        if (m === void 0 || !Number.isInteger(m) || m < 1)
          return ce.error("expected-positive-integer", mExpr.toString());
        let n = m;
        if (ops.length > 1) {
          const nExpr = ops[1].evaluate();
          n = nExpr.re ?? m;
          if (!Number.isInteger(n) || n < 1)
            return ce.error("expected-positive-integer", nExpr.toString());
        }
        const rows = [];
        for (let i = 0; i < m; i++) {
          const row = [];
          for (let j = 0; j < n; j++) {
            row.push(ce.Zero);
          }
          rows.push(ce.box(["List", ...row]));
        }
        return ce.box(["List", ...rows]);
      }
    },
    // Creates an mn matrix of ones
    OnesMatrix: {
      complexity: 8100,
      signature: "(integer, integer?) -> matrix",
      evaluate: (ops, { engine: ce }) => {
        const mExpr = ops[0].evaluate();
        const m = mExpr.re;
        if (m === void 0 || !Number.isInteger(m) || m < 1)
          return ce.error("expected-positive-integer", mExpr.toString());
        let n = m;
        if (ops.length > 1) {
          const nExpr = ops[1].evaluate();
          n = nExpr.re ?? m;
          if (!Number.isInteger(n) || n < 1)
            return ce.error("expected-positive-integer", nExpr.toString());
        }
        const rows = [];
        for (let i = 0; i < m; i++) {
          const row = [];
          for (let j = 0; j < n; j++) {
            row.push(ce.One);
          }
          rows.push(ce.box(["List", ...row]));
        }
        return ce.box(["List", ...rows]);
      }
    },
    // Computes vector and matrix norms
    // For vectors:
    //   - L2 (Euclidean, default): (|xi|)
    //   - L1: |xi|
    //   - L (max): max(|xi|)
    //   - Lp: (|xi|^p)^(1/p)
    // For matrices:
    //   - Frobenius (default): (|aij|)
    Norm: {
      complexity: 8200,
      signature: "(value, number|string?) -> number",
      evaluate: (ops, { engine: ce }) => {
        const x = ops[0].evaluate();
        const normTypeExpr = ops.length > 1 ? ops[1].evaluate() : void 0;
        if (x.isNumber) {
          return ce.box(["Abs", x]).evaluate();
        }
        if (!isBoxedTensor(x)) return void 0;
        const shape = x.shape;
        let normType = 2;
        if (normTypeExpr) {
          if (normTypeExpr.string === "Infinity" || normTypeExpr.symbol === "Infinity" || normTypeExpr.re === Infinity) {
            normType = "infinity";
          } else if (normTypeExpr.string === "Frobenius") {
            normType = "frobenius";
          } else if (normTypeExpr.re !== void 0) {
            normType = normTypeExpr.re;
          }
        }
        if (shape.length === 1) {
          const elements = [];
          const n = shape[0];
          for (let i = 0; i < n; i++) {
            const val = x.tensor.at(i + 1);
            elements.push(val !== void 0 ? ce.box(val) : ce.Zero);
          }
          if (normType === 1) {
            let sum2 = ce.Zero;
            for (const el of elements) {
              sum2 = sum2.add(ce.box(["Abs", el]).evaluate());
            }
            return sum2.evaluate();
          }
          if (normType === 2) {
            let sumSq = ce.Zero;
            for (const el of elements) {
              const absEl = ce.box(["Abs", el]).evaluate();
              sumSq = sumSq.add(absEl.mul(absEl));
            }
            return ce.box(["Sqrt", sumSq]).evaluate();
          }
          if (normType === "infinity") {
            let maxVal = ce.Zero;
            for (const el of elements) {
              const absEl = ce.box(["Abs", el]).evaluate();
              const absNum = absEl.re ?? 0;
              const maxNum = maxVal.re ?? 0;
              if (absNum > maxNum) {
                maxVal = absEl;
              }
            }
            return maxVal;
          }
          if (typeof normType === "number" && normType > 0) {
            const p = normType;
            let sumPow = ce.Zero;
            for (const el of elements) {
              const absEl = ce.box(["Abs", el]).evaluate();
              sumPow = sumPow.add(ce.box(["Power", absEl, p]).evaluate());
            }
            if (Number.isInteger(p)) {
              return ce.box(["Root", sumPow, p]).N();
            }
            return ce.box(["Power", sumPow, ce.box(["Divide", 1, p])]).N();
          }
          return void 0;
        }
        if (shape.length === 2) {
          const [m, n] = shape;
          if (normType === 2 || normType === "frobenius") {
            let sumSq = ce.Zero;
            for (let i = 0; i < m; i++) {
              for (let j = 0; j < n; j++) {
                const val = x.tensor.at(i + 1, j + 1);
                const el = val !== void 0 ? ce.box(val) : ce.Zero;
                const absEl = ce.box(["Abs", el]).evaluate();
                sumSq = sumSq.add(absEl.mul(absEl));
              }
            }
            return ce.box(["Sqrt", sumSq]).evaluate();
          }
          if (normType === 1) {
            let maxColSum = 0;
            for (let j = 0; j < n; j++) {
              let colSum = 0;
              for (let i = 0; i < m; i++) {
                const val = x.tensor.at(i + 1, j + 1);
                const el = val !== void 0 ? ce.box(val) : ce.Zero;
                const absEl = ce.box(["Abs", el]).evaluate();
                colSum += absEl.re ?? 0;
              }
              if (colSum > maxColSum) maxColSum = colSum;
            }
            return ce.number(maxColSum);
          }
          if (normType === "infinity") {
            let maxRowSum = 0;
            for (let i = 0; i < m; i++) {
              let rowSum = 0;
              for (let j = 0; j < n; j++) {
                const val = x.tensor.at(i + 1, j + 1);
                const el = val !== void 0 ? ce.box(val) : ce.Zero;
                const absEl = ce.box(["Abs", el]).evaluate();
                rowSum += absEl.re ?? 0;
              }
              if (rowSum > maxRowSum) maxRowSum = rowSum;
            }
            return ce.number(maxRowSum);
          }
          return void 0;
        }
        return void 0;
      }
    },
    // Compute the eigenvalues of a square matrix
    // For 22 matrices: uses characteristic polynomial (symbolic)
    // For larger matrices: uses QR algorithm (numeric)
    Eigenvalues: {
      complexity: 8500,
      signature: "(matrix) -> list",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          return ce.error("expected-square-matrix", M.toString());
        }
        const n = shape[0];
        if (n === 1) {
          const val = M.tensor.at(1, 1);
          return ce.box(["List", val !== void 0 ? ce.box(val) : ce.Zero]);
        }
        const isDiagonalOrTriangular = checkDiagonalOrTriangular(M, n);
        if (isDiagonalOrTriangular) {
          const eigenvalues = [];
          for (let i = 0; i < n; i++) {
            const val = M.tensor.at(i + 1, i + 1);
            eigenvalues.push(val !== void 0 ? ce.box(val) : ce.Zero);
          }
          return ce.box(["List", ...eigenvalues]);
        }
        if (n === 2) {
          const a = getElement(M, 1, 1, ce);
          const b = getElement(M, 1, 2, ce);
          const c = getElement(M, 2, 1, ce);
          const d = getElement(M, 2, 2, ce);
          const trace = a.add(d);
          const det = a.mul(d).sub(b.mul(c));
          const disc = trace.mul(trace).sub(det.mul(ce.number(4)));
          const sqrtDisc = ce.box(["Sqrt", disc]).evaluate();
          const lambda1 = trace.add(sqrtDisc).div(ce.number(2)).evaluate();
          const lambda2 = trace.sub(sqrtDisc).div(ce.number(2)).evaluate();
          return ce.box(["List", lambda1, lambda2]);
        }
        if (n === 3) {
          return computeEigenvalues3x3(M, ce);
        }
        return computeEigenvaluesQR(M, n, ce);
      }
    },
    // Compute the eigenvectors of a square matrix
    // Returns a list of eigenvectors (as column vectors)
    Eigenvectors: {
      complexity: 8600,
      signature: "(matrix) -> list",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          return ce.error("expected-square-matrix", M.toString());
        }
        const n = shape[0];
        const eigenvaluesExpr = ce.box(["Eigenvalues", M]).evaluate();
        if (eigenvaluesExpr.operator !== "List" || !eigenvaluesExpr.ops || eigenvaluesExpr.ops.length === 0) {
          return void 0;
        }
        const eigenvalues = eigenvaluesExpr.ops;
        const eigenvectors = [];
        for (const lambda of eigenvalues) {
          const eigenvector = computeEigenvector(M, lambda, n, ce);
          if (eigenvector) {
            eigenvectors.push(eigenvector);
          } else {
            return void 0;
          }
        }
        return ce.box(["List", ...eigenvectors]);
      }
    },
    // Compute both eigenvalues and eigenvectors
    // Returns a tuple: [eigenvalues, eigenvectors]
    Eigen: {
      complexity: 8700,
      signature: "(matrix) -> tuple",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          return ce.error("expected-square-matrix", M.toString());
        }
        const eigenvalues = ce.box(["Eigenvalues", M]).evaluate();
        const eigenvectors = ce.box(["Eigenvectors", M]).evaluate();
        if (eigenvalues.operator === "Error") return eigenvalues;
        if (eigenvectors.operator === "Error") return eigenvectors;
        return ce.box(["Tuple", eigenvalues, eigenvectors]);
      }
    },
    // LU Decomposition: A = LU (or PA = LU with pivoting)
    // Returns [L, U] for no pivoting or [P, L, U] with pivoting
    LUDecomposition: {
      complexity: 8600,
      signature: "(matrix) -> tuple",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          return ce.error("expected-square-matrix", M.toString());
        }
        const n = shape[0];
        const result = computeLU(M, n, ce);
        if (!result) return void 0;
        const { P: P2, L, U } = result;
        return ce.box(["Tuple", P2, L, U]);
      }
    },
    // QR Decomposition: A = QR
    // Returns [Q, R] where Q is orthogonal and R is upper triangular
    QRDecomposition: {
      complexity: 8600,
      signature: "(matrix) -> tuple",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2) {
          return ce.error("expected-matrix", M.toString());
        }
        const [m, n] = shape;
        const result = computeQR(M, m, n, ce);
        if (!result) return void 0;
        const { Q, R } = result;
        return ce.box(["Tuple", Q, R]);
      }
    },
    // Cholesky Decomposition: A = LL^T (for positive definite matrices)
    // Returns L (lower triangular matrix)
    CholeskyDecomposition: {
      complexity: 8600,
      signature: "(matrix) -> matrix",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          return ce.error("expected-square-matrix", M.toString());
        }
        const n = shape[0];
        return computeCholesky(M, n, ce);
      }
    },
    // Singular Value Decomposition: A = UV^T
    // Returns [U, , V] where U and V are orthogonal,  is diagonal
    SVD: {
      complexity: 8700,
      signature: "(matrix) -> tuple",
      evaluate: (ops, { engine: ce }) => {
        const M = ops[0].evaluate();
        if (!isBoxedTensor(M)) return void 0;
        const shape = M.shape;
        if (shape.length !== 2) {
          return ce.error("expected-matrix", M.toString());
        }
        const [m, n] = shape;
        const result = computeSVD(M, m, n, ce);
        if (!result) return void 0;
        const { U, S, V } = result;
        return ce.box(["Tuple", U, S, V]);
      }
    }
  }
];
function computeLU(M, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const A = [];
  for (let i = 0; i < n; i++) {
    A[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      if (isNaN(num)) return void 0;
      A[i][j] = num;
    }
  }
  const L = Array(n).fill(null).map(
    (_, i) => Array(n).fill(0).map((_2, j) => i === j ? 1 : 0)
  );
  const U = A.map((row) => [...row]);
  const perm = Array(n).fill(0).map((_, i) => i);
  const eps = 1e-10;
  for (let k = 0; k < n - 1; k++) {
    let maxVal = Math.abs(U[k][k]);
    let maxRow = k;
    for (let i = k + 1; i < n; i++) {
      if (Math.abs(U[i][k]) > maxVal) {
        maxVal = Math.abs(U[i][k]);
        maxRow = i;
      }
    }
    if (maxVal < eps) continue;
    if (maxRow !== k) {
      [U[k], U[maxRow]] = [U[maxRow], U[k]];
      [perm[k], perm[maxRow]] = [perm[maxRow], perm[k]];
      for (let j = 0; j < k; j++) {
        [L[k][j], L[maxRow][j]] = [L[maxRow][j], L[k][j]];
      }
    }
    for (let i = k + 1; i < n; i++) {
      const factor3 = U[i][k] / U[k][k];
      L[i][k] = factor3;
      for (let j = k; j < n; j++) {
        U[i][j] -= factor3 * U[k][j];
      }
    }
  }
  const P2 = [];
  for (let i = 0; i < n; i++) {
    P2[i] = [];
    for (let j = 0; j < n; j++) {
      P2[i][j] = perm[i] === j ? ce.One : ce.Zero;
    }
  }
  const PExpr = ce.box(["List", ...P2.map((row) => ce.box(["List", ...row]))]);
  const LExpr = ce.box([
    "List",
    ...L.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  const UExpr = ce.box([
    "List",
    ...U.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  return { P: PExpr, L: LExpr, U: UExpr };
}
function computeQR(M, m, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const A = [];
  for (let i = 0; i < m; i++) {
    A[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      if (isNaN(num)) return void 0;
      A[i][j] = num;
    }
  }
  const Q = Array(m).fill(null).map(
    (_, i) => Array(m).fill(0).map((_2, j) => i === j ? 1 : 0)
  );
  const R = A.map((row) => [...row]);
  const minMN = Math.min(m, n);
  for (let k = 0; k < minMN; k++) {
    let norm = 0;
    for (let i = k; i < m; i++) {
      norm += R[i][k] * R[i][k];
    }
    norm = Math.sqrt(norm);
    if (norm < 1e-10) continue;
    const sign3 = R[k][k] >= 0 ? 1 : -1;
    const u0 = R[k][k] + sign3 * norm;
    const v = Array(m).fill(0);
    v[k] = 1;
    for (let i = k + 1; i < m; i++) {
      v[i] = R[i][k] / u0;
    }
    let vTv = 1;
    for (let i = k + 1; i < m; i++) {
      vTv += v[i] * v[i];
    }
    const beta = 2 / vTv;
    for (let j = k; j < n; j++) {
      let vTr = 0;
      for (let i = k; i < m; i++) {
        vTr += v[i] * R[i][j];
      }
      for (let i = k; i < m; i++) {
        R[i][j] -= beta * v[i] * vTr;
      }
    }
    for (let i = 0; i < m; i++) {
      let qTv = 0;
      for (let j = k; j < m; j++) {
        qTv += Q[i][j] * v[j];
      }
      for (let j = k; j < m; j++) {
        Q[i][j] -= beta * qTv * v[j];
      }
    }
  }
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < Math.min(i, n); j++) {
      if (Math.abs(R[i][j]) < 1e-10) R[i][j] = 0;
    }
  }
  const QExpr = ce.box([
    "List",
    ...Q.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  const RExpr = ce.box([
    "List",
    ...R.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  return { Q: QExpr, R: RExpr };
}
function computeCholesky(M, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const A = [];
  for (let i = 0; i < n; i++) {
    A[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      if (isNaN(num)) return void 0;
      A[i][j] = num;
    }
  }
  const L = Array(n).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      let sum2 = 0;
      if (j === i) {
        for (let k = 0; k < j; k++) {
          sum2 += L[j][k] * L[j][k];
        }
        const val = A[j][j] - sum2;
        if (val < 0) {
          return ce.error("expected-positive-definite-matrix", M.toString());
        }
        L[j][j] = Math.sqrt(val);
      } else {
        for (let k = 0; k < j; k++) {
          sum2 += L[i][k] * L[j][k];
        }
        if (Math.abs(L[j][j]) < 1e-10) {
          return ce.error("expected-positive-definite-matrix", M.toString());
        }
        L[i][j] = (A[i][j] - sum2) / L[j][j];
      }
    }
  }
  return ce.box([
    "List",
    ...L.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
}
function computeSVD(M, m, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const A = [];
  for (let i = 0; i < m; i++) {
    A[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      if (isNaN(num)) return void 0;
      A[i][j] = num;
    }
  }
  const AtA = Array(n).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < m; k++) {
        AtA[i][j] += A[k][i] * A[k][j];
      }
    }
  }
  const AAt = Array(m).fill(null).map(() => Array(m).fill(0));
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < m; j++) {
      for (let k = 0; k < n; k++) {
        AAt[i][j] += A[i][k] * A[j][k];
      }
    }
  }
  const maxIter = 100;
  const tol = 1e-10;
  let V = Array(n).fill(null).map(
    (_, i) => Array(n).fill(0).map((_2, j) => i === j ? 1 : 0)
  );
  let B = AtA.map((row) => [...row]);
  for (let iter = 0; iter < maxIter; iter++) {
    const { Q, R } = qrDecomposition(B, n);
    const newB = Array(n).fill(null).map(() => Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          newB[i][j] += R[i][k] * Q[k][j];
        }
      }
    }
    const newV = Array(n).fill(null).map(() => Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
          newV[i][j] += V[i][k] * Q[k][j];
        }
      }
    }
    let maxOffDiag = 0;
    for (let i = 1; i < n; i++) {
      for (let j = 0; j < i; j++) {
        maxOffDiag = Math.max(maxOffDiag, Math.abs(newB[i][j]));
      }
    }
    B = newB;
    V = newV;
    if (maxOffDiag < tol) break;
  }
  const singularValues = [];
  for (let i = 0; i < n; i++) {
    singularValues.push(Math.sqrt(Math.max(0, B[i][i])));
  }
  const U = Array(m).fill(null).map(() => Array(m).fill(0));
  for (let j = 0; j < Math.min(m, n); j++) {
    if (singularValues[j] > tol) {
      for (let i = 0; i < m; i++) {
        let sum2 = 0;
        for (let k = 0; k < n; k++) {
          sum2 += A[i][k] * V[k][j];
        }
        U[i][j] = sum2 / singularValues[j];
      }
    }
  }
  if (m > n) {
    for (let j = n; j < m; j++) {
      const col = Array(m).fill(0);
      col[j] = 1;
      for (let k = 0; k < j; k++) {
        let dotProd = 0;
        for (let i = 0; i < m; i++) {
          dotProd += col[i] * U[i][k];
        }
        for (let i = 0; i < m; i++) {
          col[i] -= dotProd * U[i][k];
        }
      }
      let norm = 0;
      for (let i = 0; i < m; i++) {
        norm += col[i] * col[i];
      }
      norm = Math.sqrt(norm);
      if (norm > tol) {
        for (let i = 0; i < m; i++) {
          U[i][j] = col[i] / norm;
        }
      }
    }
  }
  const S = Array(m).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < Math.min(m, n); i++) {
    S[i][i] = singularValues[i];
  }
  const UExpr = ce.box([
    "List",
    ...U.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  const SExpr = ce.box([
    "List",
    ...S.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  const VExpr = ce.box([
    "List",
    ...V.map((row) => ce.box(["List", ...row.map((x) => ce.number(x))]))
  ]);
  return { U: UExpr, S: SExpr, V: VExpr };
}
function getElement(M, i, j, ce) {
  if (!isBoxedTensor(M)) return ce.Zero;
  const val = M.tensor.at(i, j);
  return val !== void 0 ? ce.box(val) : ce.Zero;
}
function checkDiagonalOrTriangular(M, n) {
  if (!isBoxedTensor(M)) return false;
  let isUpperTriangular = true;
  let isLowerTriangular = true;
  for (let i = 0; i < n && (isUpperTriangular || isLowerTriangular); i++) {
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const isZero2 = val === void 0 || val === 0 || typeof val === "object" && "re" in val && val.re === 0;
      if (i > j && !isZero2) isUpperTriangular = false;
      if (i < j && !isZero2) isLowerTriangular = false;
    }
  }
  return isUpperTriangular || isLowerTriangular;
}
function computeEigenvalues3x3(M, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const a11 = getElement(M, 1, 1, ce).re ?? 0;
  const a12 = getElement(M, 1, 2, ce).re ?? 0;
  const a13 = getElement(M, 1, 3, ce).re ?? 0;
  const a21 = getElement(M, 2, 1, ce).re ?? 0;
  const a22 = getElement(M, 2, 2, ce).re ?? 0;
  const a23 = getElement(M, 2, 3, ce).re ?? 0;
  const a31 = getElement(M, 3, 1, ce).re ?? 0;
  const a32 = getElement(M, 3, 2, ce).re ?? 0;
  const a33 = getElement(M, 3, 3, ce).re ?? 0;
  if ([a11, a12, a13, a21, a22, a23, a31, a32, a33].some(
    (x) => x === void 0 || isNaN(x)
  )) {
    return computeEigenvaluesQR(M, 3, ce);
  }
  const trace = a11 + a22 + a33;
  const m1 = a11 * a22 - a12 * a21;
  const m2 = a11 * a33 - a13 * a31;
  const m3 = a22 * a33 - a23 * a32;
  const minorSum = m1 + m2 + m3;
  const det = a11 * (a22 * a33 - a23 * a32) - a12 * (a21 * a33 - a23 * a31) + a13 * (a21 * a32 - a22 * a31);
  const p = minorSum - trace * trace / 3;
  const q = 2 * trace * trace * trace / 27 - trace * minorSum / 3 + det;
  const eigenvalues = solveCubic(p, q, trace / 3);
  return ce.box([
    "List",
    ce.number(eigenvalues[0]),
    ce.number(eigenvalues[1]),
    ce.number(eigenvalues[2])
  ]);
}
function solveCubic(p, q, shift) {
  const eps = 1e-10;
  if (Math.abs(p) < eps && Math.abs(q) < eps) {
    return [shift, shift, shift];
  }
  const discriminant = q * q / 4 + p * p * p / 27;
  if (discriminant > eps) {
    const sqrtD = Math.sqrt(discriminant);
    const u = Math.cbrt(-q / 2 + sqrtD);
    const v = Math.cbrt(-q / 2 - sqrtD);
    const realRoot = u + v + shift;
    const realPart = -(u + v) / 2 + shift;
    return [realRoot, realPart, realPart];
  } else if (discriminant < -eps) {
    const r = Math.sqrt(-p * p * p / 27);
    const theta = Math.acos(-q / 2 / r);
    const cbrtR = Math.cbrt(r);
    const t1 = 2 * cbrtR * Math.cos(theta / 3);
    const t2 = 2 * cbrtR * Math.cos((theta + 2 * Math.PI) / 3);
    const t3 = 2 * cbrtR * Math.cos((theta + 4 * Math.PI) / 3);
    return [t1 + shift, t2 + shift, t3 + shift];
  } else {
    const u = Math.cbrt(-q / 2);
    return [2 * u + shift, -u + shift, -u + shift];
  }
}
function computeEigenvaluesQR(M, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const A = [];
  for (let i = 0; i < n; i++) {
    A[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      if (isNaN(num)) return void 0;
      A[i][j] = num;
    }
  }
  const maxIterations = 100;
  const tolerance = 1e-10;
  for (let iter = 0; iter < maxIterations; iter++) {
    let maxOffDiag = 0;
    for (let i = 1; i < n; i++) {
      for (let j = 0; j < i; j++) {
        maxOffDiag = Math.max(maxOffDiag, Math.abs(A[i][j]));
      }
    }
    if (maxOffDiag < tolerance) break;
    const { Q, R } = qrDecomposition(A, n);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        A[i][j] = 0;
        for (let k = 0; k < n; k++) {
          A[i][j] += R[i][k] * Q[k][j];
        }
      }
    }
  }
  const eigenvalues = [];
  for (let i = 0; i < n; i++) {
    eigenvalues.push(ce.number(A[i][i]));
  }
  return ce.box(["List", ...eigenvalues]);
}
function qrDecomposition(A, n) {
  const Q = Array(n).fill(null).map(() => Array(n).fill(0));
  const R = Array(n).fill(null).map(() => Array(n).fill(0));
  const columns = [];
  for (let j = 0; j < n; j++) {
    columns[j] = [];
    for (let i = 0; i < n; i++) {
      columns[j][i] = A[i][j];
    }
  }
  const U = [];
  for (let j = 0; j < n; j++) {
    U[j] = [...columns[j]];
    for (let k = 0; k < j; k++) {
      const dotUU = dot(U[k], U[k]);
      if (Math.abs(dotUU) > 1e-10) {
        const proj = dot(columns[j], U[k]) / dotUU;
        R[k][j] = proj * Math.sqrt(dotUU);
        for (let i = 0; i < n; i++) {
          U[j][i] -= proj * U[k][i];
        }
      }
    }
    const norm = Math.sqrt(dot(U[j], U[j]));
    R[j][j] = norm;
    if (norm > 1e-10) {
      for (let i = 0; i < n; i++) {
        Q[i][j] = U[j][i] / norm;
      }
    }
  }
  return { Q, R };
}
function dot(a, b) {
  let sum2 = 0;
  for (let i = 0; i < a.length; i++) {
    sum2 += a[i] * b[i];
  }
  return sum2;
}
function computeEigenvector(M, lambda, n, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const lambdaNum = lambda.re;
  if (lambdaNum === void 0 || isNaN(lambdaNum)) {
    if (n === 2) {
      return computeEigenvector2x2Symbolic(M, lambda, ce);
    }
    return void 0;
  }
  const AminusLambdaI = [];
  for (let i = 0; i < n; i++) {
    AminusLambdaI[i] = [];
    for (let j = 0; j < n; j++) {
      const val = M.tensor.at(i + 1, j + 1);
      const num = typeof val === "number" ? val : typeof val === "object" && "re" in val ? val.re ?? 0 : 0;
      AminusLambdaI[i][j] = num - (i === j ? lambdaNum : 0);
    }
  }
  const eigenvector = solveNullSpace(AminusLambdaI, n);
  if (!eigenvector) return void 0;
  return ce.box(["List", ...eigenvector.map((x) => ce.number(x))]);
}
function computeEigenvector2x2Symbolic(M, lambda, ce) {
  if (!isBoxedTensor(M)) return void 0;
  const a = getElement(M, 1, 1, ce);
  const b = getElement(M, 1, 2, ce);
  const c = getElement(M, 2, 1, ce);
  const bVal = b.re;
  if (bVal !== void 0 && Math.abs(bVal) > 1e-10) {
    const v2 = lambda.sub(a).evaluate();
    return ce.box(["List", b, v2]);
  }
  const cVal = c.re;
  if (cVal !== void 0 && Math.abs(cVal) > 1e-10) {
    const d = getElement(M, 2, 2, ce);
    const v1 = lambda.sub(d).evaluate();
    return ce.box(["List", v1, c]);
  }
  const aVal = a.re;
  const lambdaVal = lambda.re;
  if (aVal !== void 0 && lambdaVal !== void 0) {
    if (Math.abs(aVal - lambdaVal) < 1e-10) {
      return ce.box(["List", ce.One, ce.Zero]);
    } else {
      return ce.box(["List", ce.Zero, ce.One]);
    }
  }
  return void 0;
}
function solveNullSpace(A, n) {
  const matrix = A.map((row) => [...row]);
  const eps = 1e-10;
  let pivotRow = 0;
  const pivotCols = [];
  for (let col = 0; col < n && pivotRow < n; col++) {
    let maxVal = Math.abs(matrix[pivotRow][col]);
    let maxRow = pivotRow;
    for (let row = pivotRow + 1; row < n; row++) {
      if (Math.abs(matrix[row][col]) > maxVal) {
        maxVal = Math.abs(matrix[row][col]);
        maxRow = row;
      }
    }
    if (maxVal < eps) continue;
    [matrix[pivotRow], matrix[maxRow]] = [matrix[maxRow], matrix[pivotRow]];
    for (let row = pivotRow + 1; row < n; row++) {
      const factor3 = matrix[row][col] / matrix[pivotRow][col];
      for (let j = col; j < n; j++) {
        matrix[row][j] -= factor3 * matrix[pivotRow][j];
      }
    }
    pivotCols.push(col);
    pivotRow++;
  }
  let freeCol = -1;
  for (let col = 0; col < n; col++) {
    if (!pivotCols.includes(col)) {
      freeCol = col;
      break;
    }
  }
  if (freeCol === -1) {
    const result2 = Array(n).fill(0);
    result2[0] = 1;
    return result2;
  }
  const result = Array(n).fill(0);
  result[freeCol] = 1;
  for (let i = pivotCols.length - 1; i >= 0; i--) {
    const row = i;
    const col = pivotCols[i];
    let sum2 = 0;
    for (let j = col + 1; j < n; j++) {
      sum2 += matrix[row][j] * result[j];
    }
    result[col] = -sum2 / matrix[row][col];
  }
  let norm = 0;
  for (let i = 0; i < n; i++) {
    norm += result[i] * result[i];
  }
  norm = Math.sqrt(norm);
  if (norm > eps) {
    for (let i = 0; i < n; i++) {
      result[i] /= norm;
    }
  }
  return result;
}
function reshapeWithCycling(ce, flatElements, targetShape) {
  const totalNeeded = targetShape.reduce((a, b) => a * b, 1);
  const cycledElements = [];
  for (let i = 0; i < totalNeeded; i++) {
    cycledElements.push(flatElements[i % flatElements.length]);
  }
  return buildNestedList(ce, cycledElements, targetShape, 0);
}
function buildNestedList(ce, data, shape, offset) {
  if (shape.length === 1) {
    return ce.box(["List", ...data.slice(offset, offset + shape[0])]);
  }
  const outerSize = shape[0];
  const innerShape = shape.slice(1);
  const innerSize = innerShape.reduce((a, b) => a * b, 1);
  const rows = [];
  for (let i = 0; i < outerSize; i++) {
    rows.push(buildNestedList(ce, data, innerShape, offset + i * innerSize));
  }
  return ce.box(["List", ...rows]);
}
function canonicalMatrix(ops, { engine: ce }) {
  const operator2 = "Matrix";
  if (ops.length === 0) return ce._fn(operator2, []);
  const body = ops[0].operator === "Vector" ? ops[0].canonical.ops[0] : ops[0].canonical;
  const delims = ops[1]?.canonical;
  const columns = ops[2]?.canonical;
  if (ops.length > 3) return ce._fn(operator2, checkArity(ce, ops, 3));
  if (columns) return ce._fn(operator2, [body, delims, columns]);
  if (delims) return ce._fn(operator2, [body, delims]);
  return ce._fn(operator2, [body]);
}

// src/compute-engine/library/logic.ts
init_logic_utils();
init_logic_analysis();
var LOGIC_LIBRARY = {
  True: {
    wikidata: "Q16751793",
    type: "boolean",
    isConstant: true
  },
  False: {
    wikidata: "Q5432619",
    type: "boolean",
    isConstant: true
  },
  // @todo: specify a `canonical` function that converts boolean
  // expressions into CNF (Conjunctive Normal Form)
  // https://en.wikipedia.org/wiki/Conjunctive_normal_form
  // using rules (with a rule set that's kinda the inverse of the
  // logic rules for simplify)
  // See also: https://en.wikipedia.org/wiki/Prenex_normal_form
  And: {
    wikidata: "Q191081",
    broadcastable: true,
    associative: true,
    commutative: true,
    idempotent: true,
    complexity: 1e4,
    signature: "(boolean+) -> boolean",
    evaluate: evaluateAnd
  },
  Or: {
    wikidata: "Q1651704",
    broadcastable: true,
    associative: true,
    commutative: true,
    idempotent: true,
    complexity: 1e4,
    signature: "(boolean+) -> boolean",
    evaluate: evaluateOr
  },
  Not: {
    wikidata: "Q190558",
    broadcastable: true,
    involution: true,
    complexity: 10100,
    // @todo: this may not be needed, since we also have rules.
    signature: "(boolean) -> boolean",
    evaluate: evaluateNot
  },
  Equivalent: {
    wikidata: "Q220433",
    broadcastable: true,
    complexity: 10200,
    signature: "(boolean, boolean) -> boolean",
    canonical: (args, { engine: ce }) => {
      const lhs = args[0].symbol;
      const rhs = args[1].symbol;
      if (lhs === "True" && rhs === "True" || lhs === "False" && rhs === "False")
        return ce.True;
      if (lhs === "True" && rhs === "False" || lhs === "False" && rhs === "True")
        return ce.False;
      return ce._fn("Equivalent", args);
    },
    evaluate: evaluateEquivalent
  },
  Implies: {
    wikidata: "Q7881229",
    broadcastable: true,
    complexity: 10200,
    signature: "(boolean, boolean) -> boolean",
    evaluate: evaluateImplies
  },
  Xor: {
    description: "Exclusive or: true when an odd number of operands are true",
    wikidata: "Q498186",
    broadcastable: true,
    associative: true,
    commutative: true,
    complexity: 10200,
    signature: "(boolean+) -> boolean",
    evaluate: evaluateXor
  },
  Nand: {
    description: "Not-and: negation of conjunction",
    wikidata: "Q189550",
    broadcastable: true,
    commutative: true,
    complexity: 10200,
    signature: "(boolean+) -> boolean",
    evaluate: evaluateNand
  },
  Nor: {
    description: "Not-or: negation of disjunction",
    wikidata: "Q189561",
    broadcastable: true,
    commutative: true,
    complexity: 10200,
    signature: "(boolean+) -> boolean",
    evaluate: evaluateNor
  },
  // Quantifiers return boolean values (they are propositions)
  // They support evaluation over finite domains (e.g., ForAll with Element condition)
  // The first argument can be:
  // - a symbol (e.g., "x") for symbolic quantification
  // - an Element expression (e.g., ["Element", "x", ["Set", 1, 2, 3]]) for finite domain evaluation
  Exists: {
    signature: "(value, boolean) -> boolean",
    lazy: true,
    scoped: true,
    evaluate: evaluateExists
  },
  NotExists: {
    signature: "(value, boolean) -> boolean",
    lazy: true,
    scoped: true,
    evaluate: (args, options) => {
      const result = evaluateExists(args, options);
      if (result?.symbol === "True") return options.engine.False;
      if (result?.symbol === "False") return options.engine.True;
      return void 0;
    }
  },
  ExistsUnique: {
    signature: "(value, boolean) -> boolean",
    lazy: true,
    scoped: true,
    evaluate: evaluateExistsUnique
  },
  ForAll: {
    signature: "(value, boolean) -> boolean",
    lazy: true,
    scoped: true,
    evaluate: evaluateForAll
  },
  NotForAll: {
    signature: "(value, boolean) -> boolean",
    lazy: true,
    scoped: true,
    evaluate: (args, options) => {
      const result = evaluateForAll(args, options);
      if (result?.symbol === "True") return options.engine.False;
      if (result?.symbol === "False") return options.engine.True;
      return void 0;
    }
  },
  // Predicate application in First-Order Logic.
  // ["Predicate", "P", "x"] represents the predicate P applied to x.
  // This is semantically different from a function application: predicates
  // return boolean values and are used in logical formulas.
  // In LaTeX, P(x) inside a quantifier context parses to ["Predicate", "P", "x"].
  Predicate: {
    description: "Apply a predicate to arguments, returning a boolean",
    signature: "(symbol, value+) -> boolean",
    lazy: true,
    // Predicates remain symbolic unless explicitly defined
    evaluate: (args, { engine }) => {
      if (args.length === 0) return void 0;
      const pred = args[0];
      if (!pred.symbol) return void 0;
      return void 0;
    }
  },
  KroneckerDelta: {
    description: "Return 1 if the arguments are equal, 0 otherwise",
    signature: "(value+) -> integer",
    evaluate: (args, { engine: ce }) => {
      if (args.length === 1)
        return args[0].symbol === "True" ? ce.One : ce.Zero;
      if (args.length === 2) return args[0].isEqual(args[1]) ? ce.One : ce.Zero;
      for (let i = 1; i < args.length; i++) {
        if (!args[i].isEqual(args[0])) return ce.Zero;
      }
      return ce.One;
    }
  },
  // Iverson bracket
  Boole: {
    description: "Return 1 if the argument is true, 0 otherwise. Also known as the Iverson bracket",
    signature: "(boolean) -> integer",
    evaluate: (args, { engine: ce }) => args[0].symbol === "True" ? ce.One : ce.Zero
  }
};
function simplifyLogicFunction(x) {
  const fn = {
    And: evaluateAnd,
    Or: evaluateOr,
    Not: evaluateNot,
    Equivalent: evaluateEquivalent,
    Implies: evaluateImplies,
    Xor: evaluateXor,
    Nand: evaluateNand,
    Nor: evaluateNor
  }[x.operator];
  if (!fn || !x.ops) return void 0;
  const value = fn(x.ops, { engine: x.engine });
  if (!value) return void 0;
  return { value, because: "logic" };
}
function evaluateForAll(args, { engine: ce }) {
  if (args.length < 2) return void 0;
  const condition = args[0];
  const body = args[1];
  const canonicalBody = body.canonical;
  if (canonicalBody.symbol === "True") return ce.True;
  if (canonicalBody.symbol === "False") return ce.False;
  const variable = condition.symbol ?? condition.op1?.symbol;
  if (variable && !bodyContainsVariable(canonicalBody, variable)) {
    return canonicalBody.evaluate();
  }
  const domain = extractFiniteDomain(condition, ce);
  if (domain) {
    const nestedDomains = collectNestedDomains(body, ce);
    if (nestedDomains.length > 0) {
      return evaluateForAllCartesian(
        [
          { variable: domain.variable, values: domain.values },
          ...nestedDomains
        ],
        getInnermostBody(body),
        ce
      );
    }
    for (const value of domain.values) {
      const substituted = body.subs({ [domain.variable]: value }).canonical;
      const result = substituted.evaluate();
      if (result.symbol === "False") {
        return ce.False;
      }
      if (result.symbol !== "True") {
        return void 0;
      }
    }
    return ce.True;
  }
  const bodyEval = canonicalBody.evaluate();
  if (bodyEval.symbol === "True") return ce.True;
  if (bodyEval.symbol === "False") return ce.False;
  return void 0;
}
function evaluateExists(args, { engine: ce }) {
  if (args.length < 2) return void 0;
  const condition = args[0];
  const body = args[1];
  const canonicalBody = body.canonical;
  if (canonicalBody.symbol === "True") return ce.True;
  if (canonicalBody.symbol === "False") return ce.False;
  const variable = condition.symbol ?? condition.op1?.symbol;
  if (variable && !bodyContainsVariable(canonicalBody, variable)) {
    return canonicalBody.evaluate();
  }
  const domain = extractFiniteDomain(condition, ce);
  if (domain) {
    const nestedDomains = collectNestedDomains(body, ce);
    if (nestedDomains.length > 0) {
      return evaluateExistsCartesian(
        [
          { variable: domain.variable, values: domain.values },
          ...nestedDomains
        ],
        getInnermostBody(body),
        ce
      );
    }
    for (const value of domain.values) {
      const substituted = body.subs({ [domain.variable]: value }).canonical;
      const result = substituted.evaluate();
      if (result.symbol === "True") {
        return ce.True;
      }
    }
    return ce.False;
  }
  const bodyEval = canonicalBody.evaluate();
  if (bodyEval.symbol === "True") return ce.True;
  if (bodyEval.symbol === "False") return ce.False;
  return void 0;
}
function evaluateExistsUnique(args, { engine: ce }) {
  if (args.length < 2) return void 0;
  const condition = args[0];
  const body = args[1];
  const domain = extractFiniteDomain(condition, ce);
  if (domain) {
    let count = 0;
    for (const value of domain.values) {
      const substituted = body.subs({ [domain.variable]: value }).canonical;
      const result = substituted.evaluate();
      if (result.symbol === "True") {
        count++;
        if (count > 1) return ce.False;
      } else if (result.symbol !== "False") {
        return void 0;
      }
    }
    return count === 1 ? ce.True : ce.False;
  }
  return void 0;
}
var LOGIC_FUNCTION_LIBRARY = {
  /**
   * Convert a boolean expression to Conjunctive Normal Form (CNF).
   * CNF is a conjunction (And) of disjunctions (Or) of literals.
   * A literal is either a variable or its negation.
   *
   * Example: (A  B)  (A  C)
   */
  ToCNF: {
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      return toCNF(expr.evaluate(), ce);
    }
  },
  /**
   * Convert a boolean expression to Disjunctive Normal Form (DNF).
   * DNF is a disjunction (Or) of conjunctions (And) of literals.
   * A literal is either a variable or its negation.
   *
   * Example: (A  B)  (A  C)
   */
  ToDNF: {
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      return toDNF(expr.evaluate(), ce);
    }
  },
  /**
   * Check if a boolean expression is satisfiable.
   *
   * Returns `True` if there exists an assignment of truth values to variables
   * that makes the expression true, `False` if no such assignment exists.
   *
   * **Performance**: Uses brute-force enumeration with O(2^n) complexity.
   * Limited to 20 variables; larger expressions return unevaluated.
   * Expressions with 15+ variables may take noticeable time (~10ms+).
   */
  IsSatisfiable: {
    description: "Check satisfiability using brute-force enumeration. O(2^n) complexity, max 20 variables.",
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      return isSatisfiable(expr, ce);
    }
  },
  /**
   * Check if a boolean expression is a tautology.
   *
   * Returns `True` if the expression is true for all possible assignments
   * of truth values to variables, `False` otherwise.
   *
   * **Performance**: Uses brute-force enumeration with O(2^n) complexity.
   * Limited to 20 variables; larger expressions return unevaluated.
   * Expressions with 15+ variables may take noticeable time (~10ms+).
   */
  IsTautology: {
    description: "Check if expression is a tautology using brute-force enumeration. O(2^n) complexity, max 20 variables.",
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      return isTautology(expr, ce);
    }
  },
  /**
   * Generate a truth table for a boolean expression.
   *
   * Returns a `List` of `List`s, where the first row contains column headers
   * (variable names followed by "Result") and subsequent rows contain the
   * truth values for each assignment.
   *
   * **Performance**: Generates all 2^n rows with O(2^n) time and space.
   * Limited to 10 variables (stricter than SAT/tautology checks due to
   * memory requirements); larger expressions return unevaluated.
   *
   * @example
   * TruthTable(["And", "A", "B"]) returns:
   * [["List", "A", "B", "Result"],
   *  ["List", False, False, False],
   *  ["List", False, True, False],
   *  ["List", True, False, False],
   *  ["List", True, True, True]]
   */
  TruthTable: {
    description: "Generate truth table for expression. O(2^n) complexity, max 10 variables.",
    signature: "(boolean) -> list",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      return generateTruthTable(expr, ce);
    }
  },
  /**
   * Find all prime implicants of a boolean expression.
   *
   * A prime implicant is a minimal product term (conjunction of literals)
   * that implies the expression. Uses the Quine-McCluskey algorithm.
   *
   * **Performance**: O(3^n) worst case, limited to 12 variables.
   *
   * @example
   * PrimeImplicants(["Or", ["And", "A", "B"], ["And", "A", ["Not", "B"]]]])
   *  [A] (both AB and AB simplify to just A)
   */
  PrimeImplicants: {
    description: "Find all prime implicants using Quine-McCluskey. Max 12 variables.",
    signature: "(boolean) -> list",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      const result = findPrimeImplicants(expr, ce);
      if (result === null) {
        return ce._fn("PrimeImplicants", [expr]);
      }
      return ce._fn("List", result);
    }
  },
  /**
   * Find all prime implicates of a boolean expression.
   *
   * A prime implicate is a minimal sum term (disjunction of literals)
   * that is implied by the expression. These are the minimal clauses in CNF.
   *
   * **Performance**: O(3^n) worst case, limited to 12 variables.
   *
   * @example
   * PrimeImplicates(["And", "A", "B"])
   *  [A, B] (the expression implies both A and B separately)
   */
  PrimeImplicates: {
    description: "Find all prime implicates using Quine-McCluskey. Max 12 variables.",
    signature: "(boolean) -> list",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      const result = findPrimeImplicates(expr, ce);
      if (result === null) {
        return ce._fn("PrimeImplicates", [expr]);
      }
      return ce._fn("List", result);
    }
  },
  /**
   * Convert a boolean expression to minimal Disjunctive Normal Form (DNF).
   *
   * Uses the Quine-McCluskey algorithm to find prime implicants, then
   * selects a minimal cover. The result is a disjunction of conjunctions
   * of literals with the fewest terms possible.
   *
   * **Performance**: O(3^n) worst case, limited to 12 variables.
   *
   * @example
   * MinimalDNF(["Or", ["And", "A", "B"], ["And", "A", ["Not", "B"]], ["And", ["Not", "A"], "B"]])
   *  ["Or", "A", "B"] (simplified from 3 terms to 2)
   */
  MinimalDNF: {
    description: "Convert to minimal DNF using Quine-McCluskey. Max 12 variables.",
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      const result = minimalDNF(expr, ce);
      if (result === null) {
        return ce._fn("MinimalDNF", [expr]);
      }
      return result;
    }
  },
  /**
   * Convert a boolean expression to minimal Conjunctive Normal Form (CNF).
   *
   * Uses the Quine-McCluskey algorithm to find prime implicates, then
   * selects a minimal cover. The result is a conjunction of disjunctions
   * of literals with the fewest clauses possible.
   *
   * **Performance**: O(3^n) worst case, limited to 12 variables.
   *
   * @example
   * MinimalCNF(["Or", ["And", "A", "B"], ["And", "A", ["Not", "B"]]])
   *  A (the expression simplifies to just A)
   */
  MinimalCNF: {
    description: "Convert to minimal CNF using Quine-McCluskey. Max 12 variables.",
    signature: "(boolean) -> boolean",
    evaluate: ([expr], { engine: ce }) => {
      if (!expr) return void 0;
      const result = minimalCNF(expr, ce);
      if (result === null) {
        return ce._fn("MinimalCNF", [expr]);
      }
      return result;
    }
  }
};

// src/compute-engine/library/number-theory.ts
init_numerics();
init_numeric_bigint();
init_decimal();
var NUMBER_THEORY_LIBRARY = [
  {
    Totient: {
      wikidata: "Q190026",
      description: "Euler\u2019s totient function \u03C6(n): count of positive integers \u2264 n that are coprime to n.",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1) return void 0;
        let result = 1n;
        for (let i = 2n; i < k; i++) {
          if (gcd2(i, k) === 1n) result++;
        }
        return ce.number(result);
      }
    },
    Sigma0: {
      description: "Number of positive divisors of n.",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1) return void 0;
        let count = 0;
        for (let i = 1n; i <= k; i++) {
          if (k % i === 0n) count++;
        }
        return ce.number(count);
      }
    },
    Sigma1: {
      description: "Sum of positive divisors of n.",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1) return void 0;
        let sum2 = ce.bignum(0);
        for (let i = 1n; i <= k; i++) {
          if (k % i === 0n) sum2 = sum2.add(ce.bignum(i));
        }
        return ce.number(sum2);
      }
    },
    SigmaMinus1: {
      description: "Sum of reciprocals of positive divisors of n.",
      signature: "(integer) -> number",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1) return void 0;
        let sum2 = ce.bignum(0);
        for (let i = 1n; i <= k; i++) {
          if (k % i === 0n) sum2 = sum2.add(ce.bignum(1).div(ce.bignum(i)));
        }
        return ce.number(sum2);
      }
    },
    IsPerfect: {
      wikidata: "Q170043",
      description: 'Returns "True" if n is a perfect number, a positive integer which equals the sum of all its divisors.',
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1) return void 0;
        let sum2 = 0n;
        for (let i = 1n; i < k; i++) {
          if (k % i === 0n) sum2 += i;
        }
        return ce.symbol(sum2 === k ? "True" : "False");
      }
    },
    Eulerian: {
      description: "Eulerian number A(n, m): number of permutations of {1..n} with exactly m ascents.",
      signature: "(integer, integer) -> integer",
      evaluate: ([n, m], { engine: ce }) => {
        const nn = toBigint(n);
        const mm = toBigint(m);
        if (nn === null || mm === null || nn < 0n || mm < 0n || mm >= nn)
          return void 0;
        const A = (n2, k) => {
          if (k === 0n) return 1n;
          if (k >= n2) return 0n;
          return (k + 1n) * A(n2 - 1n, k) + (n2 - k) * A(n2 - 1n, k - 1n);
        };
        return ce.number(A(nn, mm));
      }
    },
    Stirling: {
      description: "Stirling number of the second kind S(n, m): ways to partition n elements into m non-empty subsets.",
      signature: "(integer, integer) -> integer",
      evaluate: ([n, m], { engine: ce }) => {
        const nn = toBigint(n);
        const mm = toBigint(m);
        if (nn === null || mm === null || nn < 0n || mm < 0n || mm > nn)
          return void 0;
        const S = (n2, k) => {
          if (n2 === 0n && k === 0n) return 1n;
          if (n2 === 0n || k === 0n) return 0n;
          return S(n2 - 1n, k - 1n) + k * S(n2 - 1n, k);
        };
        return ce.number(S(nn, mm));
      }
    },
    NPartition: {
      description: "Number of integer partitions of n.",
      signature: "(integer) -> integer",
      evaluate: ([n], { engine: ce }) => {
        const nn = toBigint(n);
        if (nn === null || nn < 0n) return void 0;
        const memo = /* @__PURE__ */ new Map();
        const P2 = (n2) => {
          if (n2 === 0n) return 1n;
          if (n2 < 0n) return 0n;
          if (memo.has(n2)) return memo.get(n2);
          let total = 0n;
          for (let k = 1n; ; k++) {
            const pent1 = k * (3n * k - 1n) / 2n;
            const pent2 = k * (3n * k + 1n) / 2n;
            if (pent1 > n2 && pent2 > n2) break;
            const sign3 = k % 2n === 0n ? -1n : 1n;
            total += sign3 * (P2(n2 - pent1) + P2(n2 - pent2));
          }
          memo.set(n2, total);
          return total;
        };
        return ce.number(P2(nn));
      }
    },
    IsTriangular: {
      description: "True if n is a triangular number.",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1n) return ce.False;
        const D = 8n * k + 1n;
        const sqrt3 = BigInt(decimal_default.sqrt(ce.bignum(D)).toFixed(0));
        return ce.symbol(
          sqrt3 * sqrt3 === D && (sqrt3 - 1n) % 2n === 0n ? "True" : "False"
        );
      }
    },
    IsSquare: {
      description: "True if n is a perfect square.",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 0n) return ce.False;
        const sqrt3 = BigInt(decimal_default.sqrt(ce.bignum(k)).toFixed(0));
        return ce.symbol(sqrt3 * sqrt3 === k ? "True" : "False");
      }
    },
    IsOctahedral: {
      description: "True if n is an octahedral number.",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1n) return ce.False;
        const discriminant = 3n * k + 1n;
        const sqrt3 = BigInt(decimal_default.sqrt(ce.bignum(discriminant)).toFixed(0));
        return ce.symbol(sqrt3 * sqrt3 === discriminant ? "True" : "False");
      }
    },
    IsCenteredSquare: {
      description: "True if n is a centered square number.",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1n) return ce.False;
        if ((k - 1n) % 4n !== 0n) return ce.False;
        const t = (k - 1n) / 4n;
        const sqrt3 = BigInt(decimal_default.sqrt(ce.bignum(t)).toFixed(0));
        return ce.symbol(sqrt3 * sqrt3 * 4n + 1n === k ? "True" : "False");
      }
    },
    IsHappy: {
      wikidata: "Q44535",
      description: "True if n is a happy number, a number which eventually reaches 1 when the number is replaced by the sum of the square of each digit",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const seen = /* @__PURE__ */ new Set();
        let k = toBigint(n);
        if (k === null) return ce.False;
        while (!seen.has(k)) {
          if (k === 1n) return ce.True;
          seen.add(k);
          k = sumSquareDigits(k);
        }
        return ce.False;
      }
    },
    IsAbundant: {
      description: "True if n is an abundant number (sum of divisors > 2n).",
      signature: "(integer) -> boolean",
      evaluate: ([n], { engine: ce }) => {
        const k = toBigint(n);
        if (k === null || k < 1n) return ce.False;
        let sum2 = 1n;
        for (let i = 2n; i * i <= k; i++) {
          if (k % i === 0n) {
            sum2 += i;
            const j = k / i;
            if (j !== i) sum2 += j;
          }
        }
        return ce.symbol(sum2 > k ? "True" : "False");
      }
    }
  }
];
function sumSquareDigits(k) {
  return k.toString().split("").map((d) => BigInt(d)).reduce((sum2, d) => sum2 + d * d, 0n);
}

// src/compute-engine/boxed-expression/factor.ts
init_utils3();
init_product();
init_arithmetic_mul_div();
init_arithmetic_add();
init_polynomials();
function together(op) {
  const ce = op.engine;
  const h = op.operator;
  if (isRelationalOperator(h)) return ce.function(h, op.ops.map(together));
  if (h === "Divide") return op.ops[0].div(op.ops[1]);
  if (h === "Negate") return together(op.ops[0]).neg();
  if (h === "Add") {
    const [numer, denom] = op.ops.reduce(
      (acc, x) => {
        if (x.operator === "Divide") {
          acc[0].push(x.ops[0]);
          acc[1].push(x.ops[1]);
        } else acc[0].push(x);
        return acc;
      },
      [[], []]
    );
    return add3(...numer).div(add3(...denom));
  }
  return op;
}
function factorPerfectSquare(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return null;
  const terms = expr.ops;
  if (terms.length !== 3) return null;
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (i === j) continue;
      const crossIdx = 3 - i - j;
      const term1 = terms[i];
      const term2 = terms[j];
      const crossTerm = terms[crossIdx];
      const sqrt1 = extractSquareRoot(term1, ce);
      const sqrt22 = extractSquareRoot(term2, ce);
      if (sqrt1 === null || sqrt22 === null) continue;
      const positiveCross = ce.number(2).mul(sqrt1).mul(sqrt22);
      const negativeCross = positiveCross.neg();
      if (crossTerm.isSame(positiveCross)) {
        return ce.box(["Square", sqrt1.add(sqrt22).json]);
      } else if (crossTerm.isSame(negativeCross)) {
        return ce.box(["Square", sqrt1.sub(sqrt22).json]);
      }
    }
  }
  return null;
}
function extractSquareRoot(term, ce) {
  const sqrt3 = term.sqrt().simplify();
  if (sqrt3.operator === "Sqrt") return null;
  if (sqrt3.isNumberLiteral && sqrt3.numericValue) {
    const nv = sqrt3.numericValue;
    if (nv.radical !== void 0 && nv.radical !== 1) return null;
  }
  if (sqrt3.operator === "Abs") {
    return sqrt3.op1;
  }
  if (sqrt3.operator === "Multiply") {
    const absFactors = sqrt3.ops.filter((op) => op.operator === "Abs");
    if (absFactors.length > 0) {
      const newOps = sqrt3.ops.map(
        (op) => op.operator === "Abs" ? op.op1 : op
      );
      return ce.box(["Multiply", ...newOps.map((op) => op.json)]);
    }
  }
  return sqrt3;
}
function factorDifferenceOfSquares(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return null;
  const terms = expr.ops;
  if (terms.length !== 2) return null;
  const results = [];
  for (const term of terms) {
    let isNeg = term.operator === "Negate";
    let absTerm = isNeg ? term.op1 : term;
    if (!isNeg && term.isNumberLiteral && term.isNegative === true) {
      isNeg = true;
      absTerm = term.neg();
    }
    if (!isNeg && term.operator === "Multiply") {
      const ops = term.ops;
      if (ops[0].isNumberLiteral && ops[0].isNegative === true) {
        isNeg = true;
        const newOps = [ops[0].neg(), ...ops.slice(1)];
        absTerm = ce.box(["Multiply", ...newOps.map((op) => op.json)]);
      }
    }
    const sqrt3 = extractSquareRoot(absTerm, ce);
    if (sqrt3 === null) return null;
    results.push({ sqrt: sqrt3, isNegative: isNeg });
  }
  const posSquares = results.filter((r) => !r.isNegative);
  const negSquares = results.filter((r) => r.isNegative);
  if (posSquares.length !== 1 || negSquares.length !== 1) return null;
  const a = posSquares[0].sqrt;
  const b = negSquares[0].sqrt;
  return ce.box(["Multiply", a.sub(b).json, a.add(b).json]);
}
function factorQuadratic(expr, variable) {
  const ce = expr.engine;
  const degree = polynomialDegree(expr, variable);
  if (degree !== 2) return null;
  const coeffs = getPolynomialCoefficients(expr, variable);
  if (!coeffs || coeffs.length < 3) return null;
  const c = coeffs[0];
  const b = coeffs[1];
  const a = coeffs[2];
  if (a.is(0)) return null;
  const discriminant = b.pow(2).sub(ce.number(4).mul(a).mul(c));
  if (discriminant.isNegative === true) return null;
  const sqrtDisc = discriminant.sqrt();
  if (sqrtDisc.operator === "Sqrt") return null;
  if (sqrtDisc.isNumberLiteral && sqrtDisc.numericValue) {
    const nv = sqrtDisc.numericValue;
    if (nv.radical !== void 0 && nv.radical !== 1) return null;
  }
  const twoA = ce.number(2).mul(a);
  const root1 = b.neg().add(sqrtDisc).div(twoA);
  const root2 = b.neg().sub(sqrtDisc).div(twoA);
  const checkRadical = (expr2) => {
    if (expr2.operator === "Sqrt") return true;
    if (expr2.isNumberLiteral && expr2.numericValue) {
      const nv = expr2.numericValue;
      if (nv.radical !== void 0 && nv.radical !== 1) return true;
    }
    if (expr2.ops) {
      for (const op of expr2.ops) {
        if (checkRadical(op)) return true;
      }
    }
    return false;
  };
  if (checkRadical(root1) || checkRadical(root2)) return null;
  const x = ce.symbol(variable);
  const factor1 = x.sub(root1);
  const factor22 = x.sub(root2);
  if (a.is(1)) {
    return ce.box(["Multiply", factor1.json, factor22.json]);
  } else {
    return ce.box(["Multiply", a.json, factor1.json, factor22.json]);
  }
}
function factorPolynomial(expr, variable) {
  const perfectSquare = factorPerfectSquare(expr);
  if (perfectSquare !== null) return perfectSquare;
  const diffSquares = factorDifferenceOfSquares(expr);
  if (diffSquares !== null) return diffSquares;
  if (variable !== void 0) {
    const quadratic = factorQuadratic(expr, variable);
    if (quadratic !== null) return quadratic;
  }
  return factor(expr);
}
function factor(expr) {
  const h = expr.operator;
  if (isRelationalOperator(h)) {
    let lhs = Product.from(expr.op1);
    let rhs = Product.from(expr.op2);
    const [coef, common] = commonTerms(lhs, rhs);
    let flip = coef.sgn() === -1;
    if (!coef.isOne) {
      lhs.div(coef);
      rhs.div(coef);
    }
    if (!common.is(1)) {
      if (common.isPositive) {
        lhs.div(common);
        rhs.div(common);
      } else if (common.isNegative) {
        lhs.div(common.neg());
        rhs.div(common.neg());
        flip = !flip;
      }
    }
    if (flip) [lhs, rhs] = [rhs, lhs];
    return expr.engine.function(h, [lhs.asExpression(), rhs.asExpression()]);
  }
  if (h === "Negate") return factor(expr.ops[0]).neg();
  if (h === "Add") {
    const ce = expr.engine;
    let common = void 0;
    const terms = [];
    for (const op of expr.ops) {
      const [coeff, term] = op.toNumericValue();
      common = common ? common.gcd(coeff) : coeff;
      if (!coeff.isZero) terms.push({ coeff, term });
    }
    if (!common || common.isOne) return expr;
    const newTerms = terms.map(
      ({ coeff, term }) => mul3(term, ce.box(coeff.div(common)))
    );
    return mul3(ce.number(common), add3(...newTerms));
  }
  return Product.from(together(expr)).asExpression();
}

// src/compute-engine/symbolic/distribute.ts
function distribute2(lhs, rhs, g, f) {
  const ce = lhs.engine;
  if (lhs.operator === g)
    return ce.box([f, ...lhs.ops.map((x) => distribute2(x, rhs, g, f))]);
  if (rhs.operator === g)
    return ce.box([f, ...rhs.ops.map((x) => distribute2(lhs, x, g, f))]);
  return ce.box([f, lhs, rhs]);
}
function distribute(expr, g = "Add", f = "Multiply") {
  if (expr.operator !== f) return expr;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return expr;
  return expr.engine.box([
    g,
    ops.slice(1).reduce((acc, v) => distribute2(acc, v, g, f), ops[0])
  ]);
}

// src/compute-engine/library/polynomials.ts
init_expand();
init_polynomials();
var POLYNOMIALS_LIBRARY = [
  {
    Expand: {
      description: "Expand out products and positive integer powers",
      lazy: true,
      signature: "(value)-> value",
      evaluate: ([x]) => expand2(x.canonical) ?? x.canonical
    },
    ExpandAll: {
      description: "Recursively expand out products and positive integer powers",
      lazy: true,
      signature: "(value)-> value",
      evaluate: ([x]) => expandAll(x.canonical) ?? x.canonical
    },
    Factor: {
      description: "Factor a polynomial expression into a product of irreducible factors. Supports perfect square trinomials, difference of squares, and quadratic factoring with rational roots. Example: Factor(x\xB2 + 5x + 6) \u2192 (x+2)(x+3), Factor(x\xB2 + 2x + 1) \u2192 (x+1)\xB2",
      lazy: true,
      signature: "(value, symbol?) -> value",
      evaluate: ([x, varExpr]) => {
        if (!x) return x;
        if (varExpr) {
          const variable = varExpr.canonical.symbol;
          if (!variable) return x.canonical;
          return factorPolynomial(x.canonical, variable);
        }
        return factorPolynomial(x.canonical);
      }
    },
    Together: {
      description: "Combine rational expressions into a single fraction",
      lazy: true,
      signature: "(value)-> value",
      evaluate: ([x]) => together(x.canonical)
    },
    Distribute: {
      description: "Distribute multiplication over addition",
      lazy: true,
      signature: "(value)-> value",
      evaluate: ([x]) => !x ? x : distribute(x.canonical)
    },
    PolynomialDegree: {
      description: "Return the degree of a polynomial with respect to a variable. Example: PolynomialDegree(x\xB3 + 2x + 1, x) \u2192 3",
      lazy: true,
      signature: "(value, symbol) -> integer",
      evaluate: ([poly, varExpr]) => {
        if (!poly || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        const deg = polynomialDegree(poly.canonical, variable);
        return deg >= 0 ? poly.engine.number(deg) : void 0;
      }
    },
    CoefficientList: {
      description: "Return the list of coefficients of a polynomial, from lowest to highest degree. Example: CoefficientList(x\xB3 + 2x + 1, x) \u2192 [1, 2, 0, 1]",
      lazy: true,
      signature: "(value, symbol) -> list<value>",
      evaluate: ([poly, varExpr]) => {
        if (!poly || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        const coeffs = getPolynomialCoefficients(poly.canonical, variable);
        if (!coeffs) return void 0;
        return poly.engine.box(["List", ...coeffs]);
      }
    },
    PolynomialQuotient: {
      description: "Return the quotient of polynomial division of dividend by divisor. Example: PolynomialQuotient(x\xB3 - 1, x - 1, x) \u2192 x\xB2 + x + 1",
      lazy: true,
      signature: "(dividend: value, divisor: value, variable: symbol) -> value",
      evaluate: ([dividend, divisor, varExpr]) => {
        if (!dividend || !divisor || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        const result = polynomialDivide(
          dividend.canonical,
          divisor.canonical,
          variable
        );
        return result?.[0];
      }
    },
    PolynomialRemainder: {
      description: "Return the remainder of polynomial division of dividend by divisor. Example: PolynomialRemainder(x\xB3 + 2x + 1, x + 1, x) \u2192 -2",
      lazy: true,
      signature: "(dividend: value, divisor: value, variable: symbol) -> value",
      evaluate: ([dividend, divisor, varExpr]) => {
        if (!dividend || !divisor || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        const result = polynomialDivide(
          dividend.canonical,
          divisor.canonical,
          variable
        );
        return result?.[1];
      }
    },
    PolynomialGCD: {
      description: "Return the greatest common divisor of two polynomials. Example: PolynomialGCD(x\xB2 - 1, x - 1, x) \u2192 x - 1",
      lazy: true,
      signature: "(a: value, b: value, variable: symbol) -> value",
      evaluate: ([a, b, varExpr]) => {
        if (!a || !b || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        return polynomialGCD(a.canonical, b.canonical, variable);
      }
    },
    Cancel: {
      description: "Cancel common polynomial factors in the numerator and denominator of a rational expression. Example: Cancel((x\xB2 - 1)/(x - 1), x) \u2192 x + 1",
      lazy: true,
      signature: "(value, symbol) -> value",
      evaluate: ([expr, varExpr]) => {
        if (!expr || !varExpr) return void 0;
        const variable = varExpr.canonical.symbol;
        if (!variable) return void 0;
        return cancelCommonFactors(expr.canonical, variable);
      }
    }
  }
];

// src/compute-engine/library/relational-operator.ts
init_utils3();
init_flatten();
init_compare();
var RELOP_LIBRARY = {
  Congruent: {
    description: "Indicate that two expressions are congruent modulo a number",
    complexity: 11e3,
    signature: "(number, number, modulo: integer) -> boolean",
    evaluate: (ops, { engine: ce }) => {
      if (ops.length < 3) return void 0;
      const [lhs, rhs, modulo] = ops;
      const nLhs = lhs.value;
      const nRhs = rhs.value;
      const nModulo = modulo.value;
      if (typeof nLhs !== "number") return void 0;
      if (typeof nRhs !== "number") return void 0;
      if (typeof nModulo !== "number") return void 0;
      return nLhs % nModulo === nRhs % nModulo ? ce.True : ce.False;
    }
  },
  IsSame: {
    description: "Compare two expressions for structural equality",
    lazy: true,
    signature: "(any, any) -> boolean",
    // Since we want to work on non-canonical expressions,
    // do nothing to canonicalize the arguments (the lazy flag will prevent
    // canonicalization of the arguments)
    evaluate: (ops, { engine: ce }) => {
      if (ops.length !== 2) return void 0;
      const [lhs, rhs] = ops;
      return lhs.isSame(rhs) ? ce.True : ce.False;
    }
  },
  Equal: {
    complexity: 11e3,
    signature: "(any, any) -> boolean",
    lazy: true,
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "Equal", args),
    // Comparing two equalities...
    // Two equations are equivalent if they have the same solution set.
    // For polynomial equations, this means the LHS-RHS expressions differ
    // only by a non-zero constant factor.
    eq: (a, b) => {
      if (a.operator !== b.operator) return void 0;
      const ce = a.engine;
      const expr1 = a.op1.sub(a.op2);
      const expr2 = b.op1.sub(b.op2);
      const s1 = expr1.simplify();
      const s2 = expr2.simplify();
      const expr1Zero = s1.is(0) || s1.isNumberLiteral && s1.re === 0;
      const expr2Zero = s2.is(0) || s2.isNumberLiteral && s2.re === 0;
      if (expr1Zero && expr2Zero) return true;
      if (expr1Zero || expr2Zero) return false;
      const unknowns = [.../* @__PURE__ */ new Set([...expr1.unknowns, ...expr2.unknowns])];
      if (unknowns.length === 0) {
        const v1 = expr1.N().re;
        const v2 = expr2.N().re;
        if (!Number.isFinite(v1) || !Number.isFinite(v2)) return void 0;
        if (Math.abs(v2) < ce.tolerance) return false;
        return Math.abs(v1) > ce.tolerance && Math.abs(v2) > ce.tolerance && Number.isFinite(v1 / v2);
      }
      const testValues = [0.5, 1.5, 2, -1, 3, -0.5, 0.7, 2.3];
      let constantRatio = void 0;
      const tolerance = ce.tolerance;
      for (const testVal of testValues) {
        const sub3 = {};
        for (const u of unknowns) sub3[u] = testVal;
        const v1 = expr1.subs(sub3).N();
        const v2 = expr2.subs(sub3).N();
        const n1 = v1.re;
        const n2 = v2.re;
        if (!Number.isFinite(n1) || !Number.isFinite(n2)) continue;
        if (Math.abs(n2) < tolerance) continue;
        const r = n1 / n2;
        if (!Number.isFinite(r)) continue;
        if (constantRatio === void 0) {
          constantRatio = r;
        } else if (Math.abs(r - constantRatio) > tolerance) {
          return false;
        }
      }
      if (constantRatio !== void 0 && Math.abs(constantRatio) > tolerance) {
        return true;
      }
      return void 0;
    },
    evaluate: (ops, { engine: ce }) => {
      if (ops.length < 2) return ce.True;
      let lhs = void 0;
      for (const arg of ops) {
        if (!lhs) lhs = arg;
        else {
          const test = eq(lhs, arg);
          if (test === false) return ce.False;
          if (test === void 0 && ce.isVerifying) return void 0;
          if (test === void 0) return ce.False;
        }
      }
      return ce.True;
    }
  },
  NotEqual: {
    wikidata: "Q28113351",
    complexity: 11e3,
    signature: "(any, any) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "NotEqual", args),
    // Comparing two equalities...
    eq: (a, b) => {
      if (a.operator !== b.operator) return false;
      if (a.op1.isEqual(b.op1) && a.op2.isEqual(b.op2) || a.op1.isEqual(b.op2) && a.op2.isEqual(b.op1))
        return true;
      return false;
    },
    evaluate: (ops, { engine: ce }) => {
      if (ops.length < 2) return ce.False;
      let lhs = void 0;
      for (const arg of ops) {
        if (!lhs) lhs = arg;
        else {
          const test = lhs.isEqual(arg);
          if (test === true) return ce.False;
          if (test === void 0 && ce.isVerifying) return void 0;
        }
      }
      return ce.True;
    }
  },
  Less: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (ops, { engine: ce }) => canonicalRelational(ce, "Less", ops),
    eq: (a, b) => inequalityEq(a, b, "Greater"),
    evaluate: (ops, { engine: ce }) => {
      if (ops.length === 2) {
        const [lhs2, rhs] = ops;
        const cmp2 = lhs2.isLess(rhs);
        if (cmp2 === void 0) return void 0;
        return cmp2 ? ce.True : ce.False;
      }
      if (ops.length < 2) return ce.True;
      let lhs = void 0;
      for (const arg of ops) {
        if (!lhs) lhs = arg;
        else {
          const cmp2 = arg.isLess(lhs);
          if (cmp2 === void 0) return void 0;
          if (cmp2 === false) return ce.False;
          lhs = arg;
        }
      }
      return ce.True;
    }
  },
  NotLess: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (ops, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "Less", ops)])
  },
  Greater: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (ops, { engine: ce }) => canonicalRelational(ce, "Less", [...ops].reverse())
  },
  NotGreater: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => ce._fn("Not", [ce._fn("Greater", args)])
  },
  LessEqual: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (ops, { engine: ce }) => canonicalRelational(ce, "LessEqual", ops),
    eq: (a, b) => inequalityEq(a, b, "LessGreater"),
    evaluate: (ops, { engine: ce }) => {
      if (ops.length === 2) {
        const [lhs2, rhs] = ops;
        const cmp2 = lhs2.isLessEqual(rhs);
        if (cmp2 === void 0) return void 0;
        return cmp2 ? ce.True : ce.False;
      }
      if (ops.length < 2) return ce.True;
      let lhs = void 0;
      for (const arg of ops) {
        if (!lhs) lhs = arg;
        else {
          const cmp2 = arg.isLessEqual(lhs);
          if (cmp2 === void 0) return void 0;
          if (cmp2 === false) return ce.False;
          lhs = arg;
        }
      }
      return ce.True;
    }
  },
  NotLessNotEqual: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (ops, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "LessEqual", ops)])
  },
  GreaterEqual: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "LessEqual", [...args].reverse())
  },
  NotGreaterNotEqual: {
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "GreaterEqual", args)])
  },
  TildeFullEqual: {
    description: "Indicate isomorphism, congruence and homotopic equivalence",
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "TildeFullEqual", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotTildeFullEqual: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "TildeFullEqual", args)])
  },
  TildeEqual: {
    description: "Approximately or asymptotically equal",
    complexity: 11e3,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "TildeEqual", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotTildeEqual: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "TildeEqual", args)])
  },
  Approx: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "Approx", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotApprox: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "Approx", args)])
  },
  ApproxEqual: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "ApproxEqual", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotApproxEqual: {
    complexity: 11100,
    canonical: (args, { engine: ce }) => ce._fn("Not", [canonicalRelational(ce, "ApproxEqual", args)])
  },
  ApproxNotEqual: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "ApproxNotEqual", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotApproxNotEqual: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine }) => engine._fn("Not", [canonicalRelational(engine, "ApproxNotEqual", args)])
  },
  Precedes: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine: ce }) => canonicalRelational(ce, "Precedes", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotPrecedes: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine }) => engine._fn("Not", [canonicalRelational(engine, "Precedes", args)])
  },
  Succeeds: {
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine }) => canonicalRelational(engine, "Succeeds", args)
    // @todo evaluate: (ce, ...args: BoxedExpression[]) => SemiBoxedExpression {}
  },
  NotSucceeds: {
    complexity: 11100,
    signature: "(any, any+) -> boolean",
    canonical: (args, { engine }) => engine._fn("Not", [canonicalRelational(engine, "Succeeds", args)])
  }
};
function canonicalRelational(ce, operator2, ops) {
  ops = flatten(ops, operator2);
  const nestedRelational = [];
  const newOps = [];
  for (const op of ops) {
    if (isRelationalOperator(op.operator)) {
      nestedRelational.push(op);
      newOps.push(op.ops[op.ops.length - 1]);
    } else newOps.push(op);
  }
  if (nestedRelational.length === 0) return ce._fn(operator2, newOps);
  return ce._fn("And", [ce._fn(operator2, newOps), ...nestedRelational]);
}
function inequalityEq(a, b, oppositeOperator) {
  if (a.operator === b.operator) {
    if (a.nops !== b.nops) return false;
    return a.ops.every((op, i) => op.isEqual(b.ops[i]));
  }
  if (b.operator === oppositeOperator) {
    if (a.nops !== b.nops) return false;
    return a.ops.every((op, i) => op.isEqual(b.ops[b.nops - 1 - i]));
  }
  return false;
}

// src/compute-engine/library/sets.ts
init_boxed_type();
init_parse();

// src/common/type/reduce.ts
init_parse();
init_serialize();
init_subtype();
init_primitive();
function reduceType(type2) {
  if (typeof type2 === "string") {
    if (!isValidPrimitiveType(type2)) return "error";
    return type2;
  }
  switch (type2.kind) {
    case "union":
      return reduceUnionType(type2);
    case "intersection":
      return reduceIntersectionType(type2);
    case "negation":
      return reduceNegationType(type2);
    case "collection":
    case "indexed_collection":
      return reduceCollectionType(type2.kind, type2);
    case "list":
      return reduceListType(type2);
    case "set":
      return reduceSetType(type2);
    case "tuple":
      return reduceTupleType(type2);
    case "record":
      return reduceRecordType(type2);
    case "dictionary":
      return reduceDictionaryType(type2);
    case "signature":
      return reduceSignatureType(type2);
    case "value":
      return type2;
    case "reference":
      return type2;
    default:
      throw new Error(`Unknown type kind: ${type2}`);
  }
}
function decorate(t) {
  if (typeof t !== "object") return t;
  Object.defineProperty(t, "toString", { value: () => typeToString(t) });
  return t;
}
function reduceNegationType(type2) {
  const reducedType = reduceType(type2.type);
  if (reducedType === "nothing") return "any";
  if (reducedType === "any") return "nothing";
  return decorate({ kind: "negation", type: reducedType });
}
function reduceUnionType(type2) {
  const uniqueTypes = new Set(
    type2.types.map((t) => typeToString(reduceType(t)))
  );
  const reducedTypes = Array.from(uniqueTypes).map(
    (x) => parseType(x)
  );
  if (reducedTypes.length === 0) return "never";
  if (reducedTypes.some((type3) => type3 === "error")) return "error";
  if (reducedTypes.length === 1) return decorate(reducedTypes[0]);
  return decorate(
    reducedTypes.reduce((acc, current) => {
      if (!acc.some((t) => isSubtype(current, t) || isSubtype(t, current)))
        acc.push(current);
      return acc;
    }, []).reduce(
      (acc, cur, idx, arr) => arr.length === 1 ? cur : { kind: "union", types: arr }
    )
  );
}
function reduceIntersectionType(type2) {
  const uniqueTypes = new Set(
    type2.types.map((t) => typeToString(reduceType(t)))
  );
  const reducedTypes = Array.from(uniqueTypes).map((x) => parseType(x));
  const incompatible = reducedTypes.some(
    (t1) => reducedTypes.some(
      (t2) => t1 !== t2 && !isSubtype(t1, t2) && !isSubtype(t2, t1)
    )
  );
  if (incompatible) return "nothing";
  const simplified = reducedTypes.reduce((acc, current) => {
    acc = acc.filter((t) => isSubtype(t, current));
    if (!acc.some((t) => isSubtype(t, current))) acc.push(current);
    return acc;
  }, []);
  if (simplified.some((type3) => type3 === "error")) return "error";
  if (simplified.length === 0) return "nothing";
  if (simplified.length === 1) return decorate(simplified[0]);
  return decorate({
    kind: "intersection",
    types: simplified
  });
}
function reduceCollectionType(kind, type2) {
  const reducedType = reduceType(type2.elements);
  if (reducedType === "error") return "error";
  if (reducedType === "nothing") return decorate({ kind, elements: "nothing" });
  if (reducedType === "any") return kind;
  return decorate({
    ...type2,
    elements: reducedType
  });
}
function reduceListType(type2) {
  const reducedType = reduceType(type2.elements);
  if (reducedType === "error") return "error";
  if (reducedType === "nothing")
    return decorate({ kind: "list", elements: "nothing" });
  if (reducedType === "any") return "list";
  let dimensions = type2.dimensions;
  if (dimensions) {
    dimensions = dimensions.filter((dim) => dim >= 1);
    if (dimensions.length === 0) return "nothing";
  }
  return decorate({
    ...type2,
    dimensions,
    elements: reducedType
  });
}
function reduceSetType(type2) {
  const reducedType = reduceType(type2.elements);
  if (reducedType === "error") return "error";
  if (reducedType === "nothing")
    return decorate({ kind: "set", elements: "nothing" });
  if (reducedType === "any") return "set";
  return decorate({
    ...type2,
    elements: reducedType
  });
}
function reduceTupleType(type2) {
  let reducedElements = type2.elements.map((element) => ({
    ...element,
    type: reduceType(element.type)
  }));
  if (reducedElements.length === 0) return "nothing";
  if (reducedElements.some((element) => element.type === "error"))
    return "error";
  reducedElements = reducedElements.filter(
    (element) => element.type !== "nothing"
  );
  return decorate({
    ...type2,
    elements: reducedElements
  });
}
function reduceRecordType(type2) {
  let reducedElements = {};
  for (const [key, value] of Object.entries(type2.elements))
    reducedElements[key] = reduceType(value);
  if (Object.values(reducedElements).some((type3) => type3 === "error"))
    return "error";
  reducedElements = Object.fromEntries(
    Object.entries(reducedElements).filter(([_, value]) => value !== "nothing")
  );
  if (Object.keys(reducedElements).length === 0) return "record";
  return decorate({
    ...type2,
    elements: reducedElements
  });
}
function reduceDictionaryType(type2) {
  const reducedValues = reduceType(type2.values);
  if (reducedValues === "error") return "error";
  if (reducedValues === "nothing") return "error";
  if (reducedValues === "any" || reducedValues === "unknown") return "any";
  return decorate({ kind: "dictionary", values: reducedValues });
}
function reduceSignatureType(type2) {
  const reducedArgs = type2.args?.map((arg) => ({
    ...arg,
    type: reduceType(arg.type)
  }));
  let reducedOptArgs = type2.optArgs?.map((arg) => ({
    ...arg,
    type: reduceType(arg.type)
  }));
  let reducedVarArg = type2.variadicArg ? {
    ...type2.variadicArg,
    type: reduceType(type2.variadicArg.type)
  } : void 0;
  const reducedResult = reduceType(type2.result);
  if (reducedArgs?.some((arg) => arg.type === "error")) return "error";
  if (reducedOptArgs?.some((arg) => arg.type === "error")) return "error";
  if (reducedVarArg?.type === "error") return "error";
  if (reducedResult === "error") return "error";
  reducedOptArgs = reducedOptArgs?.filter((arg) => arg.type !== "nothing");
  if (reducedArgs?.length === 0) reducedOptArgs = void 0;
  if (reducedOptArgs?.length === 0) reducedOptArgs = void 0;
  if (reducedVarArg?.type === "nothing") reducedVarArg = void 0;
  return decorate({
    ...type2,
    args: reducedArgs,
    optArgs: reducedOptArgs,
    variadicArg: reducedVarArg,
    variadicMin: reducedVarArg ? type2.variadicMin : void 0,
    result: reducedResult
  });
}

// src/compute-engine/library/sets.ts
init_flatten();
init_validate();
init_collection_utils();
init_numeric();
function typeIntersection(a, b) {
  return reduceType({ kind: "intersection", types: [a, b] });
}
function listToIntervalInSetContext(ce, expr) {
  if (expr.operator === "List" && expr.nops === 2) {
    return ce.function("Interval", [expr.op1.canonical, expr.op2.canonical]);
  }
  if (expr.operator === "Tuple" && expr.nops === 2) {
    return ce.function("Interval", [
      ce.function("Open", [expr.op1.canonical]),
      ce.function("Open", [expr.op2.canonical])
    ]);
  }
  return expr.canonical;
}
var SETS_LIBRARY = {
  //
  // Constants
  //
  EmptySet: {
    type: "set",
    isConstant: true,
    wikidata: "Q226183",
    description: "The empty set, a set containing no elements.",
    eq: (b) => b.type.matches("set") && b.isEmptyCollection,
    collection: {
      iterator: () => ({
        next: () => ({ value: void 0, done: true })
      }),
      count: () => 0,
      isEmpty: () => true,
      isFinite: () => true,
      contains: () => false,
      subsetOf: () => true,
      eltsgn: () => void 0,
      elttype: () => "never"
    }
  },
  Numbers: {
    type: "set<number>",
    isConstant: true,
    description: "The set of all numbers.",
    collection: {
      iterator: complexIterator,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      contains: (_, x) => x.type.matches("number"),
      subsetOf: (_, other, strict) => {
        if (other.operator === "Range" || other.operator === "Linspace")
          return true;
        return other.type.matches(BoxedType.setNumber) && (!strict || other.symbol !== "Numbers");
      },
      eltsgn: () => "unsigned",
      elttype: () => "number"
    }
  },
  ComplexNumbers: {
    type: "set<finite_complex>",
    isConstant: true,
    description: "The set of all finite complex numbers.",
    collection: {
      iterator: complexIterator,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      contains: (_, x) => x.type.matches("finite_complex"),
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace")
          return true;
        return rhs.type.matches(BoxedType.setComplex) && (!strict || rhs.symbol !== "ComplexNumbers");
      },
      eltsgn: () => "unsigned",
      elttype: () => "finite_complex"
    }
  },
  ExtendedComplexNumbers: {
    type: "set<complex>",
    isConstant: true,
    description: "The set of all complex numbers, including infinities.",
    collection: {
      iterator: complexIterator,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      contains: (_, x) => x.type.matches("complex"),
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace")
          return true;
        return rhs.type.matches(BoxedType.setComplex) && (!strict || rhs.symbol !== "ComplexNumbers");
      },
      eltsgn: () => "unsigned",
      elttype: () => "complex"
    }
  },
  ImaginaryNumbers: {
    type: "set<imaginary>",
    isConstant: true,
    description: "The set of all imaginary numbers.",
    collection: {
      iterator: imaginaryIterator,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      contains: (_, x) => x.type.matches(BoxedType.setImaginary),
      subsetOf: (_, rhs, strict) => rhs.type.matches(BoxedType.setImaginary) && (!strict || rhs.symbol !== "ImaginaryNumbers"),
      eltsgn: () => "unsigned",
      elttype: () => "imaginary"
    }
  },
  RealNumbers: {
    type: "set<finite_real>",
    isConstant: true,
    description: "The set of all finite real numbers.",
    collection: {
      iterator: (self) => rationalIterator(self),
      contains: (_, x) => x.type.matches("finite_real"),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => rhs.type.matches(BoxedType.setReal) && (!strict || rhs.symbol !== "RealNumbers"),
      eltsgn: () => void 0,
      elttype: () => "finite_real"
    }
  },
  ExtendedRealNumbers: {
    type: "set<real>",
    isConstant: true,
    description: "The set of all real numbers, including infinities.",
    collection: {
      iterator: (self) => rationalIterator(self),
      contains: (_, x) => x.type.matches("real"),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => rhs.type.matches(BoxedType.setReal) && (!strict || rhs.symbol !== "ExtendedRealNumbers"),
      eltsgn: () => void 0,
      elttype: () => "real"
    }
  },
  Integers: {
    type: "set<finite_integer>",
    isConstant: true,
    description: "The set of all finite integers.",
    collection: {
      iterator: integerIterator,
      contains: (_, x) => x.type.matches("finite_integer"),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") return true;
        return rhs.type.matches(BoxedType.setFiniteInteger) && (!strict || rhs.symbol !== "Integers");
      },
      eltsgn: () => void 0,
      elttype: () => "finite_integer"
    }
  },
  ExtendedIntegers: {
    type: "set<integer>",
    isConstant: true,
    description: "The set of all integers, including infinities.",
    collection: {
      iterator: integerIterator,
      contains: (_, x) => x.type.matches("integer"),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") return true;
        return rhs.type.matches(BoxedType.setInteger) && (!strict || rhs.symbol !== "ExtendedIntegers");
      },
      eltsgn: () => void 0,
      elttype: () => "integer"
    }
  },
  RationalNumbers: {
    type: "set<finite_rational>",
    isConstant: true,
    description: "The set of all finite rational numbers.",
    collection: {
      iterator: (self) => rationalIterator(self),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      contains: (_, x) => x.type.matches("finite_rational"),
      subsetOf: (_, rhs, strict) => rhs.type.matches(BoxedType.setRational) && (!strict || rhs.symbol !== "RationalNumbers"),
      eltsgn: () => void 0,
      elttype: () => "finite_rational"
    }
  },
  ExtendedRationalNumbers: {
    type: "set<rational>",
    isConstant: true,
    description: "The set of all rational numbers, including infinities.",
    collection: {
      iterator: (self) => rationalIterator(self),
      contains: (_, x) => x.type.matches("rational"),
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => rhs.type.matches(BoxedType.setRational) && (!strict || rhs.symbol !== "ExtendedRationalNumbers"),
      eltsgn: () => void 0,
      elttype: () => "rational"
    }
  },
  // < 0
  NegativeNumbers: {
    type: "set<real>",
    isConstant: true,
    description: "The set of all negative real numbers.",
    collection: {
      iterator: (self) => rationalIterator(self, { sign: "-", includeZero: false }),
      count: () => Infinity,
      contains: (_, x) => x.type.matches("real") && x.isNegative === true,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low < 0 && high < 0;
        }
        return rhs.type.matches(BoxedType.setReal) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "negative" && (!strict || rhs.symbol !== "NegativeNumbers");
      },
      eltsgn: () => "negative",
      elttype: () => "real"
    }
  },
  // <= 0
  NonPositiveNumbers: {
    type: "set<real>",
    isConstant: true,
    description: "The set of all non-positive real numbers.",
    collection: {
      iterator: (self) => rationalIterator(self, { sign: "-", includeZero: true }),
      contains: (_, x) => x.type.matches("real") && x.isNonPositive === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low >= 0 && high >= 0;
        }
        return rhs.type.matches(BoxedType.setReal) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "non-positive" && (!strict || rhs.symbol !== "NonPositiveNumbers");
      },
      eltsgn: () => "non-positive",
      elttype: () => "real"
    }
  },
  // >= 0
  NonNegativeNumbers: {
    type: "set<real>",
    isConstant: true,
    description: "The set of all non-negative real numbers.",
    collection: {
      iterator: (self) => rationalIterator(self, { sign: "+", includeZero: true }),
      contains: (_, x) => x.type.matches("real") && x.isNonNegative === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low <= 0 && high <= 0;
        }
        return rhs.type.matches(BoxedType.setReal) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "non-negative" && (!strict || rhs.symbol !== "NonNegativeNumbers");
      },
      eltsgn: () => "non-negative",
      elttype: () => "real"
    }
  },
  // > 0
  PositiveNumbers: {
    type: "set<real>",
    isConstant: true,
    description: "The set of all positive real numbers.",
    collection: {
      iterator: (self) => rationalIterator(self, { sign: "+", includeZero: false }),
      contains: (_, x) => x.type.matches("real") && x.isPositive === true,
      count: () => Infinity,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range" || rhs.operator === "Linspace") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low > 0 && high > 0;
        }
        return rhs.type.matches(BoxedType.setReal) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "positive" && (!strict || rhs.symbol !== "PositiveNumbers");
      },
      eltsgn: () => "positive",
      elttype: () => "real"
    }
  },
  // <= -1
  NegativeIntegers: {
    type: "set<integer>",
    isConstant: true,
    description: "The set of all negative integers.",
    collection: {
      iterator: (self) => integerRangeIterator(self.engine, -1, -1),
      contains: (_, x) => x.type.matches("integer") && x.isNegative === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low < 0 && high < 0;
        }
        return rhs.type.matches(BoxedType.setInteger) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "negative" && (!strict || rhs.symbol !== "NegativeIntegers");
      },
      eltsgn: () => "negative",
      elttype: () => "integer"
    }
  },
  // <= 0
  NonPositiveIntegers: {
    type: "set<integer>",
    isConstant: true,
    description: "The set of all non-positive integers.",
    collection: {
      iterator: (self) => integerRangeIterator(self.engine, 0, -1),
      contains: (_, x) => x.type.matches("integer") && x.isNonPositive === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low <= 0 && high <= 0;
        }
        return rhs.type.matches(BoxedType.setInteger) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "non-positive" && (!strict || rhs.symbol !== "NonPositiveIntegers");
      },
      eltsgn: () => "non-positive",
      elttype: () => "integer"
    }
  },
  // >= 0
  NonNegativeIntegers: {
    type: "set<integer>",
    isConstant: true,
    description: "The set of all non-negative integers.",
    collection: {
      iterator: (self) => integerRangeIterator(self.engine, 0, 1),
      contains: (_, x) => x.type.matches("integer") && x.isNonNegative === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low > 0 && high > 0;
        }
        return rhs.type.matches(BoxedType.setInteger) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "non-negative" && (!strict || rhs.symbol !== "NonNegativeIntegers");
      },
      eltsgn: () => "non-negative",
      elttype: () => "integer"
    }
  },
  // >= 1
  PositiveIntegers: {
    type: "set<integer>",
    isConstant: true,
    description: "The set of all positive integers.",
    collection: {
      iterator: (self) => integerRangeIterator(self.engine, 1, 1),
      contains: (_, x) => x.type.matches("integer") && x.isPositive === true,
      count: () => Infinity,
      isEmpty: () => false,
      isFinite: () => false,
      subsetOf: (_, rhs, strict) => {
        if (rhs.operator === "Range") {
          const low = rhs.ops[0].re;
          const high = rhs.ops[1].re;
          return low > 0 && high > 0;
        }
        return rhs.type.matches(BoxedType.setInteger) && rhs.baseDefinition?.collection?.eltsgn?.(rhs) === "positive" && (!strict || rhs.symbol !== "PositiveIntegers");
      },
      eltsgn: () => "positive",
      elttype: () => "integer"
    }
  },
  //
  // Predicates
  //
  Element: {
    complexity: 11200,
    // EL-3: Extended signature to support optional condition for filtered iteration
    // The condition is used by Sum/Product to filter values when iterating
    signature: "(value, collection, boolean?) -> boolean",
    description: 'Test whether a value is an element of a collection. Optional third argument is a boolean expression (condition) for filtered iteration in Sum/Product.\n\nElement supports two modes of operation:\n1. Set membership: Element(3, [List, 1, 2, 3]) checks if 3 is in the list\n2. Type-style membership: Element(x, integer) checks if x has type integer\n\nType-style membership works with:\n- Mathematical sets: Integers, RealNumbers, ComplexNumbers, etc.\n- Type names: integer, real, number, finite_real, positive_integer, etc.\n- Invalid type names remain unevaluated (e.g., Element(2, "Booleans"))',
    canonical: (args, { engine: ce }) => {
      if (args.length === 0) {
        return ce._fn("Element", [ce.error("missing"), ce.error("missing")]);
      }
      if (args.length === 1) {
        return ce._fn("Element", [args[0].canonical, ce.error("missing")]);
      }
      const [value, collection, condition] = args;
      const canonicalCollection = listToIntervalInSetContext(ce, collection);
      if (!canonicalCollection.type.matches("collection") && !canonicalCollection.symbol && !canonicalCollection.isValid) {
        return ce._fn("Element", [
          value.canonical,
          ce.error([
            "incompatible-type",
            `'collection'`,
            canonicalCollection.type.toString()
          ]),
          ...condition ? [condition.canonical] : []
        ]);
      }
      if (condition && condition.symbol !== "Nothing") {
        if (!condition.type.matches("boolean")) {
          return ce._fn("Element", [
            value.canonical,
            canonicalCollection,
            ce.error([
              "incompatible-type",
              `'boolean'`,
              collection.type.toString()
            ])
          ]);
        }
        return ce._fn("Element", [
          value.canonical,
          canonicalCollection,
          condition.canonical
        ]);
      }
      return ce._fn("Element", [value.canonical, canonicalCollection]);
    },
    evaluate: ([value, collection, _condition], { engine: ce }) => {
      if (collection && typeof collection.contains === "function") {
        const result = collection.contains(value);
        if (result === true) return ce.True;
        if (result === false) return ce.False;
      }
      const typeName = collection?.symbol;
      if (typeName) {
        try {
          const type2 = ce.type(typeName);
          if (!type2.isUnknown) {
            const valueType = value.type;
            if (valueType.matches(type2)) return ce.True;
            if (typeIntersection(valueType.type, type2.type) === "nothing")
              return ce.False;
          }
        } catch {
        }
      }
      return void 0;
    }
  },
  NotElement: {
    complexity: 11200,
    signature: "(value, collection) -> boolean",
    description: "Test whether a value is not an element of a collection.",
    evaluate: ([value, collection], { engine: ce }) => {
      const result = collection.contains(value);
      if (result === true) return ce.False;
      if (result === false) return ce.True;
      const typeName = collection.symbol;
      if (typeName) {
        const type2 = ce.type(typeName);
        if (!type2.isUnknown) {
          const valueType = value.type;
          if (valueType.matches(type2)) return ce.False;
          if (typeIntersection(valueType.type, type2.type) === "nothing")
            return ce.True;
        }
      }
      return void 0;
    }
  },
  Subset: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is a strict subset of the second.",
    canonical: (args, { engine: ce }) => {
      if (args.length !== 2) return ce._fn("Subset", args);
      return ce._fn("Subset", [
        listToIntervalInSetContext(ce, args[0]),
        listToIntervalInSetContext(ce, args[1])
      ]);
    },
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(lhs, rhs);
      if (result === true) return ce.True;
      if (result === false) return ce.False;
      return void 0;
    }
  },
  SubsetEqual: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is a subset (possibly equal) of the second.",
    canonical: (args, { engine: ce }) => {
      if (args.length !== 2) return ce._fn("SubsetEqual", args);
      return ce._fn("SubsetEqual", [
        listToIntervalInSetContext(ce, args[0]),
        listToIntervalInSetContext(ce, args[1])
      ]);
    },
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(lhs, rhs, false);
      if (result === true) return ce.True;
      if (result === false) return ce.False;
      return void 0;
    }
  },
  NotSubset: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is not a strict subset of the second.",
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(lhs, rhs);
      if (result === true) return ce.False;
      if (result === false) return ce.True;
      return void 0;
    }
  },
  Superset: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is a strict superset of the second.",
    canonical: (args, { engine: ce }) => {
      if (args.length !== 2) return ce._fn("Superset", args);
      return ce._fn("Superset", [
        listToIntervalInSetContext(ce, args[0]),
        listToIntervalInSetContext(ce, args[1])
      ]);
    },
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(rhs, lhs);
      if (result === true) return ce.True;
      if (result === false) return ce.False;
      return void 0;
    }
  },
  SupersetEqual: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is a superset (possibly equal) of the second.",
    canonical: (args, { engine: ce }) => {
      if (args.length !== 2) return ce._fn("SupersetEqual", args);
      return ce._fn("SupersetEqual", [
        listToIntervalInSetContext(ce, args[0]),
        listToIntervalInSetContext(ce, args[1])
      ]);
    },
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(rhs, lhs, true);
      if (result === true) return ce.True;
      if (result === false) return ce.False;
      return void 0;
    }
  },
  NotSuperset: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is not a strict superset of the second.",
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(rhs, lhs);
      if (result === true) return ce.False;
      if (result === false) return ce.True;
      return void 0;
    }
  },
  NotSupersetEqual: {
    complexity: 11200,
    signature: "(lhs:collection, rhs: collection) -> boolean",
    description: "Test whether the first collection is not a superset (possibly equal) of the second.",
    evaluate: ([lhs, rhs], { engine: ce }) => {
      const result = subset(rhs, lhs, true);
      if (result === true) return ce.False;
      if (result === false) return ce.True;
      return void 0;
    }
  },
  // NotSubsetNotEqual: {
  //   complexity: 11200,
  //   signature: {
  //     domain: 'Predicates',
  //     canonical: (args, { engine: ce }) =>
  //       ce._fn('Not', [ce.function('SubsetEqual', args)]),
  //   },
  // },
  //
  // Functions
  //
  Complement: {
    // Return the elements of the first argument that are not in any of
    // the subsequent sets
    wikidata: "Q242767",
    signature: "(set+) -> set",
    description: "Return the elements of the first set that are not in any of the subsequent sets.",
    collection: {
      contains: (expr, x) => {
        const [col, ...others] = expr.ops;
        return (col.contains(x) ?? false) && others.every((set) => !set.contains(x));
      },
      count: (expr) => countMatchingElements(
        expr,
        (elem) => expr.ops.slice(1).every((set) => !set.contains(elem))
      ),
      iterator: complementIterator
    }
  },
  Intersection: {
    // notation: \cap
    wikidata: "Q185837",
    signature: "(set+) -> set",
    description: "Return the intersection of two or more sets.",
    canonical: (args, { engine: ce }) => {
      if (args.length === 0) return ce.symbol("EmptySet");
      if (args.length === 1) return ce.symbol("EmptySet");
      const transformedArgs = args.map(
        (arg) => listToIntervalInSetContext(ce, arg)
      );
      const validatedArgs = validateArguments(
        ce,
        flatten(transformedArgs, "Intersection"),
        parseType("(set+) -> set")
      ) ?? transformedArgs;
      return ce._fn("Intersection", validatedArgs);
    },
    evaluate: intersection,
    collection: {
      contains: containsAll,
      count: (expr) => countMatchingElements(
        expr,
        (elem) => expr.ops.slice(1).every((op) => op.contains(elem))
      ),
      iterator: intersectionIterator
    }
  },
  Union: {
    // Works on set, but can also work on lists
    wikidata: "Q185359",
    signature: "(collection+) -> set",
    description: "Return the union of two or more collections as a set.",
    canonical: (args, { engine: ce }) => {
      if (args.length === 0) return ce.symbol("EmptySet");
      const transformedArgs = args.map(
        (arg) => listToIntervalInSetContext(ce, arg)
      );
      const validatedArgs = validateArguments(
        ce,
        flatten(transformedArgs, "Union"),
        parseType("(collection+) -> set")
      ) ?? transformedArgs;
      return ce._fn("Union", validatedArgs);
    },
    evaluate: union,
    // These handlers will get called if we have a lazy collection,
    // that is a union of collections with more than MAX_SIZE_EAGER_COLLECTION
    // elements. Otherwise, when we evaluated the union, we got a set literal.
    collection: {
      contains: (col, x) => col.ops.some((op) => op.contains(x)),
      count: (col) => countMatchingUnion(
        col,
        (elem, seen) => seen.every((e) => !e.contains(elem))
      ),
      isEmpty: (col) => col.ops.every((op) => op.isEmptyCollection),
      isFinite: (col) => col.ops.every((op) => op.isFiniteCollection),
      iterator: unionIterator
    }
  },
  SetMinus: {
    wikidata: "Q18192442",
    signature: "(set, value*) -> set",
    description: "Return the set difference between the first set and subsequent values.",
    evaluate: setMinus,
    collection: {
      contains: (expr, x) => {
        const [col, ...values] = expr.ops;
        return (col.contains(x) ?? false) && !values.some((val) => val.isSame(x));
      },
      count: (expr) => countMatchingElements(expr, (elem) => {
        const [col, ...values] = expr.ops;
        return !values.some((val) => val.isSame(elem));
      }),
      iterator: setMinusIterator
    }
  },
  SymmetricDifference: {
    // symmetric difference = disjunctive union  (circled minus)
    /* = Union(Complement(a, b), Complement(b, a) */
    /* Corresponds to XOR in boolean logic */
    wikidata: "Q1147242",
    signature: "(set, set) -> set",
    description: "Return the symmetric difference of two sets (elements in either set but not both).",
    collection: {
      contains: (expr, x) => {
        const [a, b] = expr.ops;
        const inA = a.contains(x) ?? false;
        const inB = b.contains(x) ?? false;
        return inA && !inB || !inA && inB;
      },
      count: (expr) => countMatchingElements(expr, (elem) => {
        const [a, b] = expr.ops;
        const inA = a.contains(elem) ?? false;
        const inB = b.contains(elem) ?? false;
        return inA && !inB || !inA && inB;
      }),
      iterator: symmetricDifferenceIterator
    }
  }
};
function subset(lhs, rhs, strict = true) {
  if (!lhs.isCollection || !rhs.isCollection) return false;
  if (lhs.baseDefinition?.collection?.subsetOf?.(lhs, rhs, strict)) return true;
  return false;
}
function union(ops, { engine: ce }) {
  const xs = ops.map((op) => op.isCollection ? op : ce.function("Set", [op]));
  const totalSize = xs.reduce((acc, op) => acc + (op.count ?? 0), 0);
  if (totalSize > MAX_SIZE_EAGER_COLLECTION) return ce._fn("Union", xs);
  const elements = [];
  for (const op of xs) {
    for (const elem of op.each()) {
      if (elements.every((e) => !e.isSame(elem))) elements.push(elem);
    }
  }
  if (elements.length === 0) return ce.symbol("EmptySet");
  return ce._fn("Set", elements);
}
function intersection(ops, { engine: ce }) {
  let elements = [...ops[0].ops ?? []];
  for (const op of ops.slice(1)) {
    if (isFiniteIndexedCollection(op)) {
      elements = elements.filter(
        (element) => [...op.each()].some((op2) => element.isSame(op2))
      );
    } else {
      elements = elements.filter((element) => element.isSame(op));
    }
  }
  if (elements.length === 0) return ce.symbol("EmptySet");
  return ce._fn("Set", elements);
}
function setMinus(_ops, { engine: ce }) {
  return ce.symbol("EmptySet");
}
function imaginaryIterator(self) {
  const iterator = cantorEnumerateRationals();
  return {
    next: () => {
      const { value, done } = iterator.next();
      if (done) return { value: void 0, done: true };
      const [n, d] = value;
      return {
        value: self.engine.number({ re: 0, im: n / d }),
        done: false
      };
    }
  };
}
function complexIterator(self) {
  const iterator = cantorEnumerateComplexNumbers();
  return {
    next: () => {
      const { value, done } = iterator.next();
      if (done) return { value: void 0, done: true };
      const [re, im] = value;
      return { value: self.engine.number({ re, im }), done: false };
    }
  };
}
function* rationalIterator(self, options) {
  const signOpt = options?.sign ?? "+-";
  const includeZero = options?.includeZero ?? true;
  const iterator = signOpt === "+-" ? cantorEnumerateRationals() : cantorEnumeratePositiveRationals();
  if (!includeZero) iterator.next();
  for (const value of iterator) {
    if (signOpt === "+-") {
      yield self.engine.number(value);
    } else {
      const sign3 = signOpt === "-" ? -1 : 1;
      const [n, d] = value;
      yield self.engine.number([sign3 * n, d]);
    }
  }
}
function* integerIterator(self) {
  for (const n of cantorEnumerateIntegers()) yield self.engine.number(n);
}
function* integerRangeIterator(ce, start, step) {
  let n = start;
  while (true) {
    yield ce.number(n);
    n += step;
  }
}
function* unionIterator(col) {
  const seen = [];
  for (const op of col.ops) {
    for (const elem of op.each()) {
      if (seen.every((e) => !e.contains(elem))) {
        yield elem;
      }
    }
    seen.push(op);
  }
}
function* setMinusIterator(expr) {
  const [col, ...values] = expr.ops;
  for (const elem of col.each()) {
    if (!values.some((val) => val.isSame(elem))) {
      yield elem;
    }
  }
}
function* complementIterator(expr) {
  const [col, ...others] = expr.ops;
  for (const elem of col.each()) {
    if (others.every((set) => !set.contains(elem))) {
      yield elem;
    }
  }
}
function* intersectionIterator(expr) {
  for (const elem of expr.ops[0].each()) {
    if (expr.ops.slice(1).every((op) => op.contains(elem))) {
      yield elem;
    }
  }
}
function* symmetricDifferenceIterator(expr) {
  const [a, b] = expr.ops;
  for (const elem of a.each()) {
    if (!(b.contains(elem) ?? false)) {
      yield elem;
    }
  }
  for (const elem of b.each()) {
    if (!(a.contains(elem) ?? false)) {
      yield elem;
    }
  }
}
function countMatchingElements(expr, filter3) {
  if (expr.ops.some((op) => op.count === Infinity)) return Infinity;
  let count = 0;
  for (const elem of expr.ops[0].each()) {
    if (filter3(elem)) count += 1;
  }
  return count;
}
function countMatchingUnion(expr, isUnique) {
  if (expr.ops.some((op) => op.count === Infinity)) return Infinity;
  const seen = [];
  let count = 0;
  for (const op of expr.ops) {
    for (const elem of op.each()) {
      if (isUnique(elem, seen)) count += 1;
    }
    seen.push(op);
  }
  return count;
}
function containsAll(expr, x) {
  return expr.ops.every((op) => op.contains(x) ?? false);
}

// src/compute-engine/library/statistics.ts
init_special_functions();

// src/compute-engine/numerics/statistics.ts
function mean(values) {
  let sum2 = 0;
  let count = 0;
  for (const op of values) {
    sum2 += op;
    count++;
  }
  if (count === 0) return NaN;
  return sum2 / count;
}
function bigMean(bignum, values) {
  let sum2 = bignum(0);
  let count = 0;
  for (const op of values) {
    sum2 = sum2.add(op);
    count++;
  }
  if (count === 0) return bignum(NaN);
  return sum2.div(count);
}
function median(values) {
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
  return sorted[mid];
}
function bigMedian(values) {
  const sorted = [...values].sort((a, b) => a.cmp(b));
  const mid = Math.floor(sorted.length / 2);
  if (sorted.length % 2 === 0) return sorted[mid - 1].add(sorted[mid]).div(2);
  return sorted[mid];
}
function variance(values) {
  let sum2 = 0;
  let sum22 = 0;
  let count = 0;
  for (const op of values) {
    sum2 += op;
    sum22 += op * op;
    count++;
  }
  if (count === 0) return NaN;
  return (sum22 - sum2 * sum2 / count) / (count - 1);
}
function bigVariance(bignum, values) {
  let sum2 = bignum(0);
  let sum22 = bignum(0);
  let count = 0;
  for (const op of values) {
    sum2 = sum2.add(op);
    sum22 = sum22.add(op.mul(op));
    count++;
  }
  if (count === 0) return bignum(NaN);
  return sum22.sub(sum2.mul(sum2).div(count)).div(count - 1);
}
function populationVariance(values) {
  let sum2 = 0;
  let sum22 = 0;
  let count = 0;
  for (const op of values) {
    sum2 += op;
    sum22 += op * op;
    count++;
  }
  if (count === 0) return NaN;
  return (sum22 - sum2 * sum2 / count) / count;
}
function bigPopulationVariance(bignum, values) {
  let sum2 = bignum(0);
  let sum22 = bignum(0);
  let count = 0;
  for (const op of values) {
    sum2 = sum2.add(op);
    sum22 = sum22.add(op.mul(op));
    count++;
  }
  if (count === 0) return bignum(NaN);
  return sum22.sub(sum2.mul(sum2).div(count)).div(count);
}
function standardDeviation(values) {
  return Math.sqrt(variance(values));
}
function populationStandardDeviation(values) {
  return Math.sqrt(populationVariance(values));
}
function kurtosis(values) {
  let sum2 = 0;
  let sum22 = 0;
  let sum4 = 0;
  let count = 0;
  for (const op of values) {
    const v = op;
    if (!Number.isFinite(v)) return NaN;
    sum2 += v;
    sum22 += v * v;
    sum4 += v * v * v * v;
    count++;
  }
  if (count === 0) return NaN;
  const s2 = (sum22 - sum2 * sum2 / count) / (count - 1);
  return (sum4 - 4 * sum2 * sum22 / count + 6 * sum2 * sum2 * sum2 / count / count - 3 * sum2 * sum2 * sum2 * sum2 / count / count / count) / (s2 * s2);
}
function bigKurtosis(bignum, values) {
  let sum2 = bignum(0);
  let sum22 = bignum(0);
  let sum4 = bignum(0);
  let count = 0;
  for (const op of values) {
    const v = op;
    if (!v.isFinite()) return bignum(NaN);
    sum2 = sum2.add(v);
    sum22 = sum22.add(v.mul(v));
    sum4 = sum4.add(v.mul(v).mul(v).mul(v));
    count++;
  }
  if (count === 0) return bignum(NaN);
  const s2 = sum22.sub(sum2.mul(sum2).div(count)).div(count - 1);
  return sum4.sub(sum2.mul(sum22).mul(4).div(count)).add(sum2.mul(sum2).mul(sum2).mul(6).div(count).div(count)).sub(sum2.mul(sum2).mul(sum2).mul(sum2).div(count).div(count).div(count)).div(s2.mul(s2));
}
function skewness(values) {
  let sum2 = 0;
  let sum22 = 0;
  let sum3 = 0;
  let count = 0;
  for (const op of values) {
    const v = op;
    if (!Number.isFinite(v)) return NaN;
    sum2 += v;
    sum22 += v * v;
    sum3 += v * v * v;
    count++;
  }
  if (count === 0) return NaN;
  const s2 = (sum22 - sum2 * sum2 / count) / (count - 1);
  const s3 = (sum3 - sum22 * sum2 / count) / (count - 1);
  return s3 / Math.pow(s2, 3 / 2) * Math.sqrt(count * 1);
}
function bigSkewness(bignum, values) {
  let sum2 = bignum(0);
  let sum22 = bignum(0);
  let sum3 = bignum(0);
  let count = 0;
  for (const op of values) {
    const v = op;
    if (!v.isFinite()) return bignum(NaN);
    sum2 = sum2.add(v);
    sum22 = sum22.add(v.mul(v));
    sum3 = sum3.add(v.mul(v).mul(v));
    count++;
  }
  if (count === 0) return bignum(NaN);
  const s2 = sum22.sub(sum2.mul(sum2).div(count)).div(count - 1);
  const s3 = sum3.sub(sum22.mul(sum2).div(count)).div(count - 1);
  return s3.div(s2.pow(3 / 2)).mul(count).sqrt();
}
function mode(values) {
  const counts = {};
  for (const v of values) {
    counts[v] = (counts[v] ?? 0) + 1;
  }
  let max3 = 0;
  let mode2 = NaN;
  for (const v in counts) {
    const c = counts[v];
    if (c > max3) {
      max3 = c;
      mode2 = +v;
    }
  }
  return mode2;
}
function bigMode(bignum, values) {
  const counts = {};
  for (const v of values) {
    counts[v.toString()] = (counts[v.toString()] ?? 0) + 1;
  }
  let max3 = 0;
  let mode2 = bignum(NaN);
  for (const v in counts) {
    const c = counts[v];
    if (c > max3) {
      max3 = c;
      mode2 = bignum(v);
    }
  }
  return mode2;
}
function quartiles(values) {
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  const q1 = median(sorted.slice(0, mid));
  const q2 = median(sorted);
  const q3 = median(sorted.slice(mid));
  return [q1, q2, q3];
}
function bigQuartiles(values) {
  const sorted = [...values].sort((a, b) => a.cmp(b));
  const mid = Math.floor(sorted.length / 2);
  const q1 = bigMedian(sorted.slice(0, mid));
  const q2 = bigMedian(sorted);
  const q3 = bigMedian(sorted.slice(mid));
  return [q1, q2, q3];
}
function interquartileRange(values) {
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  const lower = sorted.slice(0, mid);
  const upper = sorted.slice(mid + 1);
  return median(upper) - median(lower);
}
function bigInterquartileRange(values) {
  const sorted = [...values].sort((a, b) => a.cmp(b));
  const mid = Math.floor(sorted.length / 2);
  const lower = sorted.slice(0, mid);
  const upper = sorted.slice(mid + 1);
  return bigMedian(upper).sub(bigMedian(lower));
}

// src/compute-engine/library/statistics.ts
init_utils5();
init_numerics();
var STATISTICS_LIBRARY = [
  {
    Erf: {
      complexity: 7500,
      signature: "(number) -> number",
      evaluate: (ops, { engine: ce }) => {
        const x = ops[0].re;
        if (!Number.isFinite(x)) return void 0;
        return ce.number(erf(x));
      }
    },
    Erfc: {
      complexity: 7500,
      signature: "(number) -> number",
      evaluate: (ops, { engine: ce }) => {
        const x = ops[0].re;
        if (!Number.isFinite(x)) return void 0;
        return ce.number(1 - erf(x));
      }
    },
    ErfInv: {
      complexity: 7500,
      signature: "(number) -> number",
      evaluate: (ops, { engine: ce }) => {
        const x = ops[0].re;
        if (!Number.isFinite(x)) return void 0;
        return ce.number(erfInv(x));
      }
    }
  },
  {
    // https://towardsdatascience.com/on-average-youre-using-the-wrong-average-geometric-harmonic-means-in-data-analysis-2a703e21ea0?gi=d56d047586c6
    // https://towardsdatascience.com/on-average-youre-using-the-wrong-average-part-ii-b32fcb41527e
    Mean: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      description: "The most frequently occurring value in the collection.",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigMean(engine.bignum.bind(engine), flattenBigScalars(ops)) : mean(flattenScalars(ops))
      )
    },
    Median: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      description: "The most frequently occurring value in the collection.",
      examples: ["Mode([1, 2, 2, 3])  // Returns 2"],
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigMedian(flattenBigScalars(ops)) : median(flattenScalars(ops))
      )
    },
    Variance: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigVariance(engine.bignum.bind(engine), flattenBigScalars(ops)) : variance(flattenScalars(ops))
      )
    },
    PopulationVariance: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigPopulationVariance(
          engine.bignum.bind(engine),
          flattenBigScalars(ops)
        ) : populationVariance(flattenScalars(ops))
      )
    },
    StandardDeviation: {
      complexity: 1200,
      broadcastable: false,
      description: "Sample Standard Deviation of a collection of numbers.",
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigVariance(
          engine.bignum.bind(engine),
          flattenBigScalars(ops)
        ).sqrt() : Math.sqrt(variance(flattenScalars(ops)))
      )
    },
    PopulationStandardDeviation: {
      complexity: 1200,
      broadcastable: false,
      description: "Population Standard Deviation of a collection of numbers.",
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigPopulationVariance(
          engine.bignum.bind(engine),
          flattenBigScalars(ops)
        ).sqrt() : Math.sqrt(populationVariance(flattenScalars(ops)))
      )
    },
    Kurtosis: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigKurtosis(engine.bignum.bind(engine), flattenBigScalars(ops)) : kurtosis(flattenScalars(ops))
      )
    },
    Skewness: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigSkewness(engine.bignum.bind(engine), flattenBigScalars(ops)) : skewness(flattenScalars(ops))
      )
    },
    Mode: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigMode(engine.bignum.bind(engine), flattenBigScalars(ops)) : mode(flattenScalars(ops))
      )
    },
    Quartiles: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> tuple<mid:number, lower:number, upper:number>",
      examples: ["Quartiles([1, 2, 3, 4, 5])  // Returns (3, 2, 4)"],
      evaluate: (ops, { engine }) => {
        const [mid, lower, upper] = (bignumPreferred(engine) ? bigQuartiles(flattenBigScalars(ops)) : quartiles(flattenScalars(ops))).map((v) => engine.number(v));
        return engine.tuple(mid, lower, upper);
      }
    },
    InterquartileRange: {
      complexity: 1200,
      broadcastable: false,
      signature: "((collection|number)+) -> number",
      evaluate: (ops, { engine }) => engine.number(
        bignumPreferred(engine) ? bigInterquartileRange(flattenBigScalars(ops)) : interquartileRange(flattenScalars(ops))
      )
    },
    Histogram: {
      description: "Compute a histogram of the values in a collection. Returns a list of (bin start, count) tuples.",
      complexity: 8200,
      signature: "(collection, integer | list<number>) -> list<tuple<number, integer>>",
      examples: [
        "Histogram([1, 2, 2, 3], 3)  // Returns [(1,1), (1.6667,2), (2.3333,1)]"
      ],
      evaluate: ([xs, binsArg], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const data = Array.from(xs.each()).map((x) => x.re).filter(Number.isFinite);
        if (data.length === 0) return void 0;
        const min3 = Math.min(...data);
        const max3 = Math.max(...data);
        let binEdges;
        if (binsArg?.operator === "List") {
          binEdges = binsArg.ops.map((op) => op.re);
        } else {
          const binCount = toInteger(binsArg);
          if (binCount === null || binCount <= 0) return void 0;
          const binWidth = (max3 - min3) / binCount;
          binEdges = Array.from(
            { length: binCount + 1 },
            (_, i) => min3 + i * binWidth
          );
        }
        const counts = Array(binEdges.length - 1).fill(0);
        for (const x of data) {
          for (let i = 0; i < binEdges.length - 1; i++) {
            if (x >= binEdges[i] && x < binEdges[i + 1]) {
              counts[i]++;
              break;
            }
          }
        }
        return ce.function(
          "List",
          counts.map(
            (count, i) => ce._fn("Tuple", [ce.number(binEdges[i]), ce.number(count)])
          )
        );
      }
    },
    BinCounts: {
      description: "Count the number of elements falling into each bin.",
      complexity: 8200,
      signature: "(collection, integer | list<number>) -> list<number>",
      examples: ["BinCounts([1, 2, 2, 3], 3)  // Returns [1, 2, 1]"],
      evaluate: ([xs, binsArg], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const data = Array.from(xs.each()).map((x) => x.re).filter(Number.isFinite);
        if (data.length === 0) return void 0;
        const min3 = Math.min(...data);
        const max3 = Math.max(...data);
        let binEdges;
        if (binsArg.isCollection) {
          binEdges = [...binsArg.each()].map((op) => op.re);
        } else {
          const binCount = toInteger(binsArg);
          if (binCount === null || binCount <= 0) return void 0;
          const binWidth = (max3 - min3) / binCount;
          binEdges = Array.from(
            { length: binCount + 1 },
            (_, i) => min3 + i * binWidth
          );
        }
        const counts = Array(binEdges.length - 1).fill(0);
        for (const x of data) {
          for (let i = 0; i < binEdges.length - 1; i++) {
            if (x >= binEdges[i] && x < binEdges[i + 1]) {
              counts[i]++;
              break;
            }
          }
        }
        return ce.function(
          "List",
          counts.map((c) => ce.number(c))
        );
      }
    },
    SlidingWindow: {
      description: "Return overlapping sliding windows of fixed size over the collection.",
      complexity: 8200,
      signature: "(collection, integer, integer?) -> list<list>",
      examples: [
        "SlidingWindow([1, 2, 3, 4], 2)  // Returns [[1,2], [2,3], [3,4]]"
      ],
      evaluate: ([xs, winArg, stepArg], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const windowSize = toInteger(winArg);
        const stepSize = stepArg ? toInteger(stepArg) : 1;
        if (windowSize === null || windowSize <= 0 || stepSize === null || stepSize <= 0)
          return void 0;
        const data = Array.from(xs.each());
        const result = [];
        for (let i = 0; i <= data.length - windowSize; i += stepSize) {
          result.push(ce.function("List", data.slice(i, i + windowSize)));
        }
        return ce.function("List", result);
      }
    }
  },
  {
    Sample: {
      description: "Return a random sample of k elements from the collection, without replacement.",
      complexity: 8200,
      signature: "(collection, integer) -> list",
      evaluate: ([xs, nArg], { engine: ce }) => {
        if (!xs.isFiniteCollection) return void 0;
        const k = toInteger(nArg);
        if (k === null || k < 0) return void 0;
        const data = Array.from(xs.each());
        if (k > data.length) return void 0;
        for (let i = data.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [data[i], data[j]] = [data[j], data[i]];
        }
        const sample = data.slice(0, k);
        return ce.function("List", sample);
      }
    }
  }
];
function* flattenArguments(args) {
  for (const arg of args) {
    if (arg.isFiniteCollection) yield* arg.each();
    else yield arg;
  }
}
function* flattenScalars(args) {
  for (const op of flattenArguments(args)) yield op.re;
}
function* flattenBigScalars(args) {
  for (const op of flattenArguments(args))
    yield op.bignumRe ?? op.engine.bignum(op.re);
}

// src/compute-engine/library/trigonometry.ts
init_decimal();
init_utils5();
init_validate();

// src/compute-engine/boxed-expression/trigonometry.ts
init_decimal();
init_apply();
init_utils5();
init_utils3();
var TRIG_IDENTITIES = {
  Sin: [
    [1, "Sin"],
    [1, "Cos"],
    [-1, "Sin"],
    [-1, "Cos"]
  ],
  Cos: [
    [1, "Cos"],
    [-1, "Sin"],
    [-1, "Cos"],
    [1, "Sin"]
  ],
  Sec: [
    [1, "Sec"],
    [-1, "Csc"],
    [-1, "Sec"],
    [1, "Csc"]
  ],
  Csc: [
    [1, "Csc"],
    [1, "Sec"],
    [-1, "Csc"],
    [-1, "Sec"]
  ],
  Tan: [
    [1, "Tan"],
    [-1, "Cot"],
    [1, "Tan"],
    [-1, "Cot"]
  ],
  Cot: [
    [1, "Cot"],
    [-1, "Tan"],
    [1, "Cot"],
    [-1, "Tan"]
  ]
};
var S2 = ["Sqrt", 2];
var S3 = ["Sqrt", 3];
var S5 = ["Sqrt", 5];
var S6 = ["Sqrt", 6];
var CONSTRUCTIBLE_VALUES = [
  [
    [0, 1],
    {
      Sin: 0,
      Cos: 1,
      Tan: 0,
      Cot: "ComplexInfinity",
      Sec: 1,
      Csc: "ComplexInfinity"
    }
  ],
  [
    [1, 12],
    {
      Sin: ["Divide", ["Subtract", S6, S2], 4],
      Cos: ["Divide", ["Add", S6, S2], 4],
      Tan: ["Subtract", 2, S3],
      Cot: ["Add", 2, S3],
      Sec: ["Subtract", S6, S2],
      Csc: ["Add", S6, S2]
    }
  ],
  [
    [1, 10],
    {
      Sin: ["Divide", ["Subtract", S5, 1], 4],
      Cos: ["Divide", ["Sqrt", ["Add", 10, ["Multiply", 2, S5]]], 4],
      Tan: ["Divide", ["Sqrt", ["Subtract", 25, ["Multiply", 10, S5]]], 5],
      Cot: ["Sqrt", ["Add", 5, ["Multiply", 2, S5]]],
      Sec: ["Divide", ["Sqrt", ["Subtract", 50, ["Multiply", 10, S5]]], 5],
      Csc: ["Add", 1, S5]
    }
  ],
  [
    [1, 8],
    {
      Sin: "$\\frac{\\sqrt{2-\\sqrt2}}{2}$",
      Cos: "$\\frac{\\sqrt {2+{\\sqrt {2}}}}{2}$",
      Tan: "$\\sqrt{2} - 1$",
      Cot: "$\\sqrt{2} + 1$",
      Sec: "$\\sqrt{ 4 - 2\\sqrt{2}}$",
      Csc: "$\\sqrt{ 4 + 2\\sqrt{2}}$"
    }
  ],
  [
    [1, 6],
    {
      Sin: "$\\frac{1}{2}$",
      Cos: "$\\frac{\\sqrt{3}}{2}$",
      Tan: "$\\frac{\\sqrt{3}}{3}$",
      Cot: "$\\sqrt{3}$",
      Sec: "$\\frac{2\\sqrt{3}}{3}$",
      Csc: 2
    }
  ],
  [
    [1, 5],
    {
      Sin: "$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$",
      Cos: "$\\frac{1+ \\sqrt{5}} {4}$",
      Tan: "$\\sqrt{5-2\\sqrt5}$",
      Cot: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$",
      Sec: "$\\sqrt{5} - 1$",
      Csc: "$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$"
    }
  ],
  [
    [1, 4],
    {
      Sin: ["Divide", S2, 2],
      Cos: ["Divide", S2, 2],
      Tan: 1,
      Cot: 1,
      Sec: S2,
      Csc: S2
    }
  ],
  [
    [3, 10],
    {
      Sin: "$\\frac{1+ \\sqrt5} {4}$",
      Cos: "$\\frac{\\sqrt{10- 2\\sqrt5}} {4}$",
      Tan: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$",
      Cot: "$\\sqrt{5-2\\sqrt5}$",
      Sec: "$\\frac{\\sqrt{50+10\\sqrt5}} {5}$",
      Csc: "$\\sqrt5-1$"
    }
  ],
  [
    [1, 3],
    {
      Sin: ["Divide", S3, 2],
      // '$\\frac{\\sqrt{3}}{2}$'
      Cos: "Half",
      // '$\\frac{1}{2}$'
      Tan: S3,
      // '$\\sqrt{3}$'
      Cot: ["Divide", S3, 3],
      // '$\\frac{\\sqrt{3}}{3}$'
      Sec: 2,
      Csc: ["Divide", ["Multiply", 2, S3], 3]
      // '$\\frac{2\\sqrt{3}}{3}$'
    }
  ],
  [
    [3, 8],
    {
      Sin: "$\\frac{ \\sqrt{2 + \\sqrt{2}} } {2}$",
      Cos: "$\\frac{ \\sqrt{2 - \\sqrt{2}} } {2}$",
      Tan: "$\\sqrt{2} + 1$",
      Cot: "$\\sqrt{2} - 1$",
      Sec: "$\\sqrt{ 4 + 2 \\sqrt{2} }$",
      Csc: "$\\sqrt{ 4 - 2 \\sqrt{2} }$"
    }
  ],
  [
    [2, 5],
    {
      Sin: "$\\frac{\\sqrt{10+ 2\\sqrt{5}}} {4}$",
      Cos: "$\\frac{\\sqrt{5}-1} {4}$",
      Tan: "$\\sqrt{5+2\\sqrt{5}}$",
      Cot: "$\\frac{\\sqrt{25-10\\sqrt{5}}} {5}$",
      Sec: "$1 + \\sqrt{5}$",
      Csc: "$\\frac{\\sqrt{50-10\\sqrt{5}}} {5}$"
    }
  ],
  [
    [5, 12],
    {
      Sin: "$\\frac{\\sqrt{6} + \\sqrt{2}} {4}$",
      Cos: "$\\frac{ \\sqrt{6} - \\sqrt{2}} {4}$",
      Tan: "$2+\\sqrt{3}$",
      Cot: "$2-\\sqrt{3}$",
      Sec: "$\\sqrt{6}+\\sqrt{2}$",
      Csc: "$\\sqrt{6} - \\sqrt{2}$"
    }
  ],
  [
    [1, 2],
    {
      Sin: 1,
      Cos: 0,
      Tan: "ComplexInfinity",
      Cot: 0,
      Sec: "ComplexInfinity",
      Csc: 1
    }
  ]
];
function applyAngle(angle, fn, bigFn, complexFn) {
  const theta = canonicalAngle(angle)?.N();
  if (theta === void 0) return void 0;
  return apply(theta, fn, bigFn, complexFn);
}
function radiansToAngle(x) {
  if (!x) return x;
  const ce = x.engine;
  const angularUnit = ce.angularUnit;
  if (angularUnit === "rad") return x;
  const theta = x.N().re;
  if (Number.isNaN(theta)) return x;
  if (angularUnit === "deg") return ce.number(theta * (180 / Math.PI));
  if (angularUnit === "grad") return ce.number(theta * (200 / Math.PI));
  if (angularUnit === "turn") return ce.number(theta / (2 * Math.PI));
  return x;
}
function evalTrig(name, op) {
  if (!op) return void 0;
  const ce = op.engine;
  switch (name) {
    case "Arccos":
      return radiansToAngle(
        apply(
          op,
          Math.acos,
          (x) => x.acos(),
          (x) => x.acos()
        )
      );
    case "Arccot":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.atan2(1, x),
          (x) => Decimal.atan2(ce._BIGNUM_ONE, x),
          (x) => x.inverse().atan()
        )
      );
    case "Arccsc":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.asin(1 / x),
          (x) => ce._BIGNUM_ONE.div(x).asin(),
          (x) => x.inverse().asin()
        )
      );
    case "Arcosh":
      return radiansToAngle(
        apply(
          op,
          Math.acosh,
          (x) => x.acosh(),
          (x) => x.acosh()
        )
      );
    case "Arcoth":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.log((1 + x) / (x - 1)) / 2,
          (x) => ce._BIGNUM_ONE.add(x).div(x.sub(ce._BIGNUM_ONE)).log().div(2),
          (x) => ce.complex(1).add(x).div(x.sub(1)).log().div(2)
        )
      );
    case "Arcsch":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.log(1 / x + Math.sqrt(1 / (x * x) + 1)),
          (x) => ce._BIGNUM_ONE.div(x.mul(x)).add(ce._BIGNUM_ONE).sqrt().add(ce._BIGNUM_ONE.div(x)).log(),
          (x) => x.mul(x).inverse().add(1).sqrt().add(x.inverse()).log()
        )
      );
    case "Arcsec":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.acos(1 / x),
          (x) => ce._BIGNUM_ONE.div(x).acos(),
          (x) => x.inverse().acos()
        )
      );
    case "Arcsin":
      return radiansToAngle(
        apply(
          op,
          Math.asin,
          (x) => x.asin(),
          (x) => x.asin()
        )
      );
    case "Arsech":
      return radiansToAngle(
        apply(
          op,
          (x) => Math.log((1 + Math.sqrt(1 - x * x)) / x),
          (x) => ce._BIGNUM_ONE.sub(x.mul(x).add(ce._BIGNUM_ONE).div(x)).log(),
          (x) => ce.complex(1).sub(x.mul(x)).add(1).div(x).log()
        )
      );
    case "Arsinh":
      return radiansToAngle(
        apply(
          op,
          Math.asinh,
          (x) => x.asinh(),
          (x) => x.asinh()
        )
      );
    case "Arctan":
      return radiansToAngle(
        apply(
          op,
          Math.atan,
          (x) => x.atan(),
          (x) => x.atan()
        )
      );
    case "Artanh":
      return radiansToAngle(
        apply(
          op,
          Math.atanh,
          (x) => x.atanh(),
          (x) => x.atanh()
        )
      );
    case "Cos":
      return applyAngle(
        op,
        Math.cos,
        (x) => ce.chop(x.cos()),
        (x) => x.cos()
      );
    case "Cosh":
      return applyAngle(
        op,
        Math.cosh,
        (x) => x.cosh(),
        (x) => x.cosh()
      );
    case "Cot":
      return applyAngle(
        op,
        (x) => 1 / Math.tan(x),
        (x) => ce._BIGNUM_ONE.div(x.tan()),
        (x) => x.tan().inverse()
      );
    case "Coth":
      return applyAngle(
        op,
        (x) => 1 / Math.tanh(x),
        (x) => ce._BIGNUM_ONE.div(x.tanh()),
        (x) => x.tanh().inverse()
      );
    case "Csc":
      return applyAngle(
        op,
        (x) => 1 / Math.sin(x),
        (x) => ce._BIGNUM_ONE.div(x.sin()),
        (x) => x.sin().inverse()
      );
    case "Csch":
      return applyAngle(
        op,
        (x) => 1 / Math.sinh(x),
        (x) => ce._BIGNUM_ONE.div(x.sinh()),
        (x) => x.sinh().inverse()
      );
    case "Sec":
      return applyAngle(
        op,
        (x) => 1 / Math.cos(x),
        (x) => ce._BIGNUM_ONE.div(x.cos()),
        (x) => x.cos().inverse()
      );
    case "Sech":
      return applyAngle(
        op,
        (x) => 1 / Math.cosh(x),
        (x) => ce._BIGNUM_ONE.div(x.cosh()),
        (x) => x.cosh().inverse()
      );
    case "Sin":
      return applyAngle(
        op,
        Math.sin,
        (x) => ce.chop(x.sin()),
        (x) => x.sin()
      );
    case "Sinh":
      return applyAngle(
        op,
        Math.sinh,
        (x) => x.sinh(),
        (x) => x.sinh()
      );
    case "Tan": {
      const result = applyAngle(
        op,
        (x) => {
          const y = Math.tan(x);
          if (y > 1e6 || y < -1e6) return ce.ComplexInfinity;
          return y;
        },
        (x) => {
          const y = x.tan();
          if (y.greaterThan(1e6) || y.lessThan(-1e6)) return ce.ComplexInfinity;
          return y;
        },
        (x) => x.tan()
      );
      return result;
    }
    case "Tanh":
      return applyAngle(
        op,
        Math.tanh,
        (x) => x.tanh(),
        (x) => x.tanh()
      );
  }
  return void 0;
}
function isInverseTrigFunc(name) {
  if (name.startsWith("Ar") && inverseTrigFuncName(name)) return true;
  return false;
}
function inverseTrigFuncName(name) {
  return {
    Sin: "Arcsin",
    Cos: "Arccos",
    Tan: "Arctan",
    Sec: "Arcsec",
    Csc: " Arccsc",
    Sinh: "Arsinh",
    Cosh: "Arcosh",
    Tanh: "Artanh",
    Sech: "Arsech",
    Csch: "Arcsch",
    Arcosh: "Cosh",
    Arccos: "Cos",
    Arccsc: "Csc",
    Arcsch: "Csch",
    // '??': 'Cot',
    // '??': 'Coth',
    Arcsec: "Sec",
    Arcsin: "Sin",
    Arsinh: "Sinh",
    Arctan: "Tan",
    Artanh: "Tanh"
  }[name];
}
function processInverseFunction(ce, xs) {
  if (xs.length !== 1 || !xs[0].isValid) return void 0;
  const expr = xs[0];
  if (expr.operator === "InverseFunction") return expr.op1.canonical;
  const name = expr.symbol;
  if (typeof name !== "string") return void 0;
  const newHead = inverseTrigFuncName(name);
  return newHead ? ce.symbol(newHead) : void 0;
}
function trigFuncParity(name) {
  return name !== "Cos" && name !== "Sec" ? -1 : 1;
}
function constructibleValuesInverse(ce, operator2, x, specialValues) {
  if (!x) return void 0;
  let x_N = x.N().re;
  if (Number.isNaN(x_N)) return void 0;
  const inv_operator = inverseTrigFuncName(operator2);
  const specialInverseValues = ce._cache(
    "constructible-inverse-trigonometric-values-" + operator2,
    () => {
      const cache = [];
      for (const [[n, d], value] of specialValues) {
        const r = value[inv_operator];
        if (r === void 0) continue;
        const rn = r.N().re;
        if (Number.isNaN(rn)) continue;
        cache.push([
          [r, rn],
          [n, d]
        ]);
      }
      return cache;
    },
    (cache) => {
      for (const [[match_arg, match_arg_N], [n, d]] of cache) {
        match_arg.reset();
      }
      return cache;
    }
  );
  let quadrant3 = 0;
  if (x_N < 0) {
    quadrant3 = trigFuncParity(inv_operator) == -1 ? -1 : 1;
    x_N = -x_N;
    x = x.neg();
  }
  for (const [[match_arg, match_arg_N], [n, d]] of specialInverseValues) {
    if (ce.chop(x_N - match_arg_N) === 0) {
      let theta = ce.Pi.mul(n).div(d);
      if (quadrant3 == -1) theta = theta.neg();
      else if (quadrant3 == 1) theta = ce.Pi.sub(theta);
      return theta.evaluate();
    }
  }
  return void 0;
}
function trigSign(operator2, x) {
  const [q, pos] = quadrant2(x);
  if (q === void 0) return void 0;
  if (pos !== void 0) {
    if ((operator2 === "Sin" || operator2 === "Tan") && (pos === 0 || pos === 2))
      return "zero";
    if ((operator2 === "Cos" || operator2 === "Cot") && (pos === 1 || pos === 3))
      return "zero";
  }
  return {
    Sin: ["positive", "positive", "negative", "negative"],
    Cos: ["positive", "negative", "negative", "positive"],
    Sec: ["positive", "negative", "negative", "positive"],
    Csc: ["positive", "positive", "negative", "negative"],
    Tan: ["positive", "negative", "positive", "negative"],
    Cot: ["positive", "negative", "positive", "negative"]
  }[operator2]?.[q];
}
function isConstructible(x) {
  return ["Sin", "Cos", "Tan", "Csc", "Sec", "Cot"].includes(
    typeof x === "string" ? x : x.operator
  );
}
function constructibleValues(operator2, x) {
  if (!x || !isConstructible(operator2)) return void 0;
  const ce = x.engine;
  x = x.N();
  if (x.im !== 0) return void 0;
  let theta = x.re;
  if (Number.isNaN(theta)) return void 0;
  const specialValues = ce._cache(
    "constructible-trigonometric-values",
    () => {
      return CONSTRUCTIBLE_VALUES.map(([val, results]) => [
        val,
        Object.fromEntries(
          Object.entries(results).map(([op, r]) => [
            op,
            (ce.parse(asLatexString(r)) ?? ce.box(r)).simplify()
          ])
        )
      ]);
    },
    (cache) => {
      for (const [_k, v] of cache) {
        for (const v2 of Object.values(v)) v2.reset();
      }
      return cache;
    }
  );
  if (isInverseTrigFunc(operator2))
    return constructibleValuesInverse(ce, operator2, x, specialValues);
  const angularUnit = ce.angularUnit;
  if (angularUnit !== "rad") {
    if (angularUnit === "deg") theta *= Math.PI / 180;
    if (angularUnit === "grad") theta *= Math.PI / 200;
    if (angularUnit === "turn") theta *= 2 * Math.PI;
  }
  const identitySign = trigFuncParity(operator2) == -1 ? Math.sign(theta) : 1;
  theta = Math.abs(theta % (2 * Math.PI));
  const quadrant3 = Math.floor(theta * 2 / Math.PI);
  theta = theta % (Math.PI / 2);
  let sign3;
  [sign3, operator2] = TRIG_IDENTITIES[operator2]?.[quadrant3] ?? [1, operator2];
  for (const [[n, d], value] of specialValues) {
    const r = value[operator2];
    if (r && Math.abs(theta - Math.PI * n / d) <= 1e-12) {
      if (r.symbol === "ComplexInfinity") return r;
      return identitySign * sign3 < 0 ? r.neg() : r;
    }
  }
  return void 0;
}
function quadrant2(theta) {
  if (!theta.isValid || !theta.isNumberLiteral) return [void 0, void 0];
  if (theta.im !== 0) return [void 0, void 0];
  const t = theta.re;
  if (isNaN(t)) return [void 0, void 0];
  const normalizedTheta = (t % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
  if (Math.abs(normalizedTheta) < 1e-12) return [1, 0];
  if (Math.abs(normalizedTheta - Math.PI / 2) < 1e-12) return [2, 1];
  if (Math.abs(normalizedTheta - Math.PI) < 1e-12) return [3, 2];
  if (Math.abs(normalizedTheta - 3 * Math.PI / 2) < 1e-12) return [4, 3];
  return [Math.floor(normalizedTheta / (Math.PI / 2)) + 1, void 0];
}

// src/compute-engine/library/trigonometry.ts
init_apply();
init_rationals();
var TRIGONOMETRY_LIBRARY = [
  {
    //
    // Constants
    //
    Pi: {
      type: "finite_real",
      isConstant: true,
      holdUntil: "N",
      wikidata: "Q167",
      value: (engine) => engine.number(bignumPreferred(engine) ? engine._BIGNUM_PI : Math.PI)
    }
  },
  {
    Degrees: {
      /* = Pi / 180 */
      signature: "(real) -> real",
      canonical: (ops, { engine }) => {
        const ce = engine;
        if (ce.angularUnit === "deg") return ops[0];
        if (ops.length !== 1) return ce._fn("Degrees", ops);
        const arg = ops[0];
        if (arg.numericValue === null || !arg.isValid)
          return ce._fn("Degrees", ops);
        let fArg = arg.re;
        if (Number.isNaN(fArg)) return arg.mul(ce.Pi).div(180);
        fArg = fArg % 360;
        if (fArg < 0) fArg += 360;
        if (Number.isInteger(fArg)) {
          const fRadians = reducedRational([fArg, 180]);
          if (fRadians[0] === 0) return ce.Zero;
          if (fRadians[0] === 1 && fRadians[1] === 1) return ce.Pi;
          if (fRadians[0] === 1) return ce.Pi.div(fRadians[1]);
          return ce.number(fRadians).mul(ce.Pi);
        }
        return ce.number(fArg).div(180).mul(ce.Pi);
      },
      evaluate: (ops, options) => {
        if (options.engine.angularUnit === "deg") return ops[0];
        return ops[0].mul(options.engine.Pi.div(180)).evaluate(options);
      }
    },
    // Hypot: sqrt(x*x + y*y)
    Hypot: {
      broadcastable: true,
      signature: "(real, real) -> real",
      sgn: () => "non-negative",
      evaluate: ([x, y], { engine }) => engine.box(["Sqrt", ["Add", ["Square", x], ["Square", y]]])
    },
    // The definition of other trig functions may rely on Sin, so it is defined
    // first in this preliminary section
    Sin: trigFunction("Sin", 5e3)
  },
  {
    //
    // Basic trigonometric function
    // (may be used in the definition of other functions below)
    //
    Arctan: {
      wikidata: "Q2257242",
      complexity: 5200,
      broadcastable: true,
      signature: "(number) -> finite_real",
      sgn: ([x]) => trigSign("Arctan", x),
      evaluate: ([x], { numericApproximation }) => numericApproximation ? evalTrig("Arctan", x) : constructibleValues("Arctan", x) ?? evalTrig("Arctan", x)
    },
    Arctan2: {
      wikidata: "Q776598",
      complexity: 5200,
      broadcastable: true,
      signature: "(y:number, x: number) -> real",
      evaluate: ([y, x], { engine: ce, numericApproximation }) => {
        if (numericApproximation)
          return apply2(y, x, Math.atan2, (a, b) => Decimal.atan2(a, b));
        if (y.isFinite === false && x.isFinite === false) return ce.NaN;
        if (y.is(0) && x.is(0)) return ce.Zero;
        if (x.isFinite === false) return x.isPositive ? ce.Zero : ce.Pi;
        if (y.isFinite === false)
          return y.isPositive ? ce.Pi.div(2) : ce.Pi.div(-2);
        if (y.is(0)) return x.isPositive ? ce.Zero : ce.Pi;
        return ce.function("Arctan", [y.div(x)]).evaluate();
      }
    },
    Cos: trigFunction("Cos", 5050),
    Tan: trigFunction("Tan", 5100)
    /* converts (x, y) -> (radius, angle) */
    // ToPolarCoordinates: {
    //   domain: 'Functions',
    //   outputDomain: ['TupleOf', 'RealNumbers', 'RealNumbers'],
    // }
  },
  //
  // Functions defined using arithmetic functions or basic
  // trigonometric functions above
  //
  {
    // Note: we use the ISO 80000-2 standard names for inverse hyperbolic
    // functions: Arsinh, Arcosh, Artanh, etc. (not Arcsinh, Arccosh, Arctanh)
    // The "ar" prefix stands for "area", which is mathematically correct
    // since these functions relate to areas on a hyperbola, not arc lengths.
    Arcosh: trigFunction("Arcosh", 6200),
    Arcsin: trigFunction("Arcsin", 5500),
    Arsinh: trigFunction("Arsinh", 6100),
    Artanh: trigFunction("Artanh", 6300),
    Cosh: trigFunction("Cosh", 6050),
    Cot: trigFunction("Cot", 5600),
    Csc: trigFunction("Csc", 5600, "Cosecant"),
    Sec: trigFunction("Sec", 5600, "Secant, inverse of cosine"),
    Sinh: trigFunction("Sinh", 6e3),
    /** = sin(z/2)^2 = (1 - cos z) / 2*/
    Haversine: {
      wikidata: "Q2528380",
      broadcastable: true,
      signature: "(real) -> number",
      evaluate: ([z], { engine }) => engine.box(["Divide", ["Subtract", 1, ["Cos", z]], 2])
    },
    /** = 2 * Arcsin(Sqrt(z)) */
    InverseHaversine: {
      //  Range ['Interval', [['Negate', 'Pi'], 'Pi'],
      broadcastable: true,
      signature: "(real) -> real",
      evaluate: ([x], { engine }) => engine.box(["Multiply", 2, ["Arcsin", ["Sqrt", x]]])
    }
  },
  {
    Csch: trigFunction("Csch", 6200, "Hyperbolic cosecant"),
    Sech: trigFunction("Sech", 6200, "Hyperbolic secant"),
    Tanh: trigFunction("Tanh", 6200, "Hyperbolic tangent")
  },
  {
    Arccos: trigFunction("Arccos", 5550),
    Arccot: trigFunction("Arccot", 5650),
    Arcoth: trigFunction("Arcoth", 6350),
    Arcsch: trigFunction("Arcsch", 6250),
    Arcsec: trigFunction("Arcsec", 5650),
    Arsech: trigFunction("Arsech", 6250),
    Arccsc: trigFunction("Arccsc", 5650),
    Coth: trigFunction("Coth", 6300),
    /* converts (radius, angle) -> (x, y) */
    // FromPolarCoordinates: {
    //   domain: 'Function',
    //   outputDomain: ['TupleOf', 'RealNumbers', 'RealNumbers'],
    // },
    InverseFunction: {
      lazy: true,
      signature: "(function) -> function",
      canonical: (ops, { engine }) => {
        ops = checkArity(engine, ops, 1);
        return processInverseFunction(engine, ops) ?? engine._fn("InverseFunction", ops);
      },
      evaluate: (ops, { engine: ce }) => processInverseFunction(ce, ops)
    }
  }
];
function trigFunction(operator2, complexity, description) {
  return {
    complexity,
    description,
    broadcastable: true,
    signature: "(number) -> number",
    sgn: ([x]) => trigSign(operator2, x),
    evaluate: ([x], { numericApproximation }) => {
      if (numericApproximation) return evalTrig(operator2, x);
      const a = constructibleValues(operator2, x);
      return a ?? evalTrig(operator2, x);
    }
  };
}

// src/compute-engine/library/library.ts
init_boxed_value_definition();
init_symbols();
init_utils5();
init_boxed_operator_definition();
function getStandardLibrary(categories) {
  if (categories === "all") {
    return getStandardLibrary([
      "core",
      "control-structures",
      // If, Block, Loop
      "logic",
      "collections",
      // Dictionary, List, Sets
      "relop",
      "numeric",
      "arithmetic",
      "trigonometry",
      "algebra",
      "calculus",
      // D, Integerate
      "polynomials",
      "combinatorics",
      "number-theory",
      "linear-algebra",
      "statistics",
      "dimensions",
      "units",
      "physics",
      "other"
    ]);
  } else if (typeof categories === "string") categories = [categories];
  const result = [];
  for (const category of categories) {
    const dict = LIBRARIES[category];
    if (!dict) throw Error(`Unknown library category ${category}`);
    if (Array.isArray(dict)) result.push(...dict);
    else result.push(dict);
  }
  return Object.freeze(result);
}
var LIBRARIES = {
  "algebra": [],
  // 'algebra': [
  //   // polynomial([0, 2, 0, 4]:list, x:symbol) -> 2x + 4x^3
  //   // polynomial(2x + 4x^3, x) -> {0, 2, 0, 4}
  //   // rational(2x + 4x^3, {3, 1}, x) -> (2x + 4x^3)/(3+x)
  //   // https://reference.wolfram.com/language/tutorial/AlgebraicCalculations.html
  //   // simplify-trig (macsyma)
  //   //  - trigReduce, trigExpand, trigFactor, trigToExp (mathematica)
  //   // Mathematica:
  //   // - distribute -> (a+b)(c+d) -> ac+ ad+ bc+ bd (doesn't have to be multiply,
  //   // f(a+b, c+d) -> f(a, c) + f(a, d) + f(b, c) + f(b, d)
  //   // -- distribute(expr, over=add, with=multiply)
  //   // https://reference.wolfram.com/language/ref/Distribute.html
  //   // - expand, expand-all
  //   // - factor
  //   // - simplify
  // ],
  "arithmetic": [...ARITHMETIC_LIBRARY, ...COMPLEX_LIBRARY],
  "calculus": CALCULUS_LIBRARY,
  "collections": [SETS_LIBRARY, COLLECTIONS_LIBRARY],
  "combinatorics": COMBINATORICS_LIBRARY,
  "control-structures": CONTROL_STRUCTURES_LIBRARY,
  "core": CORE_LIBRARY,
  "dimensions": [],
  // @todo // volume, speed, area
  "domains": [],
  // 'domains': getDomainsDictionary(),
  "linear-algebra": LINEAR_ALGEBRA_LIBRARY,
  "logic": [LOGIC_LIBRARY, LOGIC_FUNCTION_LIBRARY],
  "number-theory": NUMBER_THEORY_LIBRARY,
  "numeric": [],
  // @todo   // 'numeric': [
  "other": [],
  "relop": RELOP_LIBRARY,
  "polynomials": POLYNOMIALS_LIBRARY,
  "physics": {
    Mu0: {
      description: "Vaccum permeability",
      isConstant: true,
      wikidata: "Q1515261",
      type: "real",
      value: 125663706212e-17
      // unit: ['Divide', 'N', ['Square', 'A']],
    }
  },
  "statistics": STATISTICS_LIBRARY,
  "trigonometry": TRIGONOMETRY_LIBRARY,
  "units": []
  // @todo see also "dimensions"
};
function validateDefinitionName(name) {
  name = name.normalize();
  if (isValidSymbol(name)) return name;
  throw new Error(`Invalid definition name "${name}": ${validateSymbol(name)}`);
}
function setSymbolDefinitions(engine, table) {
  const bindings = engine.context.lexicalScope.bindings;
  if (!engine.strict) {
  }
  for (let [name, entry] of Object.entries(table)) {
    try {
      name = validateDefinitionName(name);
      if (isValidOperatorDef(entry)) {
        try {
          if (bindings.has(name))
            throw new Error(
              `Duplicate operator definition: "${name}"
${JSON.stringify(
                bindings.get(name),
                void 0,
                4
              )}
`
            );
          bindings.set(name, {
            operator: new _BoxedOperatorDefinition(engine, name, entry)
          });
        } catch (e) {
          console.error(
            [
              `
Error in operator definition`,
              JSON.stringify(entry, void 0, 4),
              "",
              e.message
            ].join("\n|   ") + "\n"
          );
        }
      } else if (isValidValueDef(entry)) {
        try {
          if (bindings.has(name))
            throw new Error(`The symbol "${name}" is already defined`);
          bindings.set(name, {
            value: new _BoxedValueDefinition(engine, name, entry)
          });
        } catch (e) {
          console.error(
            [
              `
Error in value definition of "${name}"`,
              "",
              JSON.stringify(entry, void 0, 4),
              "",
              e.message
            ].join("\n|   ")
          );
        }
      } else {
        const def = new _BoxedValueDefinition(engine, name, {
          value: engine.box(entry)
        });
        bindings.set(name, { value: def });
      }
    } catch (e) {
      console.error(
        [
          `
Error in definition of "${name}"`,
          "",
          JSON.stringify(entry, void 0, 4),
          "",
          e.message
        ].join("\n|   ") + "\n"
      );
    }
  }
}

// src/compute-engine/cost-function.ts
function numericCostFunction(n) {
  if (typeof n === "number") {
    if (n === 0) return 1;
    if (Number.isInteger(n))
      return Math.floor(Math.log2(Math.abs(n)) / Math.log2(10)) + (n > 0 ? 1 : 2);
    return 2;
  }
  if (n.isZero) return 1;
  if (n.im !== 0)
    return numericCostFunction(n.re) + numericCostFunction(n.im) + 1;
  return numericCostFunction(n.re);
}
function costFunction(expr) {
  const expLogSepCost = (() => {
    if (expr.operator !== "Multiply" || !expr.ops || expr.ops.length !== 2)
      return null;
    const match2 = (xPow, ePow) => {
      if (ePow.operator !== "Power") return null;
      if (ePow.op1?.symbol !== "ExponentialE") return null;
      if (!ePow.op2) return null;
      if (xPow.operator !== "Power") return null;
      if (!xPow.op1 || !xPow.op2) return null;
      const exponent = xPow.op2;
      if (exponent.operator !== "Divide") return null;
      if (exponent.op1?.is(1) !== true) return null;
      const denom = exponent.op2;
      if (denom?.operator !== "Ln") return null;
      if (denom.op1?.is(10) !== true) return null;
      return { xBase: xPow.op1, eExp: ePow.op2 };
    };
    const [a, b] = expr.ops;
    const m = match2(a, b) ?? match2(b, a);
    if (!m) return null;
    return 12 + costFunction(m.xBase) + costFunction(m.eExp);
  })();
  if (expLogSepCost !== null) return expLogSepCost;
  if (expr.symbol) return 1;
  if (expr.isNumberLiteral) return numericCostFunction(expr.numericValue);
  const name = expr.operator;
  let nameCost = 2;
  if (["Add"].includes(name)) nameCost = 3;
  else if (["Subtract", "Negate"].includes(name)) nameCost = 4;
  else if (name === "Sqrt") {
    const arg = expr.ops?.[0];
    if (arg?.operator === "Multiply" && arg.ops) {
      for (const factor3 of arg.ops) {
        if (factor3.operator === "Power" && factor3.op2?.isEven === true) {
          return 5 + costFunction(arg) + 6;
        }
      }
    }
    if (arg?.operator === "Power" && arg.op2?.isEven === true) {
      return 5 + costFunction(arg) + 6;
    }
    if (arg?.operator === "Power" && arg.op2?.isOdd === true && arg.op2?.isInteger === true) {
      const exp3 = arg.op2;
      const n = exp3.numericValue;
      if (typeof n === "number" && n > 1) {
        return 5 + costFunction(arg) + 10;
      }
    }
    nameCost = 5;
  } else if (["Square", "Abs"].includes(name)) nameCost = 5;
  else if (name === "Power") {
    const base = expr.ops[0];
    const exp3 = expr.ops[1];
    const expCost = costFunction(exp3);
    if (base.operator === "Negate") {
      return expCost + 4;
    }
    if (base.operator === "Multiply" && base.ops) {
      const hasNegativeCoef = base.ops.some(
        (f) => f.isNumberLiteral && f.isNegative === true
      );
      if (hasNegativeCoef && exp3.isRational === true && !exp3.isInteger) {
        return expCost + costFunction(base) + 15;
      }
      return expCost + costFunction(base);
    }
    return expCost;
  } else if (name === "Root") {
    nameCost = 5;
  } else if (["Multiply"].includes(name)) {
    const ops = expr.ops ?? [];
    if (ops.length === 2 && ops[0].isNumberLiteral) {
      const coef = ops[0].numericValue;
      let isSmallCoef = false;
      if (typeof coef === "number") {
        isSmallCoef = Number.isInteger(coef) && Math.abs(coef) <= 10;
      } else if (coef) {
        const type2 = coef.type;
        if (type2 === "finite_integer" && Math.abs(coef.re) <= 10) {
          isSmallCoef = true;
        } else if (type2 === "finite_rational") {
          isSmallCoef = true;
        }
      }
      if (isSmallCoef) {
        const secondOp = ops[1].operator;
        if (["Ln", "Log", "Lb"].includes(secondOp)) {
          return 2 + costFunction(ops[1]);
        }
        return 3 + costFunction(ops[1]);
      }
    }
    nameCost = 7;
  } else if (["Divide"].includes(name)) nameCost = 8;
  else if (["Ln", "Exp", "Log", "Lb"].includes(name)) nameCost = 9;
  else if (["Cos", "Sin", "Tan"].includes(name)) nameCost = 10;
  else nameCost = 11;
  return nameCost + (expr.ops?.reduce((acc, x) => acc + costFunction(x), 0) ?? 0);
}
var DEFAULT_COST_FUNCTION = costFunction;

// src/compute-engine/index.ts
init_rationals();
init_types2();
init_exact_numeric_value();
init_big_numeric_value();
init_machine_numeric_value();

// src/compute-engine/boxed-expression/box.ts
init_complex();
init_decimal();
init_utils2();
init_symbols();
init_rationals();
init_numerics();
init_numeric_bignum();
init_arithmetic_add();
init_arithmetic_mul_div();
init_types2();
init_arithmetic_power();
init_abstract_boxed_expression();

// src/compute-engine/boxed-expression/boxed-function.ts
init_collection_utils();
init_boxed_tensor();
init_boxed_type();
init_parse();
init_subtype();
init_utils();
init_types2();
init_solve();

// src/compute-engine/boxed-expression/solve-linear-system.ts
init_polynomials();
init_solve();
function isLinearInVariables(expr, variables) {
  const countVariables = (e) => {
    let count = 0;
    for (const v of variables) {
      if (e.symbol === v) return 1;
      if (e.has(v)) count++;
    }
    return count;
  };
  const checkTerm = (term) => {
    const varCount = countVariables(term);
    if (varCount === 0) return true;
    if (term.symbol && variables.includes(term.symbol)) return true;
    if (term.operator === "Multiply") {
      let varFactorCount = 0;
      for (const factor3 of term.ops) {
        if (countVariables(factor3) > 0) {
          varFactorCount++;
          if (countVariables(factor3) > 1) return false;
          if (!factor3.symbol && factor3.has(variables[0])) {
            for (const v of variables) {
              if (factor3.has(v) && polynomialDegree(factor3, v) > 1)
                return false;
            }
          }
        }
      }
      return varFactorCount <= 1;
    }
    if (term.operator === "Add") {
      return term.ops.every((t) => checkTerm(t));
    }
    if (term.operator === "Negate") {
      return checkTerm(term.op1);
    }
    if (term.operator === "Subtract") {
      return checkTerm(term.op1) && checkTerm(term.op2);
    }
    return varCount <= 1;
  };
  return checkTerm(expr);
}
function solveLinearSystem(equations, variables) {
  if (equations.length === 0 || variables.length === 0) return null;
  const ce = equations[0].engine;
  const n = variables.length;
  const m = equations.length;
  const matrix = buildAugmentedMatrix(equations, variables, ce);
  if (!matrix) return null;
  const { A, b } = matrix;
  if (m < n) {
    return solveParametric(A, b, variables, ce);
  }
  const solutions = gaussianElimination(A, b, n, ce);
  if (!solutions) return null;
  const result = {};
  for (let i = 0; i < n; i++) {
    result[variables[i]] = solutions[i].simplify();
  }
  return result;
}
function extractLinearCoefficients(equation, variables) {
  const ce = equation.engine;
  let expr;
  if (equation.operator === "Equal") {
    const lhs = equation.op1;
    const rhs = equation.op2;
    expr = lhs.sub(rhs).expand();
  } else {
    expr = equation.expand();
  }
  for (const v of variables) {
    const deg = polynomialDegree(expr, v);
    if (deg < 0 || deg > 1) return null;
  }
  if (!isLinearInVariables(expr, variables)) return null;
  const coefficients = [];
  for (const v of variables) {
    const coef = extractCoefficient(expr, v, ce);
    if (coef === null) return null;
    coefficients.push(coef);
  }
  const constant = extractConstantTerm(expr, variables, ce).neg();
  return { coefficients, constant };
}
function extractCoefficient(expr, variable, ce) {
  if (!expr.has(variable)) return ce.Zero;
  if (expr.symbol === variable) return ce.One;
  if (expr.operator === "Negate") {
    const inner = extractCoefficient(expr.op1, variable, ce);
    return inner?.neg() ?? null;
  }
  if (expr.operator === "Multiply") {
    const ops = expr.ops;
    let coef = ce.One;
    let foundVar = false;
    for (const op of ops) {
      if (op.symbol === variable) {
        if (foundVar) return null;
        foundVar = true;
      } else if (op.has(variable)) {
        return null;
      } else {
        coef = coef.mul(op);
      }
    }
    return foundVar ? coef : ce.Zero;
  }
  if (expr.operator === "Add") {
    let totalCoef = ce.Zero;
    for (const term of expr.ops) {
      const termCoef = extractCoefficient(term, variable, ce);
      if (termCoef === null) return null;
      totalCoef = totalCoef.add(termCoef);
    }
    return totalCoef;
  }
  if (expr.operator === "Subtract") {
    const leftCoef = extractCoefficient(expr.op1, variable, ce);
    const rightCoef = extractCoefficient(expr.op2, variable, ce);
    if (leftCoef === null || rightCoef === null) return null;
    return leftCoef.sub(rightCoef);
  }
  if (expr.has(variable)) {
    return null;
  }
  return ce.Zero;
}
function extractConstantTerm(expr, variables, ce) {
  const hasAnyVar = variables.some((v) => expr.has(v));
  if (!hasAnyVar) return expr;
  if (expr.operator === "Add") {
    let constant = ce.Zero;
    for (const term of expr.ops) {
      const termHasVar = variables.some((v) => term.has(v));
      if (!termHasVar) {
        constant = constant.add(term);
      }
    }
    return constant;
  }
  if (expr.operator === "Negate") {
    return extractConstantTerm(expr.op1, variables, ce).neg();
  }
  if (expr.operator === "Subtract") {
    const leftConst = extractConstantTerm(expr.op1, variables, ce);
    const rightConst = extractConstantTerm(expr.op2, variables, ce);
    return leftConst.sub(rightConst);
  }
  return ce.Zero;
}
function buildAugmentedMatrix(equations, variables, ce) {
  const m = equations.length;
  const n = variables.length;
  const A = [];
  const b = [];
  for (let i = 0; i < m; i++) {
    const result = extractLinearCoefficients(equations[i], variables);
    if (!result) return null;
    A.push(result.coefficients);
    b.push(result.constant);
  }
  return { A, b };
}
function gaussianElimination(A, b, n, ce) {
  const m = A.length;
  const aug = [];
  for (let i = 0; i < m; i++) {
    aug.push([...A[i], b[i]]);
  }
  for (let col = 0; col < n; col++) {
    let maxRow = col;
    for (let row = col + 1; row < m; row++) {
      const cmp2 = compareAbsoluteValues(aug[row]?.[col], aug[maxRow]?.[col]);
      if (cmp2 === 1) {
        maxRow = row;
      }
    }
    if (isEffectivelyZero(aug[maxRow]?.[col])) {
      return null;
    }
    if (maxRow !== col) {
      [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];
    }
    const pivot = aug[col][col];
    for (let row = col + 1; row < m; row++) {
      const factor3 = aug[row][col].div(pivot);
      aug[row][col] = ce.Zero;
      for (let j = col + 1; j <= n; j++) {
        aug[row][j] = aug[row][j].sub(factor3.mul(aug[col][j]));
      }
    }
  }
  for (let row = n; row < m; row++) {
    const lastCol = aug[row][n];
    if (!isEffectivelyZero(lastCol)) {
      let allZero = true;
      for (let col = 0; col < n; col++) {
        if (!isEffectivelyZero(aug[row][col])) {
          allZero = false;
          break;
        }
      }
      if (allZero) {
        return null;
      }
    }
  }
  const solution = new Array(n);
  for (let i = n - 1; i >= 0; i--) {
    let sum2 = aug[i][n];
    for (let j = i + 1; j < n; j++) {
      sum2 = sum2.sub(aug[i][j].mul(solution[j]));
    }
    solution[i] = sum2.div(aug[i][i]);
  }
  return solution;
}
function solveParametric(A, b, variables, ce) {
  const m = A.length;
  const n = variables.length;
  const aug = [];
  for (let i = 0; i < m; i++) {
    aug.push([...A[i], b[i]]);
  }
  const pivotCol = [];
  const isPivotCol = new Array(n).fill(false);
  let currentRow = 0;
  for (let col = 0; col < n && currentRow < m; col++) {
    let maxRow = currentRow;
    for (let row = currentRow + 1; row < m; row++) {
      const cmp2 = compareAbsoluteValues(aug[row]?.[col], aug[maxRow]?.[col]);
      if (cmp2 === 1) {
        maxRow = row;
      }
    }
    if (isEffectivelyZero(aug[maxRow]?.[col])) {
      continue;
    }
    if (maxRow !== currentRow) {
      [aug[currentRow], aug[maxRow]] = [aug[maxRow], aug[currentRow]];
    }
    pivotCol[currentRow] = col;
    isPivotCol[col] = true;
    const pivot = aug[currentRow][col];
    for (let row = currentRow + 1; row < m; row++) {
      if (!isEffectivelyZero(aug[row][col])) {
        const factor3 = aug[row][col].div(pivot);
        aug[row][col] = ce.Zero;
        for (let j = col + 1; j <= n; j++) {
          aug[row][j] = aug[row][j].sub(factor3.mul(aug[currentRow][j]));
        }
      }
    }
    currentRow++;
  }
  const rank2 = currentRow;
  for (let row = 0; row < m; row++) {
    let allZero = true;
    for (let col = 0; col < n; col++) {
      if (!isEffectivelyZero(aug[row][col])) {
        allZero = false;
        break;
      }
    }
    if (allZero && !isEffectivelyZero(aug[row][n])) {
      return null;
    }
  }
  const freeVars = [];
  for (let col = 0; col < n; col++) {
    if (!isPivotCol[col]) {
      freeVars.push(col);
    }
  }
  const solution = new Array(n);
  for (let col = 0; col < n; col++) {
    if (!isPivotCol[col]) {
      solution[col] = ce.symbol(variables[col]);
    }
  }
  for (let row = rank2 - 1; row >= 0; row--) {
    const col = pivotCol[row];
    if (col === void 0) continue;
    let expr = aug[row][n];
    for (let j = col + 1; j < n; j++) {
      if (!isEffectivelyZero(aug[row][j])) {
        expr = expr.sub(aug[row][j].mul(solution[j]));
      }
    }
    solution[col] = expr.div(aug[row][col]).simplify();
  }
  const result = {};
  for (let i = 0; i < n; i++) {
    result[variables[i]] = solution[i];
  }
  return result;
}
function compareAbsoluteValues(a, b) {
  if (!a || !b) return void 0;
  const absA = a.abs();
  const absB = b.abs();
  const aNum = absA.numericValue;
  const bNum = absB.numericValue;
  if (aNum !== null && bNum !== null) {
    if (typeof aNum === "number" && typeof bNum === "number") {
      if (aNum === bNum) return 0;
      return aNum > bNum ? 1 : -1;
    }
    if (typeof aNum === "object" && "re" in aNum) {
      const aRe = aNum.re;
      const bRe = typeof bNum === "number" ? bNum : bNum.re;
      if (aRe === bRe) return 0;
      return aRe > bRe ? 1 : -1;
    }
    if (typeof bNum === "object" && "re" in bNum) {
      const aRe = typeof aNum === "number" ? aNum : aNum.re;
      const bRe = bNum.re;
      if (aRe === bRe) return 0;
      return aRe > bRe ? 1 : -1;
    }
  }
  const aVal = absA.N().numericValue;
  const bVal = absB.N().numericValue;
  if (aVal === null || bVal === null) return void 0;
  const aReal = typeof aVal === "number" ? aVal : aVal.re ?? aVal;
  const bReal = typeof bVal === "number" ? bVal : bVal.re ?? bVal;
  if (typeof aReal !== "number" || typeof bReal !== "number") return void 0;
  if (isNaN(aReal) || isNaN(bReal)) return void 0;
  if (aReal === bReal) return 0;
  return aReal > bReal ? 1 : -1;
}
function isEffectivelyZero(expr) {
  if (!expr) return true;
  if (expr.is(0)) return true;
  const simplified = expr.simplify();
  if (simplified.is(0)) return true;
  const numVal = expr.N().numericValue;
  if (numVal === null) return false;
  const re = typeof numVal === "number" ? numVal : numVal.re;
  if (typeof re === "number" && Math.abs(re) < 1e-14) return true;
  return false;
}
function solvePolynomialSystem(equations, variables) {
  if (equations.length !== 2 || variables.length !== 2) return null;
  const ce = equations[0].engine;
  const [x, y] = variables;
  const normalized = equations.map((eq2) => {
    if (eq2.operator === "Equal") {
      return eq2.op1.sub(eq2.op2).expand().simplify();
    }
    return eq2.expand().simplify();
  });
  const productSumResult = tryProductSumPattern(normalized, x, y, ce);
  if (productSumResult) return productSumResult;
  const substitutionResult = trySubstitutionMethod(normalized, x, y, ce);
  if (substitutionResult) return substitutionResult;
  return null;
}
function tryProductSumPattern(equations, x, y, ce) {
  let productEq = null;
  let sumEq = null;
  let product = null;
  let sum2 = null;
  for (const eq2 of equations) {
    const productInfo = extractProductEquation(eq2, x, y, ce);
    if (productInfo) {
      productEq = eq2;
      product = productInfo.product;
      continue;
    }
    const sumInfo = extractSumEquation(eq2, x, y, ce);
    if (sumInfo) {
      sumEq = eq2;
      sum2 = sumInfo.sum;
      continue;
    }
  }
  if (!productEq || !sumEq || !product || !sum2) return null;
  const t = "_t";
  const quadratic = ce.box(["Add", ["Square", t], ["Negate", ["Multiply", sum2, t]], product]).simplify();
  const roots = findUnivariateRoots(quadratic, t);
  if (roots.length === 0) return null;
  const realRoots = filterRealRoots(roots);
  if (realRoots.length === 0) return null;
  const solutions = [];
  if (realRoots.length === 1) {
    const val = realRoots[0].simplify();
    solutions.push({ [x]: val, [y]: val });
  } else if (realRoots.length >= 2) {
    const r1 = realRoots[0].simplify();
    const r2 = realRoots[1].simplify();
    solutions.push({ [x]: r1, [y]: r2 });
    if (!r1.isSame(r2)) {
      solutions.push({ [x]: r2, [y]: r1 });
    }
  }
  return solutions.length > 0 ? solutions : null;
}
function extractProductEquation(eq2, x, y, ce) {
  if (!eq2.has(x) || !eq2.has(y)) return null;
  const degX = polynomialDegree(eq2, x);
  const degY = polynomialDegree(eq2, y);
  if (degX !== 1 || degY !== 1) return null;
  const xyCoef = extractXYCoefficient(eq2, x, y, ce);
  if (!xyCoef || xyCoef.coef.is(0)) return null;
  const product = xyCoef.constant.neg().div(xyCoef.coef).simplify();
  return { product };
}
function extractXYCoefficient(expr, x, y, ce) {
  let xyCoef = ce.Zero;
  let constant = ce.Zero;
  if (expr.operator === "Add") {
    for (const term of expr.ops) {
      const termResult2 = extractXYCoefficientFromTerm(term, x, y, ce);
      if (termResult2 === null) return null;
      xyCoef = xyCoef.add(termResult2.coef);
      constant = constant.add(termResult2.constant);
    }
    return { coef: xyCoef, constant };
  }
  const termResult = extractXYCoefficientFromTerm(expr, x, y, ce);
  if (termResult === null) return null;
  return termResult;
}
function extractXYCoefficientFromTerm(term, x, y, ce) {
  const hasX = term.has(x);
  const hasY = term.has(y);
  if (!hasX && !hasY) {
    return { coef: ce.Zero, constant: term };
  }
  if (hasX !== hasY) {
    return null;
  }
  if (term.operator === "Multiply") {
    let coef = ce.One;
    let foundX = false;
    let foundY = false;
    for (const factor3 of term.ops) {
      if (factor3.symbol === x) {
        if (foundX) return null;
        foundX = true;
      } else if (factor3.symbol === y) {
        if (foundY) return null;
        foundY = true;
      } else if (factor3.has(x) || factor3.has(y)) {
        return null;
      } else {
        coef = coef.mul(factor3);
      }
    }
    if (foundX && foundY) {
      return { coef, constant: ce.Zero };
    }
    return null;
  }
  if (term.symbol === x || term.symbol === y) {
    return null;
  }
  return null;
}
function extractSumEquation(eq2, x, y, ce) {
  if (!eq2.has(x) || !eq2.has(y)) return null;
  const degX = polynomialDegree(eq2, x);
  const degY = polynomialDegree(eq2, y);
  if (degX !== 1 || degY !== 1) return null;
  if (!isLinearInVariables(eq2, [x, y])) return null;
  const coefX = extractCoefficient(eq2, x, ce);
  const coefY = extractCoefficient(eq2, y, ce);
  const constant = extractConstantTerm(eq2, [x, y], ce);
  if (coefX === null || coefY === null) return null;
  const ratio = coefX.div(coefY).simplify();
  if (!ratio.is(1) && !ratio.is(-1)) {
    return null;
  }
  if (ratio.is(1)) {
    const sum2 = constant.neg().div(coefX).simplify();
    return { sum: sum2 };
  } else {
    return null;
  }
}
function isRealValue(expr) {
  const simplified = expr.simplify();
  if (simplified.operator === "Complex") return false;
  const im = simplified.im;
  if (im !== void 0 && im !== 0) return false;
  return true;
}
function filterRealRoots(roots) {
  return roots.filter((r) => isRealValue(r));
}
function trySubstitutionMethod(equations, x, y, ce) {
  for (let i = 0; i < equations.length; i++) {
    const eq2 = equations[i];
    const otherEq = equations[1 - i];
    const solveForXResult = trySolveLinearFor(eq2, x, y, ce);
    if (solveForXResult) {
      const substituted = otherEq.subs({ [x]: solveForXResult }, { canonical: true }).simplify();
      const yRoots = filterRealRoots(findUnivariateRoots(substituted, y));
      if (yRoots.length > 0) {
        const solutions = [];
        for (const yVal of yRoots) {
          const ySimplified = yVal.simplify();
          const xVal = solveForXResult.subs({ [y]: ySimplified }, { canonical: true }).simplify();
          if (isRealValue(xVal) && isRealValue(ySimplified)) {
            solutions.push({ [x]: xVal, [y]: ySimplified });
          }
        }
        if (solutions.length > 0) return solutions;
      }
    }
    const solveForYResult = trySolveLinearFor(eq2, y, x, ce);
    if (solveForYResult) {
      const substituted = otherEq.subs({ [y]: solveForYResult }, { canonical: true }).simplify();
      const xRoots = filterRealRoots(findUnivariateRoots(substituted, x));
      if (xRoots.length > 0) {
        const solutions = [];
        for (const xVal of xRoots) {
          const xSimplified = xVal.simplify();
          const yVal = solveForYResult.subs({ [x]: xSimplified }, { canonical: true }).simplify();
          if (isRealValue(xSimplified) && isRealValue(yVal)) {
            solutions.push({ [x]: xSimplified, [y]: yVal });
          }
        }
        if (solutions.length > 0) return solutions;
      }
    }
  }
  return null;
}
function trySolveLinearFor(eq2, solveFor, otherVar, ce) {
  const deg = polynomialDegree(eq2, solveFor);
  if (deg !== 1) return null;
  const coef = extractCoefficient(eq2, solveFor, ce);
  if (coef === null || coef.is(0)) return null;
  const rest = eq2.sub(coef.mul(ce.symbol(solveFor))).simplify();
  const solution = rest.neg().div(coef).simplify();
  return solution;
}
var INEQUALITY_OPERATORS = ["Less", "LessEqual", "Greater", "GreaterEqual"];
function isInequalityOperator2(op) {
  return op !== null && INEQUALITY_OPERATORS.includes(op);
}
function solveLinearInequalitySystem(inequalities, variables) {
  if (variables.length !== 2) return null;
  if (inequalities.length < 2) return null;
  const ce = inequalities[0].engine;
  const [xVar, yVar] = variables;
  const constraints = [];
  for (const ineq of inequalities) {
    const constraint = extractLinearConstraint(ineq, xVar, yVar, ce);
    if (!constraint) return null;
    constraints.push(constraint);
  }
  const candidates = [];
  for (let i = 0; i < constraints.length; i++) {
    for (let j = i + 1; j < constraints.length; j++) {
      const intersection2 = findLineIntersection(constraints[i], constraints[j]);
      if (intersection2) {
        candidates.push(intersection2);
      }
    }
  }
  const vertices = candidates.filter(
    (pt) => constraints.every((c) => satisfiesConstraint(pt, c))
  );
  if (vertices.length === 0) return null;
  const uniqueVertices = removeDuplicatePoints(vertices);
  if (uniqueVertices.length === 0) return null;
  const orderedVertices = orderConvexHull(uniqueVertices);
  return orderedVertices.map((pt) => ({
    [xVar]: ce.number(pt.x).simplify(),
    [yVar]: ce.number(pt.y).simplify()
  }));
}
function extractLinearConstraint(ineq, xVar, yVar, ce) {
  const op = ineq.operator;
  if (!isInequalityOperator2(op)) return null;
  const lhs = ineq.op1;
  const rhs = ineq.op2;
  if (!lhs || !rhs) return null;
  let expr;
  let strict;
  if (op === "Less" || op === "LessEqual") {
    expr = lhs.sub(rhs).expand().simplify();
    strict = op === "Less";
  } else {
    expr = rhs.sub(lhs).expand().simplify();
    strict = op === "Greater";
  }
  const degX = polynomialDegree(expr, xVar);
  const degY = polynomialDegree(expr, yVar);
  if (degX > 1 || degY > 1) return null;
  if (!isLinearInVariables(expr, [xVar, yVar])) return null;
  const coefX = extractCoefficient(expr, xVar, ce);
  const coefY = extractCoefficient(expr, yVar, ce);
  const constant = extractConstantTerm(expr, [xVar, yVar], ce);
  if (coefX === null || coefY === null) return null;
  const aVal = coefX.N().numericValue;
  const bVal = coefY.N().numericValue;
  const cVal = constant.N().numericValue;
  const toNumber = (val) => {
    if (typeof val === "number") return val;
    if (val && typeof val === "object" && "re" in val) {
      const re = val.re;
      if (typeof re === "number") return re;
    }
    return null;
  };
  const a = toNumber(aVal);
  const b = toNumber(bVal);
  const c = toNumber(cVal);
  if (a === null || b === null || c === null) return null;
  if (!Number.isFinite(a) || !Number.isFinite(b) || !Number.isFinite(c))
    return null;
  return { a, b, c, strict };
}
function findLineIntersection(c1, c2) {
  const det = c1.a * c2.b - c2.a * c1.b;
  if (Math.abs(det) < 1e-14) return null;
  const x = (c1.b * c2.c - c2.b * c1.c) / det;
  const y = (c2.a * c1.c - c1.a * c2.c) / det;
  if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
  return { x, y };
}
function satisfiesConstraint(pt, c) {
  const val = c.a * pt.x + c.b * pt.y + c.c;
  if (c.strict) {
    return val < 1e-10;
  } else {
    return val <= 1e-10;
  }
}
function removeDuplicatePoints(points) {
  const tolerance = 1e-10;
  const result = [];
  for (const pt of points) {
    const isDuplicate = result.some(
      (existing) => Math.abs(existing.x - pt.x) < tolerance && Math.abs(existing.y - pt.y) < tolerance
    );
    if (!isDuplicate) {
      result.push(pt);
    }
  }
  return result;
}
function orderConvexHull(points) {
  if (points.length <= 2) return points;
  const cx = points.reduce((sum2, p) => sum2 + p.x, 0) / points.length;
  const cy = points.reduce((sum2, p) => sum2 + p.y, 0) / points.length;
  return [...points].sort((a, b) => {
    const angleA = Math.atan2(a.y - cy, a.x - cx);
    const angleB = Math.atan2(b.y - cy, b.x - cx);
    return angleA - angleB;
  });
}

// src/compute-engine/boxed-expression/boxed-function.ts
init_rules();
init_negate();
init_product();

// src/compute-engine/boxed-expression/simplify.ts
init_rules();

// src/compute-engine/boxed-expression/hold.ts
init_flatten();
function holdMap(expr, f) {
  if (!expr.ops) return [];
  let xs = expr.ops;
  const def = expr.operatorDefinition;
  if (!def || xs.length === 0) return xs;
  const associativeHead = def?.associative ? expr.operator : "";
  xs = flattenOps(xs, associativeHead);
  if (def.lazy) return xs;
  const result = [];
  for (const x of xs) {
    const h = x.operator;
    if (h === "Hold") result.push(x);
    else {
      const op = h === "ReleaseHold" ? x.op1 : x;
      if (op) {
        const y = f(op);
        if (y !== null) result.push(y);
      }
    }
  }
  return flattenOps(result, associativeHead);
}
async function holdMapAsync(expr, f) {
  if (!expr.ops) return [];
  let xs = expr.ops;
  const def = expr.operatorDefinition;
  if (!def || xs.length === 0) return xs;
  const associativeHead = def?.associative ? expr.operator : "";
  xs = flattenOps(xs, associativeHead);
  if (def.lazy) return xs;
  const result = [];
  for (const x of xs) {
    const h = x.operator;
    if (h === "Hold") result.push(x);
    else {
      const op = h === "ReleaseHold" ? x.op1 : x;
      if (op) {
        const y = await f(op);
        if (y !== null) result.push(y);
      }
    }
  }
  return flattenOps(result, associativeHead);
}

// src/compute-engine/symbolic/fu-transforms.ts
var TRIG_FUNC_REGEX = /^(Sin|Cos|Tan|Cot|Sec|Csc)$/;
function hasTrigFunction(expr) {
  if (TRIG_FUNC_REGEX.test(expr.operator)) return true;
  if (!expr.ops) return false;
  return expr.ops.some(hasTrigFunction);
}
function hasOperator(expr, ...ops) {
  if (ops.includes(expr.operator)) return true;
  if (!expr.ops) return false;
  return expr.ops.some((x) => hasOperator(x, ...ops));
}
function mapSubexpressions(expr, fn) {
  const ce = expr.engine;
  if (expr.ops && expr.ops.length > 0) {
    const newOps = expr.ops.map((op) => mapSubexpressions(op, fn));
    const changed = newOps.some((op, i) => op !== expr.ops[i]);
    if (changed) {
      expr = ce._fn(expr.operator, newOps);
    }
  }
  return fn(expr) ?? expr;
}
function sameArg(a, b) {
  const argA = a.op1;
  const argB = b.op1;
  return argA !== void 0 && argB !== void 0 && argA.isSame(argB);
}
function TR1(expr) {
  const ce = expr.engine;
  const op = expr.operator;
  const arg = expr.op1;
  if (!arg) return void 0;
  if (op === "Sec") {
    return ce.One.div(ce._fn("Cos", [arg]));
  }
  if (op === "Csc") {
    return ce.One.div(ce._fn("Sin", [arg]));
  }
  return void 0;
}
function applyTR1(expr) {
  return mapSubexpressions(expr, TR1);
}
function TR2(expr) {
  const ce = expr.engine;
  const op = expr.operator;
  const arg = expr.op1;
  if (!arg) return void 0;
  if (op === "Tan") {
    return ce._fn("Sin", [arg]).div(ce._fn("Cos", [arg]));
  }
  if (op === "Cot") {
    return ce._fn("Cos", [arg]).div(ce._fn("Sin", [arg]));
  }
  return void 0;
}
function applyTR2(expr) {
  return mapSubexpressions(expr, TR2);
}
function TR2i(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Divide") return void 0;
  const num = expr.op1;
  const den = expr.op2;
  if (!num || !den) return void 0;
  if (num.operator === "Sin" && den.operator === "Cos" && sameArg(num, den)) {
    return ce._fn("Tan", [num.op1]);
  }
  if (num.operator === "Cos" && den.operator === "Sin" && sameArg(num, den)) {
    return ce._fn("Cot", [num.op1]);
  }
  return void 0;
}
function applyTR2i(expr) {
  return mapSubexpressions(expr, TR2i);
}
function getNegatedArg(expr) {
  if (expr.operator === "Negate" && expr.op1) {
    return expr.op1;
  }
  if (expr.operator === "Multiply" && expr.ops) {
    const negOneIndex = expr.ops.findIndex((f) => f.is(-1));
    if (negOneIndex >= 0) {
      const remaining = expr.ops.filter((_, i) => i !== negOneIndex);
      if (remaining.length === 1) return remaining[0];
      return expr.engine._fn("Multiply", remaining);
    }
  }
  return void 0;
}
function TR3(expr) {
  const ce = expr.engine;
  const op = expr.operator;
  const arg = expr.op1;
  if (!arg) return void 0;
  const innerArg = getNegatedArg(arg);
  if (!innerArg) return void 0;
  if (op === "Cos") {
    return ce._fn("Cos", [innerArg]);
  }
  if (op === "Sec") {
    return ce._fn("Sec", [innerArg]);
  }
  if (op === "Sin") {
    return ce._fn("Sin", [innerArg]).neg();
  }
  if (op === "Tan") {
    return ce._fn("Tan", [innerArg]).neg();
  }
  if (op === "Csc") {
    return ce._fn("Csc", [innerArg]).neg();
  }
  if (op === "Cot") {
    return ce._fn("Cot", [innerArg]).neg();
  }
  return void 0;
}
function applyTR3(expr) {
  return mapSubexpressions(expr, TR3);
}
function TR5(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Power") return void 0;
  const base = expr.op1;
  const exp3 = expr.op2;
  if (!base || !exp3) return void 0;
  if (base.operator !== "Sin") return void 0;
  if (!exp3.is(2)) return void 0;
  const arg = base.op1;
  if (!arg) return void 0;
  return ce.One.sub(ce._fn("Cos", [arg]).pow(2));
}
function applyTR5(expr) {
  return mapSubexpressions(expr, TR5);
}
function TR6(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Power") return void 0;
  const base = expr.op1;
  const exp3 = expr.op2;
  if (!base || !exp3) return void 0;
  if (base.operator !== "Cos") return void 0;
  if (!exp3.is(2)) return void 0;
  const arg = base.op1;
  if (!arg) return void 0;
  return ce.One.sub(ce._fn("Sin", [arg]).pow(2));
}
function applyTR6(expr) {
  return mapSubexpressions(expr, TR6);
}
function TR7(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Power") return void 0;
  const base = expr.op1;
  const exp3 = expr.op2;
  if (!base || !exp3) return void 0;
  if (base.operator !== "Cos") return void 0;
  if (!exp3.is(2)) return void 0;
  const arg = base.op1;
  if (!arg) return void 0;
  return ce.One.add(ce._fn("Cos", [arg.mul(2)])).div(2);
}
function applyTR7(expr) {
  return mapSubexpressions(expr, TR7);
}
function TR7i(expr) {
  const ce = expr.engine;
  if (expr.operator === "Divide") {
    const num = expr.op1;
    const den = expr.op2;
    if (!num || !den || !den.is(2)) return void 0;
    if (num.operator === "Add" && num.ops && num.ops.length === 2) {
      return checkHalfAnglePattern(ce, num.ops);
    }
  }
  const isHalf = (f) => {
    if (f.re === 0.5 && f.im === 0) return true;
    if (f.isSame(ce.Half)) return true;
    return false;
  };
  if (expr.operator === "Multiply" && expr.ops) {
    const halfIndex = expr.ops.findIndex((f) => isHalf(f));
    if (halfIndex >= 0) {
      const remaining = expr.ops.filter((_, i) => i !== halfIndex);
      if (remaining.length === 1 && remaining[0].operator === "Add") {
        const addOps = remaining[0].ops;
        if (addOps && addOps.length === 2) {
          return checkHalfAnglePattern(ce, addOps);
        }
      }
    }
  }
  if (expr.operator === "Add" && expr.ops && expr.ops.length === 2) {
    let halfTerm;
    let cosTerm;
    let isNegCos = false;
    const isNegHalf = (f) => {
      if (f.re === -0.5 && f.im === 0) return true;
      return false;
    };
    for (const op of expr.ops) {
      if (isHalf(op)) {
        halfTerm = op;
        continue;
      }
      let checkOp = op;
      let neg2 = false;
      if (op.operator === "Negate" && op.op1) {
        neg2 = true;
        checkOp = op.op1;
      }
      if (checkOp.operator === "Divide" && checkOp.op2?.is(2)) {
        const num = checkOp.op1;
        if (num?.operator === "Cos") {
          cosTerm = num;
          isNegCos = neg2;
          continue;
        }
      }
      if (checkOp.operator === "Multiply" && checkOp.ops) {
        const halfIdx = checkOp.ops.findIndex((f) => isHalf(f));
        if (halfIdx >= 0) {
          const rest = checkOp.ops.filter((_, i) => i !== halfIdx);
          if (rest.length === 1 && rest[0].operator === "Cos") {
            cosTerm = rest[0];
            isNegCos = neg2;
            continue;
          }
        }
        const negHalfIdx = checkOp.ops.findIndex((f) => isNegHalf(f));
        if (negHalfIdx >= 0) {
          const rest = checkOp.ops.filter((_, i) => i !== negHalfIdx);
          if (rest.length === 1 && rest[0].operator === "Cos") {
            cosTerm = rest[0];
            isNegCos = !neg2;
            continue;
          }
        }
      }
    }
    if (halfTerm && cosTerm) {
      const cosArg = cosTerm.op1;
      if (!cosArg) return void 0;
      let x;
      if (cosArg.operator === "Multiply" && cosArg.ops) {
        const twoIndex = cosArg.ops.findIndex((f) => f.is(2));
        if (twoIndex >= 0) {
          const remaining = cosArg.ops.filter((_, i) => i !== twoIndex);
          x = remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining);
        }
      }
      if (!x) return void 0;
      if (isNegCos) {
        return ce._fn("Sin", [x]).pow(2);
      } else {
        return ce._fn("Cos", [x]).pow(2);
      }
    }
  }
  return void 0;
}
function checkHalfAnglePattern(ce, ops) {
  let oneIndex = -1;
  let cosIndex = -1;
  let isNegCos = false;
  for (let i = 0; i < ops.length; i++) {
    if (ops[i].is(1)) {
      oneIndex = i;
    } else if (ops[i].operator === "Cos") {
      cosIndex = i;
      isNegCos = false;
    } else if (ops[i].operator === "Negate" && ops[i].op1?.operator === "Cos") {
      cosIndex = i;
      isNegCos = true;
    }
  }
  if (oneIndex < 0 || cosIndex < 0) return void 0;
  const cosExpr = isNegCos ? ops[cosIndex].op1 : ops[cosIndex];
  const cosArg = cosExpr.op1;
  if (!cosArg) return void 0;
  let x;
  if (cosArg.operator === "Multiply" && cosArg.ops) {
    const twoIndex = cosArg.ops.findIndex((f) => f.is(2));
    if (twoIndex >= 0) {
      const remaining = cosArg.ops.filter((_, i) => i !== twoIndex);
      x = remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining);
    }
  }
  if (!x) return void 0;
  if (isNegCos) {
    return ce._fn("Sin", [x]).pow(2);
  } else {
    return ce._fn("Cos", [x]).pow(2);
  }
}
function applyTR7i(expr) {
  return mapSubexpressions(expr, TR7i);
}
function TR8(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Multiply") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  for (let i = 0; i < ops.length; i++) {
    for (let j = i + 1; j < ops.length; j++) {
      const a = ops[i];
      const b = ops[j];
      const argA = a.op1;
      const argB = b.op1;
      if (!argA || !argB) continue;
      let result;
      if (a.operator === "Sin" && b.operator === "Cos") {
        result = ce._fn("Sin", [argA.add(argB)]).add(ce._fn("Sin", [argA.sub(argB)])).div(2);
      } else if (a.operator === "Cos" && b.operator === "Sin") {
        result = ce._fn("Sin", [argA.add(argB)]).sub(ce._fn("Sin", [argA.sub(argB)])).div(2);
      } else if (a.operator === "Cos" && b.operator === "Cos") {
        result = ce._fn("Cos", [argA.add(argB)]).add(ce._fn("Cos", [argA.sub(argB)])).div(2);
      } else if (a.operator === "Sin" && b.operator === "Sin") {
        result = ce._fn("Cos", [argA.sub(argB)]).sub(ce._fn("Cos", [argA.add(argB)])).div(2);
      }
      if (result) {
        const remaining = ops.filter((_, k) => k !== i && k !== j);
        if (remaining.length === 0) return result;
        return result.mul(
          remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining)
        );
      }
    }
  }
  return void 0;
}
function applyTR8(expr) {
  return mapSubexpressions(expr, TR8);
}
function TR9(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  for (let i = 0; i < ops.length; i++) {
    for (let j = i + 1; j < ops.length; j++) {
      const a = ops[i];
      const b = ops[j];
      let result;
      if (a.operator === "Sin" && b.operator === "Sin") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA && argB) {
          const sum2 = argA.add(argB).div(2);
          const diff = argA.sub(argB).div(2);
          result = ce._fn("Sin", [sum2]).mul(ce._fn("Cos", [diff])).mul(2);
        }
      } else if (a.operator === "Cos" && b.operator === "Cos") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA && argB) {
          const sum2 = argA.add(argB).div(2);
          const diff = argA.sub(argB).div(2);
          result = ce._fn("Cos", [sum2]).mul(ce._fn("Cos", [diff])).mul(2);
        }
      } else if (a.operator === "Sin" && b.operator === "Negate" && b.op1?.operator === "Sin") {
        const argA = a.op1;
        const argB = b.op1.op1;
        if (argA && argB) {
          const sum2 = argA.add(argB).div(2);
          const diff = argA.sub(argB).div(2);
          result = ce._fn("Cos", [sum2]).mul(ce._fn("Sin", [diff])).mul(2);
        }
      } else if (a.operator === "Cos" && b.operator === "Negate" && b.op1?.operator === "Cos") {
        const argA = a.op1;
        const argB = b.op1.op1;
        if (argA && argB) {
          const sum2 = argA.add(argB).div(2);
          const diff = argA.sub(argB).div(2);
          result = ce._fn("Sin", [sum2]).mul(ce._fn("Sin", [diff])).mul(-2);
        }
      }
      if (result) {
        const remaining = ops.filter((_, k) => k !== i && k !== j);
        if (remaining.length === 0) return result;
        return result.add(
          remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
        );
      }
    }
  }
  return void 0;
}
function applyTR9(expr) {
  return mapSubexpressions(expr, TR9);
}
function TR10(expr) {
  const ce = expr.engine;
  const op = expr.operator;
  if (op !== "Sin" && op !== "Cos") return void 0;
  const arg = expr.op1;
  if (!arg) return void 0;
  if (arg.operator === "Add" && arg.ops && arg.ops.length === 2) {
    const [x, y] = arg.ops;
    if (op === "Sin") {
      return ce._fn("Sin", [x]).mul(ce._fn("Cos", [y])).add(ce._fn("Cos", [x]).mul(ce._fn("Sin", [y])));
    } else {
      return ce._fn("Cos", [x]).mul(ce._fn("Cos", [y])).sub(ce._fn("Sin", [x]).mul(ce._fn("Sin", [y])));
    }
  }
  if (arg.operator === "Subtract") {
    const x = arg.op1;
    const y = arg.op2;
    if (!x || !y) return void 0;
    if (op === "Sin") {
      return ce._fn("Sin", [x]).mul(ce._fn("Cos", [y])).sub(ce._fn("Cos", [x]).mul(ce._fn("Sin", [y])));
    } else {
      return ce._fn("Cos", [x]).mul(ce._fn("Cos", [y])).add(ce._fn("Sin", [x]).mul(ce._fn("Sin", [y])));
    }
  }
  return void 0;
}
function applyTR10(expr) {
  return mapSubexpressions(expr, TR10);
}
function TR10i(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  for (let i = 0; i < ops.length; i++) {
    for (let j = i + 1; j < ops.length; j++) {
      const a = ops[i];
      const b = ops[j];
      const extractSinCos = (term) => {
        if (term.operator !== "Multiply") return null;
        const factors = term.ops;
        if (!factors || factors.length !== 2) return null;
        const [f1, f2] = factors;
        if (f1.operator === "Sin" && f2.operator === "Cos") {
          return { sin: f1, cos: f2 };
        }
        if (f1.operator === "Cos" && f2.operator === "Sin") {
          return { sin: f2, cos: f1 };
        }
        return null;
      };
      const extractCosCos = (term) => {
        if (term.operator !== "Multiply") return null;
        const factors = term.ops;
        if (!factors || factors.length !== 2) return null;
        const [f1, f2] = factors;
        if (f1.operator === "Cos" && f2.operator === "Cos") {
          return { cos1: f1, cos2: f2 };
        }
        return null;
      };
      const extractSinSin = (term) => {
        if (term.operator !== "Multiply") return null;
        const factors = term.ops;
        if (!factors || factors.length !== 2) return null;
        const [f1, f2] = factors;
        if (f1.operator === "Sin" && f2.operator === "Sin") {
          return { sin1: f1, sin2: f2 };
        }
        return null;
      };
      const scA = extractSinCos(a);
      const scB = extractSinCos(b);
      const negScA = a.operator === "Negate" && a.op1 ? extractSinCos(a.op1) : null;
      const negScB = b.operator === "Negate" && b.op1 ? extractSinCos(b.op1) : null;
      if (scA && scB) {
        const xA = scA.sin.op1;
        const yA = scA.cos.op1;
        const xB = scB.sin.op1;
        const yB = scB.cos.op1;
        if (xA && yA && xB && yB) {
          if (xA.isSame(yB) && yA.isSame(xB)) {
            const remaining = ops.filter((_, k) => k !== i && k !== j);
            const result = ce._fn("Sin", [xA.add(yA)]);
            if (remaining.length === 0) return result;
            return result.add(
              remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
            );
          }
        }
      }
      if (scA && negScB) {
        const xA = scA.sin.op1;
        const yA = scA.cos.op1;
        const xB = negScB.sin.op1;
        const yB = negScB.cos.op1;
        if (xA && yA && xB && yB) {
          if (xA.isSame(yB) && yA.isSame(xB)) {
            const remaining = ops.filter((_, k) => k !== i && k !== j);
            const result = ce._fn("Sin", [xA.sub(yA)]);
            if (remaining.length === 0) return result;
            return result.add(
              remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
            );
          }
        }
      }
      if (negScA && scB) {
        const xA = negScA.sin.op1;
        const yA = negScA.cos.op1;
        const xB = scB.sin.op1;
        const yB = scB.cos.op1;
        if (xA && yA && xB && yB) {
          if (xB.isSame(yA) && yB.isSame(xA)) {
            const remaining = ops.filter((_, k) => k !== i && k !== j);
            const result = ce._fn("Sin", [xB.sub(yB)]);
            if (remaining.length === 0) return result;
            return result.add(
              remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
            );
          }
        }
      }
      const ccA = extractCosCos(a);
      const ccB = extractCosCos(b);
      const ssA = extractSinSin(a);
      const ssB = extractSinSin(b);
      const negSsA = a.operator === "Negate" && a.op1 ? extractSinSin(a.op1) : null;
      const negSsB = b.operator === "Negate" && b.op1 ? extractSinSin(b.op1) : null;
      if (ccA && negSsB) {
        const x = ccA.cos1.op1;
        const y = ccA.cos2.op1;
        const x2 = negSsB.sin1.op1;
        const y2 = negSsB.sin2.op1;
        if (x && y && x2 && y2 && (x.isSame(x2) && y.isSame(y2) || x.isSame(y2) && y.isSame(x2))) {
          const remaining = ops.filter((_, k) => k !== i && k !== j);
          const result = ce._fn("Cos", [x.add(y)]);
          if (remaining.length === 0) return result;
          return result.add(
            remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
          );
        }
      }
      if (negSsA && ccB) {
        const x = ccB.cos1.op1;
        const y = ccB.cos2.op1;
        const x2 = negSsA.sin1.op1;
        const y2 = negSsA.sin2.op1;
        if (x && y && x2 && y2 && (x.isSame(x2) && y.isSame(y2) || x.isSame(y2) && y.isSame(x2))) {
          const remaining = ops.filter((_, k) => k !== i && k !== j);
          const result = ce._fn("Cos", [x.add(y)]);
          if (remaining.length === 0) return result;
          return result.add(
            remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
          );
        }
      }
      if (ccA && ssB) {
        const x = ccA.cos1.op1;
        const y = ccA.cos2.op1;
        const x2 = ssB.sin1.op1;
        const y2 = ssB.sin2.op1;
        if (x && y && x2 && y2 && (x.isSame(x2) && y.isSame(y2) || x.isSame(y2) && y.isSame(x2))) {
          const remaining = ops.filter((_, k) => k !== i && k !== j);
          const result = ce._fn("Cos", [x.sub(y)]);
          if (remaining.length === 0) return result;
          return result.add(
            remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
          );
        }
      }
      if (ssA && ccB) {
        const x = ccB.cos1.op1;
        const y = ccB.cos2.op1;
        const x2 = ssA.sin1.op1;
        const y2 = ssA.sin2.op1;
        if (x && y && x2 && y2 && (x.isSame(x2) && y.isSame(y2) || x.isSame(y2) && y.isSame(x2))) {
          const remaining = ops.filter((_, k) => k !== i && k !== j);
          const result = ce._fn("Cos", [x.sub(y)]);
          if (remaining.length === 0) return result;
          return result.add(
            remaining.length === 1 ? remaining[0] : ce._fn("Add", remaining)
          );
        }
      }
    }
  }
  return void 0;
}
function applyTR10i(expr) {
  return mapSubexpressions(expr, TR10i);
}
function TR11(expr) {
  const ce = expr.engine;
  const op = expr.operator;
  if (op !== "Sin" && op !== "Cos") return void 0;
  const arg = expr.op1;
  if (!arg) return void 0;
  if (arg.operator === "Multiply" && arg.ops) {
    const factors = arg.ops;
    const twoIndex = factors.findIndex((f) => f.is(2));
    if (twoIndex >= 0) {
      const otherFactors = factors.filter((_, i) => i !== twoIndex);
      const x = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
      if (op === "Sin") {
        return ce._fn("Sin", [x]).mul(ce._fn("Cos", [x])).mul(2);
      } else {
        return ce._fn("Cos", [x]).pow(2).mul(2).sub(ce.One);
      }
    }
  }
  return void 0;
}
function applyTR11(expr) {
  return mapSubexpressions(expr, TR11);
}
function TR11i(expr) {
  const ce = expr.engine;
  if (expr.operator === "Multiply" && expr.ops) {
    const ops = expr.ops;
    const twoIndex = ops.findIndex((f) => f.is(2));
    if (twoIndex >= 0) {
      const remaining = ops.filter((_, i) => i !== twoIndex);
      let sinTerm;
      let cosTerm;
      for (const f of remaining) {
        if (f.operator === "Sin" && !sinTerm) sinTerm = f;
        else if (f.operator === "Cos" && !cosTerm) cosTerm = f;
      }
      if (sinTerm && cosTerm && sameArg(sinTerm, cosTerm)) {
        const otherFactors = remaining.filter(
          (f) => f !== sinTerm && f !== cosTerm
        );
        const result = ce._fn("Sin", [sinTerm.op1.mul(2)]);
        if (otherFactors.length === 0) return result;
        return result.mul(
          otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors)
        );
      }
    }
  }
  if (expr.operator === "Add" && expr.ops && expr.ops.length === 2) {
    const [a, b] = expr.ops;
    if (a.operator === "Power" && a.op1?.operator === "Cos" && a.op2?.is(2) && b.operator === "Negate" && b.op1?.operator === "Power" && b.op1?.op1?.operator === "Sin" && b.op1?.op2?.is(2)) {
      const cosArg2 = a.op1.op1;
      const sinArg = b.op1.op1.op1;
      if (cosArg2 && sinArg && cosArg2.isSame(sinArg)) {
        return ce._fn("Cos", [cosArg2.mul(2)]);
      }
    }
    const extractTwoCosSq = (term) => {
      if (term.operator !== "Multiply" || !term.ops) return void 0;
      const twoIdx = term.ops.findIndex((f) => f.is(2));
      if (twoIdx < 0) return void 0;
      const rest = term.ops.filter((_, i) => i !== twoIdx);
      if (rest.length !== 1) return void 0;
      const powerTerm = rest[0];
      if (powerTerm.operator === "Power" && powerTerm.op1?.operator === "Cos" && powerTerm.op2?.is(2)) {
        return powerTerm.op1.op1;
      }
      return void 0;
    };
    let cosArg = extractTwoCosSq(a);
    if (cosArg && (b.is(-1) || b.operator === "Negate" && b.op1?.is(1))) {
      return ce._fn("Cos", [cosArg.mul(2)]);
    }
    cosArg = extractTwoCosSq(b);
    if (cosArg && (a.is(-1) || a.operator === "Negate" && a.op1?.is(1))) {
      return ce._fn("Cos", [cosArg.mul(2)]);
    }
    const extractTwoSinSq = (term) => {
      if (term.operator !== "Multiply" || !term.ops) return void 0;
      const twoIdx = term.ops.findIndex((f) => f.is(2));
      if (twoIdx < 0) return void 0;
      const rest = term.ops.filter((_, i) => i !== twoIdx);
      if (rest.length !== 1) return void 0;
      const powerTerm = rest[0];
      if (powerTerm.operator === "Power" && powerTerm.op1?.operator === "Sin" && powerTerm.op2?.is(2)) {
        return powerTerm.op1.op1;
      }
      return void 0;
    };
    if (a.is(1) && b.operator === "Negate" && b.op1) {
      const sinArg = extractTwoSinSq(b.op1);
      if (sinArg) {
        return ce._fn("Cos", [sinArg.mul(2)]);
      }
    }
    if (b.is(1) && a.operator === "Negate" && a.op1) {
      const sinArg = extractTwoSinSq(a.op1);
      if (sinArg) {
        return ce._fn("Cos", [sinArg.mul(2)]);
      }
    }
    const extractNegTwoSinSq = (term) => {
      if (term.operator !== "Multiply" || !term.ops) return void 0;
      const negTwoIdx = term.ops.findIndex((f) => f.is(-2));
      if (negTwoIdx < 0) return void 0;
      const rest = term.ops.filter((_, i) => i !== negTwoIdx);
      if (rest.length !== 1) return void 0;
      const powerTerm = rest[0];
      if (powerTerm.operator === "Power" && powerTerm.op1?.operator === "Sin" && powerTerm.op2?.is(2)) {
        return powerTerm.op1.op1;
      }
      return void 0;
    };
    if (a.is(1)) {
      const sinArg = extractNegTwoSinSq(b);
      if (sinArg) {
        return ce._fn("Cos", [sinArg.mul(2)]);
      }
    }
    if (b.is(1)) {
      const sinArg = extractNegTwoSinSq(a);
      if (sinArg) {
        return ce._fn("Cos", [sinArg.mul(2)]);
      }
    }
  }
  return void 0;
}
function applyTR11i(expr) {
  return mapSubexpressions(expr, TR11i);
}
function TR12(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Tan") return void 0;
  const arg = expr.op1;
  if (!arg) return void 0;
  if (arg.operator === "Add" && arg.ops && arg.ops.length === 2) {
    const [x, y] = arg.ops;
    const tanX = ce._fn("Tan", [x]);
    const tanY = ce._fn("Tan", [y]);
    return tanX.add(tanY).div(ce.One.sub(tanX.mul(tanY)));
  }
  if (arg.operator === "Subtract") {
    const x = arg.op1;
    const y = arg.op2;
    if (!x || !y) return void 0;
    const tanX = ce._fn("Tan", [x]);
    const tanY = ce._fn("Tan", [y]);
    return tanX.sub(tanY).div(ce.One.add(tanX.mul(tanY)));
  }
  return void 0;
}
function applyTR12(expr) {
  return mapSubexpressions(expr, TR12);
}
var KNOWN_TAN_VALUES = [
  { value: 0, angle: [0, 1] },
  // tan(0)
  { value: 1 / Math.sqrt(3), angle: [1, 6] },
  // tan(/6) = 1/3
  { value: 1, angle: [1, 4] },
  // tan(/4) = 1
  { value: Math.sqrt(3), angle: [1, 3] },
  // tan(/3) = 3
  { value: 2 - Math.sqrt(3), angle: [1, 12] },
  // tan(/12) = 2-3
  { value: 2 + Math.sqrt(3), angle: [5, 12] }
  // tan(5/12) = 2+3
];
function findTanAngle(k, tolerance = 1e-10) {
  for (const entry of KNOWN_TAN_VALUES) {
    if (Math.abs(entry.value - k) < tolerance) {
      return entry.angle;
    }
  }
  return void 0;
}
function extractTanProduct(expr) {
  if (expr.operator !== "Multiply") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  const tanFactors = [];
  let coef = 1;
  for (const op of ops) {
    if (op.operator === "Tan" && op.op1) {
      tanFactors.push(op.op1);
    } else if (op.operator === "Negate" && op.op1?.operator === "Sqrt") {
      const sqrtArg = op.op1.op1;
      if (sqrtArg?.isNumberLiteral && typeof sqrtArg.re === "number") {
        coef *= -Math.sqrt(sqrtArg.re);
      } else {
        return void 0;
      }
    } else if (op.operator === "Sqrt") {
      const sqrtArg = op.op1;
      if (sqrtArg?.isNumberLiteral && typeof sqrtArg.re === "number") {
        coef *= Math.sqrt(sqrtArg.re);
      } else {
        return void 0;
      }
    } else if (op.isNumberLiteral && typeof op.re === "number") {
      coef *= op.re;
    } else {
      return void 0;
    }
  }
  if (tanFactors.length !== 2) return void 0;
  return [coef, tanFactors[0], tanFactors[1]];
}
function extractPiFraction(arg) {
  if (arg.operator === "Multiply" && arg.ops) {
    let piFound = false;
    let fraction;
    for (const op of arg.ops) {
      if (op.symbol === "Pi") {
        piFound = true;
      } else if (op.isNumberLiteral && typeof op.re === "number") {
        const val = op.re;
        for (let d = 1; d <= 36; d++) {
          const n = Math.round(val * d);
          if (Math.abs(n / d - val) < 1e-10) {
            fraction = [n, d];
            break;
          }
        }
      }
    }
    if (piFound && fraction) return fraction;
  }
  if (arg.symbol === "Pi") return [1, 1];
  return void 0;
}
function TR12i(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length !== 3) return void 0;
  const tanTerms = [];
  let productTerm;
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.operator === "Tan" && op.op1) {
      tanTerms.push({ arg: op.op1, index: i });
    } else {
      const extracted = extractTanProduct(op);
      if (extracted) {
        productTerm = {
          coef: extracted[0],
          arg1: extracted[1],
          arg2: extracted[2],
          index: i
        };
      }
    }
  }
  if (tanTerms.length !== 2 || !productTerm) return void 0;
  const [tanA, tanB] = tanTerms;
  const arg1MatchesA = tanA.arg.isSame(productTerm.arg1) || tanA.arg.isSame(productTerm.arg2);
  const arg1MatchesB = tanB.arg.isSame(productTerm.arg1) || tanB.arg.isSame(productTerm.arg2);
  const arg2MatchesA = tanA.arg.isSame(productTerm.arg2) || tanA.arg.isSame(productTerm.arg1);
  const arg2MatchesB = tanB.arg.isSame(productTerm.arg2) || tanB.arg.isSame(productTerm.arg1);
  if (!(arg1MatchesA && arg2MatchesB || arg1MatchesB && arg2MatchesA)) {
    return void 0;
  }
  const k = -productTerm.coef;
  if (k <= 0) return void 0;
  const angleC = findTanAngle(k);
  if (!angleC) return void 0;
  const fracA = extractPiFraction(tanA.arg);
  const fracB = extractPiFraction(tanB.arg);
  if (!fracA || !fracB) return void 0;
  const lcd = lcm4(lcm4(fracA[1], fracB[1]), angleC[1]);
  const sumNumerator = fracA[0] * (lcd / fracA[1]) + fracB[0] * (lcd / fracB[1]) + angleC[0] * (lcd / angleC[1]);
  if (sumNumerator !== lcd) return void 0;
  const tanCArg = ce._fn("Multiply", [
    ce.number([angleC[0], angleC[1]]),
    ce.symbol("Pi")
  ]);
  return ce._fn("Tan", [tanCArg]).neg();
}
function lcm4(a, b) {
  return Math.abs(a * b) / gcd4(a, b);
}
function gcd4(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b) {
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
}
function applyTR12i(expr) {
  return mapSubexpressions(expr, TR12i);
}
function TR13(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Multiply") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  for (let i = 0; i < ops.length; i++) {
    for (let j = i + 1; j < ops.length; j++) {
      const a = ops[i];
      const b = ops[j];
      const argA = a.op1;
      const argB = b.op1;
      if (!argA || !argB) continue;
      if (a.operator === "Tan" && b.operator === "Tan") {
        const tanX = a;
        const tanY = b;
        const cotSum = ce._fn("Cot", [argA.add(argB)]);
        const result = ce.One.sub(tanX.add(tanY).mul(cotSum));
        const remaining = ops.filter((_, k) => k !== i && k !== j);
        if (remaining.length === 0) return result;
        return result.mul(
          remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining)
        );
      }
      if (a.operator === "Cot" && b.operator === "Cot") {
        const cotX = a;
        const cotY = b;
        const cotSum = ce._fn("Cot", [argA.add(argB)]);
        const result = ce.One.add(cotX.add(cotY).mul(cotSum));
        const remaining = ops.filter((_, k) => k !== i && k !== j);
        if (remaining.length === 0) return result;
        return result.mul(
          remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining)
        );
      }
    }
  }
  return void 0;
}
function applyTR13(expr) {
  return mapSubexpressions(expr, TR13);
}
function TR22(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Power") return void 0;
  const base = expr.op1;
  const exp3 = expr.op2;
  if (!base || !exp3) return void 0;
  if (!exp3.is(2)) return void 0;
  const arg = base.op1;
  if (!arg) return void 0;
  if (base.operator === "Tan") {
    return ce._fn("Sec", [arg]).pow(2).sub(ce.One);
  }
  if (base.operator === "Cot") {
    return ce._fn("Csc", [arg]).pow(2).sub(ce.One);
  }
  if (base.operator === "Sec") {
    return ce.One.add(ce._fn("Tan", [arg]).pow(2));
  }
  if (base.operator === "Csc") {
    return ce.One.add(ce._fn("Cot", [arg]).pow(2));
  }
  return void 0;
}
function applyTR22(expr) {
  return mapSubexpressions(expr, TR22);
}
function TR22i(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length !== 2) return void 0;
  const extractPower2 = (op) => {
    let neg2 = false;
    let powerOp = op;
    if (op.operator === "Negate" && op.op1) {
      neg2 = true;
      powerOp = op.op1;
    }
    if (powerOp.operator !== "Power" || !powerOp.op2?.is(2)) return null;
    const base2 = powerOp.op1;
    if (!base2 || !base2.op1) return null;
    const func = base2.operator;
    if (!["Tan", "Cot", "Sec", "Csc"].includes(func)) return null;
    return { func, arg: base2.op1, neg: neg2 };
  };
  const p0 = extractPower2(ops[0]);
  const p1 = extractPower2(ops[1]);
  if (p0 && p1 && p0.arg.isSame(p1.arg)) {
    if (p0.func === "Cot" && !p0.neg && p1.func === "Csc" && p1.neg || p0.func === "Csc" && p0.neg && p1.func === "Cot" && !p1.neg) {
      return ce.number(-1);
    }
    if (p0.func === "Csc" && !p0.neg && p1.func === "Cot" && p1.neg || p0.func === "Cot" && p0.neg && p1.func === "Csc" && !p1.neg) {
      return ce.One;
    }
    if (p0.func === "Tan" && !p0.neg && p1.func === "Sec" && p1.neg || p0.func === "Sec" && p0.neg && p1.func === "Tan" && !p1.neg) {
      return ce.number(-1);
    }
    if (p0.func === "Sec" && !p0.neg && p1.func === "Tan" && p1.neg || p0.func === "Tan" && p0.neg && p1.func === "Sec" && !p1.neg) {
      return ce.One;
    }
  }
  let oneIndex = -1;
  let powerIndex = -1;
  let isNegOne = false;
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    if (op.is(1)) {
      oneIndex = i;
      isNegOne = false;
    } else if (op.is(-1)) {
      oneIndex = i;
      isNegOne = true;
    } else if (op.operator === "Negate" && op.op1?.is(1)) {
      oneIndex = i;
      isNegOne = true;
    } else if (op.operator === "Power" && op.op2?.is(2)) {
      powerIndex = i;
    }
  }
  if (oneIndex < 0 || powerIndex < 0) return void 0;
  const powerExpr = ops[powerIndex];
  const base = powerExpr.op1;
  if (!base) return void 0;
  const arg = base.op1;
  if (!arg) return void 0;
  if (base.operator === "Sec" && isNegOne) {
    return ce._fn("Tan", [arg]).pow(2);
  }
  if (base.operator === "Csc" && isNegOne) {
    return ce._fn("Cot", [arg]).pow(2);
  }
  if (base.operator === "Tan" && !isNegOne) {
    return ce._fn("Sec", [arg]).pow(2);
  }
  if (base.operator === "Cot" && !isNegOne) {
    return ce._fn("Csc", [arg]).pow(2);
  }
  return void 0;
}
function applyTR22i(expr) {
  return mapSubexpressions(expr, TR22i);
}
function extractMultiplier(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Multiply" || !expr.ops) {
    return [1, ce.One, expr];
  }
  for (let i = 0; i < expr.ops.length; i++) {
    const op = expr.ops[i];
    let numValue;
    if (op.isNumberLiteral) {
      if (typeof op.re === "number" && op.im === 0) {
        numValue = op.re;
      }
    }
    if (numValue !== void 0) {
      const rest = expr.ops.filter((_, j) => j !== i);
      const baseArg = rest.length === 1 ? rest[0] : ce._fn("Multiply", rest);
      return [numValue, op, baseArg];
    }
  }
  return [1, ce.One, expr];
}
function TRmorrie(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Multiply") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  const cosFactors = [];
  const otherFactors = [];
  for (const op of ops) {
    if (op.operator === "Cos" && op.op1) {
      const extracted = extractMultiplier(op.op1);
      if (extracted) {
        cosFactors.push({
          arg: extracted[2],
          numericMult: extracted[0],
          symbolicCoeff: extracted[1]
        });
      } else {
        cosFactors.push({
          arg: op.op1,
          numericMult: 1,
          symbolicCoeff: ce.One
        });
      }
    } else {
      otherFactors.push(op);
    }
  }
  if (cosFactors.length < 2) return void 0;
  const baseArg = cosFactors[0].arg;
  const matchingFactors = cosFactors.filter((f) => f.arg.isSame(baseArg));
  const nonMatchingCosFactors = cosFactors.filter(
    (f) => !f.arg.isSame(baseArg)
  );
  if (matchingFactors.length < 2) return void 0;
  matchingFactors.sort((a, b) => a.numericMult - b.numericMult);
  const morrieFactors = [];
  let remainingCosFactors = [];
  const sorted = [...matchingFactors];
  const currentMult = sorted[0].numericMult;
  if (currentMult > 0) {
    morrieFactors.push(sorted[0]);
    const used = /* @__PURE__ */ new Set([0]);
    let nextMult = currentMult * 2;
    while (true) {
      const idx = sorted.findIndex(
        (f, i) => !used.has(i) && Math.abs(f.numericMult - nextMult) < 1e-10
      );
      if (idx === -1) break;
      morrieFactors.push(sorted[idx]);
      used.add(idx);
      nextMult *= 2;
    }
    remainingCosFactors = sorted.filter((_, i) => !used.has(i));
  }
  if (morrieFactors.length < 2) return void 0;
  const minMult = morrieFactors[0].numericMult;
  const allOtherFactors = [...otherFactors];
  for (const f of remainingCosFactors) {
    const cosArg = f.symbolicCoeff.isSame(ce.One) ? f.arg : ce._fn("Multiply", [f.symbolicCoeff, f.arg]);
    allOtherFactors.push(ce._fn("Cos", [cosArg]));
  }
  for (const f of nonMatchingCosFactors) {
    const cosArg = f.symbolicCoeff.isSame(ce.One) ? f.arg : ce._fn("Multiply", [f.symbolicCoeff, f.arg]);
    allOtherFactors.push(ce._fn("Cos", [cosArg]));
  }
  const n = morrieFactors.length;
  const minCoeff = morrieFactors[0].symbolicCoeff;
  const powerOf2n = Math.pow(2, n);
  if (baseArg.symbol === "Pi") {
    const targetCoeff = 1 / (powerOf2n + 1);
    if (Math.abs(minMult - targetCoeff) < 1e-10) {
      const result2 = ce.number([1, powerOf2n]);
      if (allOtherFactors.length === 0) return result2;
      return result2.mul(
        allOtherFactors.length === 1 ? allOtherFactors[0] : ce._fn("Multiply", allOtherFactors)
      );
    }
  }
  const finalCoeff = minCoeff.mul(powerOf2n);
  const smallArg = minCoeff.isSame(ce.One) ? baseArg : ce._fn("Multiply", [minCoeff, baseArg]);
  const largeArg = ce._fn("Multiply", [finalCoeff, baseArg]);
  const sinNumerator = ce._fn("Sin", [largeArg]);
  const sinDenominator = ce._fn("Sin", [smallArg]);
  const result = sinNumerator.div(ce.number(powerOf2n).mul(sinDenominator));
  if (allOtherFactors.length === 0) return result;
  return result.mul(
    allOtherFactors.length === 1 ? allOtherFactors[0] : ce._fn("Multiply", allOtherFactors)
  );
}
function applyTRmorrie(expr) {
  return mapSubexpressions(expr, TRmorrie);
}
function extractSquaredTrig(op) {
  if (op.operator === "Power" && op.op2?.is(2)) {
    const base = op.op1;
    if (base?.operator === "Sin" && base.op1) {
      return { func: "Sin", arg: base.op1, coef: 1 };
    }
    if (base?.operator === "Cos" && base.op1) {
      return { func: "Cos", arg: base.op1, coef: 1 };
    }
  }
  if (op.operator === "Multiply" && op.ops) {
    let coef = 1;
    let trigPower;
    for (const factor3 of op.ops) {
      if (factor3.operator === "Power" && factor3.op2?.is(2)) {
        const base = factor3.op1;
        if (base?.operator === "Sin" || base?.operator === "Cos") {
          trigPower = factor3;
        }
      } else if (typeof factor3.re === "number" && factor3.im === 0) {
        coef *= factor3.re;
      }
    }
    if (trigPower) {
      const base = trigPower.op1;
      if (base.operator === "Sin" && base.op1) {
        return { func: "Sin", arg: base.op1, coef };
      }
      if (base.operator === "Cos" && base.op1) {
        return { func: "Cos", arg: base.op1, coef };
      }
    }
  }
  return null;
}
function TRpythagorean(expr) {
  const ce = expr.engine;
  if (expr.operator !== "Add") return void 0;
  const ops = expr.ops;
  if (!ops || ops.length < 2) return void 0;
  const trigTerms = [];
  const otherTerms = [];
  const constantTerms = [];
  for (let i = 0; i < ops.length; i++) {
    const op = ops[i];
    const extracted = extractSquaredTrig(op);
    if (extracted) {
      trigTerms.push({ ...extracted, index: i });
    } else if (typeof op.re === "number" && op.im === 0 && op.isNumberLiteral) {
      constantTerms.push({ value: op.re, index: i });
    } else {
      otherTerms.push({ expr: op, index: i });
    }
  }
  for (let i = 0; i < trigTerms.length; i++) {
    for (let j = i + 1; j < trigTerms.length; j++) {
      const a = trigTerms[i];
      const b = trigTerms[j];
      if (a.arg.isSame(b.arg) && (a.func === "Sin" && b.func === "Cos" || a.func === "Cos" && b.func === "Sin")) {
        if (Math.abs(a.coef - b.coef) < 1e-10) {
          const coef = a.coef;
          const usedIndices = /* @__PURE__ */ new Set([a.index, b.index]);
          const remaining = ops.filter((_, k) => !usedIndices.has(k));
          if (remaining.length === 0) {
            return ce.number(coef);
          }
          if (coef === 1) {
            return ce._fn("Add", [ce.One, ...remaining]);
          }
          return ce._fn("Add", [ce.number(coef), ...remaining]);
        }
      }
    }
  }
  for (const trig of trigTerms) {
    if (trig.coef < 0) {
      const absCoef = Math.abs(trig.coef);
      for (const constant of constantTerms) {
        if (Math.abs(constant.value - absCoef) < 1e-10) {
          const usedIndices = /* @__PURE__ */ new Set([trig.index, constant.index]);
          const remaining = ops.filter((_, k) => !usedIndices.has(k));
          const otherFunc = trig.func === "Sin" ? "Cos" : "Sin";
          const result = ce._fn(otherFunc, [trig.arg]).pow(2).mul(absCoef);
          if (remaining.length === 0) {
            return result;
          }
          return ce._fn("Add", [result, ...remaining]);
        }
      }
    }
  }
  return void 0;
}
function applyTRpythagorean(expr) {
  return mapSubexpressions(expr, TRpythagorean);
}

// src/compute-engine/symbolic/fu-cost.ts
var TRIG_FUNCS = /* @__PURE__ */ new Set(["Sin", "Cos", "Tan", "Cot", "Sec", "Csc"]);
function countTrigFunctions(expr) {
  let count = 0;
  if (TRIG_FUNCS.has(expr.operator)) {
    count = 1;
  }
  if (expr.ops) {
    for (const op of expr.ops) {
      count += countTrigFunctions(op);
    }
  }
  return count;
}
function countLeaves2(expr) {
  if (expr.symbol) return 1;
  if (expr.isNumberLiteral) return 1;
  let count = 1;
  if (expr.ops) {
    for (const op of expr.ops) {
      count += countLeaves2(op);
    }
  }
  return count;
}
function trigCost(expr) {
  const trigCount = countTrigFunctions(expr);
  const leaves = countLeaves2(expr);
  return trigCount * 1e3 + leaves;
}
var DEFAULT_TRIG_COST = trigCost;

// src/compute-engine/symbolic/fu.ts
function bestOf(exprs, measure) {
  if (exprs.length === 0) throw new Error("bestOf called with empty array");
  if (exprs.length === 1) return exprs[0];
  let best = exprs[0];
  let bestCost = measure(best);
  for (let i = 1; i < exprs.length; i++) {
    const cost = measure(exprs[i]);
    if (cost < bestCost) {
      best = exprs[i];
      bestCost = cost;
    }
  }
  return best;
}
function tryTransform(expr, transform) {
  const result = transform(expr);
  if (result.isSame(expr)) return null;
  return result;
}
function CTR1(expr, measure) {
  const tr5Result = tryTransform(expr, applyTR5);
  const tr6Result = tryTransform(expr, applyTR6);
  const candidates = [expr];
  if (tr5Result) candidates.push(tr5Result);
  if (tr6Result) candidates.push(tr6Result);
  return bestOf(candidates, measure);
}
function CTR2(expr, measure) {
  return CTR1(expr, measure);
}
function CTR3(expr, measure) {
  const tr8Result = tryTransform(expr, applyTR8);
  const candidates = [expr];
  if (tr8Result) {
    candidates.push(tr8Result);
    const tr8_tr10i = tryTransform(tr8Result, applyTR10i);
    if (tr8_tr10i) candidates.push(tr8_tr10i);
  }
  return bestOf(candidates, measure);
}
function CTR4(expr, measure) {
  const tr10iResult = tryTransform(expr, applyTR10i);
  const candidates = [expr];
  if (tr10iResult) candidates.push(tr10iResult);
  return bestOf(candidates, measure);
}
function RL1(expr, measure) {
  let result = applyTR12(expr);
  result = applyTR13(result);
  return result;
}
function RL2(expr, measure) {
  let result = expr;
  result = applyTR10(result);
  result = applyTR11(result);
  result = applyTR5(result);
  result = applyTR7(result);
  result = applyTR11(result);
  result = CTR3(result, measure);
  result = CTR1(result, measure);
  result = applyTR9(result);
  result = CTR2(result, measure);
  result = applyTR9(result);
  result = CTR4(result, measure);
  return result;
}
function fu(expr, options) {
  if (!hasTrigFunction(expr)) return void 0;
  const measure = options?.measure ?? DEFAULT_TRIG_COST;
  const maxIterations = options?.maxIterations ?? 100;
  let result = expr;
  let iterations = 0;
  let bestResult = expr;
  let bestCost = measure(expr);
  const updateBest = (candidate) => {
    const cost = measure(candidate);
    if (cost < bestCost) {
      bestResult = candidate;
      bestCost = cost;
    }
  };
  result = applyTR3(result);
  updateBest(result);
  const tr22iEarly = applyTR22i(result);
  updateBest(tr22iEarly);
  const tr22Early = applyTR22(result);
  updateBest(tr22Early);
  result = bestResult;
  const tr7iEarly = applyTR7i(result);
  updateBest(tr7iEarly);
  result = bestResult;
  if (hasOperator(result, "Sec", "Csc")) {
    result = applyTR1(result);
    bestResult = result;
    bestCost = measure(result);
  }
  if (hasOperator(result, "Tan", "Cot")) {
    const rl1Result = RL1(result, measure);
    updateBest(rl1Result);
    result = rl1Result;
  }
  if (hasOperator(result, "Tan", "Cot")) {
    result = applyTR2(result);
    updateBest(result);
  }
  if (hasOperator(result, "Sin", "Cos")) {
    const tr9Early = applyTR9(result);
    updateBest(tr9Early);
    result = bestResult;
  }
  if (hasOperator(result, "Sin", "Cos")) {
    let prevCost = measure(result);
    while (iterations < maxIterations) {
      iterations++;
      const rl2Result = RL2(result, measure);
      const newCost = measure(rl2Result);
      updateBest(rl2Result);
      if (newCost >= prevCost) break;
      result = rl2Result;
      prevCost = newCost;
    }
  }
  const tr2iResult = applyTR2i(bestResult);
  updateBest(tr2iResult);
  const tr11iResult = applyTR11i(bestResult);
  updateBest(tr11iResult);
  const morrieResult = applyTRmorrie(bestResult);
  updateBest(morrieResult);
  const tr7iResult = applyTR7i(bestResult);
  updateBest(tr7iResult);
  const tr22iResult = applyTR22i(bestResult);
  updateBest(tr22iResult);
  const tr10iResult = applyTR10i(bestResult);
  updateBest(tr10iResult);
  const pythagoreanResult = applyTRpythagorean(bestResult);
  updateBest(pythagoreanResult);
  const tr12iResult = applyTR12i(bestResult);
  updateBest(tr12iResult);
  if (bestResult.operator === "Add" || bestResult.operator === "Multiply") {
    const simplified = expr.engine.box(bestResult.json);
    updateBest(simplified);
  }
  if (bestResult.isSame(expr)) return void 0;
  return { value: bestResult, because: "fu" };
}

// src/compute-engine/boxed-expression/simplify.ts
var BASIC_ARITHMETIC = [
  "Add",
  "Subtract",
  "Multiply",
  "Divide",
  "Negate",
  "Power",
  "Rational"
];
var CONSTRUCTIBLE_TRIG = ["Sin", "Cos", "Tan", "Csc", "Sec", "Cot"];
function containsConstructibleTrig(expr) {
  if (CONSTRUCTIBLE_TRIG.includes(expr.operator)) return true;
  if (!expr.ops) return false;
  return expr.ops.some((op) => containsConstructibleTrig(op));
}
function evaluateNumericSubexpressions(expr) {
  if (expr.isNumberLiteral) return expr;
  if (!expr.ops) return expr;
  if (expr.operator === "Power") {
    if (expr.op1?.symbol === "ExponentialE") {
      return expr;
    }
    if (expr.op2?.isRational === true && expr.op2?.isInteger === false) {
      return expr;
    }
  }
  if (expr.unknowns.length === 0 && BASIC_ARITHMETIC.includes(expr.operator)) {
    const evaluated = expr.evaluate();
    if (evaluated.isNumberLiteral) return evaluated;
  }
  const newOps = expr.ops.map((op) => evaluateNumericSubexpressions(op));
  const changed = newOps.some((op, i) => op !== expr.ops[i]);
  if (!changed) return expr;
  return expr.engine._fn(expr.operator, newOps);
}
function simplify(expr, options, steps) {
  const hasSeen = (x) => steps && steps.some((y) => y.value.isSame(x));
  if (hasSeen(expr)) return steps;
  const MAX_SIMPLIFY_STEPS = 1e3;
  if (steps && steps.length >= MAX_SIMPLIFY_STEPS) {
    console.warn(
      `Simplification exceeded ${MAX_SIMPLIFY_STEPS} steps, stopping to prevent infinite recursion`
    );
    return steps;
  }
  if (!steps) steps = [{ value: expr, because: "initial" }];
  if (!expr.isValid) return steps;
  if (!(expr.isCanonical || expr.isStructural)) {
    const canonical2 = expr.canonical;
    if (!(canonical2.isCanonical || canonical2.isStructural)) return steps;
    return simplify(canonical2, options);
  }
  const ce = expr.engine;
  if (options?.strategy === "fu") {
    const costFn = (e) => ce.costFunction(e);
    const fuFirst = fu(expr);
    let result1 = fuFirst?.value ?? expr;
    if (fuFirst) {
      const postSimplified = result1.simplify();
      if (!postSimplified.isSame(result1)) {
        result1 = postSimplified;
      }
    }
    const preSimplified = expr.simplify();
    const fuSecond = fu(preSimplified);
    let result2 = fuSecond?.value ?? preSimplified;
    if (fuSecond) {
      const postSimplified = result2.simplify();
      if (!postSimplified.isSame(result2)) {
        result2 = postSimplified;
      }
    }
    const cost1 = costFn(result1);
    const cost2 = costFn(result2);
    const bestResult = cost1 <= cost2 ? result1 : result2;
    if (!bestResult.isSame(expr)) {
      steps.push({ value: bestResult, because: "fu" });
    }
    return steps;
  }
  const rules = options?.rules ? ce.rules(options.rules, { canonical: true }) : ce.getRuleSet("standard-simplification");
  options = { ...options, rules };
  do {
    const newSteps = simplifyExpression(expr, rules, options, steps);
    if (newSteps.length <= steps.length) break;
    expr = newSteps.at(-1).value;
    steps = newSteps;
  } while (!steps.slice(0, -1).some((x) => x.value.isSame(expr)));
  return steps;
}
function isCheaper(oldExpr, newExpr, costFunction2) {
  if (newExpr === null || newExpr === void 0) return false;
  if (oldExpr === newExpr) return false;
  if (oldExpr.isSame(newExpr)) return false;
  const ce = oldExpr.engine;
  costFunction2 ??= (x) => ce.costFunction(x);
  const oldCost = costFunction2(oldExpr);
  const newCost = costFunction2(newExpr);
  if (newCost <= 1.3 * oldCost) return true;
  return false;
}
function simplifyOperands(expr, options) {
  if (!expr.ops) return expr;
  const def = expr.operatorDefinition;
  if (def?.scoped === true) {
    const simplifiedOps2 = expr.ops.map((x, i) => {
      if (i === 0) return x;
      return simplify(x, options).at(-1).value;
    });
    return expr.engine._fn(expr.operator, simplifiedOps2);
  }
  const ops = holdMap(expr, (x) => x);
  if (def?.lazy) {
    const simplifiedOps2 = ops.map((x) => {
      if (x.operator === "Sum" || x.operator === "Product" || containsConstructibleTrig(x)) {
        return simplify(x, options).at(-1).value;
      }
      if (x.operator === "Power" && x.op2?.isRational === true && !x.op2.isInteger) {
        return simplify(x, options).at(-1).value;
      }
      return evaluateNumericSubexpressions(x);
    });
    return expr.engine.function(expr.operator, simplifiedOps2);
  }
  if (expr.operator === "Divide") {
    const simplifiedOps2 = ops.map((x) => evaluateNumericSubexpressions(x));
    const changed = simplifiedOps2.some((op, i) => op !== ops[i]);
    if (!changed) return expr;
    return expr.engine._fn(expr.operator, simplifiedOps2);
  }
  const simplifiedOps = ops.map((x) => {
    if (!x.isNumberLiteral && x.ops && x.unknowns.length === 0) {
      if (BASIC_ARITHMETIC.includes(x.operator)) {
        if (x.operator === "Power") {
          if (x.op1?.symbol === "ExponentialE") return x;
          if (x.op2?.isRational === true && x.op2?.isInteger === false)
            return x;
        }
        const evaluated = x.evaluate();
        if (evaluated.isNumberLiteral) return evaluated;
      }
    }
    if (x.ops) {
      return simplify(x, options).at(-1).value;
    }
    return x;
  });
  return expr.engine._fn(expr.operator, simplifiedOps);
}
function simplifyExpression(expr, rules, options, steps) {
  if (expr.isNumberLiteral || expr.string) return steps;
  if (expr.symbol) {
    const result2 = replace(expr, rules, {
      recursive: false,
      canonical: true,
      useVariations: false
    });
    if (result2.length > 0) return [...steps, ...result2];
    return steps;
  }
  const alt = simplifyOperands(expr, options);
  if (!alt.isSame(expr)) {
    steps = [...steps, { value: alt, because: "simplified operands" }];
    expr = alt;
  }
  const result = simplifyNonCommutativeFunction(expr, rules, options, steps);
  if (result.length > steps.length) return result;
  return steps;
}
function simplifyNonCommutativeFunction(expr, rules, options, steps) {
  const result = replace(expr, rules, {
    recursive: false,
    canonical: true,
    useVariations: options.useVariations ?? false
  });
  if (result.length === 0) return steps;
  let last = result.at(-1).value;
  if (last.isSame(expr)) return steps;
  last = simplifyOperands(last);
  if (!isCheaper(expr, last, options?.costFunction)) return steps;
  result.at(-1).value = last;
  return [...steps, ...result];
}

// src/compute-engine/boxed-expression/boxed-function.ts
init_arithmetic_mul_div();
init_arithmetic_add();
init_arithmetic_power();
init_numerics();
init_abstract_boxed_expression();
init_order();
init_utils5();

// src/compute-engine/boxed-expression/match.ts
init_boxed_patterns();
init_utils5();
function hasWildcards(expr) {
  if (typeof expr === "string") return expr.startsWith("_");
  if (isWildcard(expr)) return true;
  if (expr.ops)
    return hasWildcards(expr.operator) || expr.ops.some(hasWildcards);
  return false;
}
function captureWildcard(wildcard, expr, substitution) {
  console.assert(wildcard.startsWith("_"));
  if (wildcard === "_" || wildcard === "__" || wildcard === "___")
    return substitution;
  if (wildcard in substitution) {
    if (!expr.isSame(substitution[wildcard])) return null;
    return substitution;
  }
  if (hasWildcards(expr)) return null;
  return { ...substitution, [wildcard]: expr };
}
function matchOnce(expr, pattern, substitution, options) {
  if (isWildcard(pattern))
    return captureWildcard(wildcardName(pattern), expr, substitution);
  const acceptVariants = options.acceptVariants ?? true;
  options = { ...options, acceptVariants: true };
  if (pattern.numericValue !== null) {
    if (expr.numericValue === null) return null;
    if (pattern.isEqual(expr)) return substitution;
    if (!acceptVariants) return null;
    return matchVariations(expr, pattern, substitution, options);
  }
  const str = pattern.string;
  if (str !== null) return expr.string === str ? substitution : null;
  const symbol2 = pattern.symbol;
  if (symbol2 !== null) {
    if (symbol2 === expr.symbol) return substitution;
    if (!acceptVariants) return null;
    return matchVariations(expr, pattern, substitution, options);
  }
  if (pattern.ops) {
    const useVariations = options.useVariations ?? false;
    const ce = expr.engine;
    let result = null;
    const operator2 = pattern.operator;
    if (operator2 === "Divide" && expr.numericValue !== null && !expr.denominator.is(1)) {
      const divideExpr = ce.function(
        "Divide",
        [expr.numerator, expr.denominator],
        { canonical: false, structural: true }
      );
      return matchArguments(divideExpr, pattern.ops, substitution, options);
    }
    if (operator2 === "Divide" && expr.operator === "Multiply") {
      const ops = expr.ops;
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        if (op.numericValue !== null && op.numerator.is(1) && !op.denominator.is(1)) {
          const others = ops.filter((_, j) => j !== i);
          const numerator = others.length === 1 ? others[0] : ce.function("Multiply", others, { canonical: false });
          const divideExpr = ce.function(
            "Divide",
            [numerator, op.denominator],
            { canonical: false, structural: true }
          );
          const result2 = matchArguments(
            divideExpr,
            pattern.ops,
            substitution,
            options
          );
          if (result2 !== null) return result2;
        }
      }
    }
    if (operator2 === "Power" && expr.operator === "Divide" && expr.op1.is(1)) {
      const powerExpr = ce.function("Power", [expr.op2, ce.number(-1)], {
        canonical: false,
        structural: true
      });
      const result2 = matchArguments(
        powerExpr,
        pattern.ops,
        substitution,
        options
      );
      if (result2 !== null) return result2;
    }
    if (operator2 === "Power" && expr.operator === "Root") {
      const powerExpr = ce.function(
        "Power",
        [expr.op1, ce.box(["Divide", 1, expr.op2], { canonical: false })],
        { canonical: false, structural: true }
      );
      const result2 = matchArguments(
        powerExpr,
        pattern.ops,
        substitution,
        options
      );
      if (result2 !== null) return result2;
    }
    if (operator2.startsWith("_")) {
      result = captureWildcard(operator2, ce.box(expr.operator), substitution);
      if (result !== null)
        result = matchArguments(expr, pattern.ops, result, options);
    } else if (operator2 === expr.operator) {
      const matchPerms = options.matchPermutations ?? true;
      result = pattern.operatorDefinition.commutative && matchPerms ? matchPermutation(expr, pattern, substitution, options) : matchArguments(expr, pattern.ops, substitution, options);
    }
    if (result === null && useVariations) {
      if (!acceptVariants) return null;
      result = matchVariations(expr, pattern, substitution, options);
    }
    if (result !== null) substitution = result;
    if (options.recursive && expr.ops)
      result = matchRecursive(expr, pattern, substitution, {
        ...options,
        acceptVariants
      }) ?? result;
    return result;
  }
  return null;
}
function matchRecursive(expr, pattern, substitution, options) {
  console.assert(expr.ops !== null);
  let result = null;
  for (const op of expr.ops) {
    const r = matchOnce(op, pattern, substitution, options);
    if (r !== null) {
      result = r;
      substitution = r;
    }
  }
  return result;
}
function matchVariations(expr, pattern, substitution, options) {
  if (!options.useVariations) return null;
  const ce = expr.engine;
  const varOptions = { ...options, acceptVariants: false };
  const matchVariation = (op, ops) => matchOnce(
    ce.function(op, ops, { canonical: false }),
    pattern,
    substitution,
    varOptions
  );
  const operator2 = pattern.operator;
  if (operator2 === "Negate") {
    if (expr.is(0))
      return matchOnce(ce.Zero, pattern.op1, substitution, varOptions);
  }
  if (operator2 === "Add") {
    let result = matchVariation("Add", [0, expr]);
    if (result !== null) return result;
    if (expr.operator === "Subtract")
      result = matchVariation("Add", [expr.op1, ["Negate", expr.op2]]);
    if (result !== null) return result;
  }
  if (operator2 === "Subtract") {
    let result = matchVariation("Subtract", [expr, 0]);
    if (result !== null) return result;
    if (expr.operator === "Negate")
      result = matchVariation("Subtract", [0, expr.op1]);
    if (result !== null) return result;
  }
  if (operator2 === "Multiply") {
    let result = matchVariation("Multiply", [1, expr]);
    if (result !== null) return result;
    if (expr.operator === "Negate") {
      result = matchVariation("Multiply", [-1, expr.op1]);
      if (result !== null) return result;
    }
    if (expr.operator === "Divide") {
      result = matchVariation("Multiply", [
        expr.op1,
        ["Divide", 1, expr.op2]
      ]);
      if (result !== null) return result;
    }
  }
  if (operator2 === "Divide") {
    const result = matchVariation("Divide", [expr, 1]);
    if (result !== null) return result;
  }
  if (operator2 === "Square") {
    const result = matchVariation("Power", [expr, 2]);
    if (result !== null) return result;
  }
  if (operator2 === "Exp") {
    const result = matchVariation("Power", [ce.E, expr]);
    if (result !== null) return result;
  }
  if (operator2 === "Power") {
    if (pattern.op2.re === 2 && pattern.op2.im === 0) {
      const result = matchVariation("Square", [expr]);
      if (result !== null) return result;
    }
    if (pattern.op1.symbol === "ExponentialE") {
      const result = matchVariation("Exp", [expr]);
      if (result !== null) return result;
    }
    {
      const result = matchVariation("Power", [expr, 1]);
      if (result !== null) return result;
    }
  }
  return null;
}
function matchPermutation(expr, pattern, substitution, options) {
  console.assert(expr.operator === pattern.operator);
  const patternOps = pattern.ops;
  const exprOps = expr.ops;
  let universalCount = 0;
  let sequenceCount = 0;
  let optionalSequenceCount = 0;
  let anchorCount = 0;
  for (const op of patternOps) {
    const wType = wildcardType(op);
    if (wType === null) {
      anchorCount++;
    } else if (wType === "Wildcard") {
      universalCount++;
    } else if (wType === "Sequence") {
      sequenceCount++;
    } else {
      optionalSequenceCount++;
    }
  }
  if (sequenceCount === 0 && optionalSequenceCount === 0) {
    if (exprOps.length !== patternOps.length) return null;
  } else {
    const minRequired = anchorCount + universalCount + sequenceCount;
    if (exprOps.length < minRequired) return null;
  }
  if (anchorCount > 0) {
    if (anchorCount >= 4 && exprOps.length >= 6) {
      const hashIndex = /* @__PURE__ */ new Map();
      for (let i = 0; i < exprOps.length; i++) {
        const h = exprOps[i].hash;
        const bucket = hashIndex.get(h);
        if (bucket) bucket.push(i);
        else hashIndex.set(h, [i]);
      }
      const usedIndices = /* @__PURE__ */ new Set();
      for (const op of patternOps) {
        if (!hasWildcards(op)) {
          const h = op.hash;
          const candidates = hashIndex.get(h);
          if (!candidates) return null;
          let found = false;
          for (const idx of candidates) {
            if (!usedIndices.has(idx) && exprOps[idx].isSame(op)) {
              usedIndices.add(idx);
              found = true;
              break;
            }
          }
          if (!found) return null;
        }
      }
    } else {
      const availableOps = [...exprOps];
      for (const op of patternOps) {
        if (!hasWildcards(op)) {
          const idx = availableOps.findIndex((e) => e.isSame(op));
          if (idx === -1) return null;
          availableOps.splice(idx, 1);
        }
      }
    }
  }
  const hasSequenceWildcard = sequenceCount > 0 || optionalSequenceCount > 0;
  const hasAnchor = anchorCount > 0;
  if (hasAnchor) {
    const result = matchCommutativeWithAnchors(
      expr,
      pattern,
      substitution,
      options
    );
    if (result !== null) return result;
  }
  const cond = (xs) => !xs.some((x, index) => {
    if (!isWildcard(x)) return false;
    const xType = wildcardType(x);
    if (xType !== "Sequence" && xType !== "OptionalSequence") return false;
    const next = xs[index + 1];
    if (!next || !isWildcard(next)) return false;
    const nextType = wildcardType(next);
    return nextType === "Sequence" || nextType === "OptionalSequence";
  });
  const patterns = permutations(patternOps, cond);
  for (const pat of patterns) {
    const result = matchArguments(expr, pat, substitution, options);
    if (result !== null) return result;
  }
  return null;
}
var MAX_COMBINATIONS = 1e3;
function anchorSpecificity(anchor) {
  if (anchor.isNumberLiteral) return 100;
  if (anchor.symbol) return 80;
  if (anchor.string !== void 0) return 90;
  if (anchor.operator) {
    const opCount = anchor.nops ?? 0;
    let nonWildcardChildren = 0;
    if (anchor.ops) {
      for (const op of anchor.ops) {
        if (wildcardType(op) === null) nonWildcardChildren++;
      }
    }
    return 50 + opCount + nonWildcardChildren * 5;
  }
  return 0;
}
function matchCommutativeWithAnchors(expr, pattern, substitution, options) {
  const ce = expr.engine;
  const patternOps = pattern.ops;
  const exprOps = [...expr.ops];
  const anchors = [];
  const universalWildcards = [];
  const sequenceWildcards = [];
  const optionalSeqWildcards = [];
  for (const op of patternOps) {
    const wType = wildcardType(op);
    if (wType === null) {
      anchors.push(op);
    } else if (wType === "Wildcard") {
      universalWildcards.push(op);
    } else if (wType === "Sequence") {
      sequenceWildcards.push(op);
    } else {
      optionalSeqWildcards.push(op);
    }
  }
  const minNeeded = anchors.length + universalWildcards.length + sequenceWildcards.length;
  const maxAllowed = anchors.length + universalWildcards.length + (sequenceWildcards.length + optionalSeqWildcards.length > 0 ? Infinity : 0);
  if (exprOps.length < minNeeded) return null;
  if (sequenceWildcards.length === 0 && optionalSeqWildcards.length === 0 && exprOps.length > maxAllowed)
    return null;
  const sortedAnchors = [...anchors].sort(
    (a, b) => anchorSpecificity(b) - anchorSpecificity(a)
  );
  return tryMatchAnchors(0, exprOps, substitution);
  function tryMatchAnchors(anchorIndex, remainingOps, sub3) {
    if (anchorIndex >= sortedAnchors.length) {
      return assignWildcards(remainingOps, sub3);
    }
    const anchorsLeft = sortedAnchors.length - anchorIndex;
    const minWildcardNeeds = universalWildcards.length + sequenceWildcards.length;
    if (remainingOps.length < anchorsLeft + minWildcardNeeds) {
      return null;
    }
    const anchor = sortedAnchors[anchorIndex];
    for (let i = 0; i < remainingOps.length; i++) {
      const matchResult = matchOnce(remainingOps[i], anchor, sub3, options);
      if (matchResult !== null) {
        const newRemaining = [...remainingOps];
        newRemaining.splice(i, 1);
        const finalResult = tryMatchAnchors(
          anchorIndex + 1,
          newRemaining,
          matchResult
        );
        if (finalResult !== null) return finalResult;
      }
    }
    return null;
  }
  function assignWildcards(remainingOps, sub3) {
    const result = sub3;
    const neededForUniversal = universalWildcards.length;
    const minNeededForSequence = sequenceWildcards.length;
    const totalNeeded = neededForUniversal + minNeededForSequence;
    if (remainingOps.length < totalNeeded) return null;
    return tryAssignWildcards(
      [...universalWildcards, ...sequenceWildcards, ...optionalSeqWildcards],
      remainingOps,
      result
    );
  }
  function tryAssignWildcards(wildcards, remaining, sub3) {
    if (wildcards.length === 0) {
      return remaining.length === 0 ? sub3 : null;
    }
    const [wc, ...restWildcards] = wildcards;
    const wcType = wildcardType(wc);
    const wcName = wildcardName(wc);
    if (wcType === "Wildcard") {
      for (let i = 0; i < remaining.length; i++) {
        const newSub = captureWildcard(wcName, remaining[i], sub3);
        if (newSub !== null) {
          const newRemaining = [...remaining];
          newRemaining.splice(i, 1);
          const result = tryAssignWildcards(
            restWildcards,
            newRemaining,
            newSub
          );
          if (result !== null) return result;
        }
      }
      return null;
    }
    if (wcType === "Sequence") {
      const minCapture = 1;
      const maxCapture2 = remaining.length - countMinNeeded(restWildcards);
      for (let count = maxCapture2; count >= minCapture; count--) {
        const combinations = getCombinations(remaining.length, count);
        for (const indices of combinations) {
          const captured = indices.map((i) => remaining[i]);
          const capturedExpr = wrapCaptured(captured);
          const newSub = captureWildcard(wcName, capturedExpr, sub3);
          if (newSub !== null) {
            const newRemaining = remaining.filter(
              (_, i) => !indices.includes(i)
            );
            const result = tryAssignWildcards(
              restWildcards,
              newRemaining,
              newSub
            );
            if (result !== null) return result;
          }
        }
      }
      return null;
    }
    const maxCapture = remaining.length - countMinNeeded(restWildcards);
    for (let count = maxCapture; count >= 0; count--) {
      if (count === 0) {
        const identity = expr.operator === "Add" ? ce.Zero : expr.operator === "Multiply" ? ce.One : ce.Nothing;
        const newSub = captureWildcard(wcName, identity, sub3);
        if (newSub !== null) {
          const result = tryAssignWildcards(restWildcards, remaining, newSub);
          if (result !== null) return result;
        }
      } else {
        const combinations = getCombinations(remaining.length, count);
        for (const indices of combinations) {
          const captured = indices.map((i) => remaining[i]);
          const capturedExpr = wrapCaptured(captured);
          const newSub = captureWildcard(wcName, capturedExpr, sub3);
          if (newSub !== null) {
            const newRemaining = remaining.filter(
              (_, i) => !indices.includes(i)
            );
            const result = tryAssignWildcards(
              restWildcards,
              newRemaining,
              newSub
            );
            if (result !== null) return result;
          }
        }
      }
    }
    return null;
  }
  function countMinNeeded(wildcards) {
    return wildcards.reduce((sum2, wc) => {
      const wType = wildcardType(wc);
      if (wType === "Wildcard") return sum2 + 1;
      if (wType === "Sequence") return sum2 + 1;
      return sum2;
    }, 0);
  }
  function wrapCaptured(captured) {
    if (captured.length === 1) return captured[0];
    const def = ce.lookupDefinition(expr.operator);
    if (def && isOperatorDef(def) && def.operator.associative) {
      return ce.function(expr.operator, captured, { canonical: false });
    }
    return ce.function("Sequence", captured, { canonical: false });
  }
  function getCombinations(n, k) {
    if (n > 20 && k > 2 && k < n - 2) {
      let approxCount = 1;
      for (let i = 0; i < Math.min(k, n - k); i++) {
        approxCount = approxCount * (n - i) / (i + 1);
        if (approxCount > MAX_COMBINATIONS) return [];
      }
    }
    const result = [];
    const combo = [];
    function backtrack(start) {
      if (result.length >= MAX_COMBINATIONS) return;
      if (combo.length === k) {
        result.push([...combo]);
        return;
      }
      for (let i = start; i < n; i++) {
        combo.push(i);
        backtrack(i + 1);
        combo.pop();
      }
    }
    backtrack(0);
    return result;
  }
}
function matchArguments(expr, patterns, substitution, options) {
  if (patterns.length === 0) {
    if (expr.ops && expr.ops.length === 0) return substitution;
    return null;
  }
  const ce = patterns[0].engine;
  const ops = [...expr.ops];
  return matchRemaining(patterns, substitution);
  function matchRemaining(patterns2, substitution2) {
    let result = { ...substitution2 };
    let i = 0;
    while (i < patterns2.length) {
      const pat = patterns2[i];
      const argName = wildcardName(pat);
      if (argName !== null) {
        if (argName.startsWith("__")) {
          const nextPattern = patterns2[i + 1];
          const isOptionalSeq = argName.startsWith("___");
          if (nextPattern === void 0) {
            if (ops.length === 0 && !isOptionalSeq) return null;
            result = captureWildcard(argName, captureOps(ops.length), result);
          } else {
            let j = isOptionalSeq ? 0 : 1;
            console.assert(
              !(isWildcard(nextPattern) && wildcardType(nextPattern) === "Sequence")
            );
            let nextAppPattern = nextPattern;
            let nextAppPatternIndex = i + 1;
            while (isWildcard(nextAppPattern) && wildcardType(nextAppPattern) === "OptionalSequence") {
              if (!patterns2[nextAppPatternIndex + 1]) break;
              nextAppPattern = patterns2[++nextAppPatternIndex];
            }
            let found = false;
            while (!found && j < ops.length) {
              found = matchOnce(ops[j], nextAppPattern, result, options) !== null;
              if (!found) j += 1;
            }
            if (!found) {
              if (!isOptionalSeq) return null;
              result = captureWildcard(argName, captureOps(0), result);
            } else {
              if (nextAppPattern !== nextPattern) {
                let wildcardIndex = i + 1;
                while (wildcardIndex < nextAppPatternIndex && result !== null) {
                  result = captureWildcard(
                    wildcardName(patterns2[wildcardIndex++]),
                    captureOps(0),
                    result
                  );
                }
                if (result === null) return null;
              }
              const savedSubstitution = result;
              while (j <= ops.length) {
                const capturedOps = ops.slice(0, j);
                result = matchRemaining(
                  patterns2.slice(nextAppPatternIndex),
                  captureWildcard(argName, captureOps(j), savedSubstitution) ?? savedSubstitution
                );
                if (result) break;
                ops.unshift(...capturedOps);
                j++;
                if (j >= ops.length) break;
                if (!matchOnce(
                  ops[j - 1],
                  nextAppPattern,
                  savedSubstitution,
                  options
                ))
                  break;
              }
              return result;
            }
          }
        } else if (argName.startsWith("_")) {
          if (ops.length === 0) return null;
          result = captureWildcard(argName, ops.shift(), result);
        } else {
          result = matchOnce(ops.shift(), pat, result, options);
        }
      } else {
        const arg = ops.shift();
        if (!arg) return null;
        result = matchOnce(arg, pat, result, options);
      }
      if (result === null) return null;
      i += 1;
    }
    if (ops.length > 0) return null;
    return result;
    function captureOps(qty) {
      let value;
      if (qty < 1) {
        if (expr.operator === "Add") value = ce.Zero;
        else if (expr.operator === "Multiply") value = ce.One;
        else value = ce.Nothing;
      } else if (qty === 1) {
        value = ops.shift();
      } else {
        const def = ce.lookupDefinition(expr.operator);
        const args = ops.splice(0, qty);
        if (def && isOperatorDef(def) && def.operator.associative) {
          value = ce.function(expr.operator, args, { canonical: false });
        } else {
          value = ce.function("Sequence", args, { canonical: false });
        }
      }
      return value;
    }
  }
}
function match(subject, pattern, options) {
  pattern = pattern.structural;
  const useVariations = options?.useVariations ?? false;
  const opts = {
    recursive: options?.recursive ?? false,
    useVariations,
    acceptVariants: useVariations,
    matchPermutations: options?.matchPermutations ?? true
  };
  const substitution = options?.substitution ?? {};
  return matchOnce(subject.structural, pattern.structural, substitution, opts);
}

// src/compute-engine/boxed-expression/sgn.ts
function sgn(expr) {
  const ce = expr.engine;
  if (expr.operator === "Hold") return void 0;
  let s = void 0;
  if (expr.ops) {
    const def = expr.operatorDefinition;
    if (def?.sgn) s = def.sgn(expr.ops, { engine: ce });
    return s;
  }
  if (expr.symbol || expr.isNumberLiteral) return expr.sgn;
  return "unsigned";
}
function positiveSign(s) {
  if (s === void 0) return void 0;
  if (s === "positive") return true;
  if (["non-positive", "zero", "negative"].includes(s))
    return false;
  return void 0;
}
function nonNegativeSign(s) {
  if (s === void 0) return void 0;
  if (["positive", "positive-infinity", "non-negative", "zero"].includes(s))
    return true;
  if (s === "negative") return false;
  return void 0;
}
function negativeSign(s) {
  if (s === void 0) return void 0;
  if (s === "negative") return true;
  if (["non-negative", "zero", "positive"].includes(s))
    return false;
  return void 0;
}
function nonPositiveSign(s) {
  if (s === void 0) return void 0;
  if (["negative", "non-positive", "zero"].includes(s))
    return true;
  if (["positive", "positive-infinity"].includes(s)) return false;
  return void 0;
}

// src/compute-engine/boxed-expression/cache.ts
function cachedValue(v, generation, fn) {
  v.generation = generation;
  v.value = fn();
  return v.value;
}

// src/compute-engine/boxed-expression/boxed-function.ts
init_function_utils();
var DEFAULT_MATERIALIZATION = [5, 5];
var BoxedFunction = class extends _BoxedExpression {
  // The operator of the function expression
  _operator;
  // The operands of the function expression
  _ops;
  // Only canonical expressions have an associated def (are bound)
  // If `null`, the expression is not bound, if `undefined`, the expression
  // is bound but no definition was found.
  _def;
  /** @todo: wrong. If the function is scoped (has its own lexical scope), the captured eval context. This includes the lexical scope for this expression
   */
  _capturedContext;
  /** If the operator is scoped, the local scope associated with
   * the function expression
   */
  _localScope;
  _isPure;
  _isStructural;
  _hash;
  // Cached properties of the expression
  _value = {
    value: null,
    generation: -1
  };
  _valueN = {
    value: null,
    generation: -1
  };
  _sgn = {
    value: null,
    generation: -1
  };
  _type = {
    value: null,
    generation: -1
  };
  constructor(ce, operator2, ops, options) {
    super(ce, options?.metadata);
    this._operator = operator2;
    this._ops = ops;
    this._localScope = options?.scope;
    this._isStructural = options?.structural ?? false;
    if (options?.canonical || this._isStructural) this.bind();
  }
  get hash() {
    if (this._hash !== void 0) return this._hash;
    let h = 0;
    for (const op of this._ops) h = h << 1 ^ op.hash | 0;
    h = h ^ hashCode(this._operator) | 0;
    this._hash = h;
    return h;
  }
  /**
   * For function expressions, `infer()` infers the result type of the function
   * based on the provided type and inference mode.
   */
  infer(t, inferenceMode) {
    const def = this.operatorDefinition;
    if (!def || !def.inferredSignature) return false;
    if (def.signature.is("function")) {
      def.signature = new BoxedType(
        { kind: "signature", result: t },
        this.engine._typeResolver
      );
    } else if (isSignatureType(def.signature.type)) {
      const oldSig = def.signature.type;
      def.signature = new BoxedType(
        {
          kind: "signature",
          args: oldSig.args,
          optArgs: oldSig.optArgs,
          variadicArg: oldSig.variadicArg,
          variadicMin: oldSig.variadicMin,
          result: inferenceMode === "narrow" ? narrow(oldSig.result, t) : widen(oldSig.result, t)
        },
        this.engine._typeResolver
      );
    }
    this.engine._generation += 1;
    return true;
  }
  bind() {
    this._def = lookup(
      this._operator,
      this._localScope ?? this.engine.context.lexicalScope
    );
  }
  reset() {
  }
  get value() {
    return void 0;
  }
  get isCanonical() {
    return this._def !== void 0 && this._def !== null && !this._isStructural;
  }
  get isPure() {
    if (this._isPure !== void 0) return this._isPure;
    let pure = this.operatorDefinition?.pure ?? false;
    if (pure) pure = this._ops.every((x) => x.isPure);
    this._isPure = pure;
    return pure;
  }
  get isConstant() {
    return this.isPure && this._ops.every((x) => x.isConstant);
  }
  get constantValue() {
    return this.isConstant ? this.value : void 0;
  }
  get json() {
    return [this._operator, ...this.structural.ops.map((x) => x.json)];
  }
  get operator() {
    return this._operator;
  }
  get ops() {
    return this._ops;
  }
  get nops() {
    return this._ops.length;
  }
  get op1() {
    return this._ops[0] ?? this.engine.Nothing;
  }
  get op2() {
    return this._ops[1] ?? this.engine.Nothing;
  }
  get op3() {
    return this._ops[2] ?? this.engine.Nothing;
  }
  get isScoped() {
    return this._localScope !== void 0;
  }
  get localScope() {
    return this._localScope;
  }
  get isValid() {
    if (this._operator === "Error") return false;
    return this._ops.every((x) => x?.isValid);
  }
  /** Note: if the expression is not canonical, this will return a canonical
   * version of the expression in the current lexical scope.
   */
  get canonical() {
    if (this.isCanonical || !this.isValid) return this;
    return this.engine.function(this._operator, this._ops);
  }
  get structural() {
    if (this.isStructural) return this;
    const def = this.operatorDefinition;
    if (def?.associative || def?.commutative) {
      const xs = this.ops.map((x) => x.structural);
      let ys = [];
      if (!def.associative) ys = xs;
      else {
        for (const x of xs) {
          if (x.operator === this.operator) ys.push(...x.ops);
          else ys.push(x);
        }
      }
      return this.engine.function(
        this._operator,
        this.isValid ? sortOperands(this._operator, ys) : ys,
        {
          canonical: false,
          structural: true
        }
      );
    }
    return this.engine.function(
      this._operator,
      this.ops.map((x) => x.structural),
      { canonical: false, structural: true }
    );
  }
  get isStructural() {
    return this._isStructural;
  }
  toNumericValue() {
    console.assert(this.isCanonical || this.isStructural);
    const ce = this.engine;
    if (this.operator === "Complex") {
      return [ce._numericValue({ re: this.op1.re, im: this.op2.re }), ce.One];
    }
    let expr = this;
    if (expr.operator === "Add") {
      expr = factor(this);
      if (expr.numericValue !== null) {
        if (typeof expr.numericValue === "number") {
          if (Number.isInteger(expr.numericValue))
            return [ce._numericValue(expr.numericValue), ce.One];
        } else if (expr.numericValue.isExact)
          return [expr.numericValue, ce.One];
      }
    }
    if (expr.operator === "Negate") {
      const [coef, rest] = expr.op1.toNumericValue();
      return [coef.neg(), rest];
    }
    if (expr.operator === "Multiply") {
      const rest = [];
      let coef = ce._numericValue(1);
      for (const arg of expr.ops) {
        const [c, r] = arg.toNumericValue();
        coef = coef.mul(c);
        if (!r.is(1)) rest.push(r);
      }
      if (rest.length === 0) return [coef, ce.One];
      if (rest.length === 1) return [coef, rest[0]];
      return [coef, canonicalMultiply(this.engine, rest)];
    }
    if (expr.operator === "Divide") {
      const [coef1, numer] = expr.op1.toNumericValue();
      const [coef2, denom] = expr.op2.toNumericValue();
      const coef = coef1.div(coef2);
      if (denom.is(1)) return [coef, numer];
      return [coef, ce.function("Divide", [numer, denom])];
    }
    if (expr.operator === "Power") {
      if (expr.op2.numericValue === null) return [ce._numericValue(1), this];
      let [coef, base] = expr.op1.toNumericValue();
      if (coef.isOne) return [coef, this];
      const exponent = asSmallInteger(expr.op2);
      if (exponent !== null)
        return [coef.pow(exponent), ce.function("Power", [base, expr.op2])];
      if (expr.op2.is(0.5)) return [coef.sqrt(), ce.function("Sqrt", [base])];
      return [ce._numericValue(1), this];
    }
    if (expr.operator === "Sqrt") {
      const [coef, rest] = expr.op1.toNumericValue();
      if (rest.is(1) || rest.is(0)) {
        if (coef.isOne || coef.isZero) return [coef, rest];
        return [coef.sqrt(), rest];
      }
      return [coef.sqrt(), ce.function("Sqrt", [rest])];
    }
    if (expr.operator === "Root") {
      const exp3 = expr.op2.re;
      if (isNaN(exp3) || expr.op2.im !== 0) return [ce._numericValue(1), this];
      const [coef, rest] = expr.op1.toNumericValue();
      if (exp3 === 2) return [coef.sqrt(), ce.function("Sqrt", [rest])];
      return [coef.root(exp3), ce.function("Root", [rest, expr.op2])];
    }
    if (expr.operator === "Abs") {
      const [coef, rest] = expr.op1.toNumericValue();
      return [coef.abs(), ce.function("Abs", [rest])];
    }
    console.assert(expr.operator !== "Complex");
    console.assert(expr.operator !== "Exp");
    if (expr.operator === "Log" || expr.operator === "Ln")
      return [ce._numericValue(1), this];
    return [ce._numericValue(1), expr];
  }
  /**
   * Note: the result is bound to the current scope, not the scope of the
   * original expression.
   * <!-- This may or may not be desirable -->
   */
  subs(sub3, options) {
    options ??= { canonical: void 0 };
    if (options.canonical === void 0)
      options = { canonical: this.isCanonical || this.isStructural };
    const ops = this._ops.map((x) => x.subs(sub3, options));
    if (!ops.every((x) => x.isValid))
      return this.engine.function(this._operator, ops, { canonical: false });
    return this.engine.function(this._operator, ops, options);
  }
  replace(rules, options) {
    return replace(this, rules, options).at(-1)?.value ?? null;
  }
  match(pattern, options) {
    return match(this, pattern, options);
  }
  has(v) {
    if (typeof v === "string") {
      if (this._operator === v) return true;
    } else if (v.includes(this._operator)) return true;
    return this._ops.some((x) => x.has(v));
  }
  get sgn() {
    const gen = this.isPure && this._ops.every((x) => x.isConstant) ? void 0 : this.engine._generation;
    return cachedValue(this._sgn, gen, () => {
      if (!this.isValid || this.isNumber !== true) return void 0;
      return sgn(this);
    });
  }
  get isNaN() {
    if (!this.isNumber) return false;
    return void 0;
  }
  get isInfinity() {
    if (!this.isNumber) return false;
    return void 0;
  }
  // Not +- Infinity, not NaN
  get isFinite() {
    if (this.isNumber !== true) return false;
    if (this.isNaN || this.isInfinity) return false;
    if (this.isNaN === void 0 || this.isInfinity === void 0)
      return void 0;
    return true;
  }
  get isOne() {
    if (this.isNonPositive === true || this.isReal === false) return false;
    return void 0;
  }
  get isNegativeOne() {
    if (this.isNonNegative === true || this.isReal === false) return false;
    return void 0;
  }
  // x > 0
  get isPositive() {
    return positiveSign(this.sgn);
  }
  // x >= 0
  get isNonNegative() {
    return nonNegativeSign(this.sgn);
  }
  // x < 0
  get isNegative() {
    return negativeSign(this.sgn);
  }
  // x <= 0
  get isNonPositive() {
    return nonPositiveSign(this.sgn);
  }
  get numerator() {
    return this.numeratorDenominator[0];
  }
  get denominator() {
    return this.numeratorDenominator[1];
  }
  get numeratorDenominator() {
    if (!(this.isCanonical || this.isStructural)) return [this, this.engine.One];
    if (this.isNumber !== true)
      return [this.engine.Nothing, this.engine.Nothing];
    const operator2 = this.operator;
    if (operator2 === "Divide") return [this.op1, this.op2];
    if (operator2 === "Negate") {
      const [num, denom] = this.op1.numeratorDenominator;
      return [num.neg(), denom];
    }
    if (operator2 === "Power") {
      const [num, denom] = this.op1.numeratorDenominator;
      return [num.pow(this.op2), denom.pow(this.op2)];
    }
    if (operator2 === "Root") {
      const [num, denom] = this.op1.numeratorDenominator;
      return [num.root(this.op2), denom.root(this.op2)];
    }
    if (operator2 === "Sqrt") {
      const [num, denom] = this.op1.numeratorDenominator;
      return [num.sqrt(), denom.sqrt()];
    }
    if (operator2 === "Abs") {
      const [num, denom] = this.op1.numeratorDenominator;
      return [num.abs(), denom.abs()];
    }
    if (operator2 === "Multiply")
      return new Product(this.engine, this.ops).asNumeratorDenominator();
    if (operator2 === "Add") {
    }
    if (operator2 === "Log" || operator2 === "Ln") {
    }
    return [this, this.engine.One];
  }
  //
  //
  // ALGEBRAIC OPERATIONS
  //
  neg() {
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    return negate(this);
  }
  inv() {
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (this.operator === "Sqrt") return this.op1.inv().sqrt();
    if (this.operator === "Divide") return this.op2.div(this.op1);
    if (this.operator === "Power") {
      const neg2 = this.op2.neg();
      if (neg2.operator !== "Negate") return this.op1.pow(neg2);
      return this.engine.function("Power", [this.op1, neg2]);
    }
    if (this.operator === "Root") {
      const neg2 = this.op2.neg();
      if (neg2.operator !== "Negate") return this.op1.root(neg2);
      return this.engine.function("Root", [this.op1, neg2]);
    }
    if (this.operator === "Exp") return this.engine.E.pow(this.op1.neg());
    if (this.operator === "Rational") return this.op2.div(this.op1);
    if (this.operator === "Negate") return this.op1.inv().neg();
    return this.engine._fn("Divide", [this.engine.One, this]);
  }
  abs() {
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    if (this.operator === "Abs" || this.operator === "Negate") return this;
    if (this.isNonNegative) return this;
    if (this.isNonPositive) return this.neg();
    return this.engine._fn("Abs", [this]);
  }
  add(rhs) {
    if (rhs === 0) return this;
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    return add3(this, this.engine.box(rhs));
  }
  mul(rhs) {
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    if (rhs === 0) return this.engine.Zero;
    if (rhs === 1) return this;
    if (rhs === -1) return this.neg();
    if (rhs instanceof NumericValue) {
      if (rhs.isZero) return this.engine.Zero;
      if (rhs.isOne) return this;
      if (rhs.isNegativeOne) return this.neg();
    }
    return mul3(this, this.engine.box(rhs));
  }
  div(rhs) {
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    return div2(this, rhs);
  }
  pow(exp3) {
    return pow2(this, exp3, { numericApproximation: false });
  }
  root(exp3) {
    if (!(this.isCanonical || this.isStructural) || typeof exp3 !== "number" && !(exp3.isCanonical || exp3.isStructural))
      throw new Error("Not canonical");
    const e = typeof exp3 === "number" ? exp3 : exp3.im === 0 ? exp3.re : void 0;
    if (e === 0) return this.engine.NaN;
    if (e === 1) return this;
    if (e === -1) return this.inv();
    if (e === 2) return this.engine.function("Sqrt", [this]);
    if (this.operator === "Power" && e !== void 0) {
      const [base, power] = this.ops;
      return base.pow(power.div(e));
    }
    if (this.operator === "Divide") {
      const [num, denom] = this.ops;
      return num.root(exp3).div(denom.root(exp3));
    }
    if (this.operator === "Negate") {
      if (e !== void 0) {
        if (e % 2 === 0) return this.op1.root(exp3);
        return this.op1.root(exp3).neg();
      }
    }
    if (this.operator === "Sqrt") {
      if (e !== void 0) return this.op1.root(e * 2);
      if (typeof exp3 !== "number") return this.op1.root(exp3.mul(2));
    }
    if (this.operator === "Root") {
      const [base, root2] = this.ops;
      return base.root(root2.mul(exp3));
    }
    if (this.operator === "Multiply") {
      const ops = this.ops.map((x) => x.root(exp3));
      return mul3(...ops);
    }
    if (this.isNumberLiteral) {
      const v = this.numericValue;
      if (typeof v === "number") {
        if (v < 0) return this.engine.NaN;
        if (v === 0) return this.engine.Zero;
        if (v === 1) return this.engine.One;
        if (e !== void 0) {
          const r = this.engine.number(Math.pow(v, 1 / e));
          if (!r.isFinite || r.isInteger) return r;
        }
      } else {
        if (v.isOne) return this.engine.One;
        if (v.isZero) return this.engine.Zero;
        if (e !== void 0) {
          const r = v.root(e);
          if (r.isExact) return this.engine.number(r);
        }
      }
    }
    return this.engine._fn("Root", [this, this.engine.box(exp3)]);
  }
  sqrt() {
    return this.root(2);
  }
  ln(semiBase) {
    const base = semiBase ? this.engine.box(semiBase) : void 0;
    if (!(this.isCanonical || this.isStructural)) throw new Error("Not canonical");
    if (this.is(0)) return this.engine.NegativeInfinity;
    if (this.operator === "Exp") {
      if (!base) return this.op1;
      return this.op1.div(base.ln());
    }
    if (base && this.isSame(base)) return this.engine.One;
    if (this.isSame(this.engine.E)) {
      if (!base) return this.engine.One;
      return this.engine.One.div(base.ln());
    }
    if (this.operator === "Power") {
      const [b, exp3] = this.ops;
      if (b.isSame(this.engine.E)) {
        if (!base) return exp3;
        return exp3.div(base.ln());
      }
      return exp3.mul(b.ln(base));
    }
    if (this.operator === "Root") {
      const [a, b] = this.ops;
      return b.div(a.ln(base));
    }
    if (this.operator === "Sqrt") return this.op1.ln(base).div(2);
    if (this.operator === "Divide")
      return this.op1.ln(base).sub(this.op2.ln(base));
    if (base && base.type.matches("finite_integer")) {
      if (base.re === 10) return this.engine._fn("Log", [this]);
      return this.engine._fn("Log", [this, base]);
    }
    return this.engine._fn("Ln", [this]);
  }
  get complexity() {
    if (!(this.isCanonical || this.isStructural)) return void 0;
    return this.operatorDefinition?.complexity ?? DEFAULT_COMPLEXITY;
  }
  get baseDefinition() {
    if (!this._def) return void 0;
    return isOperatorDef(this._def) ? this._def.operator : this._def.value;
  }
  get operatorDefinition() {
    if (!this._def) return void 0;
    return isOperatorDef(this._def) ? this._def.operator : void 0;
  }
  get valueDefinition() {
    if (!this._def) return void 0;
    return isValueDef(this._def) ? this._def.value : void 0;
  }
  get isNumber() {
    if (this.type.isUnknown) return void 0;
    return isSubtype(this.type.type, "number");
  }
  get isInteger() {
    if (this.type.isUnknown) return void 0;
    return isSubtype(this.type.type, "integer");
  }
  get isRational() {
    if (this.type.isUnknown) return void 0;
    return isSubtype(this.type.type, "rational");
  }
  get isReal() {
    if (this.type.isUnknown) return void 0;
    return isSubtype(this.type.type, "real");
  }
  get isFunctionExpression() {
    return true;
  }
  /** The type of the value of the function */
  get type() {
    const gen = this.isPure && this._ops.every((x) => x.isConstant) ? void 0 : this.engine._generation;
    return cachedValue(
      this._type,
      gen,
      () => new BoxedType(type(this), this.engine._typeResolver)
    ) ?? BoxedType.unknown;
  }
  /** The shape of the tensor (dimensions), derived from the type */
  get shape() {
    const t = this.type.type;
    if (typeof t === "object" && t.kind === "list" && t.dimensions)
      return t.dimensions;
    return [];
  }
  /** The rank of the tensor (number of dimensions), derived from the type */
  get rank() {
    return this.shape.length;
  }
  simplify(options) {
    return simplify(this, options).at(-1)?.value ?? this;
  }
  evaluate(options) {
    return withDeadline(this.engine, this._computeValue(options))();
  }
  evaluateAsync(options) {
    return withDeadlineAsync(this.engine, this._computeValueAsync(options))();
  }
  N() {
    return this.evaluate({ numericApproximation: true });
  }
  solve(vars) {
    const varNames = normalizedUnknownsForSolve(vars ?? this.unknowns);
    if (this.operator === "List") {
      const equations = this.ops;
      if (equations && equations.every((eq2) => eq2.operator === "Equal")) {
        const linearResult = solveLinearSystem([...equations], varNames);
        if (linearResult) return linearResult;
        const polyResult = solvePolynomialSystem([...equations], varNames);
        if (polyResult) return polyResult;
      }
      const inequalityOps = ["Less", "LessEqual", "Greater", "GreaterEqual"];
      if (equations && equations.every((eq2) => inequalityOps.includes(eq2.operator ?? ""))) {
        const inequalityResult = solveLinearInequalitySystem(
          [...equations],
          varNames
        );
        if (inequalityResult) return inequalityResult;
      }
    }
    if (varNames.length !== 1) return null;
    return findUnivariateRoots(this, varNames[0]);
  }
  get isCollection() {
    if (!this.isValid) return false;
    const def = this.baseDefinition?.collection;
    console.assert(
      !def || def.count !== void 0 && def.iterator !== void 0
    );
    return def !== void 0;
  }
  get isIndexedCollection() {
    if (!this.isValid) return false;
    const def = this.baseDefinition?.collection;
    if (!def?.at) return false;
    return this.type.matches("indexed_collection");
  }
  get isLazyCollection() {
    if (!this.isValid) return false;
    const def = this.baseDefinition?.collection;
    if (!def) return false;
    return def?.isLazy?.(this) ?? false;
  }
  contains(rhs) {
    return this.baseDefinition?.collection?.contains?.(this, rhs);
  }
  get count() {
    return this.operatorDefinition?.collection?.count?.(this);
  }
  get isEmptyCollection() {
    if (!this.isCollection) return void 0;
    return this.operatorDefinition?.collection?.isEmpty?.(this);
  }
  get isFiniteCollection() {
    if (!this.isCollection) return void 0;
    return this.operatorDefinition?.collection?.isFinite?.(this);
  }
  each() {
    const iter = this.operatorDefinition?.collection?.iterator?.(this);
    if (!iter) return (function* () {
    })();
    return (function* () {
      let result = iter.next();
      let i = 0;
      while (!result.done) {
        i += 1;
        yield result.value;
        result = iter.next();
      }
    })();
  }
  at(index) {
    return this.operatorDefinition?.collection?.at?.(this, index);
  }
  get(index) {
    if (typeof index === "string")
      return this.operatorDefinition?.collection?.at?.(this, index);
    if (!index.string) return void 0;
    return this.operatorDefinition?.collection?.at?.(this, index.string);
  }
  indexWhere(predicate2) {
    if (this.operatorDefinition?.collection?.indexWhere)
      return this.operatorDefinition.collection.indexWhere(this, predicate2);
    if (!this.isIndexedCollection) return void 0;
    if (!this.isFiniteCollection) return void 0;
    let i = 0;
    for (const x of this.each()) {
      if (predicate2(x)) return i;
      i += 1;
    }
    return void 0;
  }
  subsetOf(rhs, strict) {
    return this.operatorDefinition?.collection?.subsetOf?.(this, rhs, strict) ?? false;
  }
  _computeValue(options) {
    return () => {
      if (!this.isValid || !this._def) return this;
      const numericApproximation = options?.numericApproximation ?? false;
      const materialization = options?.materialization ?? false;
      if (isValueDef(this._def))
        return applyFunctionLiteral(this, this._def.value, options);
      const def = this._def.operator;
      const hasTensors = this.ops.some((x) => isBoxedTensor(x));
      const skipBroadcastForTensors = hasTensors && (this.operator === "Add" || this.operator === "Multiply");
      if (def.broadcastable && this.ops.some((x) => isFiniteIndexedCollection(x)) && !skipBroadcastForTensors) {
        const items = zip(this._ops);
        if (!items) return this.engine.Nothing;
        const results = [];
        while (true) {
          const { done, value } = items.next();
          if (done) break;
          results.push(this.engine._fn(this.operator, value).evaluate(options));
        }
        if (results.length === 0) return this.engine.Nothing;
        if (results.length === 1) return results[0];
        return this.engine._fn("List", results);
      }
      if (materialization !== false && !def.evaluate && this.isLazyCollection)
        return materialize(this, def, options);
      const tail = holdMap(this, (x) => x.evaluate(options));
      const isScoped = this._localScope !== void 0 || options?.withArguments;
      if (isScoped) {
        this.engine._pushEvalContext(
          this._localScope ?? {
            parent: this.engine.context?.lexicalScope,
            bindings: /* @__PURE__ */ new Map()
          }
        );
        if (options?.withArguments) {
          for (const [k, v] of Object.entries(options.withArguments))
            this.engine.context.values[k] = v;
        }
      }
      const evalResult = def.evaluate?.(tail, {
        numericApproximation,
        engine: this.engine,
        materialization
      });
      if (isScoped) this.engine._popEvalContext();
      return evalResult ?? this.engine.function(this._operator, tail);
    };
  }
  _computeValueAsync(options) {
    return async () => {
      if (!this.isValid || !this._def) return this;
      const numericApproximation = options?.numericApproximation ?? false;
      if (isValueDef(this._def))
        return applyFunctionLiteral(this, this._def.value, options);
      const def = this._def.operator;
      const hasTensors = this.ops.some((x) => isBoxedTensor(x));
      const skipBroadcastForTensors = hasTensors && (this.operator === "Add" || this.operator === "Multiply");
      if (def?.broadcastable && this.ops.some((x) => isFiniteIndexedCollection(x)) && !skipBroadcastForTensors) {
        const items = zip(this._ops);
        if (!items) return this.engine.Nothing;
        const results = [];
        while (true) {
          const { done, value } = items.next();
          if (done) break;
          results.push(
            this.engine._fn(this.operator, value).evaluateAsync(options)
          );
        }
        if (results.length === 0) return this.engine.Nothing;
        if (results.length === 1) return results[0];
        return Promise.all(results).then(
          (resolved) => this.engine._fn("List", resolved)
        );
      }
      const tail = await holdMapAsync(
        this,
        async (x) => await x.evaluateAsync(options)
      );
      const isScoped = this._localScope !== void 0 || options?.withArguments;
      if (isScoped) {
        this.engine._pushEvalContext(
          this._localScope ?? {
            parent: this.engine.context?.lexicalScope,
            bindings: /* @__PURE__ */ new Map()
          }
        );
        if (options?.withArguments) {
          for (const [k, v] of Object.entries(options.withArguments))
            this.engine.context.values[k] = v;
        }
      }
      const engine = this.engine;
      const opts = {
        numericApproximation,
        engine,
        signal: options?.signal,
        eager: options?.materialization
      };
      const evaluateFn = def.evaluateAsync?.(tail, opts) ?? def.evaluate?.(tail, opts);
      if (isScoped) this.engine._popEvalContext();
      return Promise.resolve(evaluateFn).then(
        (result) => result ?? engine.function(this._operator, tail)
      );
    };
  }
};
function type(expr) {
  if (!expr.isValid) return "error";
  if (expr.operator === "Function") {
    const body = expr.ops[0];
    const bodyType = body.type;
    const args = expr.ops.slice(1);
    return parseType(
      `(${args.map((_) => "unknown").join(", ")}) -> ${bodyType}`,
      expr.engine._typeResolver
    );
  }
  const def = expr.operatorDefinition;
  if (def) {
    const sig = def.signature instanceof BoxedType ? def.signature.type : typeof def.signature === "string" ? parseType(def.signature, expr.engine._typeResolver) : def.signature;
    let sigResult = functionResult(sig) ?? "unknown";
    if (typeof def.type === "function") {
      const calculatedType = def.type(expr.ops, { engine: expr.engine });
      if (calculatedType) {
        if (calculatedType instanceof BoxedType)
          sigResult = calculatedType.type;
        else
          sigResult = parseType(calculatedType, expr.engine._typeResolver) ?? sigResult;
      }
    }
    return sigResult;
  }
  if (expr.valueDefinition)
    return functionResult(expr.valueDefinition.type.type) ?? "unknown";
  return "unknown";
}
function withDeadline(engine, fn) {
  return () => {
    if (engine._deadline === void 0) {
      engine._deadline = Date.now() + engine.timeLimit;
      const result = fn();
      engine._deadline = void 0;
      return result;
    }
    return fn();
  };
}
function withDeadlineAsync(engine, fn) {
  return async () => {
    if (engine._deadline === void 0) {
      engine._deadline = Date.now() + engine.timeLimit;
      const result = await fn();
      engine._deadline = void 0;
      return result;
    }
    return fn();
  };
}
function applyFunctionLiteral(expr, def, options) {
  const value = def.isConstant ? def.value : expr.engine._getSymbolValue(expr.operator);
  if (value && !value.type.matches("function")) {
    if (!value.isValid) return expr;
    return expr.engine.typeError("function", value.type, value.toString());
  }
  const ops = expr.ops.map((x) => x.evaluate(options));
  if (!value || value.type.isUnknown)
    return expr.engine.function(expr.operator, ops);
  return apply3(value, ops);
}
function materialize(expr, def, options) {
  if (!expr.isValid || options?.materialization === false) return expr;
  let materialization = options?.materialization ?? false;
  if (typeof materialization === "boolean")
    materialization = DEFAULT_MATERIALIZATION;
  const isIndexed = expr.isIndexedCollection;
  const isFinite2 = expr.isFiniteCollection;
  const xs = [];
  if (!expr.isEmptyCollection) {
    if (!isIndexed || !isFinite2) {
      const last = typeof materialization === "number" ? materialization : materialization[0];
      const iter = expr.each();
      for (const x of iter) {
        if (xs.length === last) {
          if (!iter.next().done)
            xs.push(expr.engine.symbol("ContinuationPlaceholder"));
          break;
        }
        xs.push(x.evaluate(options));
      }
    } else {
      const [headSize, tailSize] = typeof materialization === "number" ? [
        Math.ceil(materialization / 2),
        materialization - Math.ceil(materialization / 2)
      ] : materialization;
      let i = 1;
      const iter = expr.each();
      for (const x of iter) {
        xs.push(x.evaluate(options));
        i += 1;
        if (i > headSize) break;
      }
      const count = expr.count;
      if (count === void 0 || count <= headSize) {
        if (count === void 0 || xs.length < count)
          xs.push(expr.engine.symbol("ContinuationPlaceholder"));
      } else {
        const tailStartIndex = Math.max(headSize + 1, count - tailSize + 1);
        if (count > headSize + tailSize) {
          xs.push(expr.engine.symbol("ContinuationPlaceholder"));
        }
        i = tailStartIndex;
        while (i <= count) {
          const x = expr.at(i);
          if (!x) break;
          xs.push(x.evaluate(options));
          i += 1;
        }
      }
    }
  }
  const elttype = def.collection?.elttype?.(expr);
  if (elttype && isSubtype(elttype, "tuple<string, any>")) {
    return expr.engine.function("Dictionary", xs);
  }
  if (isIndexed) return expr.engine._fn("List", xs);
  return expr.engine.function("Set", [...xs]);
}

// src/compute-engine/boxed-expression/boxed-string.ts
init_abstract_boxed_expression();
init_utils5();
init_boxed_patterns();
init_boxed_type();
init_utils2();
var BoxedString = class _BoxedString extends _BoxedExpression {
  [Symbol.toStringTag] = "[BoxedString]";
  _string;
  _utf8Buffer;
  _unicodeScalarValues;
  constructor(ce, expr, metadata) {
    super(ce, metadata);
    this._string = expr.normalize();
  }
  get json() {
    return !(matchesSymbol(this._string) && !matchesNumber(this._string)) ? `'${this._string}'` : this._string;
  }
  get hash() {
    return hashCode("String" + this._string);
  }
  get operator() {
    return "String";
  }
  get isPure() {
    return true;
  }
  get isCanonical() {
    return true;
  }
  set isCanonical(_va) {
    return;
  }
  get value() {
    return this;
  }
  get type() {
    return BoxedType.string;
  }
  get complexity() {
    return 19;
  }
  get string() {
    return this._string;
  }
  get buffer() {
    if (this._utf8Buffer === void 0) {
      const encoder = new TextEncoder();
      this._utf8Buffer = encoder.encode(this._string);
    }
    return this._utf8Buffer;
  }
  get unicodeScalars() {
    if (this._unicodeScalarValues === void 0) {
      this._unicodeScalarValues = toUnicodeScalarValues(this._string);
    }
    return this._unicodeScalarValues;
  }
  match(pattern, _options) {
    if (!isBoxedExpression(pattern))
      pattern = this.engine.box(pattern, { canonical: false });
    if (isWildcard(pattern)) return { [wildcardName(pattern)]: this };
    if (!(pattern instanceof _BoxedString)) return null;
    if (this._string === pattern._string) return {};
    return null;
  }
};
function toUnicodeScalarValues(str) {
  const scalarValues = [];
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    scalarValues.push(codePoint);
    if (codePoint > 65535) i++;
  }
  return scalarValues;
}

// src/compute-engine/boxed-expression/box.ts
init_boxed_tensor();

// src/compute-engine/boxed-expression/boxed-dictionary.ts
init_abstract_boxed_expression();
init_utils5();
init_boxed_patterns();
init_utils();
var BoxedDictionary = class _BoxedDictionary extends _BoxedExpression {
  [Symbol.toStringTag] = "[BoxedDictionary]";
  _keyValues = {};
  _type;
  /** The input to the constructor is either a ["Dictionary", ["KeyValuePair", ..., ...], ...] expression or a record of key-value pairs */
  constructor(ce, keyValues, options) {
    super(ce, options?.metadata);
    if (keyValues instanceof _BoxedExpression) {
      this._initFromExpression(keyValues, options);
    } else {
      this._initFromRecord(
        keyValues,
        options
      );
    }
  }
  _initFromRecord(keyValues, options) {
    for (const key in keyValues) {
      if (typeof key !== "string") {
        throw new Error(
          `Dictionary keys must be strings, but got ${typeof key}`
        );
      }
      if (key.length === 0)
        throw new Error("Dictionary keys must not be empty strings");
      this._keyValues[key] = dictionaryValueToBoxedExpression(
        this.engine,
        keyValues[key],
        options
      );
    }
  }
  _initFromExpression(dictionary, options) {
    if (dictionary instanceof _BoxedDictionary) {
      Object.assign(this._keyValues, dictionary._keyValues);
      return;
    }
    if (dictionary.operator === "Tuple" || dictionary.operator === "Pair" || dictionary.operator === "KeyValuePair") {
      if (dictionary.nops !== 2) {
        throw new Error(
          `Expected a key/value pair, got ${dictionary.nops} elements`
        );
      }
      const [key, value] = dictionary.ops;
      let k;
      if (key.string) k = key.string;
      else if (key.symbol) k = key.symbol;
      else throw new Error(`Expected a string key, got ${key.type}`);
      this._keyValues[k] = value.canonical;
      return;
    }
    if (dictionary.operator === "Dictionary") {
      for (const pair of dictionary.ops) {
        if (pair.operator === "KeyValuePair" || pair.operator === "Pair" || pair.operator === "Tuple") {
          const [key, value] = pair.ops;
          let k;
          if (key.string) k = key.string;
          else if (key.symbol) k = key.symbol;
          else return;
          this._keyValues[k] = value.canonical;
        } else throw new Error(`Expected a key/value pair, got ${pair.type}`);
      }
      return;
    }
  }
  get json() {
    return {
      dict: Object.fromEntries(
        Object.entries(this._keyValues).map(([k, v]) => [
          k,
          boxedExpressionToDictionaryValue(v)
        ])
      )
    };
  }
  toMathJson(options) {
    if (options.shorthands.includes("dictionary")) {
      const result2 = this.json;
      return result2;
    }
    if (this.isEmptyCollection) return { dict: {} };
    const result = {};
    for (const [key, value] of this.entries)
      result[key] = value.toMathJson(options);
    return { dict: result };
  }
  get hash() {
    return hashCode("Dictionary" + JSON.stringify(this._keyValues));
  }
  get operator() {
    return "Dictionary";
  }
  get type() {
    if (this._type) return this._type;
    const eltType = widen(
      ...Object.values(this._keyValues).map((op) => op.type.type)
    );
    this._type = this.engine.type(`dictionary<${eltType}>`);
    return this._type;
  }
  get isPure() {
    return true;
  }
  get isCanonical() {
    return true;
  }
  set isCanonical(_va) {
    return;
  }
  get value() {
    return void 0;
  }
  get complexity() {
    return 1e3;
  }
  get isCollection() {
    return true;
  }
  get isIndexedCollection() {
    return false;
  }
  get isLazyCollection() {
    return false;
  }
  contains(_rhs) {
    return void 0;
  }
  get count() {
    return Object.keys(this._keyValues).length;
  }
  get isEmptyCollection() {
    return Object.keys(this._keyValues).length === 0;
  }
  get isFiniteCollection() {
    return true;
  }
  each() {
    const ce = this.engine;
    return (function* (self) {
      for (const [key, value] of Object.entries(self._keyValues)) {
        yield ce.tuple(ce.string(key), value);
      }
    })(this);
  }
  get(key) {
    return this._keyValues[key];
  }
  has(key) {
    return this._keyValues.hasOwnProperty(key);
  }
  get keys() {
    return Object.keys(this._keyValues);
  }
  get entries() {
    return Object.entries(this._keyValues);
  }
  get values() {
    return Object.values(this._keyValues);
  }
  match(pattern, _options) {
    if (isWildcard(pattern)) return { [wildcardName(pattern)]: this };
    if (!(pattern instanceof _BoxedDictionary)) return null;
    let result = null;
    const keys = Object.keys(pattern._keyValues);
    for (const key of keys) {
      if (!this._keyValues.hasOwnProperty(key)) return null;
      const value = this._keyValues[key];
      const patternValue = pattern._keyValues[key];
      if (!value.match(patternValue)) return null;
      if (isWildcard(pattern._keyValues[key])) {
        const wcKey = wildcardName(pattern._keyValues[key]);
        if (wcKey) result = { ...result ?? {}, [wcKey]: value };
      }
    }
    return result;
  }
};
function boxedExpressionToDictionaryValue(value) {
  if (value.string) return value.string;
  if (value.symbol === "True") return true;
  if (value.symbol === "False") return false;
  if (value.symbol) return { sym: value.symbol };
  if (value.numericValue !== null && value.type.matches("real"))
    return value.re;
  if (value.operator === "List")
    return value.ops.map(boxedExpressionToDictionaryValue);
  return value.toMathJson({ shorthands: [] });
}
function dictionaryValueToBoxedExpression(ce, value, options) {
  if (value === null || value === void 0) return ce.Nothing;
  if (value instanceof _BoxedExpression) return value;
  if (typeof value === "string") return ce.string(value);
  if (typeof value === "number") return ce.number(value, options);
  if (typeof value === "boolean") return value ? ce.True : ce.False;
  if (Array.isArray(value)) {
    return ce.function(
      "List",
      value.map((x) => dictionaryValueToBoxedExpression(ce, x, options))
    );
  }
  if (typeof value === "object") {
    if ("num" in value) return ce.number(value.num, options);
    if ("str" in value) return ce.string(value.str);
    if ("sym" in value) return ce.symbol(value.sym, options);
    if ("fn" in value) return ce.box(value, options);
    if ("dict" in value) return new BoxedDictionary(ce, value.dict, options);
  }
  return ce.Nothing;
}

// src/compute-engine/boxed-expression/box.ts
init_order();
init_validate();
init_flatten();
init_utils5();
init_negate();
init_canonical_utils();
function boxHold(ce, expr, options) {
  if (expr instanceof _BoxedExpression) return expr;
  expr = missingIfEmpty(expr);
  if (typeof expr === "string") return box(ce, expr, options);
  if (Array.isArray(expr)) {
    const [fnName, ...ops] = expr;
    return new BoxedFunction(
      ce,
      fnName,
      ops.map((x) => boxHold(ce, x, options)),
      { canonical: false }
    );
  }
  if (typeof expr === "object") {
    if ("fn" in expr) return boxHold(ce, expr.fn, options);
    if ("str" in expr) return new BoxedString(ce, expr.str);
    if ("sym" in expr) return box(ce, expr.sym, options);
    if ("num" in expr) return box(ce, expr.num, options);
  }
  return box(ce, expr, options);
}
function boxFunction(ce, name, ops, options) {
  options = options ? { ...options } : {};
  if (!("canonical" in options)) options.canonical = true;
  if (!isValidSymbol(name)) {
    throw new Error(
      `Unexpected operator: "${name}" is not a valid symbol: ${validateSymbol(name)}`
    );
  }
  const structural = options.structural ?? false;
  if (name === "Hold") {
    return new BoxedFunction(ce, "Hold", [boxHold(ce, ops[0], options)], {
      ...options,
      canonical: true,
      structural
    });
  }
  if (name === "Error" || name === "ErrorCode") {
    return new BoxedFunction(
      ce,
      name,
      ops.map((x) => ce.box(x, { canonical: false })),
      { metadata: options?.metadata, canonical: true }
    );
  }
  if (name === "Number" && ops.length === 1) return box(ce, ops[0], options);
  const canonicalNumber2 = structural === false && options.canonical === true;
  if (canonicalNumber2) {
    if ((name === "Divide" || name === "Rational") && ops.length === 2) {
      const n = asBigint(ops[0]);
      if (n !== null) {
        const d = asBigint(ops[1]);
        if (d !== null) {
          if (d === 0n) return n === 0n ? ce.NaN : ce.ComplexInfinity;
          return ce.number([n, d], options);
        }
      }
      name = "Divide";
    }
    if (name === "Complex") {
      if (ops.length === 1) {
        const op1 = ops[0];
        if (op1 instanceof _BoxedExpression && op1.isNumberLiteral)
          return ce.number(ce.complex(0, op1.re), options);
        const im = machineValue(ops[0]);
        if (im !== null && im !== 0)
          return ce.number(ce.complex(0, im), options);
        return ce.box(op1).mul(ce.I);
      }
      if (ops.length === 2) {
        const re = ops[0] instanceof _BoxedExpression ? ops[0].re : machineValue(ops[0]);
        const im = ops[1] instanceof _BoxedExpression ? ops[1].re : machineValue(ops[1]);
        if (im !== null && re !== null && !isNaN(im) && !isNaN(re)) {
          if (im === 0 && re === 0) return ce.Zero;
          if (im !== 0) return ce.number(ce._numericValue({ re, im }), options);
          return box(ce, ops[0], options);
        }
        return box(ce, ops[0], options).add(box(ce, ops[1], options).mul(ce.I));
      }
      throw new Error("Expected one or two arguments with Complex expression");
    }
    if (name === "Negate" && ops.length === 1) {
      const op1 = ops[0];
      if (typeof op1 === "number") return ce.number(-op1, options);
      if (op1 instanceof Decimal) return ce.number(op1.neg(), options);
      const boxedop1 = ce.box(op1, options);
      const num = boxedop1.numericValue;
      if (num !== null)
        return ce.number(typeof num === "number" ? -num : num.neg(), options);
      ops = [boxedop1];
    }
  }
  if (options.canonical === true)
    return makeCanonicalFunction(
      ce,
      name,
      ops,
      options.metadata,
      options.scope
    );
  return canonicalForm(
    new BoxedFunction(
      ce,
      name,
      ops.map(
        (x) => box(ce, x, {
          canonical: options.canonical,
          structural,
          scope: options.scope
        })
      ),
      {
        metadata: options.metadata,
        canonical: false,
        structural,
        scope: options.scope
      }
    ),
    options.canonical ?? false,
    options.scope
  );
}
function box(ce, expr, options) {
  if (expr === null || expr === void 0) return ce.error("missing");
  if (expr instanceof NumericValue) return fromNumericValue(ce, expr);
  if (expr instanceof _BoxedExpression)
    return canonicalForm(expr, options?.canonical ?? true, options?.scope);
  options = options ? { ...options } : {};
  if (!("canonical" in options)) options.canonical = true;
  const canonical2 = options.canonical === true;
  const structural = options.structural ?? false;
  if (Array.isArray(expr)) {
    if (typeof expr[0] !== "string")
      throw new Error(
        `The first element of an array should be a string (the function name): ${JSON.stringify(expr, void 0, 4)}`
      );
    return canonicalForm(
      boxFunction(ce, expr[0], expr.slice(1), {
        canonical: canonical2,
        structural,
        scope: options?.scope
      }),
      options?.canonical ?? true,
      options?.scope
    );
  }
  if (typeof expr === "number" || expr instanceof Decimal || expr instanceof Complex)
    return ce.number(expr);
  if (typeof expr === "string") {
    if (matchesSymbol(expr)) {
      const sym = symbol(expr);
      if (!sym || !isValidSymbol(sym)) return ce.error("invalid-symbol", expr);
      const canonicalSymbol = canonical2 || options.canonical !== false;
      return ce.symbol(sym, { canonical: canonicalSymbol });
    }
    if (matchesNumber(expr)) return ce.number(expr);
    console.assert(matchesString(expr));
    return new BoxedString(ce, stringValue(expr));
  }
  if (typeof expr === "object") {
    const metadata = hasMetaData(expr) ? {
      latex: expr.latex,
      wikidata: expr.wikidata
    } : void 0;
    if ("fn" in expr) {
      const [fnName, ...ops] = expr.fn;
      return canonicalForm(
        boxFunction(ce, fnName, ops, { canonical: canonical2, structural, metadata }),
        options.canonical,
        options.scope
      );
    }
    if ("str" in expr) return new BoxedString(ce, expr.str, metadata);
    if ("sym" in expr) return ce.symbol(expr.sym, { canonical: canonical2, metadata });
    if ("num" in expr) return ce.number(expr, { canonical: canonical2, metadata });
    if ("dict" in expr)
      return new BoxedDictionary(ce, expr.dict, { canonical: canonical2 });
    throw new Error(
      `Unexpected MathJSON object: ${JSON.stringify(expr, void 0, 4)}`
    );
  }
  return ce.symbol("Undefined");
}
function makeCanonicalFunction(ce, name, ops, metadata, scope) {
  let result = makeNumericFunction(ce, name, ops, metadata, scope);
  if (result) return result;
  if (name === "List") {
    const boxedOps = ops.map((x) => ce.box(x, { canonical: false }));
    const tensorInfo = expressionTensorInfo("List", boxedOps);
    if (tensorInfo && tensorInfo.dtype) {
      return new BoxedTensor(
        ce,
        {
          ops: canonical(ce, boxedOps, scope),
          shape: tensorInfo.shape,
          dtype: tensorInfo.dtype
        },
        { metadata }
      );
    }
    return new BoxedFunction(ce, "List", canonical(ce, boxedOps, scope), {
      canonical: true
    });
  }
  if (name === "Dictionary") {
    const boxedOps = ops.map((x) => ce.box(x, { canonical: false }));
    return new BoxedDictionary(ce, ce._fn("Dictionary", boxedOps), {
      canonical: true
    });
  }
  const def = ce.lookupDefinition(name);
  if (!def) {
    ce.declare(name, { type: "function", inferred: true });
    return new BoxedFunction(ce, name, flatten(semiCanonical(ce, ops)), {
      metadata,
      canonical: true
    });
  }
  if (isValueDef(def)) {
    return new BoxedFunction(ce, name, flatten(semiCanonical(ce, ops)), {
      metadata,
      canonical: true
    });
  }
  const opDef = def.operator;
  scope ??= opDef.scoped ? {
    parent: ce.context.lexicalScope,
    bindings: /* @__PURE__ */ new Map()
  } : void 0;
  if (opDef.lazy) {
    const xs2 = ops.map((x) => ce.box(x, { canonical: false }));
    if (opDef.canonical) {
      try {
        result = opDef.canonical(xs2, { engine: ce, scope });
        if (result) return result;
      } catch (e) {
        console.error(e.message);
      }
      result = new BoxedFunction(ce, name, xs2, {
        metadata,
        canonical: false
      });
      return result;
    }
    result = new BoxedFunction(
      ce,
      name,
      opDef.inferredSignature ? xs2 : validateArguments(
        ce,
        xs2,
        opDef.signature.type,
        opDef.lazy,
        opDef.broadcastable
      ) ?? xs2,
      { metadata, canonical: true, scope }
    );
    return result;
  }
  const xs = ops.map((x) => ce.box(x));
  if (opDef.canonical) {
    try {
      const result3 = opDef.canonical(xs, { engine: ce, scope });
      if (result3) return result3;
    } catch (e) {
      console.error(e.message);
    }
    const result2 = new BoxedFunction(ce, name, xs, {
      metadata,
      canonical: false
    });
    return result2;
  }
  const args = flatten(
    xs,
    opDef.associative ? name : void 0
  );
  const adjustedArgs = opDef.inferredSignature ? null : validateArguments(
    ce,
    args,
    opDef.signature.type,
    opDef.lazy,
    opDef.broadcastable
  );
  if (adjustedArgs) {
    return new BoxedFunction(ce, name, adjustedArgs, {
      metadata,
      canonical: true,
      scope
    });
  }
  if (args.length === 1 && args[0].operator === name) {
    if (opDef.involution) return args[0].op1;
    if (opDef.idempotent)
      return new BoxedFunction(ce, name, xs[0].ops, {
        metadata,
        canonical: true,
        scope
      });
  }
  return new BoxedFunction(ce, name, sortOperands(name, args), {
    metadata,
    canonical: true,
    scope
  });
}
function makeNumericFunction(ce, name, semiOps, metadata, scope) {
  let ops = [];
  if (name === "Add" || name === "Multiply")
    ops = checkNumericArgs(ce, semiCanonical(ce, semiOps, scope), {
      flatten: name
    });
  else if (name === "Negate" || name === "Square" || name === "Sqrt" || name === "Exp")
    ops = checkNumericArgs(ce, semiCanonical(ce, semiOps, scope), 1);
  else if (name === "Ln" || name === "Log") {
    ops = checkNumericArgs(ce, semiCanonical(ce, semiOps, scope));
    if (ops.length === 0) ops = [ce.error("missing")];
  } else if (name === "Power" || name === "Root")
    ops = checkNumericArgs(ce, semiCanonical(ce, semiOps, scope), 2);
  else if (name === "Divide") {
    ops = checkNumericArgs(ce, semiCanonical(ce, semiOps, scope));
    if (ops.length === 0) ops = [ce.error("missing"), ce.error("missing")];
    if (ops.length === 1) ops = [ops[0], ce.error("missing")];
  } else return null;
  if (!ops.every((x) => x.isValid))
    return new BoxedFunction(ce, name, ops, { metadata, canonical: true });
  if (name === "Add") return canonicalAdd(ce, ops);
  if (name === "Negate") return canonicalNegate(ops[0]);
  if (name === "Multiply") return canonicalMultiply(ce, ops);
  if (name === "Divide") {
    if (ops.length === 2)
      return canonicalDivide(...ops);
    return ops.slice(1).reduce((a, b) => canonicalDivide(a, b), ops[0]);
  }
  if (name === "Exp") return canonicalPower(ce.E, ops[0]);
  if (name === "Square") return canonicalPower(ops[0], ce.number(2));
  if (name === "Power") return canonicalPower(ops[0], ops[1]);
  if (name === "Root") return canonicalRoot(ops[0], ops[1]);
  if (name === "Sqrt") return canonicalRoot(ops[0], 2);
  if (name === "Ln" || name === "Log") {
    if (ops.length > 0) {
      if (ops[0].is(1)) return ce.Zero;
      if (ops.length === 1)
        return new BoxedFunction(ce, name, ops, { metadata, canonical: true });
    }
    return new BoxedFunction(ce, "Log", ops, { metadata, canonical: true });
  }
  return null;
}
function fromNumericValue(ce, value) {
  if (value.isZero) return ce.Zero;
  if (value.isOne) return ce.One;
  if (value.isNegativeOne) return ce.NegativeOne;
  if (value.isNaN) return ce.NaN;
  if (value.isNegativeInfinity) return ce.NegativeInfinity;
  if (value.isPositiveInfinity) return ce.PositiveInfinity;
  value = value.asExact ?? value;
  if (!value.isExact) {
    const im = value.im;
    if (im === 0) return ce.number(value.bignumRe ?? value.re);
    if (value.re === 0) return ce.number(ce.complex(0, im));
    if (value.bignumRe !== void 0 && !isInMachineRange(value.bignumRe)) {
      return canonicalAdd(ce, [
        ce.number(value.bignumRe),
        ce.number(ce.complex(0, im))
      ]);
    }
    return ce.number(ce.complex(value.re, value.im));
  }
  const terms = [];
  const exactValue = value;
  if (exactValue.sign !== 0) {
    if (exactValue.radical === 1) {
      terms.push(ce.number(exactValue.rational));
    } else {
      const rational = exactValue.rational;
      const radical = ce.function("Sqrt", [ce.number(exactValue.radical)]);
      if (isOne(rational)) terms.push(radical);
      else {
        const [n, d] = rational;
        if (d === 1) {
          if (n === 1) terms.push(radical);
          else terms.push(ce.function("Multiply", [ce.number(n), radical]));
        } else {
          if (n === 1)
            terms.push(ce.function("Divide", [radical, ce.number(d)]));
          else
            terms.push(
              ce.function("Divide", [
                ce.function("Multiply", [ce.number(n), radical]),
                ce.number(d)
              ])
            );
        }
      }
    }
  }
  let result;
  if (value.im === 0) {
    if (terms.length === 0) return ce.Zero;
    result = terms.length === 1 ? terms[0] : canonicalMultiply(ce, terms);
    return result;
  }
  if (terms.length === 0) return ce.number(ce.complex(0, value.im));
  result = terms.length === 1 ? terms[0] : canonicalMultiply(ce, terms);
  return canonicalAdd(ce, [result, ce.number(ce.complex(0, value.im))]);
}
function semiCanonical(ce, xs, scope) {
  if (xs.every((x) => x instanceof _BoxedExpression && x.isCanonical))
    return xs;
  return xs.map((x) => ce.box(x, { scope }));
}

// src/compute-engine/boxed-expression/expression-map.ts
var ExpressionMap = class _ExpressionMap {
  _items;
  constructor(source) {
    if (!source) {
      this._items = /* @__PURE__ */ new Map();
    } else if (source instanceof _ExpressionMap) {
      this._items = new Map(source._items);
    } else {
      this._items = new Map(
        source
      );
    }
  }
  has(expr) {
    for (const x of this._items.keys()) if (x.isSame(expr)) return true;
    return false;
  }
  get(expr) {
    for (const [x, v] of this._items) if (x.isSame(expr)) return v;
    return void 0;
  }
  clear() {
    this._items.clear();
  }
  set(expr, value) {
    for (const x of this._items.keys()) {
      if (x.isSame(expr)) {
        this._items.set(x, value);
        return;
      }
    }
    this._items.set(expr, value);
  }
  delete(expr) {
    this._items.delete(expr);
  }
  [Symbol.iterator]() {
    return this._items.entries();
  }
  entries() {
    return this._items.entries();
  }
};

// src/compute-engine/index.ts
init_utils5();
init_rules();
init_boxed_patterns();

// src/compute-engine/boxed-expression/boxed-number.ts
init_complex();
init_decimal();
init_arithmetic_mul_div();
init_numeric();
init_bigint();
init_types2();
init_exact_numeric_value();
init_rules();
init_abstract_boxed_expression();
init_utils5();
init_arithmetic_add();
init_arithmetic_power();
init_subtype();
init_boxed_type();
var BoxedNumber = class extends _BoxedExpression {
  // The value of a BoxedNumber is either a small integer or a NumericValue
  _value;
  _hash;
  /**
   * By the time the constructor is called, the `value` should have been
   * screened for cases where it's a well-known value (0, NaN, +Infinity,
   * etc...) or non-normal (complex number with im = 0, rational with
   * denom = 1, etc...).
   *
   * This is done in `ce.number()`. In general, use `ce.number()` rather
   * than calling this constructor directly.
   *
   * We may store as a machine number if a Decimal is passed that is in machine
   * range
   */
  constructor(ce, value, options) {
    super(ce, options?.metadata);
    if (value instanceof NumericValue || typeof value === "number")
      this._value = value;
    else this._value = ce._numericValue(value);
  }
  get hash() {
    this._hash ??= hashCode(this._value.toString());
    return this._hash;
  }
  get json() {
    const value = this._value;
    if (typeof value === "number") {
      if (Number.isNaN(value)) return "NaN";
      if (!Number.isFinite(value))
        return value > 0 ? "PositiveInfinity" : "NegativeInfinity";
      return value;
    }
    return value.toJSON();
  }
  get operator() {
    return "Number";
  }
  get isPure() {
    return true;
  }
  get isCanonical() {
    return true;
  }
  set isCanonical(val) {
  }
  get complexity() {
    return 1;
  }
  /**
   *
   * Return a JavaScript number when possible (most cases); else return a
   * string representation of the number (ComplexInfinity and complex numbers
   * for example).
   *
   * When a JavaScript number is returned, it may have fewer digits than the
   * original number, but it will be a close approximation.
   *
   * @returns {number | string} The value of the number.
   */
  valueOf() {
    if (typeof this._value === "number") return this._value;
    return this._value.N().valueOf();
  }
  get numericValue() {
    return this._value;
  }
  get isNumberLiteral() {
    return true;
  }
  get re() {
    if (typeof this._value === "number") return this._value;
    return this._value.re;
  }
  get im() {
    if (typeof this._value === "number") return 0;
    return this._value.im;
  }
  get bignumRe() {
    if (typeof this._value === "number") return void 0;
    return this._value.bignumRe;
  }
  get bignumIm() {
    if (typeof this._value === "number") return this.engine._BIGNUM_ZERO;
    return this.engine.bignum(this._value.im);
  }
  neg() {
    const n = this._value;
    if (n === 0) return this;
    if (typeof n === "number") return this.engine.number(-n);
    return this.engine.number(n.neg());
  }
  inv() {
    if (typeof this._value === "number") {
      if (Math.abs(this._value) === 1) return this;
      if (!Number.isInteger(this._value))
        return this.engine.number(1 / this._value);
      return this.engine.number(
        this.engine._numericValue({ rational: [1, this._value] })
      );
    }
    if (Math.abs(this.re) === 1 && this.im === 0) return this;
    return this.engine.number(this._value.inv());
  }
  abs() {
    if (this.isPositive) return this;
    if (typeof this._value === "number")
      return this.engine.number(-this._value);
    return this.engine.number(this._value.abs());
  }
  add(rhs) {
    const ce = this.engine;
    if (this.is(0)) return ce.box(rhs);
    if (typeof rhs === "number") {
      if (rhs === 0) return this;
      if (typeof this._value === "number") return ce.number(this._value + rhs);
      return ce.number(this._value.add(rhs));
    }
    if (rhs.numericValue !== null) {
      if (typeof this._value === "number") {
        if (typeof rhs.numericValue === "number")
          return ce.number(this._value + rhs.numericValue);
        return ce.number(rhs.numericValue.add(this._value));
      }
      return ce.number(this._value.add(rhs.numericValue));
    }
    return add3(this, rhs.canonical);
  }
  mul(rhs) {
    if (this.is(1)) return this.engine.box(rhs);
    if (this.is(-1)) return this.engine.box(rhs).neg();
    const ce = this.engine;
    if (typeof rhs === "number") {
      if (rhs === 1) return this;
      if (rhs === 0 || this.is(0)) return this.engine.Zero;
      if (rhs === -1) return this.neg();
      return ce.number(
        typeof this._value === "number" ? this._value * rhs : this._value.mul(rhs)
      );
    }
    if (typeof this._value === "number" && typeof rhs === "number")
      return ce.number(this._value * rhs);
    if (rhs instanceof NumericValue) {
      if (this.is(1)) return ce.number(rhs);
      if (this.is(-1)) return ce.number(rhs.neg());
      return ce.number(rhs.mul(this._value));
    }
    if (rhs.numericValue !== null)
      return ce.number(ce._numericValue(this._value).mul(rhs.numericValue));
    return mul3(this, rhs);
  }
  div(rhs) {
    return div2(this, rhs);
  }
  pow(exp3) {
    return pow2(this, exp3, { numericApproximation: false });
  }
  root(exp3) {
    if (typeof exp3 === "number") {
      if (exp3 === 0) return this.engine.NaN;
      if (exp3 === 1) return this;
      if (exp3 === -1) return this.inv();
      if (exp3 === 2) return this.sqrt();
      if (this.isNegative) {
        if (exp3 % 2 === 1) return this.neg().root(exp3).neg();
        if (exp3 % 2 === 0) return this.neg().root(exp3);
      }
    } else {
      exp3 = exp3.canonical;
      if (exp3.is(0)) return this.engine.NaN;
      if (exp3.is(1)) return this;
      if (exp3.is(-1)) return this.inv();
      if (exp3.is(2)) return this.sqrt();
      if (this.isNegative) {
        if (exp3.isOdd) return this.neg().root(exp3).neg();
        if (exp3.isEven) return this.neg().root(exp3);
      }
    }
    const n = typeof exp3 === "number" ? exp3 : exp3.re;
    if (Number.isInteger(n)) {
      if (typeof this._value === "number") {
        const r = this._value ** (1 / n);
        if (Number.isInteger(r)) return this.engine.number(r);
      } else {
        const r = this._value.root(n);
        if (isSubtype(r.type, "integer")) return this.engine.number(r);
      }
    }
    return this.engine._fn("Root", [this, this.engine.box(exp3)]);
  }
  sqrt() {
    if (typeof this._value === "number") {
      if (this._value === 0 || this._value === 1) return this;
      if (this._value === -1) return this.engine.I;
      if (this._value > 0 && Number.isInteger(this._value) && this._value < SMALL_INTEGER)
        return this.engine.number(
          this.engine._numericValue({ radical: this._value })
        );
      return this.engine.number(this.engine._numericValue(this._value).sqrt());
    }
    if (this.is(0) || this.is(1)) return this;
    return this.engine.number(this._value.sqrt());
  }
  ln(semiBase) {
    const base = semiBase ? this.engine.box(semiBase) : void 0;
    if (this.is(0)) return this.engine.NegativeInfinity;
    if (base && this.isSame(base)) return this.engine.One;
    if ((!base || base.symbol === "ExponentialE") && this.symbol === "ExponentialE")
      return this.engine.One;
    const f = this.re;
    if (Number.isInteger(f) && f > 0) {
      const ce = this.engine;
      let [factor3, root2] = canonicalInteger(f, 3);
      if (factor3 !== 1)
        return ce.number(factor3).ln(base).mul(3).add(ce.number(root2).ln(base));
      [factor3, root2] = canonicalInteger(f, 2);
      if (factor3 !== 1)
        return ce.number(factor3).ln(base).mul(2).add(ce.number(root2).ln(base));
    }
    if (base && base.isInteger) {
      if (typeof this._value === "number")
        return this.engine.number(Math.log(this._value) / Math.log(base.re));
      return this.engine.number(this._value.ln(base.re));
    }
    if (base === void 0) {
      if (typeof this._value === "number")
        return this.engine.number(Math.log(this._value));
      return this.engine.number(this._value.ln());
    }
    return this.engine._fn("Ln", [this]);
  }
  get value() {
    return this;
  }
  get type() {
    if (typeof this._value === "number") {
      if (Number.isNaN(this._value)) return BoxedType.number;
      if (!Number.isFinite(this._value)) return BoxedType.non_finite_number;
      return Number.isInteger(this._value) ? BoxedType.finite_integer : BoxedType.finite_real;
    }
    return new BoxedType(this._value.type, this.engine._typeResolver);
  }
  get sgn() {
    if (this._value === 0) return "zero";
    let s;
    if (typeof this._value === "number") s = Math.sign(this._value);
    else s = this._value.sgn();
    if (s === void 0) return "unsigned";
    if (Number.isNaN(s)) return "unsigned";
    if (s === 0) return "zero";
    if (s > 0) return "positive";
    return "negative";
  }
  get numerator() {
    if (typeof this._value === "number") return this;
    return this.engine.number(this._value.numerator);
  }
  get denominator() {
    if (typeof this._value === "number") return this.engine.One;
    return this.engine.number(this._value.denominator);
  }
  get numeratorDenominator() {
    if (typeof this._value === "number") return [this, this.engine.One];
    const ce = this.engine;
    return [
      ce.number(this._value.numerator),
      ce.number(this._value.denominator)
    ];
  }
  subs(sub3, options) {
    if (this.isStructural) return this;
    return this.structural.subs(sub3, options);
  }
  replace(rules, options) {
    return replace(this.structural, rules, options).at(-1)?.value ?? null;
  }
  match(pattern, options) {
    return match(this.structural, pattern, options);
  }
  /** x > 0, same as `isGreater(0)` */
  get isPositive() {
    if (typeof this._value === "number")
      return !Number.isNaN(this._value) && this._value > 0;
    return positiveSign(this.sgn);
  }
  /** x >= 0, same as `isGreaterEqual(0)` */
  get isNonNegative() {
    if (typeof this._value === "number")
      return !Number.isNaN(this._value) && this._value >= 0;
    return nonNegativeSign(this.sgn);
  }
  /** x < 0, same as `isLess(0)` */
  get isNegative() {
    if (typeof this._value === "number")
      return !Number.isNaN(this._value) && this._value < 0;
    return negativeSign(this.sgn);
  }
  /** x <= 0, same as `isLessEqual(0)` */
  get isNonPositive() {
    if (typeof this._value === "number")
      return !Number.isNaN(this._value) && this._value <= 0;
    return nonPositiveSign(this.sgn);
  }
  get isOdd() {
    if (this.is(1) || this.is(-1)) return true;
    if (this.is(0)) return false;
    if (!this.isFinite || !this.isInteger) return void 0;
    if (typeof this._value === "number") return this._value % 2 !== 0;
    const [n, d] = [this._value.numerator, this._value.denominator];
    if (d.isOne) {
      const re = n.re;
      return re % 2 !== 0;
    }
    return n.re % 2 !== 0 && d.re % 2 === 0;
  }
  get isEven() {
    const odd = this.isOdd;
    return odd !== void 0 ? !odd : void 0;
  }
  get isInfinity() {
    if (typeof this._value === "number")
      return !Number.isFinite(this._value) && !Number.isNaN(this._value);
    if (!Number.isFinite(this._value.im)) return true;
    return this._value.isPositiveInfinity || this._value.isNegativeInfinity;
  }
  get isNaN() {
    if (typeof this._value === "number") return Number.isNaN(this._value);
    return this._value.isNaN;
  }
  get isFinite() {
    return this.isInfinity === false && this.isNaN === false;
  }
  get isNumber() {
    return true;
  }
  get isInteger() {
    if (typeof this._value === "number") return Number.isInteger(this._value);
    return isSubtype(this._value.type, "integer");
  }
  get isRational() {
    if (typeof this._value === "number") return Number.isInteger(this._value);
    return isSubtype(this._value.type, "rational");
  }
  get isReal() {
    if (typeof this._value === "number") return true;
    return isSubtype(this._value.type, "real");
  }
  is(other) {
    if (typeof other === "number") {
      if (typeof this._value === "number") return Object.is(this._value, other);
      if (this._value.isNaN) return Object.is(other, NaN);
      return this._value.eq(other);
    }
    if (typeof other === "bigint") {
      if (typeof this._value === "number") return bigint(this._value) === other;
      return this._value.eq(this.engine._numericValue(other));
    }
    if (typeof other === "boolean") return false;
    return this.isSame(other);
  }
  get canonical() {
    return this;
  }
  get isStructural() {
    if (typeof this._value === "number") return true;
    if (this.type.matches("rational")) return true;
    if (this._value instanceof ExactNumericValue) return false;
    return true;
  }
  get structural() {
    if (this.isStructural) return this;
    return this.engine.box(this.json, { canonical: false, structural: true });
  }
  toNumericValue() {
    const v = this._value;
    if (typeof v === "number")
      return [this.engine._numericValue(v), this.engine.One];
    return [v, this.engine.One];
  }
  simplify(options) {
    const results = simplify(this.structural, options);
    return results.at(-1).value ?? this;
  }
  evaluate(options) {
    if (options?.numericApproximation) return this.N();
    return this;
  }
  N() {
    const v = this._value;
    if (typeof v === "number") return this;
    const n = v.N();
    if (v === n) return this;
    return this.engine.number(n);
  }
};
function canonicalNumber(ce, value) {
  if (value === void 0 || value === null) return NaN;
  if (value instanceof NumericValue) return value;
  if (typeof value === "number") {
    if (Number.isInteger(value) && value >= -SMALL_INTEGER && value <= SMALL_INTEGER)
      return value;
    if (!Number.isFinite(value)) return value;
    return ce._numericValue(value);
  }
  if (value instanceof Decimal) {
    const n = value.toNumber();
    if (value.isInteger() && Math.abs(n) <= SMALL_INTEGER) return n;
    if (value.isNaN()) return NaN;
    if (!value.isFinite()) return n > 0 ? Infinity : -Infinity;
    return ce._numericValue(value);
  }
  if (typeof value === "bigint") {
    if (value >= -SMALL_INTEGER && value <= SMALL_INTEGER) return Number(value);
    return ce._numericValue(value);
  }
  if (value instanceof Complex) {
    if (value.im === 0) return canonicalNumber(ce, value.re);
    if (value.isNaN()) return NaN;
    if (!value.isFinite() && value.im === 0)
      return value.re > 0 ? Infinity : -Infinity;
    return ce._numericValue({ re: value.re, im: value.im });
  }
  if (typeof value === "object" && "num" in value) {
    if (typeof value.num === "number") return canonicalNumber(ce, value.num);
    if (typeof value.num !== "string")
      throw new Error("MathJSON `num` property should be a string of digits");
    return canonicalNumberString(ce, value.num);
  }
  if (typeof value === "string") return canonicalNumberString(ce, value);
  if (value[1] == 0) return NaN;
  if (typeof value[1] === "number" && !Number.isFinite(value[1])) {
    if (!Number.isFinite(value[0])) return NaN;
    return 0;
  }
  if (typeof value[0] === "number" && !Number.isFinite(value[0])) {
    const sign3 = value[0] > 0 ? 1 : -1;
    if (value[0] > 0) return sign3 > 0 ? Infinity : -Infinity;
    if (value[0] < 0) return sign3 > 0 ? -Infinity : Infinity;
    return NaN;
  }
  return ce._numericValue(value);
}
function canonicalNumberString(ce, s) {
  s = s.toLowerCase();
  if (/[0-9][nd]$/.test(s)) s = s.slice(0, -1);
  s = s.replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
  if (s === "nan") return NaN;
  if (s === "infinity" || s === "+infinity" || s === "oo" || s === "+oo")
    return Number.POSITIVE_INFINITY;
  if (s === "-infinity" || s === "-oo") return Number.NEGATIVE_INFINITY;
  if (s === "0") return 0;
  if (s === "1") return 1;
  if (s === "-1") return -1;
  if (/\([0-9]+\)/.test(s)) {
    const [_, body, repeat2, trail] = s.match(/(.+)\(([0-9]+)\)(.+)?$/) ?? [];
    s = body + repeat2.repeat(Math.ceil(ce.precision / repeat2.length)) + (trail ?? "");
  }
  const n = bigint(s);
  if (n !== null) {
    if (n >= -SMALL_INTEGER && n <= SMALL_INTEGER) return Number(n);
    return ce._numericValue(n);
  }
  return ce._numericValue(ce.bignum(s));
}

// src/compute-engine/index.ts
init_boxed_value_definition();

// src/compute-engine/boxed-expression/boxed-symbol.ts
init_symbols();
init_utils();
init_boxed_type();
init_parse();
init_types2();
init_arithmetic_mul_div();
init_rules();
init_negate();
init_abstract_boxed_expression();
init_utils5();
init_arithmetic_power();
init_arithmetic_add();
init_utils2();
init_assume();
var BoxedSymbol = class extends _BoxedExpression {
  _hash;
  /** The name of the symbol */
  _id;
  /**
   * The definition of the symbol, if the symbol is bound/canonical.
   */
  _def;
  /** Note: to indicate that the symbol should be canonical, pass a def. */
  constructor(ce, name, options) {
    super(ce, options?.metadata);
    console.assert(
      isValidSymbol(name),
      `Invalid symbol "${name}": ${validateSymbol(name)}`
    );
    this._id = name;
    this._def = options?.def;
  }
  get json() {
    return matchesSymbol(this._id) ? this._id : { sym: this._id };
  }
  get hash() {
    this._hash ??= hashCode(this._id);
    return this._hash;
  }
  get isPure() {
    return true;
  }
  get isConstant() {
    const def = this._def;
    return (isValueDef(def) && def?.value.isConstant) ?? false;
  }
  bind() {
  }
  reset() {
  }
  get isCanonical() {
    return this._def !== void 0;
  }
  set isCanonical(val) {
    throw new Error(
      "Setting the isCanonical property is not allowed. Use the canonical() method instead."
    );
  }
  get canonical() {
    if (this._def) return this;
    return this.engine.symbol(this._id);
  }
  is(other) {
    if (other === true)
      return this.symbol === "True" || this.value?.symbol === "True";
    if (other === false)
      return this.symbol === "False" || this.value?.symbol === "False";
    if (other instanceof _BoxedExpression && other.symbol)
      return this.symbol === other.symbol;
    return this.value?.is(other instanceof _BoxedExpression ? other.value : other) ?? false;
  }
  toNumericValue() {
    console.assert(this.isCanonical);
    const ce = this.engine;
    if (this.symbol === "ImaginaryUnit")
      return [ce._numericValue({ re: 0, im: 1 }), ce.One];
    if (this.symbol === "PositiveInfinity" || this.isInfinity && this.isPositive)
      return [ce._numericValue(Infinity), ce.One];
    if (this.symbol === "NegativeInfinity" || this.isInfinity && this.isNegative)
      return [ce._numericValue(-Infinity), ce.One];
    if (this.symbol === "NaN") return [ce._numericValue(NaN), ce.One];
    return [ce._numericValue(1), this];
  }
  neg() {
    return negate(this);
  }
  inv() {
    return this.engine._fn("Divide", [this.engine.One, this]);
  }
  abs() {
    if (this.isNonNegative) return this;
    if (this.isNonPositive) return this.neg();
    return this.engine._fn("Abs", [this]);
  }
  add(rhs) {
    if (rhs === 0) return this;
    return add3(this, this.engine.box(rhs));
  }
  mul(rhs) {
    if (rhs === 1) return this;
    if (rhs === -1) return this.neg();
    if (rhs === 0 && !this.isNaN) return this.engine.Zero;
    if (rhs instanceof NumericValue) {
      if (rhs.isOne) return this;
      if (rhs.isNegativeOne) return this.neg();
      if (rhs.isZero && !this.isNaN) return this.engine.Zero;
    }
    return mul3(this, this.engine.box(rhs));
  }
  div(rhs) {
    return div2(this, rhs);
  }
  pow(exp3) {
    return pow2(this, exp3, { numericApproximation: false });
  }
  root(n) {
    const e = typeof n === "number" ? n : n.im === 0 ? n.re : void 0;
    const ce = this.engine;
    if (this.symbol === "ComplexInfinity") return ce.NaN;
    if (e === 0) return ce.NaN;
    if (e === 1) return this;
    if (e === 2) return this.sqrt();
    if (e === -1) return this.inv();
    return ce._fn("Root", [this, ce.box(n)]);
  }
  sqrt() {
    const ce = this.engine;
    if (this.symbol === "ComplexInfinity") return ce.NaN;
    if (this.is(0)) return this;
    if (this.is(1)) return this.engine.One;
    if (this.is(-1)) return ce.I;
    return ce._fn("Sqrt", [this]);
  }
  ln(semiBase) {
    const base = semiBase ? this.engine.box(semiBase) : void 0;
    if (this.is(0)) return this.engine.NegativeInfinity;
    if (this.symbol === "ExponentialE") {
      if (!base || base.symbol === "ExponentialE") return this.engine.One;
      return this.engine.One.div(base.ln());
    }
    if (base) {
      if (base.re === 10) return this.engine._fn("Log", [this]);
      return this.engine._fn("Log", [this, base]);
    }
    return this.engine._fn("Ln", [this]);
  }
  solve(vars) {
    const varNames = normalizedUnknownsForSolve(vars);
    if (varNames.length !== 1) return null;
    if (varNames.includes(this.symbol)) return [this.engine.Zero];
    return null;
  }
  get complexity() {
    return 7;
  }
  get operator() {
    return "Symbol";
  }
  get symbol() {
    return this._id;
  }
  //  A base definition is the base class of both value and operator definition
  get baseDefinition() {
    return this.valueDefinition ?? this.operatorDefinition;
  }
  get valueDefinition() {
    if (isValueDef(this._def)) return this._def.value;
    return void 0;
  }
  get operatorDefinition() {
    if (isOperatorDef(this._def)) return this._def.operator;
    return void 0;
  }
  /**
   *
   * Assuming the symbol is used as an argument, subsequent inferences will
   * narrow the domain of the symbol:
   *
   * ```
   * f: real -> number, g: integer -> number
   * f(x) => x: inferred to real
   * g(x) => x: narrowed to integer
   * ```
   *
   * If the symbol is used as a return value, its domain should be widened:
   *
   * ```
   * f: number -> integer, g: number -> real
   * x = f(2) => x: inferred to integer
   * x = g(2) => x: widened to real
   * ```
   *
   * Arguments accumulate constraints and narrow.
   * Return values accumulate possibilities and widen.
   *
   * @inheritdoc
   */
  infer(t, inferenceMode = "narrow") {
    if (!this._def) return false;
    const def = this._def;
    if (isValueDef(def)) {
      if (def.value.inferredType || def.value.type.isUnknown) {
        console.assert(!def.value.isConstant);
        def.value.type = this.engine.type(
          inferenceMode === "widen" ? widen(def.value.type.type, t) : narrow(def.value.type.type, t)
        );
        return true;
      }
      return false;
    }
    if (isOperatorDef(def)) {
      const newType = this.engine.type(
        inferenceMode === "widen" ? widen(def.operator.signature.type, t) : narrow(def.operator.signature.type, t)
      );
      if (newType.matches("function")) {
        def.operator.signature = newType;
        return true;
      }
      delete def.operator;
      def.value = { value: { type: newType } };
      return true;
    }
    return false;
  }
  /** Return the value of the symbol, undefined if an operator or not bound */
  get _value() {
    if (!this._def || isOperatorDef(this._def)) return void 0;
    if (this._def.value.isConstant) return this._def.value.value;
    return this.engine._getSymbolValue(this._id);
  }
  get value() {
    if (isOperatorDef(this._def))
      return this.engine._fn("Operator", [this.engine.string(this._id)]);
    return this._value;
  }
  set value(value) {
    if (!this._def)
      throw new Error(`Cannot set value of non-canonical ${this._id}`);
    const ce = this.engine;
    ce.forget(this._id);
    let v;
    if (typeof value === "boolean") value = value ? ce.True : ce.False;
    if (typeof value === "string") value = ce.string(value);
    if (typeof value === "object") {
      if ("re" in value && "im" in value)
        value = ce.complex(value.re ?? 0, value.im);
      else if ("num" in value && "denom" in value)
        value = ce.number([value.num, value.denom]);
      else if (Array.isArray(value))
        value = ce._fn(
          "List",
          value.map((x) => ce.box(x))
        );
      else throw new Error(`Invalid value for symbol ${this._id}: ${value}`);
    }
    if (value !== void 0) {
      const boxedValue = ce.box(value);
      v = boxedValue.evaluate();
    }
    if (v?.type.matches("function")) {
      delete this._def.value;
      this._def.operator = {
        signature: v.type,
        evaluate: v
        // Evaluate as a lambda
      };
      return;
    }
    if (isValueDef(this._def) && this._def.value.isConstant)
      throw new Error(
        `The value of the constant "${this._id}" cannot be changed`
      );
    ce._setSymbolValue(this._id, v);
  }
  /**
   * The type of the symbol.
   *
   * Note that the type of the value of the symbol may be more specific.'
   * For example, a symbol could have a type of 'number' but the value
   * could be 'integer'.
   *
   * If the symbol is not canonical (not bound to a definition), the type is
   * 'unknown'
   */
  get type() {
    const def = this._def;
    if (isValueDef(def)) return def.value.type;
    if (isOperatorDef(def)) return def.operator.signature;
    return BoxedType.unknown;
  }
  set type(t) {
    if (!this._def)
      throw new Error(`Cannot set type of non-canonical symbol "${this._id}"`);
    if (this._id[0] === "_")
      throw new Error(
        `The type of the wildcard "${this._id}" cannot be changed`
      );
    this.engine.forget(this._id);
    if (typeof t === "string") t = parseType(t);
    else if (t instanceof BoxedType) t = t.type;
    if (t === "function" || isSignatureType(t)) {
      if (isOperatorDef(this._def)) {
        this._def.operator.signature = t;
      } else {
        delete this._def.value;
        this._def.operator = { signature: t };
      }
    } else {
      if (isOperatorDef(this._def)) {
        delete this._def.operator;
        this._def.value = { type: t };
      } else {
        this._def.value.type = t;
      }
    }
  }
  has(x) {
    if (typeof x === "string") return this._id === x;
    return x.includes(this._id);
  }
  match(pattern, options) {
    return match(this, pattern, options);
  }
  /** The shape of the tensor (dimensions), derived from the type */
  get shape() {
    const t = this.type.type;
    if (typeof t === "object" && t.kind === "list" && t.dimensions)
      return t.dimensions;
    return [];
  }
  /** The rank of the tensor (number of dimensions), derived from the type */
  get rank() {
    return this.shape.length;
  }
  // The sign of the value of the symbol
  get sgn() {
    if (this.value) return this.value.sgn;
    return getSignFromAssumptions(this.engine, this.symbol);
  }
  get isOdd() {
    return this.value?.isOdd;
  }
  get isEven() {
    return this.value?.isEven;
  }
  get isFinite() {
    return this.value?.isFinite;
  }
  get isInfinity() {
    return this.value?.isInfinity;
  }
  get isNaN() {
    return this.value?.isNaN;
  }
  // x > 0
  get isPositive() {
    return positiveSign(this.sgn);
  }
  get isNonPositive() {
    return nonPositiveSign(this.sgn);
  }
  get isNegative() {
    return negativeSign(this.sgn);
  }
  get isNonNegative() {
    return nonNegativeSign(this.sgn);
  }
  get isFunction() {
    const t = this.type;
    if (t.isUnknown) return void 0;
    return this.type.matches("function");
  }
  get isNumber() {
    const t = this.type;
    if (t.isUnknown) return void 0;
    return t.matches("number");
  }
  get isInteger() {
    const t = this.type;
    if (t.isUnknown) return void 0;
    return t.matches("integer");
  }
  get isRational() {
    const t = this.type;
    if (t.isUnknown) return void 0;
    return t.matches("rational");
  }
  get isReal() {
    const t = this.type;
    if (t.isUnknown) return void 0;
    return t.matches("real");
  }
  get re() {
    return this.value?.re ?? NaN;
  }
  get im() {
    return this.value?.im ?? NaN;
  }
  get bignumRe() {
    return this.value?.bignumRe;
  }
  get bignumIm() {
    return this.value?.bignumIm;
  }
  simplify(options) {
    return simplify(this, options).at(-1)?.value ?? this;
  }
  evaluate(options) {
    const def = this.valueDefinition;
    if (!def) return this;
    const hold = def.holdUntil;
    if (def.isConstant) {
      if (options?.numericApproximation) {
        if (hold === "never" || hold === "evaluate" || hold === "N")
          return def.value?.N() ?? this;
      } else if (hold === "never" || hold === "evaluate")
        return def.value?.evaluate(options) ?? this;
    } else {
      if (hold === "never" || hold === "evaluate" || hold === "N" && options?.numericApproximation) {
        let expr = this.engine._getSymbolValue(this._id) ?? this;
        if (expr.operator === "Unevaluated")
          expr = expr.evaluate(options) ?? this;
        return expr;
      }
    }
    return this;
  }
  N() {
    const def = this.valueDefinition;
    if (def && def.holdUntil === "never") return this;
    if (def && !def.isConstant) {
      const contextValue = this.engine._getSymbolValue(this._id);
      if (contextValue) return contextValue.N();
    }
    return def?.value?.N() ?? this;
  }
  replace(rules, options) {
    return replace(this, rules, options).at(-1)?.value ?? null;
  }
  subs(sub3, options) {
    const canonical2 = options?.canonical ?? this.isCanonical;
    if (sub3[this._id] === void 0) return canonical2 ? this.canonical : this;
    return this.engine.box(sub3[this._id], { canonical: canonical2 });
  }
  get _asCollection() {
    if (isValueDef(this._def)) return this._def.value.collection;
    return void 0;
  }
  get isCollection() {
    return this._asCollection?.iterator !== void 0 || (this._value?.isCollection ?? false);
  }
  get isIndexedCollection() {
    return this._asCollection?.at !== void 0 || (this._value?.isIndexedCollection ?? false);
  }
  get isLazyCollection() {
    return this._asCollection?.isLazy?.(this._value ?? this) ?? this._value?.isLazyCollection ?? false;
  }
  contains(rhs) {
    return this._asCollection?.contains?.(this._value ?? this, rhs) ?? this._value?.contains?.(rhs);
  }
  get count() {
    return this._asCollection?.count(this._value ?? this) ?? this._value?.count ?? 0;
  }
  get isEmptyCollection() {
    return this._asCollection?.isEmpty?.(this._value ?? this) ?? this._value?.isEmptyCollection ?? this.count === 0;
  }
  get isFiniteCollection() {
    return this._asCollection?.isFinite?.(this._value ?? this) ?? this._value?.isFiniteCollection ?? isFinite(this.count);
  }
  each() {
    const iter = this._asCollection?.iterator?.(this._value ?? this);
    if (iter)
      return (function* () {
        let result = iter.next();
        while (!result.done) {
          yield result.value;
          result = iter.next();
        }
      })();
    return this._value?.each() ?? (function* () {
    })();
  }
  at(index) {
    return this._asCollection?.at?.(this._value ?? this, index) ?? this._value?.at?.(index);
  }
  get(index) {
    return this._value?.get?.(index);
  }
  indexWhere(predicate2) {
    if (this._asCollection?.indexWhere)
      return this._asCollection.indexWhere(this._value ?? this, predicate2);
    return this._value?.indexWhere(predicate2);
  }
  subsetOf(rhs, strict) {
    return this._asCollection?.subsetOf?.(this._value ?? this, rhs, strict) ?? this._value?.subsetOf?.(rhs, strict) ?? false;
  }
};

// src/compute-engine/index.ts
init_solve();
init_serialize2();

// src/compute-engine/symbolic/simplify-rules.ts
init_arithmetic_mul_div();
init_expand();
init_arithmetic_add();
init_numeric();
init_utils3();
init_polynomials();

// src/compute-engine/symbolic/simplify-sum.ts
function simplifySum(x) {
  if (x.operator !== "Sum") return void 0;
  const body = x.op1;
  const limits = x.op2;
  if (!body || !limits || limits.operator !== "Limits") return void 0;
  const index = limits.op1?.symbol;
  const lower = limits.op2;
  const upper = limits.op3;
  if (!index || !lower || !upper) return void 0;
  const ce = x.engine;
  if (body.operator === "Sum" || body.operator === "Product") {
    const simplifiedBody = body.simplify();
    if (!simplifiedBody.isSame(body)) {
      const newSum = ce.function("Sum", [simplifiedBody, limits]);
      return { value: newSum, because: "simplified nested sum/product" };
    }
  }
  if (lower.isNumberLiteral && upper.isNumberLiteral) {
    const lowerVal = lower.numericValue;
    const upperVal = upper.numericValue;
    if (typeof lowerVal === "number" && typeof upperVal === "number" && Number.isInteger(lowerVal) && Number.isInteger(upperVal)) {
      if (upperVal < lowerVal) {
        return { value: ce.Zero, because: "empty sum" };
      }
      if (upperVal === lowerVal) {
        return {
          value: body.subs({ [index]: lower }).simplify(),
          because: "single term sum"
        };
      }
    }
  }
  const bodyUnknowns = new Set(body.unknowns);
  if (!bodyUnknowns.has(index)) {
    const count = upper.sub(lower).add(ce.One).simplify();
    if (count.isNumberLiteral && count.numericValue !== null) {
      const countVal = typeof count.numericValue === "number" ? count.numericValue : count.numericValue.re;
      if (countVal <= 0) {
        return { value: ce.Zero, because: "empty sum" };
      }
    }
    return {
      value: count.mul(body.simplify()),
      because: "sum of constant"
    };
  }
  if (body.symbol === index) {
    const a = lower;
    const b = upper;
    const result = b.mul(b.add(ce.One)).sub(a.mul(a.sub(ce.One))).div(2);
    return { value: result.simplify(), because: "triangular number" };
  }
  if (body.operator === "Power" && body.op1?.symbol === index && body.op2?.is(2) && lower.is(1)) {
    const b = upper;
    const result = b.mul(b.add(ce.One)).mul(b.mul(2).add(ce.One)).div(6);
    return { value: result, because: "sum of squares" };
  }
  if (body.operator === "Power" && body.op1?.symbol === index && body.op2?.is(3) && lower.is(1)) {
    const b = upper;
    const triangular = b.mul(b.add(ce.One)).div(2);
    return { value: triangular.pow(2), because: "sum of cubes" };
  }
  if (body.operator === "Power" && body.op1?.is(-1) && body.op2?.symbol === index && lower.is(0)) {
    const b = upper;
    const result = ce.One.add(ce.number(-1).pow(b)).div(2);
    return { value: result, because: "alternating unit series" };
  }
  if (body.operator === "Multiply" && body.ops && lower.is(0)) {
    let hasAlternating = false;
    let hasIndex = false;
    for (const op of body.ops) {
      if (op.operator === "Power" && op.op1?.is(-1) && op.op2?.symbol === index) {
        hasAlternating = true;
      } else if (op.symbol === index) {
        hasIndex = true;
      }
    }
    if (hasAlternating && hasIndex && body.ops.length === 2) {
      const b = upper;
      const result = ce.function("Multiply", [
        ce.function("Power", [ce.number(-1), b]),
        ce.function("Floor", [
          ce.function("Divide", [
            ce.function("Add", [b, ce.One]),
            ce.number(2)
          ])
        ])
      ]);
      return { value: result, because: "alternating linear series" };
    }
  }
  if (body.operator === "Add" && body.ops) {
    let constant = null;
    let coefficient = null;
    for (const term of body.ops) {
      const termUnknowns = new Set(term.unknowns);
      if (!termUnknowns.has(index)) {
        constant = constant ? constant.add(term) : term;
      } else if (term.symbol === index) {
        coefficient = coefficient ? coefficient.add(ce.One) : ce.One;
      } else if (term.operator === "Multiply" && term.ops?.some((op) => op.symbol === index)) {
        const coef = term.ops.filter((op) => op.symbol !== index);
        if (coef.length === term.ops.length - 1) {
          const c = coef.length === 1 ? coef[0] : ce.function("Multiply", coef);
          coefficient = coefficient ? coefficient.add(c) : c;
        }
      } else {
        constant = null;
        coefficient = null;
        break;
      }
    }
    if (constant !== null && coefficient !== null) {
      const m = lower;
      const b = upper;
      if (lower.is(0)) {
        const bPlus1 = ce.function("Add", [b, ce.One]);
        const inner = ce.function("Add", [
          constant,
          ce.function("Divide", [
            ce.function("Multiply", [coefficient, b]),
            ce.number(2)
          ])
        ]);
        const result = ce.function("Multiply", [bPlus1, inner]);
        return { value: result, because: "arithmetic progression" };
      } else {
        const numTerms = ce.function("Add", [
          ce.function("Subtract", [b, m]),
          ce.One
        ]);
        const avgIndex = ce.function("Divide", [
          ce.function("Add", [m, b]),
          ce.number(2)
        ]);
        const avgValue = ce.function("Add", [
          constant,
          ce.function("Multiply", [coefficient, avgIndex])
        ]);
        const result = ce.function("Multiply", [numTerms, avgValue]);
        return { value: result, because: "arithmetic progression" };
      }
    }
  }
  if (body.operator === "Power" && body.op2?.symbol === index && !new Set(body.op1?.unknowns ?? []).has(index)) {
    const r = body.op1;
    const b = upper;
    if (lower.is(0)) {
      const numerator = ce.One.sub(r.pow(b.add(ce.One)));
      const denominator = ce.One.sub(r);
      return { value: numerator.div(denominator), because: "geometric series" };
    } else if (lower.is(1)) {
      const numerator = r.sub(r.pow(b.add(ce.One)));
      const denominator = ce.One.sub(r);
      return { value: numerator.div(denominator), because: "geometric series" };
    }
  }
  if (body.operator === "Binomial" && lower.is(0) && body.op2?.symbol === index) {
    const n = body.op1;
    if (n && upper.isSame(n)) {
      const result = ce.function("Power", [ce.number(2), n]);
      return { value: result, because: "sum of binomial coefficients" };
    }
  }
  if (body.operator === "Multiply" && body.ops && lower.is(0)) {
    let hasBinomial = false;
    let hasAlternating = false;
    let binomialN = null;
    for (const op of body.ops) {
      if (op.operator === "Binomial" && op.op2?.symbol === index) {
        hasBinomial = true;
        binomialN = op.op1 ?? null;
      } else if (op.operator === "Power" && op.op1?.is(-1) && op.op2?.symbol === index) {
        hasAlternating = true;
      }
    }
    if (hasBinomial && hasAlternating && binomialN && upper.isSame(binomialN)) {
      return { value: ce.Zero, because: "alternating binomial sum" };
    }
    let hasIndex = false;
    binomialN = null;
    hasBinomial = false;
    for (const op of body.ops) {
      if (op.symbol === index) {
        hasIndex = true;
      } else if (op.operator === "Binomial" && op.op2?.symbol === index) {
        hasBinomial = true;
        binomialN = op.op1 ?? null;
      }
    }
    if (hasIndex && hasBinomial && binomialN && upper.isSame(binomialN) && body.ops.length === 2) {
      const n = binomialN;
      const result = ce.function("Multiply", [
        n,
        ce.function("Power", [ce.number(2), n.sub(ce.One)])
      ]);
      return { value: result, because: "weighted binomial sum" };
    }
    let hasIndexSquared = false;
    binomialN = null;
    hasBinomial = false;
    for (const op of body.ops) {
      if (op.operator === "Power" && op.op1?.symbol === index && op.op2?.is(2)) {
        hasIndexSquared = true;
      } else if (op.operator === "Binomial" && op.op2?.symbol === index) {
        hasBinomial = true;
        binomialN = op.op1 ?? null;
      }
    }
    if (hasIndexSquared && hasBinomial && binomialN && upper.isSame(binomialN) && body.ops.length === 2) {
      const n = binomialN;
      const result = ce.function("Multiply", [
        n,
        n.add(ce.One),
        ce.function("Power", [ce.number(2), n.sub(ce.number(2))])
      ]);
      return { value: result, because: "weighted squared binomial sum" };
    }
    let hasIndexCubed = false;
    binomialN = null;
    hasBinomial = false;
    for (const op of body.ops) {
      if (op.operator === "Power" && op.op1?.symbol === index && op.op2?.is(3)) {
        hasIndexCubed = true;
      } else if (op.operator === "Binomial" && op.op2?.symbol === index) {
        hasBinomial = true;
        binomialN = op.op1 ?? null;
      }
    }
    if (hasIndexCubed && hasBinomial && binomialN && upper.isSame(binomialN) && body.ops.length === 2) {
      const n = binomialN;
      const result = ce.function("Multiply", [
        ce.function("Power", [n, ce.number(2)]),
        n.add(ce.number(3)),
        ce.function("Power", [ce.number(2), n.sub(ce.number(3))])
      ]);
      return { value: result, because: "weighted cubed binomial sum" };
    }
    let hasAltTerm = false;
    let hasIndexTerm = false;
    binomialN = null;
    hasBinomial = false;
    for (const op of body.ops) {
      if (op.operator === "Power" && op.op1?.is(-1) && op.op2?.symbol === index) {
        hasAltTerm = true;
      } else if (op.symbol === index) {
        hasIndexTerm = true;
      } else if (op.operator === "Binomial" && op.op2?.symbol === index) {
        hasBinomial = true;
        binomialN = op.op1 ?? null;
      }
    }
    if (hasAltTerm && hasIndexTerm && hasBinomial && binomialN && upper.isSame(binomialN) && body.ops.length === 3) {
      return { value: ce.Zero, because: "alternating weighted binomial sum" };
    }
  }
  if (body.operator === "Power" && body.op1?.operator === "Binomial" && body.op2?.is(2) && lower.is(0)) {
    const binomial2 = body.op1;
    const n = binomial2.op1;
    const k = binomial2.op2;
    if (n && k?.symbol === index && upper.isSame(n)) {
      const result = ce.function("Binomial", [
        ce.function("Multiply", [ce.number(2), n]),
        n
      ]);
      return { value: result, because: "sum of binomial squares" };
    }
  }
  if (body.operator === "Multiply" && body.ops?.length === 2 && lower.is(1)) {
    const [op1, op2] = body.ops;
    const isKTimesKPlus1 = op1.symbol === index && op2.operator === "Add" && op2.ops?.length === 2 && op2.ops.some((o) => o.symbol === index) && op2.ops.some((o) => o.is(1)) || op2.symbol === index && op1.operator === "Add" && op1.ops?.length === 2 && op1.ops.some((o) => o.symbol === index) && op1.ops.some((o) => o.is(1));
    if (isKTimesKPlus1) {
      const n = upper;
      const result = ce.function("Divide", [
        ce.function("Multiply", [
          n,
          ce.function("Add", [n, ce.One]),
          ce.function("Add", [n, ce.number(2)])
        ]),
        ce.number(3)
      ]);
      return { value: result, because: "sum of k*(k+1)" };
    }
  }
  if (body.operator === "Divide" && body.op1?.is(1) && body.op2?.operator === "Multiply") {
    const denom = body.op2;
    if (denom.ops?.length === 2) {
      const [d1, d2] = denom.ops;
      if (lower.is(1)) {
        const isKTimesKPlus1 = d1.symbol === index && d2.operator === "Add" && d2.ops?.length === 2 && d2.ops.some((op) => op.symbol === index) && d2.ops.some((op) => op.is(1)) || d2.symbol === index && d1.operator === "Add" && d1.ops?.length === 2 && d1.ops.some((op) => op.symbol === index) && d1.ops.some((op) => op.is(1));
        if (isKTimesKPlus1) {
          const n = upper;
          const result = n.div(n.add(ce.One));
          return { value: result, because: "partial fractions (telescoping)" };
        }
      }
      if (lower.is(2)) {
        const isKTimesKMinus1 = d1.symbol === index && d2.operator === "Add" && d2.ops?.length === 2 && d2.ops.some((op) => op.symbol === index) && d2.ops.some((op) => op.is(-1)) || d2.symbol === index && d1.operator === "Add" && d1.ops?.length === 2 && d1.ops.some((op) => op.symbol === index) && d1.ops.some((op) => op.is(-1));
        if (isKTimesKMinus1) {
          const n = upper;
          const result = n.sub(ce.One).div(n);
          return {
            value: result,
            because: "partial fractions (telescoping k*(k-1))"
          };
        }
      }
    }
  }
  if (body.operator === "Multiply" && body.ops) {
    const constantFactors = [];
    const indexFactors = [];
    for (const factor3 of body.ops) {
      const factorUnknowns = new Set(factor3.unknowns);
      if (factorUnknowns.has(index)) {
        indexFactors.push(factor3);
      } else {
        constantFactors.push(factor3);
      }
    }
    if (constantFactors.length > 0 && indexFactors.length > 0) {
      const constant = constantFactors.length === 1 ? constantFactors[0] : ce.function("Multiply", constantFactors);
      const indexPart = indexFactors.length === 1 ? indexFactors[0] : ce.function("Multiply", indexFactors);
      const newSum = ce.function("Sum", [indexPart, limits]);
      return {
        value: constant.mul(newSum),
        because: "factor out constant from sum"
      };
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-product.ts
function simplifyProduct(x) {
  if (x.operator !== "Product") return void 0;
  const body = x.op1;
  const limits = x.op2;
  if (!body || !limits || limits.operator !== "Limits") return void 0;
  const index = limits.op1?.symbol;
  const lower = limits.op2;
  const upper = limits.op3;
  if (!index || !lower || !upper) return void 0;
  const ce = x.engine;
  if (body.operator === "Sum" || body.operator === "Product") {
    const simplifiedBody = body.simplify();
    if (!simplifiedBody.isSame(body)) {
      const newProduct = ce.function("Product", [simplifiedBody, limits]);
      return { value: newProduct, because: "simplified nested sum/product" };
    }
  }
  if (lower.isNumberLiteral && upper.isNumberLiteral) {
    const lowerVal = lower.numericValue;
    const upperVal = upper.numericValue;
    if (typeof lowerVal === "number" && typeof upperVal === "number" && Number.isInteger(lowerVal) && Number.isInteger(upperVal)) {
      if (upperVal < lowerVal) {
        return { value: ce.One, because: "empty product" };
      }
      if (upperVal === lowerVal) {
        return {
          value: body.subs({ [index]: lower }).simplify(),
          because: "single term product"
        };
      }
    }
  }
  const bodyUnknowns = new Set(body.unknowns);
  if (!bodyUnknowns.has(index)) {
    const count = upper.sub(lower).add(ce.One).simplify();
    if (count.isNumberLiteral && count.numericValue !== null) {
      const countVal = typeof count.numericValue === "number" ? count.numericValue : count.numericValue.re;
      if (countVal <= 0) {
        return { value: ce.One, because: "empty product" };
      }
    }
    return {
      value: body.simplify().pow(count),
      because: "product of constant"
    };
  }
  if (body.symbol === index && lower.is(1)) {
    return {
      value: ce.function("Factorial", [upper]),
      because: "factorial"
    };
  }
  if (body.operator === "Add" && body.ops?.length === 2 && lower.is(1)) {
    const [op1, op2] = body.ops;
    let indexTerm = null;
    let constTerm = null;
    if (op1.symbol === index && !new Set(op2.unknowns).has(index)) {
      indexTerm = op1;
      constTerm = op2;
    } else if (op2.symbol === index && !new Set(op1.unknowns).has(index)) {
      indexTerm = op2;
      constTerm = op1;
    }
    if (indexTerm && constTerm) {
      const b = upper;
      const c = constTerm;
      const result = ce.function("Divide", [
        ce.function("Factorial", [ce.function("Add", [b, c])]),
        ce.function("Factorial", [c])
      ]);
      return { value: result, because: "shifted factorial" };
    }
  }
  if (body.operator === "Divide" && lower.is(1)) {
    const num = body.op1;
    const denom = body.op2;
    if (denom?.symbol === index && num?.operator === "Add" && num.ops?.length === 2 && num.ops.some((o) => o.symbol === index) && num.ops.some((o) => o.is(1))) {
      return { value: upper.add(ce.One), because: "telescoping product" };
    }
  }
  if (body.operator === "Add" && body.ops?.length === 2 && lower.is(2)) {
    let hasOne = false;
    let hasNegInvSq = false;
    for (const op of body.ops) {
      if (op.is(1)) {
        hasOne = true;
      } else if (op.operator === "Negate" && op.op1?.operator === "Power" && op.op1.op1?.symbol === index && op.op1.op2?.is(-2)) {
        hasNegInvSq = true;
      } else if (op.operator === "Power" && op.op1?.symbol === index && op.op2?.is(-2)) {
      } else if (op.operator === "Multiply" && op.ops?.some((o) => o.is(-1)) && op.ops?.some(
        (o) => o.operator === "Power" && o.op1?.symbol === index && o.op2?.is(-2)
      )) {
        hasNegInvSq = true;
      }
    }
    if (hasOne && hasNegInvSq) {
      const n = upper;
      const result = ce.function("Divide", [
        ce.function("Add", [n, ce.One]),
        ce.function("Multiply", [ce.number(2), n])
      ]);
      return { value: result, because: "Wallis-like product" };
    }
  }
  if (body.operator === "Add" && body.ops?.length === 2 && lower.is(1)) {
    const [op1, op2] = body.ops;
    let hasLinearTerm = false;
    let coefficient = 0;
    let constantTerm = 0;
    for (const op of body.ops) {
      if (op.isNumberLiteral && typeof op.numericValue === "number") {
        constantTerm = op.numericValue;
      } else if (op.operator === "Multiply" && op.ops?.length === 2) {
        const [a, b] = op.ops;
        if (a.isNumberLiteral && typeof a.numericValue === "number" && b.symbol === index) {
          coefficient = a.numericValue;
          hasLinearTerm = true;
        } else if (b.isNumberLiteral && typeof b.numericValue === "number" && a.symbol === index) {
          coefficient = b.numericValue;
          hasLinearTerm = true;
        }
      }
    }
    if (hasLinearTerm && coefficient === 2 && constantTerm === -1) {
      const b = upper;
      const result = ce.function("Factorial2", [
        ce.function("Subtract", [
          ce.function("Multiply", [ce.number(2), b]),
          ce.One
        ])
      ]);
      return { value: result, because: "odd double factorial" };
    }
  }
  if (body.operator === "Multiply" && body.ops?.length === 2 && lower.is(1)) {
    const [op1, op2] = body.ops;
    if (op1.is(2) && op2.symbol === index || op2.is(2) && op1.symbol === index) {
      const b = upper;
      const result = ce.function("Multiply", [
        ce.function("Power", [ce.number(2), b]),
        ce.function("Factorial", [b])
      ]);
      return { value: result, because: "even double factorial" };
    }
  }
  if (body.operator === "Add" && body.ops?.length === 2 && lower.is(0)) {
    let base = null;
    let hasIndex = false;
    for (const op of body.ops) {
      if (op.symbol === index) {
        hasIndex = true;
      } else if (!new Set(op.unknowns).has(index)) {
        base = op;
      }
    }
    if (hasIndex && base) {
      const n = upper.add(ce.One).simplify();
      const result = ce.function("Pochhammer", [base, n]);
      return { value: result, because: "rising factorial (Pochhammer)" };
    }
  }
  if (lower.is(0)) {
    let base = null;
    let hasNegIndex = false;
    if (body.operator === "Subtract" && body.ops?.length === 2) {
      const [op1, op2] = body.ops;
      if (op2.symbol === index && !new Set(op1.unknowns).has(index)) {
        base = op1;
        hasNegIndex = true;
      }
    } else if (body.operator === "Add" && body.ops?.length === 2) {
      for (const op of body.ops) {
        if (op.operator === "Negate" && op.op1?.symbol === index) {
          hasNegIndex = true;
        } else if (!new Set(op.unknowns).has(index)) {
          base = op;
        }
      }
    }
    if (hasNegIndex && base) {
      const n = upper.add(ce.One).simplify();
      const result = ce.function("Divide", [
        ce.function("Factorial", [base]),
        ce.function("Factorial", [base.sub(n)])
      ]);
      return { value: result, because: "falling factorial" };
    }
  }
  if (body.operator === "Multiply" && body.ops) {
    const constantFactors = [];
    const indexFactors = [];
    for (const factor3 of body.ops) {
      const factorUnknowns = new Set(factor3.unknowns);
      if (factorUnknowns.has(index)) {
        indexFactors.push(factor3);
      } else {
        constantFactors.push(factor3);
      }
    }
    if (constantFactors.length > 0 && indexFactors.length > 0) {
      const constant = constantFactors.length === 1 ? constantFactors[0] : ce.function("Multiply", constantFactors);
      const indexPart = indexFactors.length === 1 ? indexFactors[0] : ce.function("Multiply", indexFactors);
      const count = upper.sub(lower).add(ce.One).simplify();
      const newProduct = ce.function("Product", [indexPart, limits]);
      return {
        value: constant.pow(count).mul(newProduct),
        because: "factor out constant from product"
      };
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-abs.ts
var ODD_TRIG = /* @__PURE__ */ new Set([
  "Sin",
  "Tan",
  "Cot",
  "Csc",
  "Arcsin",
  "Arctan",
  "Arccot",
  "Arccsc"
]);
var ODD_HYPER = /* @__PURE__ */ new Set([
  "Sinh",
  "Tanh",
  "Coth",
  "Csch",
  "Arsinh",
  "Artanh",
  "Arcoth",
  "Arcsch"
]);
var EVEN_FUNCS = /* @__PURE__ */ new Set(["Cos", "Sec", "Cosh", "Sech"]);
function simplifyAbs(x) {
  if (x.operator !== "Abs") return void 0;
  const op = x.op1;
  if (!op) return void 0;
  const ce = x.engine;
  if (op.isNonNegative === true) return { value: op, because: "|x| -> x" };
  if (op.isNonPositive === true)
    return { value: op.neg(), because: "|x| -> -x" };
  const opOperator = op.operator;
  if (opOperator === "Negate") {
    return { value: ce._fn("Abs", [op.op1]), because: "|-x| -> |x|" };
  }
  if (opOperator === "Multiply" && op.ops) {
    const ops = op.ops;
    for (let i = 0; i < ops.length; i++) {
      const factor3 = ops[i];
      if (factor3.isNonNegative === true) {
        const otherFactors = ops.filter((_, idx) => idx !== i);
        const remaining = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
        return {
          value: factor3.mul(ce._fn("Abs", [remaining])),
          because: "|xy| -> x|y| when x >= 0"
        };
      }
      if (factor3.isNonPositive === true) {
        const otherFactors = ops.filter((_, idx) => idx !== i);
        const remaining = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
        return {
          value: factor3.neg().mul(ce._fn("Abs", [remaining])),
          because: "|xy| -> -x|y| when x <= 0"
        };
      }
    }
    if (ops.length === 2) {
      return {
        value: ce._fn("Abs", [ops[0]]).mul(ce._fn("Abs", [ops[1]])),
        because: "|xy| -> |x||y|"
      };
    }
  }
  if (opOperator === "Divide") {
    const num = op.op1;
    const denom = op.op2;
    if (num && denom) {
      if (num.isNonNegative === true) {
        return {
          value: num.div(ce._fn("Abs", [denom])),
          because: "|x/y| -> x/|y| when x >= 0"
        };
      }
      if (num.isNonPositive === true) {
        return {
          value: num.neg().div(ce._fn("Abs", [denom])),
          because: "|x/y| -> -x/|y| when x <= 0"
        };
      }
      if (denom.isNonNegative === true) {
        return {
          value: ce._fn("Abs", [num]).div(denom),
          because: "|x/y| -> |x|/y when y >= 0"
        };
      }
      if (denom.isNonPositive === true) {
        return {
          value: ce._fn("Abs", [num]).neg().div(denom),
          because: "|x/y| -> -|x|/y when y <= 0"
        };
      }
      return {
        value: ce._fn("Abs", [num]).div(ce._fn("Abs", [denom])),
        because: "|x/y| -> |x|/|y|"
      };
    }
  }
  if (opOperator === "Power") {
    const base = op.op1;
    const exp3 = op.op2;
    if (base && exp3) {
      if (exp3.isEven === true) {
        return {
          value: base.pow(exp3),
          because: "|x^n| -> x^n when n is even"
        };
      }
      if (exp3.isOdd === true) {
        return {
          value: ce._fn("Abs", [base]).pow(exp3),
          because: "|x^n| -> |x|^n when n is odd"
        };
      }
      if (exp3.isRational === false) {
        return {
          value: ce._fn("Abs", [base]).pow(exp3),
          because: "|x^n| -> |x|^n when n is irrational"
        };
      }
      if (exp3.isRational === true && exp3.isInteger === false) {
        const num = exp3.numerator;
        if (num) {
          if (num.isEven === true) {
            return {
              value: base.pow(exp3),
              because: "|x^(p/q)| -> x^(p/q) when p is even"
            };
          }
          if (num.isOdd === true) {
            return {
              value: ce._fn("Abs", [base]).pow(exp3),
              because: "|x^(p/q)| -> |x|^(p/q) when p is odd"
            };
          }
        }
      }
    }
  }
  if (ODD_TRIG.has(opOperator) || ODD_HYPER.has(opOperator)) {
    const innerArg = op.op1;
    if (innerArg) {
      return {
        value: ce._fn(opOperator, [ce._fn("Abs", [innerArg])]),
        because: `|${opOperator}(x)| -> ${opOperator}(|x|) (odd function)`
      };
    }
  }
  return void 0;
}
function simplifyAbsPower(x) {
  if (x.operator !== "Power") return void 0;
  const base = x.op1;
  const exp3 = x.op2;
  if (!base || !exp3 || base.operator !== "Abs") return void 0;
  const innerBase = base.op1;
  if (!innerBase) return void 0;
  if (exp3.isEven === true) {
    return {
      value: innerBase.pow(exp3),
      because: "|x|^n -> x^n when n is even"
    };
  }
  if (exp3.operator === "Divide") {
    const n = exp3.op1;
    const m = exp3.op2;
    if (n && m && n.isEven === true && m.isOdd === true) {
      return {
        value: innerBase.pow(exp3),
        because: "|x|^(n/m) -> x^(n/m) when n even, m odd"
      };
    }
  }
  return void 0;
}
function simplifyEvenFunctionAbs(x) {
  const op = x.operator;
  if (!EVEN_FUNCS.has(op)) return void 0;
  const arg = x.op1;
  if (!arg || arg.operator !== "Abs") return void 0;
  const innerArg = arg.op1;
  if (!innerArg) return void 0;
  return {
    value: x.engine._fn(op, [innerArg]),
    because: `${op}(|x|) -> ${op}(x) (even function)`
  };
}

// src/compute-engine/symbolic/simplify-infinity.ts
function simplifyInfinity(x) {
  const op = x.operator;
  const ce = x.engine;
  if (op === "Multiply" && x.ops && x.ops.length === 2) {
    const [a, b] = x.ops;
    const aIsInf = a.isInfinity === true;
    const bIsInf = b.isInfinity === true;
    const aIsPosInf = aIsInf && a.isPositive === true;
    const aIsNegInf = aIsInf && a.isNegative === true;
    const bIsPosInf = bIsInf && b.isPositive === true;
    const bIsNegInf = bIsInf && b.isNegative === true;
    if (a.is(0) && bIsInf) {
      return { value: ce.NaN, because: "0 * infinity -> NaN" };
    }
    if (b.is(0) && aIsInf) {
      return { value: ce.NaN, because: "infinity * 0 -> NaN" };
    }
    if (a.is(0) && b.isFinite === true) {
      return { value: ce.Zero, because: "0 * finite -> 0" };
    }
    if (b.is(0) && a.isFinite === true) {
      return { value: ce.Zero, because: "finite * 0 -> 0" };
    }
    if (aIsPosInf) {
      if (b.isPositive === true) {
        return {
          value: ce.PositiveInfinity,
          because: "+inf * positive -> +inf"
        };
      }
      if (b.isNegative === true) {
        return {
          value: ce.NegativeInfinity,
          because: "+inf * negative -> -inf"
        };
      }
    }
    if (bIsNegInf) {
      if (a.isPositive === true) {
        return {
          value: ce.NegativeInfinity,
          because: "positive * -inf -> -inf"
        };
      }
      if (a.isNegative === true) {
        return {
          value: ce.PositiveInfinity,
          because: "negative * -inf -> +inf"
        };
      }
    }
    if (aIsNegInf) {
      if (b.isPositive === true) {
        return {
          value: ce.NegativeInfinity,
          because: "-inf * positive -> -inf"
        };
      }
      if (b.isNegative === true) {
        return {
          value: ce.PositiveInfinity,
          because: "-inf * negative -> +inf"
        };
      }
    }
    if (bIsPosInf) {
      if (a.isPositive === true) {
        return {
          value: ce.PositiveInfinity,
          because: "positive * +inf -> +inf"
        };
      }
      if (a.isNegative === true) {
        return {
          value: ce.NegativeInfinity,
          because: "negative * +inf -> -inf"
        };
      }
    }
  }
  if (op === "Divide") {
    const num = x.op1;
    const denom = x.op2;
    if (num && denom) {
      const numIsInf = num.isInfinity === true;
      const denomIsInf = denom.isInfinity === true;
      const numIsPosInf = numIsInf && num.isPositive === true;
      const numIsNegInf = numIsInf && num.isNegative === true;
      if (numIsInf && denomIsInf) {
        return { value: ce.NaN, because: "inf / inf -> NaN" };
      }
      if (numIsPosInf) {
        if (denom.isPositive === true && denom.isFinite === true) {
          return {
            value: ce.PositiveInfinity,
            because: "+inf / positive -> +inf"
          };
        }
        if (denom.isNegative === true && denom.isFinite === true) {
          return {
            value: ce.NegativeInfinity,
            because: "+inf / negative -> -inf"
          };
        }
      }
      if (numIsNegInf) {
        if (denom.isPositive === true && denom.isFinite === true) {
          return {
            value: ce.NegativeInfinity,
            because: "-inf / positive -> -inf"
          };
        }
        if (denom.isNegative === true && denom.isFinite === true) {
          return {
            value: ce.PositiveInfinity,
            because: "-inf / negative -> +inf"
          };
        }
      }
    }
  }
  if (op === "Exp") {
    const arg = x.op1;
    if (arg) {
      if (arg.symbol === "PositiveInfinity") {
        return { value: ce.PositiveInfinity, because: "exp(+inf) -> +inf" };
      }
      if (arg.symbol === "NegativeInfinity") {
        return { value: ce.Zero, because: "exp(-inf) -> 0" };
      }
    }
  }
  if (op === "Power") {
    const base = x.op1;
    const exp3 = x.op2;
    if (base && exp3) {
      const baseIsInf = base.isInfinity === true;
      const expIsInf = exp3.isInfinity === true;
      const baseIsPosInf = baseIsInf && base.isPositive === true;
      const baseIsNegInf = baseIsInf && base.isNegative === true;
      const expIsPosInf = expIsInf && exp3.isPositive === true;
      const expIsNegInf = expIsInf && exp3.isNegative === true;
      if (base.symbol === "ExponentialE" && expIsPosInf) {
        return { value: ce.PositiveInfinity, because: "e^(+inf) -> +inf" };
      }
      if (base.symbol === "ExponentialE" && expIsNegInf) {
        return { value: ce.Zero, because: "e^(-inf) -> 0" };
      }
      if (base.is(1) && exp3.isFinite === true) {
        return { value: ce.One, because: "1^finite -> 1" };
      }
      if (exp3.is(0) && baseIsInf) {
        return { value: ce.NaN, because: "inf^0 -> NaN" };
      }
      if (exp3.is(0) && base.is(0) === false && base.isFinite === true) {
        return { value: ce.One, because: "x^0 -> 1" };
      }
      if (expIsPosInf) {
        if (base.isGreater(1) === true) {
          return {
            value: ce.PositiveInfinity,
            because: "a^+inf -> +inf when a > 1"
          };
        }
        if (base.isPositive === true && base.isLess(1) === true) {
          return { value: ce.Zero, because: "a^+inf -> 0 when 0 < a < 1" };
        }
      }
      if (expIsNegInf) {
        if (base.isGreater(1) === true) {
          return { value: ce.Zero, because: "a^-inf -> 0 when a > 1" };
        }
        if (base.isPositive === true && base.isLess(1) === true) {
          return {
            value: ce.PositiveInfinity,
            because: "a^-inf -> +inf when 0 < a < 1"
          };
        }
      }
      if (baseIsPosInf) {
        if (exp3.isNegative === true) {
          return { value: ce.Zero, because: "+inf^negative -> 0" };
        }
      }
      if (baseIsNegInf) {
        if (exp3.isNegative === true) {
          return { value: ce.Zero, because: "-inf^negative -> 0" };
        }
        if (exp3.isInteger === true && exp3.isEven === true) {
          return {
            value: ce.PositiveInfinity,
            because: "(-inf)^(even integer) -> +inf"
          };
        }
        if (exp3.isInteger === true && exp3.isOdd === true) {
          return {
            value: ce.NegativeInfinity,
            because: "(-inf)^(odd integer) -> -inf"
          };
        }
        if (exp3.isRational === true) {
          const [numExpr, denomExpr] = exp3.numeratorDenominator;
          const num = numExpr.re;
          const denom = denomExpr.re;
          if (typeof num === "number" && typeof denom === "number" && Number.isInteger(num) && Number.isInteger(denom)) {
            const numIsEven = num % 2 === 0;
            const numIsOdd = num % 2 !== 0;
            const denomIsOdd = denom % 2 !== 0;
            if (numIsEven && denomIsOdd) {
              return {
                value: ce.PositiveInfinity,
                because: "(-inf)^(even/odd) -> +inf"
              };
            }
            if (numIsOdd && denomIsOdd) {
              return {
                value: ce.NegativeInfinity,
                because: "(-inf)^(odd/odd) -> -inf (real)"
              };
            }
          }
        }
      }
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-log.ts
function simplifyLog(x) {
  const op = x.operator;
  const ce = x.engine;
  if (op === "Ln") {
    const arg = x.op1;
    if (!arg) return void 0;
    if (arg.is(0)) {
      return { value: ce.NaN, because: "ln(0) -> NaN" };
    }
    if (arg.symbol === "PositiveInfinity") {
      return { value: ce.PositiveInfinity, because: "ln(+inf) -> +inf" };
    }
    if (arg.operator === "Power") {
      const base = arg.op1;
      const exp3 = arg.op2;
      if (base && exp3) {
        if (base.isNonNegative === true || exp3.isOdd === true || exp3.isRational === false) {
          return {
            value: exp3.mul(ce._fn("Ln", [base])),
            because: "ln(x^n) -> n*ln(x)"
          };
        }
        if (exp3.isEven === true) {
          return {
            value: exp3.mul(ce._fn("Ln", [ce._fn("Abs", [base])])),
            because: "ln(x^n) -> n*ln(|x|) when n even"
          };
        }
      }
    }
    if (arg.operator === "Power" && arg.op1?.symbol === "ExponentialE") {
      return { value: arg.op2, because: "ln(e^x) -> x" };
    }
    if (arg.operator === "Multiply" && arg.ops) {
      for (let i = 0; i < arg.ops.length; i++) {
        const factor3 = arg.ops[i];
        if (factor3.operator === "Power" && factor3.op1?.symbol === "ExponentialE") {
          const exp3 = factor3.op2;
          const otherFactors = arg.ops.filter((_, idx) => idx !== i);
          const remaining = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
          return {
            value: exp3.add(ce._fn("Ln", [remaining])),
            because: "ln(e^x * y) -> x + ln(y)"
          };
        }
      }
    }
    if (arg.operator === "Divide" && arg.op1?.operator === "Power" && arg.op1.op1?.symbol === "ExponentialE") {
      return {
        value: arg.op1.op2.sub(ce._fn("Ln", [arg.op2])),
        because: "ln(e^x / y) -> x - ln(y)"
      };
    }
    if (arg.operator === "Divide" && arg.op1 && arg.op2) {
      const num = arg.op1;
      const denom = arg.op2;
      if (num.isPositive === true && denom.isPositive === true) {
        return {
          value: ce._fn("Ln", [num]).sub(ce._fn("Ln", [denom])),
          because: "ln(x/y) -> ln(x) - ln(y)"
        };
      }
    }
    if (arg.operator === "Divide" && arg.op2?.operator === "Power" && arg.op2.op1?.symbol === "ExponentialE") {
      return {
        value: ce._fn("Ln", [arg.op1]).sub(arg.op2.op2),
        because: "ln(y / e^x) -> ln(y) - x"
      };
    }
  }
  if (op === "Log") {
    const arg = x.op1;
    const base = x.op2;
    if (!arg) return void 0;
    const logBase = !base || base.symbol === "Nothing" ? ce.number(10) : base;
    if (logBase.is(0) || logBase.is(1)) {
      return { value: ce.NaN, because: "log base 0 or 1 -> NaN" };
    }
    if (arg.is(0)) {
      return { value: ce.NaN, because: "log(0) -> NaN" };
    }
    if (arg.isSame(logBase)) {
      return { value: ce.One, because: "log_c(c) -> 1" };
    }
    if (arg.symbol === "ExponentialE" && logBase.symbol !== "ExponentialE") {
      return {
        value: ce.One.div(ce._fn("Ln", [logBase])),
        because: "log_c(e) -> 1/ln(c)"
      };
    }
    if (arg.symbol === "PositiveInfinity") {
      if (logBase.isGreater(1) === true) {
        return {
          value: ce.PositiveInfinity,
          because: "log_c(+inf) -> +inf when c > 1"
        };
      }
      if (logBase.isLess(1) === true && logBase.isPositive === true) {
        return {
          value: ce.NegativeInfinity,
          because: "log_c(+inf) -> -inf when 0 < c < 1"
        };
      }
    }
    if (logBase.symbol === "PositiveInfinity" && arg.isPositive === true && arg.is(1) === false && arg.isFinite === true) {
      return { value: ce.Zero, because: "log_inf(x) -> 0" };
    }
    if (arg.operator === "Power" && arg.op1?.isSame(logBase)) {
      return { value: arg.op2, because: "log_c(c^x) -> x" };
    }
    if (arg.operator === "Power" && arg.op1?.symbol === "ExponentialE" && !logBase.symbol?.match(/ExponentialE/)) {
      return {
        value: arg.op2.div(ce._fn("Ln", [logBase])),
        because: "log_c(e^x) -> x/ln(c)"
      };
    }
    if (arg.operator === "Exp" && arg.op1 && !logBase.symbol?.match(/ExponentialE/)) {
      return {
        value: arg.op1.div(ce._fn("Ln", [logBase])),
        because: "log_c(exp(x)) -> x/ln(c)"
      };
    }
    if (arg.operator === "Power") {
      const powerBase = arg.op1;
      const exp3 = arg.op2;
      if (powerBase && exp3) {
        if (powerBase.isNonNegative === true || exp3.isOdd === true || exp3.isRational === false) {
          return {
            value: exp3.mul(ce._fn("Log", [powerBase, logBase])),
            because: "log_c(x^n) -> n*log_c(x)"
          };
        }
        if (exp3.isEven === true) {
          return {
            value: exp3.mul(
              ce._fn("Log", [ce._fn("Abs", [powerBase]), logBase])
            ),
            because: "log_c(x^n) -> n*log_c(|x|) when n even"
          };
        }
      }
    }
    if (arg.operator === "Multiply" && arg.ops) {
      for (let i = 0; i < arg.ops.length; i++) {
        const factor3 = arg.ops[i];
        if (factor3.operator === "Power" && factor3.op1?.isSame(logBase)) {
          const exp3 = factor3.op2;
          const otherFactors = arg.ops.filter((_, idx) => idx !== i);
          const remaining = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
          return {
            value: exp3.add(ce._fn("Log", [remaining, logBase])),
            because: "log_c(c^x * y) -> x + log_c(y)"
          };
        }
      }
    }
    if (arg.operator === "Divide" && arg.op1?.operator === "Power" && arg.op1.op1?.isSame(logBase)) {
      return {
        value: arg.op1.op2.sub(ce._fn("Log", [arg.op2, logBase])),
        because: "log_c(c^x / y) -> x - log_c(y)"
      };
    }
    if (arg.operator === "Divide" && arg.op2?.operator === "Power" && arg.op2.op1?.isSame(logBase)) {
      return {
        value: ce._fn("Log", [arg.op1, logBase]).sub(arg.op2.op2),
        because: "log_c(y / c^x) -> log_c(y) - x"
      };
    }
    if (arg.operator === "Divide" && arg.op1 && arg.op2) {
      const num = arg.op1;
      const denom = arg.op2;
      if (num.isPositive === true && denom.isPositive === true) {
        const isDefaultBase = logBase.symbol === "Nothing";
        const logNum = isDefaultBase ? ce._fn("Log", [num]) : ce._fn("Log", [num, logBase]);
        const logDenom = isDefaultBase ? ce._fn("Log", [denom]) : ce._fn("Log", [denom, logBase]);
        return {
          value: logNum.sub(logDenom),
          because: "log_c(x/y) -> log_c(x) - log_c(y)"
        };
      }
    }
    if (logBase.operator === "Divide" && logBase.op1?.is(1)) {
      return {
        value: ce._fn("Log", [arg, logBase.op2]).neg(),
        because: "log_{1/c}(a) -> -log_c(a)"
      };
    }
  }
  if (op === "Power") {
    const base = x.op1;
    const exp3 = x.op2;
    if (!base || !exp3) return void 0;
    if (base.symbol === "ExponentialE" && exp3.operator === "Ln") {
      return { value: exp3.op1, because: "e^ln(x) -> x" };
    }
    if (base.symbol === "ExponentialE" && exp3.operator === "Log" && exp3.op1) {
      const logBase = exp3.op2;
      const isDefaultOrBase10 = !logBase || logBase.symbol === "Nothing" || logBase.is(10);
      if (isDefaultOrBase10) {
        return {
          value: exp3.op1.pow(ce.One.div(ce._fn("Ln", [ce.number(10)]))),
          because: "e^log(x) -> x^{1/ln(10)}"
        };
      }
      if (logBase && logBase.symbol !== "ExponentialE") {
        return {
          value: exp3.op1.pow(ce.One.div(ce._fn("Ln", [logBase]))),
          because: "e^log_c(x) -> x^{1/ln(c)}"
        };
      }
    }
    if (base.symbol === "ExponentialE" && exp3.operator === "Add" && exp3.ops) {
      for (let i = 0; i < exp3.ops.length; i++) {
        const term = exp3.ops[i];
        if (term.operator === "Ln") {
          const otherTerms = exp3.ops.filter((_, idx) => idx !== i);
          const remaining = otherTerms.length === 0 ? ce.Zero : otherTerms.length === 1 ? otherTerms[0] : ce._fn("Add", otherTerms);
          return {
            value: term.op1.mul(ce._fn("Exp", [remaining])),
            because: "e^(ln(x) + y) -> x * e^y"
          };
        }
      }
      for (let i = 0; i < exp3.ops.length; i++) {
        const term = exp3.ops[i];
        if (term.operator !== "Log" || !term.op1) continue;
        const otherTerms = exp3.ops.filter((_, idx) => idx !== i);
        const remaining = otherTerms.length === 0 ? ce.Zero : otherTerms.length === 1 ? otherTerms[0] : ce._fn("Add", otherTerms);
        const logBase = term.op2;
        const isDefaultOrBase10 = !logBase || logBase.symbol === "Nothing" || logBase.is(10);
        const expOfLog = isDefaultOrBase10 ? term.op1.pow(ce.One.div(ce._fn("Ln", [ce.number(10)]))) : logBase.symbol === "ExponentialE" ? term.op1 : term.op1.pow(ce.One.div(ce._fn("Ln", [logBase])));
        return {
          value: expOfLog.mul(base.pow(remaining)),
          because: "e^(log_c(x) + y) -> x^{1/ln(c)} * e^y"
        };
      }
    }
    if (base.symbol === "ExponentialE" && exp3.operator === "Multiply" && exp3.ops) {
      for (let i = 0; i < exp3.ops.length; i++) {
        const factor3 = exp3.ops[i];
        if (factor3.operator === "Ln") {
          const otherFactors = exp3.ops.filter((_, idx) => idx !== i);
          const y = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
          return {
            value: factor3.op1.pow(y),
            because: "e^(ln(x) * y) -> x^y"
          };
        }
      }
    }
    if (base.symbol === "ExponentialE" && exp3.operator === "Divide" && exp3.op1?.operator === "Ln") {
      return {
        value: exp3.op1.op1.pow(ce.One.div(exp3.op2)),
        because: "e^(ln(x) / y) -> x^(1/y)"
      };
    }
    if (exp3.operator === "Log" && exp3.op2?.isSame(base)) {
      return { value: exp3.op1, because: "c^log_c(x) -> x" };
    }
    if (exp3.operator === "Add" && exp3.ops) {
      for (let i = 0; i < exp3.ops.length; i++) {
        const term = exp3.ops[i];
        if (term.operator === "Log" && term.op2?.isSame(base)) {
          const otherTerms = exp3.ops.filter((_, idx) => idx !== i);
          const remaining = otherTerms.length === 0 ? ce.Zero : otherTerms.length === 1 ? otherTerms[0] : ce._fn("Add", otherTerms);
          return {
            value: term.op1.mul(base.pow(remaining)),
            because: "c^(log_c(x) + y) -> x * c^y"
          };
        }
      }
    }
    if (exp3.operator === "Multiply" && exp3.ops) {
      for (let i = 0; i < exp3.ops.length; i++) {
        const factor3 = exp3.ops[i];
        if (factor3.operator === "Log" && factor3.op2?.isSame(base)) {
          const otherFactors = exp3.ops.filter((_, idx) => idx !== i);
          const y = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
          return {
            value: factor3.op1.pow(y),
            because: "c^(log_c(x) * y) -> x^y"
          };
        }
      }
    }
    if (exp3.operator === "Divide" && exp3.op1?.operator === "Log" && exp3.op1.op2?.isSame(base)) {
      return {
        value: exp3.op1.op1.pow(ce.One.div(exp3.op2)),
        because: "c^(log_c(x) / y) -> x^(1/y)"
      };
    }
  }
  if (op === "Add" && x.ops && x.ops.length >= 2) {
    const lnTerms = [];
    const logTerms = /* @__PURE__ */ new Map();
    for (let i = 0; i < x.ops.length; i++) {
      const term = x.ops[i];
      if (term.operator === "Ln" && term.op1) {
        lnTerms.push({ index: i, arg: term.op1, positive: true });
      } else if (term.operator === "Negate" && term.op1?.operator === "Ln" && term.op1.op1) {
        lnTerms.push({ index: i, arg: term.op1.op1, positive: false });
      } else if (term.operator === "Log" && term.op1 && term.op2) {
        const baseKey = JSON.stringify(term.op2.json);
        if (!logTerms.has(baseKey)) {
          logTerms.set(baseKey, []);
        }
        logTerms.get(baseKey).push({ index: i, arg: term.op1, base: term.op2, positive: true });
      } else if (term.operator === "Negate" && term.op1?.operator === "Log" && term.op1.op1 && term.op1.op2) {
        const baseKey = JSON.stringify(term.op1.op2.json);
        if (!logTerms.has(baseKey)) {
          logTerms.set(baseKey, []);
        }
        logTerms.get(baseKey).push({
          index: i,
          arg: term.op1.op1,
          base: term.op1.op2,
          positive: false
        });
      }
    }
    if (lnTerms.length >= 2) {
      let numerator = ce.One;
      let denominator = ce.One;
      for (const t of lnTerms) {
        if (t.positive) {
          numerator = numerator.mul(t.arg);
        } else {
          denominator = denominator.mul(t.arg);
        }
      }
      const combinedArg = numerator.div(denominator);
      const combinedIndices = new Set(lnTerms.map((t) => t.index));
      const remainingTerms = x.ops.filter((_, i) => !combinedIndices.has(i));
      if (remainingTerms.length === 0) {
        return {
          value: ce._fn("Ln", [combinedArg]),
          because: "combine ln terms"
        };
      }
      return {
        value: ce._fn("Add", [ce._fn("Ln", [combinedArg]), ...remainingTerms]),
        because: "combine ln terms"
      };
    }
    for (const [, terms] of logTerms) {
      if (terms.length >= 2) {
        let numerator = ce.One;
        let denominator = ce.One;
        for (const t of terms) {
          if (t.positive) {
            numerator = numerator.mul(t.arg);
          } else {
            denominator = denominator.mul(t.arg);
          }
        }
        const combinedArg = numerator.div(denominator);
        const combinedIndices = new Set(terms.map((t) => t.index));
        const remainingTerms = x.ops.filter((_, i) => !combinedIndices.has(i));
        const base = terms[0].base;
        const isDefaultBase = base.symbol === "Nothing";
        const combinedLog = isDefaultBase ? ce._fn("Log", [combinedArg]) : ce._fn("Log", [combinedArg, base]);
        if (remainingTerms.length === 0) {
          return {
            value: combinedLog,
            because: "combine log terms"
          };
        }
        return {
          value: ce._fn("Add", [combinedLog, ...remainingTerms]),
          because: "combine log terms"
        };
      }
    }
  }
  if (op === "Divide") {
    const num = x.op1;
    const denom = x.op2;
    if (num && denom) {
      if (num.operator === "Log" && denom.operator === "Log" && num.op2?.isSame(denom.op2)) {
        return {
          value: ce._fn("Ln", [num.op1]).div(ce._fn("Ln", [denom.op1])),
          because: "log_c(a) / log_c(b) -> ln(a) / ln(b)"
        };
      }
      if (num.operator === "Log" && denom.operator === "Ln" && num.op1?.isSame(denom.op1)) {
        return {
          value: ce.One.div(ce._fn("Ln", [num.op2])),
          because: "log_c(a) / ln(a) -> 1/ln(c)"
        };
      }
      if (num.operator === "Ln" && denom.operator === "Log" && num.op1?.isSame(denom.op1)) {
        return {
          value: ce._fn("Ln", [denom.op2]),
          because: "ln(a) / log_c(a) -> ln(c)"
        };
      }
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-power.ts
init_numerics();
function simplifyPower(x) {
  const op = x.operator;
  const ce = x.engine;
  if (op === "Root") {
    const arg = x.op1;
    const rootIndex = x.op2;
    if (!arg || !rootIndex) return void 0;
    if (arg.operator === "Sqrt" && arg.op1) {
      const innerBase = arg.op1;
      return {
        value: innerBase.pow(ce.One.div(ce.number(2).mul(rootIndex))),
        because: "root(sqrt(x), n) -> x^{1/(2n)}"
      };
    }
    if (arg.operator === "Root" && arg.op1 && arg.op2) {
      const innerBase = arg.op1;
      const innerRootIndex = arg.op2;
      return {
        value: innerBase.pow(ce.One.div(innerRootIndex.mul(rootIndex))),
        because: "root(root(x, m), n) -> x^{1/(m*n)}"
      };
    }
    if (arg.operator === "Power") {
      const base = arg.op1;
      const exp3 = arg.op2;
      if (base && exp3?.isSame(rootIndex)) {
        if (rootIndex.isEven === true) {
          return {
            value: ce._fn("Abs", [base]),
            because: "root(x^n, n) -> |x| when n even"
          };
        }
        if (rootIndex.isOdd === true || base.isNonNegative === true) {
          return { value: base, because: "root(x^n, n) -> x when n odd" };
        }
      }
      if (base && exp3) {
        const resultExp = exp3.div(rootIndex);
        if (rootIndex.isEven === true) {
          if (resultExp.isInteger === true) {
            return {
              value: ce._fn("Abs", [base]).pow(resultExp),
              because: "root(x^m, n) -> |x|^{m/n} when m/n is integer"
            };
          }
          const rat = asRational(resultExp);
          if (rat) {
            const [, denom] = rat;
            const rootN = asRational(rootIndex);
            if (rootN && Number(denom) < Number(rootN[0])) {
              return {
                value: ce._fn("Abs", [base]).pow(resultExp),
                because: "root(x^m, n) -> |x|^{m/n}"
              };
            }
          }
        }
        if (rootIndex.isOdd === true && exp3.isInteger === true) {
          return {
            value: base.pow(resultExp),
            because: "root(x^m, n) -> x^{m/n} when n is odd"
          };
        }
        if (base.isNonNegative === true) {
          if (resultExp.isInteger === true) {
            return {
              value: base.pow(resultExp),
              because: "root(x^m, n) -> x^{m/n} when x >= 0"
            };
          }
        }
      }
    }
  }
  if (op === "Sqrt") {
    const arg = x.op1;
    if (!arg) return void 0;
    if (arg.operator === "Add") {
      const perfectSquare = factorPerfectSquare(arg);
      if (perfectSquare !== null) {
        const base = perfectSquare.op1;
        return {
          value: ce._fn("Abs", [base]),
          because: "sqrt(perfect square trinomial) -> |factor|"
        };
      }
      const diffSquares = factorDifferenceOfSquares(arg);
      if (diffSquares !== null) {
        return {
          value: ce._fn("Sqrt", [diffSquares]),
          because: "sqrt(a\xB2-b\xB2) -> sqrt((a-b)(a+b))"
        };
      }
    }
    if (arg.operator === "Sqrt" && arg.op1) {
      return {
        value: arg.op1.pow(ce.number([1, 4])),
        because: "sqrt(sqrt(x)) -> x^{1/4}"
      };
    }
    if (arg.operator === "Root" && arg.op1 && arg.op2) {
      const innerBase = arg.op1;
      const rootIndex = arg.op2;
      return {
        value: innerBase.pow(ce.One.div(ce.number(2).mul(rootIndex))),
        because: "sqrt(root(x, n)) -> x^{1/(2n)}"
      };
    }
    if (arg.operator === "Power") {
      const base = arg.op1;
      const exp3 = arg.op2;
      if (base && exp3) {
        if (exp3.is(2) && base.isNonNegative === true) {
          return { value: base, because: "sqrt(x^2) -> x when x >= 0" };
        }
        if (exp3.is(2)) {
          return { value: ce._fn("Abs", [base]), because: "sqrt(x^2) -> |x|" };
        }
        if (exp3.isEven === true && exp3.isPositive === true) {
          return {
            value: ce._fn("Abs", [base]).pow(exp3.div(2)),
            because: "sqrt(x^{2n}) -> |x|^n"
          };
        }
        if (exp3.isOdd === true && exp3.isInteger === true && exp3.isPositive === true) {
          const n = exp3.sub(ce.One).div(2);
          if (n.isPositive === true) {
            return {
              value: ce._fn("Abs", [base]).pow(n).mul(ce._fn("Sqrt", [base])),
              because: "sqrt(x^{2n+1}) -> |x|^n * sqrt(x)"
            };
          }
        }
      }
    }
    if (arg.operator === "Multiply" && arg.ops) {
      const perfectSquares = [];
      const remaining = [];
      for (const factor3 of arg.ops) {
        if (factor3.operator === "Power" && factor3.op1 && factor3.op2) {
          const base = factor3.op1;
          const exp3 = factor3.op2;
          if (exp3.is(2)) {
            perfectSquares.push(ce._fn("Abs", [base]));
          } else if (exp3.isEven === true && exp3.isPositive === true) {
            perfectSquares.push(ce._fn("Abs", [base]).pow(exp3.div(2)));
          } else if (exp3.isInteger === true && exp3.isPositive === true && exp3.isOdd === true) {
            const n = exp3.sub(ce.One).div(2);
            if (n.isPositive === true) {
              perfectSquares.push(ce._fn("Abs", [base]).pow(n));
            }
            remaining.push(base);
          } else {
            remaining.push(factor3);
          }
        } else {
          remaining.push(factor3);
        }
      }
      if (perfectSquares.length > 0) {
        const outsideSqrt = perfectSquares.length === 1 ? perfectSquares[0] : ce._fn("Multiply", perfectSquares);
        if (remaining.length === 0) {
          return {
            value: outsideSqrt,
            because: "sqrt(a^2 * ...) -> |a| * ..."
          };
        }
        const insideSqrt = remaining.length === 1 ? remaining[0] : ce._fn("Multiply", remaining);
        return {
          value: outsideSqrt.mul(ce._fn("Sqrt", [insideSqrt])),
          because: "sqrt(a^2 * b) -> |a| * sqrt(b)"
        };
      }
    }
  }
  if (op === "Power") {
    const base = x.op1;
    const exp3 = x.op2;
    if (!base || !exp3) return void 0;
    if (base.is(0) && exp3.isPositive === true) {
      return { value: ce.Zero, because: "0^x -> 0 when x > 0" };
    }
    if (base.is(-1)) {
      const rat = asRational(exp3);
      if (rat) {
        const [num, denom] = rat;
        const numN = Number(num);
        const denomN = Number(denom);
        if (numN % 2 !== 0 && denomN % 2 !== 0) {
          return {
            value: ce.number(-1),
            because: "(-1)^{p/q} -> -1 when p,q odd"
          };
        }
      }
    }
    if (base.operator === "Multiply" && base.ops) {
      const rat = asRational(exp3);
      if (rat) {
        const [num, denom] = rat;
        const numN = Number(num);
        const denomN = Number(denom);
        const numIsOdd = numN % 2 !== 0;
        const denomIsOdd = denomN % 2 !== 0;
        if (numIsOdd && denomIsOdd) {
          let negativeIndex = -1;
          for (let i = 0; i < base.ops.length; i++) {
            const factor3 = base.ops[i];
            if (factor3.isNumberLiteral && factor3.isNegative === true) {
              negativeIndex = i;
              break;
            }
          }
          if (negativeIndex >= 0) {
            const negFactor = base.ops[negativeIndex];
            const posFactor = negFactor.neg();
            const newFactors = base.ops.map(
              (f, i) => i === negativeIndex ? posFactor : f
            );
            const posBase = newFactors.length === 1 ? newFactors[0] : ce._fn("Multiply", newFactors);
            return {
              value: posBase.pow(exp3).neg(),
              because: "(-a*b)^{p/q} -> -(a*b)^{p/q} when p,q odd"
            };
          }
        }
      }
    }
    if (base.operator === "Multiply" && base.ops && exp3.isInteger === true) {
      const newFactors = base.ops.map((factor3) => factor3.pow(exp3));
      return {
        value: ce._fn("Multiply", newFactors),
        because: "(a*b)^n -> a^n * b^n"
      };
    }
    if (base.operator === "Negate" && base.op1) {
      const innerBase = base.op1;
      if (exp3.isEven === true) {
        return {
          value: innerBase.pow(exp3),
          because: "(-x)^n -> x^n when n is even"
        };
      }
      if (exp3.isOdd === true) {
        return {
          value: innerBase.pow(exp3).neg(),
          because: "(-x)^n -> -x^n when n is odd"
        };
      }
      const rat = asRational(exp3);
      if (rat) {
        const [num, denom] = rat;
        const numN = Number(num);
        const denomN = Number(denom);
        const numIsEven = numN % 2 === 0;
        const numIsOdd = numN % 2 !== 0;
        const denomIsOdd = denomN % 2 !== 0;
        if (numIsEven && denomIsOdd) {
          return {
            value: innerBase.pow(exp3),
            because: "(-x)^{n/m} -> x^{n/m} when n is even and m is odd"
          };
        }
        if (numIsOdd && denomIsOdd) {
          return {
            value: innerBase.pow(exp3).neg(),
            because: "(-x)^{n/m} -> -x^{n/m} when n and m are odd"
          };
        }
      }
    }
    if (base.operator === "Sqrt" && base.op1) {
      const innerBase = base.op1;
      if (exp3.isEven === true) {
        return {
          value: innerBase.pow(exp3.div(2)),
          because: "sqrt(x)^n -> x^{n/2} when n is even"
        };
      }
      if (innerBase.isNonNegative === true) {
        return {
          value: innerBase.pow(exp3.div(2)),
          because: "sqrt(x)^n -> x^{n/2} when x >= 0"
        };
      }
    }
    if (base.operator === "Root" && base.op1 && base.op2) {
      const innerBase = base.op1;
      const rootIndex = base.op2;
      const resultExp = exp3.div(rootIndex);
      if (resultExp.isInteger === true || innerBase.isNonNegative === true) {
        return {
          value: innerBase.pow(resultExp),
          because: "root(x, k)^n -> x^{n/k}"
        };
      }
    }
    if (base.operator === "Power") {
      const innerBase = base.op1;
      const innerExp = base.op2;
      if (innerBase && innerExp) {
        const bothIntegers = innerExp.isInteger === true && exp3.isInteger === true;
        const baseNonNeg = innerBase.isNonNegative === true;
        const productIrrational = innerExp.mul(exp3).isRational === false;
        const atLeastOnePositive = innerExp.isPositive === true || exp3.isPositive === true;
        if ((bothIntegers || baseNonNeg || productIrrational) && atLeastOnePositive) {
          return {
            value: innerBase.pow(innerExp.mul(exp3)),
            because: "(x^n)^m -> x^{n*m}"
          };
        }
      }
    }
    if (base.operator === "Divide" && base.op2?.is(0) === false) {
      const num = base.op1;
      const denom = base.op2;
      if (exp3.operator === "Negate") {
        return {
          value: denom.div(num).pow(exp3.op1),
          because: "(a/b)^{-n} -> (b/a)^n"
        };
      }
      if (exp3.is(-1)) {
        return { value: denom.div(num), because: "(a/b)^{-1} -> b/a" };
      }
      if (exp3.isNegative === true && exp3.isNumberLiteral) {
        return {
          value: denom.div(num).pow(exp3.neg()),
          because: "(a/b)^{-n} -> (b/a)^n"
        };
      }
    }
  }
  if (op === "Divide") {
    const num = x.op1;
    const denom = x.op2;
    if (!num || !denom) return void 0;
    if (num.operator === "Power" && denom.operator === "Power") {
      const baseNum = num.op1;
      const expNum = num.op2;
      const baseDenom = denom.op1;
      const expDenom = denom.op2;
      if (baseNum?.isSame(baseDenom) && expNum && expDenom) {
        return {
          value: baseNum.pow(expNum.sub(expDenom)),
          because: "a^m / a^n -> a^{m-n}"
        };
      }
    }
    if (num.operator === "Power" && num.op1?.isSame(denom)) {
      return {
        value: denom.pow(num.op2.sub(ce.One)),
        because: "a^m / a -> a^{m-1}"
      };
    }
    if (denom.operator === "Power" && denom.op1?.isSame(num)) {
      return {
        value: num.pow(ce.One.sub(denom.op2)),
        because: "a / a^n -> a^{1-n}"
      };
    }
    if (denom.operator === "Power" && denom.op1?.is(0) === false) {
      const base = denom.op1;
      const exp3 = denom.op2;
      if (exp3?.operator === "Negate") {
        return {
          value: num.mul(base.pow(exp3.op1)),
          because: "a / b^{-n} -> a * b^n"
        };
      }
    }
    if (denom.operator === "Multiply" && denom.ops) {
      for (let i = 0; i < denom.ops.length; i++) {
        const factor3 = denom.ops[i];
        if (factor3.operator === "Power" && factor3.op1?.is(0) === false && factor3.op2?.operator === "Negate") {
          const base = factor3.op1;
          const posExp = factor3.op2.op1;
          const otherFactors = denom.ops.filter((_, idx) => idx !== i);
          const d = otherFactors.length === 1 ? otherFactors[0] : ce._fn("Multiply", otherFactors);
          return {
            value: num.div(d).mul(base.pow(posExp)),
            because: "a / (d * b^{-n}) -> (a/d) * b^n"
          };
        }
      }
    }
    if (denom.operator === "Power" && denom.op1?.operator === "Divide" && denom.op1.op2?.is(0) === false) {
      const fracNum = denom.op1.op1;
      const fracDenom = denom.op1.op2;
      const exp3 = denom.op2;
      return {
        value: num.mul(fracDenom.div(fracNum).pow(exp3)),
        because: "a / (b/c)^d -> a * (c/b)^d"
      };
    }
  }
  if (op === "Multiply" && x.ops && x.ops.length >= 2) {
    if (x.ops.length === 2) {
      const [a, b] = x.ops;
      if (a.operator === "Power" && b.operator === "Power") {
        const baseA = a.op1;
        const expA = a.op2;
        const baseB = b.op1;
        const expB = b.op2;
        if (baseA?.isSame(baseB) && expA && expB) {
          const canCombine2 = baseA.isPositive === true || baseA.isNegative === true || expA.add(expB).isNonNegative === true;
          if (canCombine2) {
            return {
              value: baseA.pow(expA.add(expB)),
              because: "x^n * x^m -> x^{n+m}"
            };
          }
        }
      }
      if (b.operator === "Power" && a.isSame(b.op1)) {
        const canCombine2 = a.isPositive === true || a.isNegative === true || a.isNumberLiteral === true;
        if (canCombine2) {
          return {
            value: a.pow(b.op2.add(ce.One)),
            because: "x * x^n -> x^{n+1}"
          };
        }
      }
      if (a.operator === "Power" && b.isSame(a.op1)) {
        const canCombine2 = b.isPositive === true || b.isNegative === true || b.isNumberLiteral === true;
        if (canCombine2) {
          return {
            value: b.pow(a.op2.add(ce.One)),
            because: "x^n * x -> x^{n+1}"
          };
        }
      }
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-trig.ts
init_arithmetic_add();
var TRIG_FUNCS2 = /* @__PURE__ */ new Set(["Sin", "Cos", "Tan", "Cot", "Sec", "Csc"]);
var ODD_TRIG2 = /* @__PURE__ */ new Set(["Sin", "Tan", "Cot", "Csc"]);
var EVEN_TRIG = /* @__PURE__ */ new Set(["Cos", "Sec"]);
var COFUNCTION_MAP = {
  Sin: "Cos",
  Cos: "Sin",
  Tan: "Cot",
  Cot: "Tan",
  Sec: "Csc",
  Csc: "Sec"
};
var PI_PLUS_SIGN = {
  Sin: -1,
  Cos: -1,
  Tan: 1,
  Cot: 1,
  // cotangent has period , so cot(+x) = cot(x)
  Sec: -1,
  Csc: -1
  // csc(+x) = 1/sin(+x) = 1/(-sin(x)) = -csc(x)
};
var PI_MINUS_SIGN = {
  Sin: 1,
  Cos: -1,
  Tan: -1,
  Cot: -1,
  Sec: -1,
  Csc: 1
};
var INVERSE_TRIG = /* @__PURE__ */ new Set([
  "Arcsin",
  "Arccos",
  "Arctan",
  "Arccot",
  "Arcsec",
  "Arccsc"
]);
function reduceTrigPeriodicity(fn, arg, ce) {
  if (arg.operator !== "Add" || !arg.ops) return null;
  const terms = arg.ops;
  let piCoeff = null;
  let piTermIndex = -1;
  for (let i = 0; i < terms.length; i++) {
    const term = terms[i];
    if (term.symbol === "Pi") {
      piCoeff = 1;
      piTermIndex = i;
      break;
    }
    if (term.operator === "Multiply" && term.ops) {
      const termOps = term.ops;
      const piIndex = termOps.findIndex((op) => op.symbol === "Pi");
      if (piIndex >= 0) {
        const otherFactors = termOps.filter((_, idx) => idx !== piIndex);
        if (otherFactors.length === 1) {
          const n = otherFactors[0].numericValue;
          if (typeof n === "number" && Number.isInteger(n)) {
            piCoeff = n;
            piTermIndex = i;
            break;
          }
        } else if (otherFactors.length === 0) {
          piCoeff = 1;
          piTermIndex = i;
          break;
        }
      }
    }
    if (term.operator === "Negate" && term.op1?.symbol === "Pi") {
      piCoeff = -1;
      piTermIndex = i;
      break;
    }
  }
  if (piCoeff === null || piTermIndex < 0) return null;
  const period = fn === "Tan" || fn === "Cot" ? 1 : 2;
  let reduced = piCoeff % period;
  if (reduced < 0) reduced += period;
  const remainingTerms = terms.filter((_, idx) => idx !== piTermIndex);
  if (reduced !== 0) {
    if (reduced === 1) {
      remainingTerms.push(ce.Pi);
    } else {
      remainingTerms.push(ce.box(["Multiply", reduced, "Pi"]));
    }
  }
  if (reduced === piCoeff % period && reduced === piCoeff) return null;
  let newArg;
  if (remainingTerms.length === 0) {
    newArg = ce.Zero;
  } else if (remainingTerms.length === 1) {
    newArg = remainingTerms[0];
  } else {
    newArg = add3(...remainingTerms);
  }
  return ce.box([fn, newArg]);
}
function simplifyTrig(x) {
  const op = x.operator;
  const ce = x.engine;
  if (TRIG_FUNCS2.has(op)) {
    const arg = x.op1;
    if (!arg) return void 0;
    if (arg.isInfinity === true) {
      return { value: ce.NaN, because: `${op}(infinity) -> NaN` };
    }
    if (arg.operator === "Negate") {
      const innerArg = arg.op1;
      if (innerArg) {
        if (ODD_TRIG2.has(op)) {
          return {
            value: ce._fn(op, [innerArg]).neg(),
            because: `${op}(-x) -> -${op}(x)`
          };
        }
        if (EVEN_TRIG.has(op)) {
          return {
            value: ce._fn(op, [innerArg]),
            because: `${op}(-x) -> ${op}(x)`
          };
        }
      }
    }
    if (arg.operator === "Subtract") {
      const left = arg.op1;
      const right = arg.op2;
      if (left?.symbol === "Pi" && right) {
        const sign3 = PI_MINUS_SIGN[op];
        if (sign3 !== void 0) {
          const result = ce._fn(op, [right]);
          return {
            value: sign3 === 1 ? result : result.neg(),
            because: `${op}(\u03C0 - x) -> ${sign3 === 1 ? "" : "-"}${op}(x)`
          };
        }
      }
    }
    if (arg.operator === "Add" && arg.ops) {
      const piIndex = arg.ops.findIndex((op2) => op2.symbol === "Pi");
      if (piIndex >= 0) {
        const otherTerms = arg.ops.filter((_, idx) => idx !== piIndex);
        if (otherTerms.length === arg.ops.length - 1) {
          const remaining = otherTerms.length === 1 ? otherTerms[0] : ce._fn("Add", otherTerms);
          const sign3 = PI_PLUS_SIGN[op];
          if (sign3 !== void 0) {
            const result = ce._fn(op, [remaining]);
            return {
              value: sign3 === 1 ? result : result.neg(),
              because: `${op}(\u03C0 + x) -> ${sign3 === 1 ? "" : "-"}${op}(x)`
            };
          }
        }
      }
    }
    if (arg.operator === "Subtract") {
      const left = arg.op1;
      const right = arg.op2;
      let isPiOver2 = false;
      if (left?.operator === "Divide" && left.op1?.symbol === "Pi" && left.op2?.is(2)) {
        isPiOver2 = true;
      }
      if (isPiOver2 && right) {
        const coFunc = COFUNCTION_MAP[op];
        if (coFunc) {
          return {
            value: ce._fn(coFunc, [right]),
            because: `${op}(\u03C0/2 - x) -> ${coFunc}(x)`
          };
        }
      }
    }
    if (arg.operator === "Add" && arg.nops === 2) {
      const ops = arg.ops;
      let piOver2Term = null;
      let negatedTerm = null;
      for (const term of ops) {
        if (term.operator === "Multiply" && term.nops === 2) {
          const [coef, sym] = [term.op1, term.op2];
          if (sym?.symbol === "Pi") {
            const coefRe = coef?.re;
            if (typeof coefRe === "number" && Math.abs(coefRe - 0.5) < 1e-10) {
              piOver2Term = term;
            }
          }
        }
        if (term.operator === "Negate" && term.op1) {
          negatedTerm = term.op1;
        }
      }
      if (piOver2Term && negatedTerm) {
        const coFunc = COFUNCTION_MAP[op];
        if (coFunc) {
          return {
            value: ce._fn(coFunc, [negatedTerm]),
            because: `${op}(\u03C0/2 - x) -> ${coFunc}(x)`
          };
        }
      }
    }
    if (arg.operator === "Add") {
      const reduced = reduceTrigPeriodicity(
        op,
        arg,
        ce
      );
      if (reduced) {
        return { value: reduced, because: `${op} periodicity reduction` };
      }
    }
  }
  if (INVERSE_TRIG.has(op)) {
    const arg = x.op1;
    if (!arg) return void 0;
    if (op === "Arcsin" || op === "Arccos") {
      if (arg.isInfinity === true) {
        return { value: ce.NaN, because: `${op}(infinity) -> NaN` };
      }
    }
    if (op === "Arctan") {
      if (arg.symbol === "PositiveInfinity") {
        return { value: ce.Pi.div(2), because: "arctan(+inf) -> \u03C0/2" };
      }
      if (arg.symbol === "NegativeInfinity") {
        return { value: ce.Pi.div(-2), because: "arctan(-inf) -> -\u03C0/2" };
      }
    }
    if (op === "Arccot") {
      if (arg.symbol === "PositiveInfinity") {
        return { value: ce.Zero, because: "arccot(+inf) -> 0" };
      }
      if (arg.symbol === "NegativeInfinity") {
        return { value: ce.Pi, because: "arccot(-inf) -> \u03C0" };
      }
    }
    if (op === "Arcsec") {
      if (arg.isInfinity === true) {
        return { value: ce.Pi.div(2), because: "arcsec(\xB1inf) -> \u03C0/2" };
      }
    }
    if (op === "Arccsc") {
      if (arg.isInfinity === true) {
        return { value: ce.Zero, because: "arccsc(\xB1inf) -> 0" };
      }
    }
  }
  if (op === "Multiply" && x.ops) {
    if (x.ops.length >= 2) {
      let sinTerm = null;
      let cosTerm = null;
      const otherTerms = [];
      for (const term of x.ops) {
        if (term.operator === "Sin" && !sinTerm) {
          sinTerm = term;
        } else if (term.operator === "Cos" && !cosTerm) {
          cosTerm = term;
        } else {
          otherTerms.push(term);
        }
      }
      if (sinTerm && cosTerm) {
        const sinArg = sinTerm.op1;
        const cosArg = cosTerm.op1;
        if (sinArg?.isSame(cosArg)) {
          const sin2x = ce._fn("Sin", [sinArg.mul(2)]);
          if (otherTerms.length === 0) {
            return {
              value: sin2x.div(2),
              because: "sin(x)*cos(x) -> sin(2x)/2"
            };
          } else {
            const coefficient = otherTerms.length === 1 ? otherTerms[0] : ce._fn("Multiply", otherTerms);
            if (coefficient.is(2)) {
              return {
                value: sin2x,
                because: "2*sin(x)*cos(x) -> sin(2x)"
              };
            }
            return {
              value: coefficient.mul(sin2x).div(2),
              because: "c*sin(x)*cos(x) -> c*sin(2x)/2"
            };
          }
        }
      }
    }
    if (x.ops.length === 2) {
      const [a, b] = x.ops;
      if (a.operator === "Sin" && b.operator === "Sin") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA && argB) {
          return {
            value: ce._fn("Cos", [argA.sub(argB)]).sub(ce._fn("Cos", [argA.add(argB)])).div(2),
            because: "sin(x)*sin(y) -> (cos(x-y)-cos(x+y))/2"
          };
        }
      }
      if (a.operator === "Cos" && b.operator === "Cos") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA && argB) {
          return {
            value: ce._fn("Cos", [argA.sub(argB)]).add(ce._fn("Cos", [argA.add(argB)])).div(2),
            because: "cos(x)*cos(y) -> (cos(x-y)+cos(x+y))/2"
          };
        }
      }
      if (a.operator === "Tan" && b.operator === "Cot") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA?.isSame(argB)) {
          return { value: ce.One, because: "tan(x)*cot(x) -> 1" };
        }
      }
      if (a.operator === "Cot" && b.operator === "Tan") {
        const argA = a.op1;
        const argB = b.op1;
        if (argA?.isSame(argB)) {
          return { value: ce.One, because: "cot(x)*tan(x) -> 1" };
        }
      }
      if (a.is(2) && b.operator === "Power" && b.op2?.is(2)) {
        const base = b.op1;
        if (base?.operator === "Sin" && base.op1) {
          const cos2x = ce._fn("Cos", [base.op1.mul(2)]);
          return {
            value: ce.One.sub(cos2x),
            because: "2sin\xB2(x) -> 1 - cos(2x)"
          };
        }
        if (base?.operator === "Cos" && base.op1) {
          const cos2x = ce._fn("Cos", [base.op1.mul(2)]);
          return {
            value: ce.One.add(cos2x),
            because: "2cos\xB2(x) -> 1 + cos(2x)"
          };
        }
      }
      if (b.is(2) && a.operator === "Power" && a.op2?.is(2)) {
        const base = a.op1;
        if (base?.operator === "Sin" && base.op1) {
          const cos2x = ce._fn("Cos", [base.op1.mul(2)]);
          return {
            value: ce.One.sub(cos2x),
            because: "2sin\xB2(x) -> 1 - cos(2x)"
          };
        }
        if (base?.operator === "Cos" && base.op1) {
          const cos2x = ce._fn("Cos", [base.op1.mul(2)]);
          return {
            value: ce.One.add(cos2x),
            because: "2cos\xB2(x) -> 1 + cos(2x)"
          };
        }
      }
    }
  }
  if (op === "Add" && x.ops && x.ops.length === 2) {
    const [a, b] = x.ops;
    if (a.operator === "Power" && b.operator === "Power" && a.op2?.is(2) && b.op2?.is(2)) {
      const sinArg = a.op1?.operator === "Sin" ? a.op1.op1 : null;
      const cosArg = b.op1?.operator === "Cos" ? b.op1.op1 : null;
      if (sinArg && cosArg && sinArg.isSame(cosArg)) {
        return { value: ce.One, because: "sin\xB2(x) + cos\xB2(x) -> 1" };
      }
      const sinArg2 = b.op1?.operator === "Sin" ? b.op1.op1 : null;
      const cosArg2 = a.op1?.operator === "Cos" ? a.op1.op1 : null;
      if (sinArg2 && cosArg2 && sinArg2.isSame(cosArg2)) {
        return { value: ce.One, because: "cos\xB2(x) + sin\xB2(x) -> 1" };
      }
    }
    if (a.operator === "Power" && a.op2?.is(2) && b.is(1)) {
      if (a.op1?.operator === "Tan") {
        return {
          value: ce._fn("Sec", [a.op1.op1]).pow(2),
          because: "tan\xB2(x) + 1 -> sec\xB2(x)"
        };
      }
    }
    if (b.operator === "Power" && b.op2?.is(2) && a.is(1)) {
      if (b.op1?.operator === "Tan") {
        return {
          value: ce._fn("Sec", [b.op1.op1]).pow(2),
          because: "1 + tan\xB2(x) -> sec\xB2(x)"
        };
      }
    }
    if (a.operator === "Power" && a.op2?.is(2) && b.is(1)) {
      if (a.op1?.operator === "Cot") {
        return {
          value: ce._fn("Csc", [a.op1.op1]).pow(2),
          because: "cot\xB2(x) + 1 -> csc\xB2(x)"
        };
      }
    }
    if (b.operator === "Power" && b.op2?.is(2) && a.is(1)) {
      if (b.op1?.operator === "Cot") {
        return {
          value: ce._fn("Csc", [b.op1.op1]).pow(2),
          because: "1 + cot\xB2(x) -> csc\xB2(x)"
        };
      }
    }
    if (a.operator === "Multiply" && b.operator === "Multiply") {
      const extractCoeffAndTrig = (expr) => {
        if (expr.operator !== "Multiply" || !expr.ops || expr.ops.length !== 2)
          return null;
        const [c, p] = expr.ops;
        if (p.operator === "Power" && p.op2?.is(2) && (p.op1?.operator === "Sin" || p.op1?.operator === "Cos")) {
          return { coeff: c, trigFunc: p.op1.operator, trigArg: p.op1.op1 };
        }
        if (c.operator === "Power" && c.op2?.is(2) && (c.op1?.operator === "Sin" || c.op1?.operator === "Cos")) {
          return { coeff: p, trigFunc: c.op1.operator, trigArg: c.op1.op1 };
        }
        return null;
      };
      const infoA = extractCoeffAndTrig(a);
      const infoB = extractCoeffAndTrig(b);
      if (infoA && infoB && infoA.coeff.isSame(infoB.coeff) && infoA.trigArg?.isSame(infoB.trigArg) && (infoA.trigFunc === "Sin" && infoB.trigFunc === "Cos" || infoA.trigFunc === "Cos" && infoB.trigFunc === "Sin")) {
        return {
          value: infoA.coeff,
          because: "a*sin\xB2(x) + a*cos\xB2(x) -> a"
        };
      }
    }
  }
  if (op === "Add" && x.ops && x.ops.length === 2) {
    const [a, b] = x.ops;
    let one = null;
    let negatedTrigSquared = null;
    if (a.is(1) && b.operator === "Negate") {
      one = a;
      negatedTrigSquared = b.op1;
    } else if (b.is(1) && a.operator === "Negate") {
      one = b;
      negatedTrigSquared = a.op1;
    }
    if (one && negatedTrigSquared) {
      if (negatedTrigSquared.operator === "Power" && negatedTrigSquared.op2?.is(2)) {
        const base = negatedTrigSquared.op1;
        if (base?.operator === "Sin") {
          return {
            value: ce._fn("Cos", [base.op1]).pow(2),
            because: "1 - sin\xB2(x) -> cos\xB2(x)"
          };
        }
        if (base?.operator === "Cos") {
          return {
            value: ce._fn("Sin", [base.op1]).pow(2),
            because: "1 - cos\xB2(x) -> sin\xB2(x)"
          };
        }
      }
    }
    let negOne = null;
    let trigSquared = null;
    if (a.is(-1) && b.operator === "Power" && b.op2?.is(2)) {
      negOne = a;
      trigSquared = b;
    } else if (b.is(-1) && a.operator === "Power" && a.op2?.is(2)) {
      negOne = b;
      trigSquared = a;
    }
    if (negOne && trigSquared) {
      const base = trigSquared.op1;
      if (base?.operator === "Sin") {
        return {
          value: ce._fn("Cos", [base.op1]).pow(2).neg(),
          because: "sin\xB2(x) - 1 -> -cos\xB2(x)"
        };
      }
      if (base?.operator === "Cos") {
        return {
          value: ce._fn("Sin", [base.op1]).pow(2).neg(),
          because: "cos\xB2(x) - 1 -> -sin\xB2(x)"
        };
      }
      if (base?.operator === "Sec") {
        return {
          value: ce._fn("Tan", [base.op1]).pow(2),
          because: "sec\xB2(x) - 1 -> tan\xB2(x)"
        };
      }
      if (base?.operator === "Csc") {
        return {
          value: ce._fn("Cot", [base.op1]).pow(2),
          because: "csc\xB2(x) - 1 -> cot\xB2(x)"
        };
      }
    }
    let negOneAlt = null;
    let secOrCscSquared = null;
    if (a.operator === "Negate" && a.op1?.is(1) && b.operator === "Power" && b.op2?.is(2)) {
      negOneAlt = a;
      secOrCscSquared = b;
    } else if (b.operator === "Negate" && b.op1?.is(1) && a.operator === "Power" && a.op2?.is(2)) {
      negOneAlt = b;
      secOrCscSquared = a;
    }
    if (negOneAlt && secOrCscSquared) {
      const base = secOrCscSquared.op1;
      if (base?.operator === "Sec") {
        return {
          value: ce._fn("Tan", [base.op1]).pow(2),
          because: "sec\xB2(x) - 1 -> tan\xB2(x)"
        };
      }
      if (base?.operator === "Csc") {
        return {
          value: ce._fn("Cot", [base.op1]).pow(2),
          because: "csc\xB2(x) - 1 -> cot\xB2(x)"
        };
      }
    }
    if (a.operator === "Negate" && b.operator === "Negate") {
      const aInner = a.op1;
      const bInner = b.op1;
      if (aInner?.operator === "Power" && aInner.op2?.is(2) && bInner?.operator === "Power" && bInner.op2?.is(2)) {
        const aBase = aInner.op1;
        const bBase = bInner.op1;
        if ((aBase?.operator === "Sin" && bBase?.operator === "Cos" || aBase?.operator === "Cos" && bBase?.operator === "Sin") && aBase?.op1?.isSame(bBase?.op1)) {
          return { value: ce.NegativeOne, because: "-sin\xB2(x) - cos\xB2(x) -> -1" };
        }
      }
    }
  }
  if (op === "Arcsin") {
    const arg = x.op1;
    if (arg) {
      return {
        value: ce._fn("Arctan2", [
          arg,
          ce.One.add(ce._fn("Sqrt", [ce.One.sub(arg.pow(2))]))
        ]).mul(2),
        because: "arcsin(x) -> 2*arctan2(x, 1+sqrt(1-x\xB2))"
      };
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-hyperbolic.ts
var HYPERBOLIC_FUNCS = /* @__PURE__ */ new Set([
  "Sinh",
  "Cosh",
  "Tanh",
  "Coth",
  "Sech",
  "Csch"
]);
var ODD_HYPERBOLIC = /* @__PURE__ */ new Set(["Sinh", "Tanh", "Coth", "Csch"]);
var EVEN_HYPERBOLIC = /* @__PURE__ */ new Set(["Cosh", "Sech"]);
var INVERSE_HYPERBOLIC = /* @__PURE__ */ new Set([
  "Arsinh",
  "Arcosh",
  "Artanh",
  "Arcoth",
  "Arsech",
  "Arcsch"
]);
function simplifyHyperbolic(x) {
  const op = x.operator;
  const ce = x.engine;
  if (HYPERBOLIC_FUNCS.has(op)) {
    const arg = x.op1;
    if (!arg) return void 0;
    if (arg.symbol === "PositiveInfinity") {
      switch (op) {
        case "Sinh":
          return { value: ce.PositiveInfinity, because: "sinh(+inf) -> +inf" };
        case "Cosh":
          return { value: ce.PositiveInfinity, because: "cosh(+inf) -> +inf" };
        case "Tanh":
          return { value: ce.One, because: "tanh(+inf) -> 1" };
        case "Coth":
          return { value: ce.One, because: "coth(+inf) -> 1" };
        case "Sech":
          return { value: ce.Zero, because: "sech(+inf) -> 0" };
        case "Csch":
          return { value: ce.Zero, because: "csch(+inf) -> 0" };
      }
    }
    if (arg.symbol === "NegativeInfinity") {
      switch (op) {
        case "Sinh":
          return { value: ce.NegativeInfinity, because: "sinh(-inf) -> -inf" };
        case "Cosh":
          return { value: ce.PositiveInfinity, because: "cosh(-inf) -> +inf" };
        case "Tanh":
          return { value: ce.NegativeOne, because: "tanh(-inf) -> -1" };
        case "Coth":
          return { value: ce.NegativeOne, because: "coth(-inf) -> -1" };
        case "Sech":
          return { value: ce.Zero, because: "sech(-inf) -> 0" };
        case "Csch":
          return { value: ce.Zero, because: "csch(-inf) -> 0" };
      }
    }
    if (arg.isInfinity === true) {
    }
    if (arg.operator === "Negate") {
      const innerArg = arg.op1;
      if (innerArg) {
        if (ODD_HYPERBOLIC.has(op)) {
          return {
            value: ce._fn(op, [innerArg]).neg(),
            because: `${op}(-x) -> -${op}(x)`
          };
        }
        if (EVEN_HYPERBOLIC.has(op)) {
          return {
            value: ce._fn(op, [innerArg]),
            because: `${op}(-x) -> ${op}(x)`
          };
        }
      }
    }
    if (op === "Sinh") {
      return {
        value: ce._fn("Exp", [arg]).sub(ce._fn("Exp", [arg.neg()])).div(2),
        because: "sinh(x) -> (e^x - e^{-x})/2"
      };
    }
    if (op === "Cosh") {
      return {
        value: ce._fn("Exp", [arg]).add(ce._fn("Exp", [arg.neg()])).div(2),
        because: "cosh(x) -> (e^x + e^{-x})/2"
      };
    }
  }
  if (INVERSE_HYPERBOLIC.has(op)) {
    const arg = x.op1;
    if (!arg) return void 0;
    if (op === "Arsinh") {
      if (arg.symbol === "PositiveInfinity") {
        return { value: ce.PositiveInfinity, because: "arsinh(+inf) -> +inf" };
      }
      if (arg.symbol === "NegativeInfinity") {
        return { value: ce.NegativeInfinity, because: "arsinh(-inf) -> -inf" };
      }
      return {
        value: ce._fn("Ln", [
          arg.add(ce._fn("Sqrt", [arg.pow(2).add(ce.One)]))
        ]),
        because: "arsinh(x) -> ln(x + sqrt(x^2 + 1))"
      };
    }
    if (op === "Arcosh") {
      if (arg.symbol === "PositiveInfinity") {
        return { value: ce.PositiveInfinity, because: "arcosh(+inf) -> +inf" };
      }
      if (arg.symbol === "NegativeInfinity") {
        return { value: ce.NaN, because: "arcosh(-inf) -> NaN" };
      }
      if (arg.isGreater(1) === true) {
        return {
          value: ce._fn("Ln", [
            arg.add(ce._fn("Sqrt", [arg.pow(2).sub(ce.One)]))
          ]),
          because: "arcosh(x) -> ln(x + sqrt(x^2 - 1))"
        };
      }
    }
    if (op === "Artanh") {
      if (arg.isInfinity === true) {
        return { value: ce.NaN, because: "artanh(\xB1inf) -> NaN" };
      }
      return {
        value: ce.Half.mul(
          ce._fn("Ln", [ce.One.add(arg).div(ce.One.sub(arg))])
        ),
        because: "artanh(x) -> (1/2)*ln((1+x)/(1-x))"
      };
    }
    if (op === "Arcoth") {
      if (arg.isInfinity === true) {
        return { value: ce.NaN, because: "arcoth(\xB1inf) -> NaN" };
      }
    }
    if (op === "Arsech") {
      if (arg.isInfinity === true) {
        return { value: ce.NaN, because: "arsech(\xB1inf) -> NaN" };
      }
    }
    if (op === "Arcsch") {
      if (arg.isInfinity === true) {
        return { value: ce.Zero, because: "arcsch(\xB1inf) -> 0" };
      }
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-divide.ts
function simplifyDivide(x) {
  if (x.operator !== "Divide") return void 0;
  const num = x.op1;
  const denom = x.op2;
  if (!num || !denom) return void 0;
  const ce = x.engine;
  if (num.is(0) && denom.is(0)) {
    return { value: ce.NaN, because: "0/0 -> NaN" };
  }
  if (num.is(0) && denom.is(0) === false && (denom.isNumberLiteral || denom.symbols.length !== 0)) {
    return { value: ce.Zero, because: "0/a -> 0" };
  }
  if (num.isSame(denom) && num.is(0) === false && num.isInfinity !== true && (num.isNumberLiteral || num.symbols.length !== 0)) {
    return { value: ce.One, because: "a/a -> 1" };
  }
  if (num.isInfinity && denom.isInfinity) {
    return { value: ce.NaN, because: "inf/inf -> NaN" };
  }
  if (denom.operator === "Divide") {
    const denomNum = denom.op1;
    const denomDenom = denom.op2;
    if (!denomNum || !denomDenom) return void 0;
    if (num.is(1) && denomNum.is(1) && denomDenom.is(0) === false) {
      return { value: denomDenom, because: "1/(1/a) -> a" };
    }
    if (denomNum.is(1) && denomDenom.is(0) === false) {
      return { value: num.mul(denomDenom), because: "a/(1/b) -> a*b" };
    }
    if (denomDenom.is(0) === false) {
      return {
        value: num.mul(denomDenom).div(denomNum),
        because: "a/(b/c) -> a*c/b"
      };
    }
  }
  return void 0;
}

// src/compute-engine/symbolic/simplify-rules.ts
var SIMPLIFY_RULES = [
  // The Golden Ratio, a constant that can be simplified
  {
    match: { sym: "GoldenRatio" },
    replace: ["Divide", ["Add", 1, ["Sqrt", 5]], 2]
  },
  simplifyRelationalOperator,
  simplifySystemOfEquations,
  //
  // Cancel common polynomial factors in Divide expressions
  // e.g., (x - 1)/(x - 1)  x + 1
  // Must run before expand to preserve polynomial structure
  //
  // IMPORTANT: cancelCommonFactors must not call .simplify() on its result
  // to avoid infinite recursion (this rule would trigger again, creating
  // an infinite loop). See polynomials.ts for implementation details.
  //
  (x) => {
    if (x.operator !== "Divide") return void 0;
    const unknowns = x.unknowns;
    if (unknowns.length !== 1) return void 0;
    const variable = unknowns[0];
    const result = cancelCommonFactors(x, variable);
    if (result.isSame(x)) return void 0;
    return { value: result, because: "cancel common polynomial factors" };
  },
  // Try to expand the expression:
  // x*(y+z) -> x*y + x*z
  (x) => {
    if (x.operator === "Multiply" && x.ops) {
      const powerBases = /* @__PURE__ */ new Map();
      for (const op of x.ops) {
        let baseKey = null;
        if (op.operator === "Power" && op.op1) {
          baseKey = JSON.stringify(op.op1.json);
        } else if (op.symbol) {
          baseKey = JSON.stringify(op.json);
        }
        if (baseKey) {
          powerBases.set(baseKey, (powerBases.get(baseKey) || 0) + 1);
        }
      }
      for (const count of powerBases.values()) {
        if (count > 1) return void 0;
      }
    }
    const value = expand2(x);
    return value ? { value, because: "expand" } : void 0;
  },
  //
  // Add, Negate
  //
  (x) => {
    if (x.operator !== "Add") return void 0;
    return {
      value: add3(
        ...x.ops.map((op) => {
          const canonical2 = op.canonical;
          if (canonical2.unknowns.length === 0 && canonical2.ops) {
            const evaluated = canonical2.evaluate();
            if (evaluated.isNumberLiteral) return evaluated;
          }
          return canonical2;
        })
      ),
      because: "addition"
    };
  },
  (x) => {
    if (x.operator !== "Negate") return void 0;
    return { value: x.op1.neg(), because: "negation" };
  },
  //
  // Multiply
  //
  (x) => {
    if (x.operator !== "Multiply") return void 0;
    const ops = x.ops;
    const powerBases = /* @__PURE__ */ new Map();
    for (const op of ops) {
      let baseKey = null;
      let baseOp = null;
      if (op.operator === "Power" && op.op1) {
        baseKey = JSON.stringify(op.op1.json);
        baseOp = op;
      } else if (op.symbol) {
        baseKey = JSON.stringify(op.json);
        baseOp = op;
      }
      if (baseKey && baseOp) {
        const group = powerBases.get(baseKey) || [];
        group.push(baseOp);
        powerBases.set(baseKey, group);
      }
    }
    for (const group of powerBases.values()) {
      if (group.length > 1) return void 0;
    }
    if (ops.length === 2) {
      const [a, b] = ops;
      const hasTrigSquared = a.operator === "Power" && a.op2?.is(2) && ["Sin", "Cos"].includes(a.op1?.operator || "") || b.operator === "Power" && b.op2?.is(2) && ["Sin", "Cos"].includes(b.op1?.operator || "");
      const hasCoefficient = a.isNumberLiteral || b.isNumberLiteral;
      if (hasTrigSquared && hasCoefficient) return void 0;
      const hasSin = a.operator === "Sin" || b.operator === "Sin";
      const hasCos = a.operator === "Cos" || b.operator === "Cos";
      if (hasSin && hasCos) return void 0;
      const hasTan = a.operator === "Tan" || b.operator === "Tan";
      const hasCot = a.operator === "Cot" || b.operator === "Cot";
      if (hasTan && hasCot) return void 0;
    }
    return {
      value: mul3(
        ...ops.map((op) => {
          const canonical2 = op.canonical;
          if (canonical2.unknowns.length === 0 && canonical2.ops) {
            if (canonical2.operator === "Power") {
              if (canonical2.op1?.symbol === "ExponentialE") {
                return canonical2;
              }
              if (canonical2.op2?.isRational === true && canonical2.op2?.isInteger === false) {
                return canonical2;
              }
            }
            const evaluated = canonical2.evaluate();
            if (evaluated.isNumberLiteral) return evaluated;
          }
          return canonical2;
        })
      ),
      because: "multiplication"
    };
  },
  //
  // Divide, Rational
  //
  (x) => {
    if (x.operator === "Divide") {
      const num = x.op1;
      const denom = x.op2;
      if (num && denom && denom.isNumberLiteral !== true && denom.symbols.length === 0) {
        if (num.is(0) || num.isSame(denom)) return void 0;
      }
      if (num.operator === "Power" && denom.operator === "Power") {
        if (num.op1?.isSame(denom.op1)) return void 0;
      }
      if (num.operator === "Power" && num.op1?.isSame(denom)) return void 0;
      if (denom.operator === "Power" && denom.op1?.isSame(num))
        return void 0;
      return { value: num.div(denom), because: "division" };
    }
    if (x.operator === "Rational" && x.nops === 2)
      return { value: x.op1.div(x.op2), because: "rational" };
    return void 0;
  },
  //
  // Power, Root, Sqrt
  //
  (x) => {
    if (!x.op1?.isNumberLiteral) return void 0;
    if (x.operator === "Sqrt") {
      if (x.op1.isNegative)
        return {
          value: x.engine.box(["Multiply", ["Sqrt", x.op1.neg()], "ImaginaryUnit"]).simplify(),
          because: "sqrt"
        };
      const val = x.op1.sqrt();
      if (isExact(val.numericValue)) return { value: val, because: "sqrt" };
      return void 0;
    }
    const op1 = x.op1;
    const op2 = x.op2;
    if (!op2?.isNumberLiteral) return void 0;
    if (op1.isInteger && op2.isInteger && op1.re < SMALL_INTEGER && op2.re < SMALL_INTEGER) {
      if (x.operator === "Power")
        return { value: x.op1.pow(x.op2), because: "power" };
      if (x.operator === "Root") {
        const val = x.op1.root(x.op2);
        if (isExact(val.numericValue))
          return { value: x.op1.root(x.op2), because: "root" };
      }
    }
    return void 0;
  },
  //
  // Sign
  //
  (x) => {
    if (x.operator !== "Sign") return void 0;
    const s = x.sgn;
    const ce = x.engine;
    if (s === void 0) return void 0;
    if (s === "positive") return { value: ce.One, because: "sign positive" };
    if (s === "negative")
      return { value: ce.NegativeOne, because: "sign negative" };
    if (s === "zero") return { value: ce.Zero, because: "sign zero" };
    if (s === "unsigned") return { value: ce.NaN, because: "sign unsinged" };
    return void 0;
  },
  //
  // Ln, Log (basic evaluation)
  //
  (x) => {
    if (x.operator === "Ln")
      return { value: x.op1.ln(x.ops[1]), because: "ln" };
    if (x.operator === "Log")
      return { value: x.op1.ln(x.ops[1] ?? 10), because: "log" };
    return void 0;
  },
  //
  // Min/Max/Supremum/Infimum
  //
  (x) => {
    if (x.operator === "Max") {
      if (x.nops === 0)
        return { value: x.engine.NegativeInfinity, because: "max" };
      if (x.nops === 1) return { value: x.op1, because: "max" };
    } else if (x.operator === "Min") {
      if (x.nops === 0)
        return { value: x.engine.PositiveInfinity, because: "min" };
      if (x.nops === 1) return { value: x.op1, because: "min" };
    } else if (x.operator === "Supremum") {
      if (x.nops === 0)
        return { value: x.engine.NegativeInfinity, because: "sup" };
      if (x.nops === 1) return { value: x.op1, because: "sup" };
    } else if (x.operator === "Infimum") {
      if (x.nops === 0)
        return { value: x.engine.PositiveInfinity, because: "inf" };
      if (x.nops === 1) return { value: x.op1, because: "inf" };
    }
    return void 0;
  },
  //
  // Derivative
  //
  (x) => {
    if (x.operator !== "Derivative") return void 0;
    const ce = x.engine;
    const [f, degree] = x.ops;
    if (x.nops === 2)
      return {
        value: ce._fn("Derivative", [f.simplify(), degree]),
        because: "derivative"
      };
    if (x.nops === 1) {
      return {
        value: ce._fn("Derivative", [f.simplify()]),
        because: "derivative"
      };
    }
    return void 0;
  },
  //
  // Hypot
  //
  (x) => {
    if (x.operator !== "Hypot") return void 0;
    const ce = x.engine;
    return {
      value: ce.box(["Sqrt", ["Add", ["Square", x.op1], ["Square", x.op2]]]).simplify(),
      because: "hypot(x,y) -> sqrt(x^2+y^2)"
    };
  },
  //
  // Congruent
  //
  (x) => {
    if (x.operator !== "Congruent") return void 0;
    if (x.nops < 3) return void 0;
    const ce = x.engine;
    return {
      value: ce._fn("Equal", [
        ce.function("Mod", [x.ops[0], x.ops[2]]).simplify(),
        ce.function("Mod", [x.ops[1], x.ops[2]]).simplify()
      ]).simplify(),
      because: "congruent"
    };
  },
  // Sum simplification (extracted to simplify-sum.ts)
  simplifySum,
  // Product simplification (extracted to simplify-product.ts)
  simplifyProduct,
  //
  // Constructible values of trig functions
  //
  (x) => {
    if (!isConstructible(x)) return void 0;
    const value = constructibleValues(x.operator, x.op1);
    if (!value) return void 0;
    return { value, because: "constructible value" };
  },
  //
  // Inverse Function (i.e. sin^{-1})
  //
  (x) => {
    if (x.operator !== "InverseFunction") return void 0;
    const value = processInverseFunction(x.engine, x.ops);
    if (!value) return void 0;
    return { value, because: "inverse function" };
  },
  //
  // Arctan2
  //
  (expr) => {
    if (expr.operator !== "Arctan2") return void 0;
    const [y, x] = expr.ops;
    const ce = expr.engine;
    if (y.isFinite === false && x.isFinite === false)
      return { value: ce.NaN, because: "arctan2" };
    if (y.is(0) && x.is(0)) return { value: ce.Zero, because: "arctan2" };
    if (x.isFinite === false)
      return { value: x.isPositive ? ce.Zero : ce.Pi, because: "arctan2" };
    if (y.isFinite === false)
      return {
        value: y.isPositive ? ce.Pi.div(2) : ce.Pi.div(-2),
        because: "arctan2"
      };
    if (y.is(0))
      return { value: x.isPositive ? ce.Zero : ce.Pi, because: "arctan2" };
    return {
      value: ce.function("Arctan", [y.div(x)]).simplify(),
      because: "arctan2"
    };
  },
  //
  // Logic
  //
  simplifyLogicFunction,
  //
  // Consolidated functional rules for better performance
  //
  // These functional rules replace ~200+ pattern-matching rules,
  // providing O(1) operator lookup instead of pattern matching overhead.
  //
  // Absolute value simplification
  simplifyAbs,
  simplifyAbsPower,
  simplifyEvenFunctionAbs,
  // Infinity-related simplifications
  simplifyInfinity,
  // Logarithm simplifications (advanced rules)
  simplifyLog,
  // Power-related simplifications
  simplifyPower,
  // Trigonometric simplifications
  simplifyTrig,
  // Hyperbolic trig simplifications
  simplifyHyperbolic,
  // Division simplifications
  simplifyDivide,
  //
  // Power combination for 2+ operands in Multiply
  //
  (x) => {
    if (x.operator !== "Multiply" || !x.ops || x.ops.length < 2)
      return void 0;
    const ce = x.engine;
    const baseGroups = /* @__PURE__ */ new Map();
    const otherTerms = [];
    for (const term of x.ops) {
      let base;
      let exp3;
      if (term.operator === "Power") {
        base = term.op1;
        exp3 = term.op2;
      } else if (term.symbol) {
        base = term;
        exp3 = ce.One;
      } else {
        otherTerms.push(term);
        continue;
      }
      const baseKey = JSON.stringify(base.json);
      let group = baseGroups.get(baseKey);
      if (!group) {
        group = { base, terms: [] };
        baseGroups.set(baseKey, group);
      }
      group.terms.push({ term, exp: exp3 });
    }
    let hasCombinations = false;
    for (const group of baseGroups.values()) {
      if (group.terms.length > 1) {
        const base = group.base;
        const baseNonZero = base.isPositive === true || base.isNegative === true || base.isNumberLiteral === true;
        if (baseNonZero) {
          hasCombinations = true;
        } else {
          const exponents = group.terms.map((t) => t.exp);
          const summedExp = exponents.reduce((a, b) => a.add(b));
          if (summedExp.isPositive === true) {
            hasCombinations = true;
          } else {
            for (const t of group.terms) {
              otherTerms.push(t.term);
            }
            group.terms.length = 0;
          }
        }
      }
    }
    if (!hasCombinations) return void 0;
    const resultTerms = [...otherTerms];
    for (const group of baseGroups.values()) {
      if (group.terms.length === 1) {
        resultTerms.push(group.terms[0].term);
      } else {
        const exponents = group.terms.map((t) => t.exp);
        const summedExp = exponents.reduce((a, b) => a.add(b));
        if (summedExp.is(0)) {
          resultTerms.push(ce.One);
        } else if (summedExp.is(1)) {
          resultTerms.push(group.base);
        } else {
          resultTerms.push(ce._fn("Power", [group.base, summedExp]));
        }
      }
    }
    if (resultTerms.length === 0)
      return { value: ce.One, because: "combined powers" };
    if (resultTerms.length === 1)
      return { value: resultTerms[0], because: "combined powers" };
    return {
      value: ce._fn("Multiply", resultTerms),
      because: "combined powers with same base"
    };
  }
];
function isExact(n) {
  if (n === null) return false;
  if (typeof n === "number") return Number.isInteger(n);
  return n.isExact;
}
function simplifyRelationalOperator(expr) {
  const h = expr.operator;
  if (!isInequalityOperator(h) && !isEquationOperator(h)) return void 0;
  const originalExpr = expr;
  const ce = expr.engine;
  const op1 = expr.op1.simplify();
  const op2 = expr.op2.simplify();
  expr = ce._fn(expr.operator, [op1, op2]);
  expr = factor(expr) ?? expr;
  console.assert(isRelationalOperator(expr.operator));
  if (expr.nops === 2) {
    if (!expr.op2.is(0)) {
      const alt = factor(
        ce._fn(expr.operator, [expr.op1.sub(expr.op2), ce.Zero])
      );
      if (ce.costFunction(alt) < ce.costFunction(expr)) expr = alt;
    }
  }
  if (expr.isSame(originalExpr)) return void 0;
  return { value: expr, because: "simplify-relational-operator" };
}
function simplifySystemOfEquations(expr) {
  if (expr.operator !== "List") return void 0;
  if (!expr.ops.every(
    (x) => isEquationOperator(x.operator) || isInequalityOperator(x.operator)
  ))
    return void 0;
  const ce = expr.engine;
  return {
    value: ce.function(
      "List",
      expr.ops.map((x) => x.simplify())
    ),
    because: "simplify-system-of-equations"
  };
}

// src/compute-engine/index.ts
init_bigint();
init_function_utils();
init_assume();

// src/compute-engine/oeis.ts
var OEIS_BASE_URL = "https://oeis.org";
var DEFAULT_TIMEOUT = 1e4;
var DEFAULT_MAX_RESULTS = 5;
function parseOEISResponse(data) {
  let results;
  if (Array.isArray(data)) {
    results = data;
  } else if (data && data.results && Array.isArray(data.results)) {
    results = data.results;
  } else {
    return [];
  }
  return results.map((result) => {
    const terms = result.data ? result.data.split(",").map((s) => parseInt(s.trim(), 10)) : [];
    const formula = result.formula?.[0];
    return {
      id: result.number ? `A${String(result.number).padStart(6, "0")}` : "",
      name: result.name || "",
      terms,
      formula,
      comments: result.comment,
      url: result.number ? `${OEIS_BASE_URL}/A${String(result.number).padStart(6, "0")}` : ""
    };
  });
}
async function lookupOEISByTerms(terms, options = {}) {
  const timeout = options.timeout ?? DEFAULT_TIMEOUT;
  const maxResults = options.maxResults ?? DEFAULT_MAX_RESULTS;
  const query = terms.join(",");
  const url = `${OEIS_BASE_URL}/search?fmt=json&q=${encodeURIComponent(query)}&start=0&count=${maxResults}`;
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        Accept: "application/json"
      }
    });
    clearTimeout(timeoutId);
    if (!response.ok) {
      throw new Error(`OEIS request failed: ${response.status}`);
    }
    const data = await response.json();
    const results = parseOEISResponse(data);
    return results.slice(0, maxResults);
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("OEIS request timed out");
    }
    throw error;
  }
}
async function lookupSequence(ce, terms, options = {}) {
  const numericTerms = terms.map((t) => {
    if (typeof t === "number") {
      if (!Number.isInteger(t)) {
        throw new Error("OEIS lookup requires integer terms");
      }
      return t;
    }
    const n = t.re;
    if (!Number.isInteger(n)) {
      throw new Error("OEIS lookup requires integer terms");
    }
    return n;
  });
  return lookupOEISByTerms(numericTerms, options);
}
async function checkSequence(ce, name, count = 10, options = {}) {
  const termExprs = ce.getSequenceTerms(name, 0, count - 1);
  if (!termExprs) {
    throw new Error(`'${name}' is not a defined sequence`);
  }
  const terms = termExprs.map((t) => t.re);
  const matches = await lookupOEISByTerms(terms, options);
  return { matches, terms };
}

// src/compute-engine/index.ts
init_global_types();

// src/compute-engine/compilation/javascript-target.ts
init_numeric();
init_special_functions();
init_utils4();
init_base_compiler();
var JAVASCRIPT_OPERATORS = {
  Add: ["+", 11],
  Negate: ["-", 14],
  // Unary operator
  Subtract: ["-", 11],
  Multiply: ["*", 12],
  Divide: ["/", 13],
  Equal: ["===", 8],
  NotEqual: ["!==", 8],
  LessEqual: ["<=", 9],
  GreaterEqual: [">=", 9],
  Less: ["<", 9],
  Greater: [">", 9],
  And: ["&&", 4],
  Or: ["||", 3],
  Not: ["!", 14]
  // Unary operator
};
var JAVASCRIPT_FUNCTIONS = {
  Abs: "Math.abs",
  Add: (args, compile) => {
    if (args.length === 1) return compile(args[0]);
    return `(${args.map((x) => compile(x)).join(" + ")})`;
  },
  Arccos: "Math.acos",
  Arcosh: "Math.acosh",
  Arccot: ([x], compile) => {
    if (x === null) throw new Error("Arccot: no argument");
    return `Math.atan(1 / (${compile(x)}))`;
  },
  Arcoth: ([x], compile) => {
    if (x === null) throw new Error("Arcoth: no argument");
    return `Math.atanh(1 / (${compile(x)}))`;
  },
  Arccsc: ([x], compile) => {
    if (x === null) throw new Error("Arccsc: no argument");
    return `Math.asin(1 / (${compile(x)}))`;
  },
  Arcsch: ([x], compile) => {
    if (x === null) throw new Error("Arcsch: no argument");
    return `Math.asinh(1 / (${compile(x)}))`;
  },
  Arcsec: ([x], compile) => {
    if (x === null) throw new Error("Arcsec: no argument");
    return `Math.acos(1 / (${compile(x)}))`;
  },
  Arsech: ([x], compile) => {
    if (x === null) throw new Error("Arsech: no argument");
    return `Math.acosh(1 / (${compile(x)}))`;
  },
  Arcsin: "Math.asin",
  Arsinh: "Math.asinh",
  Arctan: "Math.atan",
  Artanh: "Math.atanh",
  Ceiling: "Math.ceil",
  Chop: "_SYS.chop",
  Cos: "Math.cos",
  Cosh: "Math.cosh",
  Cot: ([x], compile) => {
    if (x === null) throw new Error("Cot: no argument");
    return BaseCompiler.inlineExpression(
      "Math.cos(${x}) / Math.sin(${x})",
      compile(x)
    );
  },
  Coth: ([x], compile) => {
    if (x === null) throw new Error("Coth: no argument");
    return BaseCompiler.inlineExpression(
      "(Math.cosh(${x}) / Math.sinh(${x}))",
      compile(x)
    );
  },
  Csc: ([x], compile) => {
    if (x === null) throw new Error("Csc: no argument");
    return `1 / Math.sin(${compile(x)})`;
  },
  Csch: ([x], compile) => {
    if (x === null) throw new Error("Csch: no argument");
    return `1 / Math.sinh(${compile(x)})`;
  },
  Exp: "Math.exp",
  Floor: "Math.floor",
  Gamma: "_SYS.gamma",
  GCD: "_SYS.gcd",
  Integrate: (args, compile, target) => compileIntegrate(args, compile, target),
  LCM: "_SYS.lcm",
  Limit: (args, compile) => `_SYS.limit(${compile(args[0])}, ${compile(args[1])})`,
  Ln: "Math.log",
  List: (args, compile) => `[${args.map((x) => compile(x)).join(", ")}]`,
  Log: (args, compile) => {
    if (args.length === 1) return `Math.log10(${compile(args[0])})`;
    return `(Math.log(${compile(args[0])}) / Math.log(${compile(args[1])}))`;
  },
  LogGamma: "_SYS.lngamma",
  Lb: "Math.log2",
  Max: "Math.max",
  Mean: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.mean(${compile(args[0])})`;
    return `_SYS.mean([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Median: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.median(${compile(args[0])})`;
    return `_SYS.median([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Variance: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.variance(${compile(args[0])})`;
    return `_SYS.variance([${args.map((x) => compile(x)).join(", ")}])`;
  },
  PopulationVariance: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1)
      return `_SYS.populationVariance(${compile(args[0])})`;
    return `_SYS.populationVariance([${args.map((x) => compile(x)).join(", ")}])`;
  },
  StandardDeviation: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.standardDeviation(${compile(args[0])})`;
    return `_SYS.standardDeviation([${args.map((x) => compile(x)).join(", ")}])`;
  },
  PopulationStandardDeviation: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1)
      return `_SYS.populationStandardDeviation(${compile(args[0])})`;
    return `_SYS.populationStandardDeviation([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Kurtosis: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.kurtosis(${compile(args[0])})`;
    return `_SYS.kurtosis([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Skewness: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.skewness(${compile(args[0])})`;
    return `_SYS.skewness([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Mode: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.mode(${compile(args[0])})`;
    return `_SYS.mode([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Quartiles: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1) return `_SYS.quartiles(${compile(args[0])})`;
    return `_SYS.quartiles([${args.map((x) => compile(x)).join(", ")}])`;
  },
  InterquartileRange: (args, compile) => {
    if (args.length === 0) return "NaN";
    if (args.length === 1)
      return `_SYS.interquartileRange(${compile(args[0])})`;
    return `_SYS.interquartileRange([${args.map((x) => compile(x)).join(", ")}])`;
  },
  Min: "Math.min",
  Power: (args, compile) => {
    const arg = args[0];
    if (arg === null) throw new Error("Power: no argument");
    const exp3 = args[1].re;
    if (exp3 === 0.5) return `Math.sqrt(${compile(arg)})`;
    if (exp3 === 1 / 3) return `Math.cbrt(${compile(arg)})`;
    if (exp3 === 1) return compile(arg);
    if (exp3 === -1) return `(1 / (${compile(arg)}))`;
    if (exp3 === -0.5) return `(1 / Math.sqrt(${compile(arg)}))`;
    return `Math.pow(${compile(arg)}, ${compile(args[1])})`;
  },
  Range: (args, compile) => {
    if (args.length === 0) return "[]";
    if (args.length === 1)
      return `Array.from({length: ${compile(args[0])}}, (_, i) => i)`;
    let start = compile(args[0]);
    let stop = compile(args[1]);
    const step = args[2] ? compile(args[2]) : "1";
    if (start === null) throw new Error("Range: no start");
    if (stop === null) {
      stop = start;
      start = "1";
    }
    if (step === "0") throw new Error("Range: step cannot be zero");
    if (parseFloat(step) === 1) {
      const fStop = parseFloat(stop);
      const fStart = parseFloat(start);
      if (fStop !== null && fStart !== null) {
        if (fStop - fStart < 50) {
          return `[${Array.from(
            { length: fStop - fStart + 1 },
            (_, i) => fStart + i
          ).join(", ")}]`;
        }
        return `Array.from({length: ${fStop - fStart + 1} 
        }, (_, i) => ${start} + i)`;
      }
      return `Array.from({length: ${stop} - ${start} + 1
      }, (_, i) => ${start} + i)`;
    }
    return `Array.from({length: Math.floor((${stop} - ${start}) / ${step}) + 1}, (_, i) => ${start} + i * ${step})`;
  },
  Root: ([arg, exp3], compile) => {
    if (arg === null) throw new Error("Root: no argument");
    if (exp3 === null) return `Math.sqrt(${compile(arg)})`;
    if (exp3?.re === 2) return `Math.sqrt(${compile(arg)})`;
    if (exp3?.re === 3) return `Math.cbrt(${compile(arg)})`;
    if (!isNaN(exp3?.re)) return `Math.pow(${compile(arg)},  ${1 / exp3.re})`;
    return `Math.pow(${compile(arg)}, 1 / (${compile(exp3)}))`;
  },
  Random: "Math.random",
  Round: "Math.round",
  Square: (args, compile) => {
    const arg = args[0];
    if (arg === null) throw new Error("Square: no argument");
    return `Math.pow(${compile(arg)}, 2)`;
  },
  Sec: (args, compile) => {
    const arg = args[0];
    if (arg === null) throw new Error("Sec: no argument");
    return `1 / Math.cos(${compile(arg)})`;
  },
  Sech: (args, compile) => {
    const arg = args[0];
    if (arg === null) throw new Error("Sech: no argument");
    return `1 / Math.cosh(${compile(arg)})`;
  },
  Sgn: "Math.sign",
  Sin: "Math.sin",
  Sinh: "Math.sinh",
  Sqrt: "Math.sqrt",
  Tan: "Math.tan",
  Tanh: "Math.tanh"
};
var ComputeEngineFunction = class extends Function {
  SYS = {
    chop,
    factorial: factorial2,
    gamma: gamma2,
    gcd,
    integrate: (f, a, b) => monteCarloEstimate(f, a, b, 1e7).estimate,
    lcm,
    lngamma: gammaln2,
    limit,
    mean,
    median,
    variance,
    populationVariance,
    standardDeviation,
    populationStandardDeviation,
    kurtosis,
    skewness,
    mode,
    quartiles,
    interquartileRange
  };
  constructor(body, preamble = "") {
    super(
      "_SYS",
      "_",
      preamble ? `${preamble};return ${body}` : `return ${body}`
    );
    return new Proxy(this, {
      apply: (target, thisArg, argumentsList) => super.apply(thisArg, [this.SYS, ...argumentsList]),
      get: (target, prop) => {
        if (prop === "toString") return () => body;
        if (prop === "isCompiled") return true;
        return target[prop];
      }
    });
  }
};
var ComputeEngineFunctionLiteral = class extends Function {
  SYS = {
    chop,
    factorial: factorial2,
    gamma: gamma2,
    gcd,
    integrate: (f, a, b) => monteCarloEstimate(f, a, b, 1e7).estimate,
    lcm,
    lngamma: gammaln2,
    limit,
    mean,
    median,
    variance,
    populationVariance,
    standardDeviation,
    populationStandardDeviation,
    kurtosis,
    skewness,
    mode,
    quartiles,
    interquartileRange
  };
  constructor(body, args) {
    super("_SYS", ...args, `return ${body}`);
    return new Proxy(this, {
      apply: (target, thisArg, argumentsList) => super.apply(thisArg, [this.SYS, ...argumentsList]),
      get: (target, prop) => {
        if (prop === "toString")
          return () => `(${args.join(", ")}) => ${body}`;
        if (prop === "isCompiled") return true;
        return target[prop];
      }
    });
  }
};
var JavaScriptTarget = class {
  getOperators() {
    return JAVASCRIPT_OPERATORS;
  }
  getFunctions() {
    return JAVASCRIPT_FUNCTIONS;
  }
  createTarget(options = {}) {
    return {
      language: "javascript",
      operators: (op) => JAVASCRIPT_OPERATORS[op],
      functions: (id) => JAVASCRIPT_FUNCTIONS[id],
      var: (id) => {
        const result = {
          Pi: "Math.PI",
          ExponentialE: "Math.E",
          NaN: "Number.NaN",
          ImaginaryUnit: "Number.NaN",
          Half: "0.5",
          MachineEpsilon: "Number.EPSILON",
          GoldenRatio: "((1 + Math.sqrt(5)) / 2)",
          CatalanConstant: "0.91596559417721901",
          EulerGamma: "0.57721566490153286"
        }[id];
        return result;
      },
      string: (str) => JSON.stringify(str),
      number: (n) => n.toString(),
      indent: 0,
      ws: (s) => s ?? "",
      preamble: "",
      ...options
    };
  }
  compileToExecutable(expr, options = {}) {
    const { operators, functions, vars, imports = [], preamble } = options;
    const unknowns = expr.unknowns;
    let preambleImports = imports.map((x) => {
      if (typeof x === "function") return x.toString();
      throw new Error(`Unsupported import \`${x}\``);
    }).join("\n");
    const namedFunctions = {};
    if (functions) {
      for (const [k, v] of Object.entries(functions)) {
        if (typeof v === "function") {
          if (isTrulyNamed(v)) {
            preambleImports += `${v.toString()};
`;
            namedFunctions[k] = v.name;
          } else {
            preambleImports += `const ${k} = ${v.toString()};
`;
            namedFunctions[k] = k;
          }
        } else if (typeof v === "string") {
          namedFunctions[k] = v;
        }
      }
    }
    const operatorLookup = (op) => {
      if (operators) {
        const customOp = typeof operators === "function" ? operators(op) : operators[op];
        if (customOp) return customOp;
      }
      return JAVASCRIPT_OPERATORS[op];
    };
    const target = this.createTarget({
      operators: operatorLookup,
      functions: (id) => namedFunctions?.[id] ? namedFunctions[id] : JAVASCRIPT_FUNCTIONS[id],
      var: (id) => {
        if (vars && id in vars) return JSON.stringify(vars[id]);
        const result = {
          Pi: "Math.PI",
          ExponentialE: "Math.E",
          NaN: "Number.NaN",
          ImaginaryUnit: "Number.NaN",
          Half: "0.5",
          MachineEpsilon: "Number.EPSILON",
          GoldenRatio: "((1 + Math.sqrt(5)) / 2)",
          CatalanConstant: "0.91596559417721901",
          EulerGamma: "0.57721566490153286"
        }[id];
        if (result !== void 0) return result;
        if (unknowns.includes(id)) return `_.${id}`;
        return void 0;
      },
      preamble: (preamble ?? "") + preambleImports
    });
    return compileToTarget(expr, target);
  }
};
function compileToTarget(expr, target) {
  if (expr.operator === "Function") {
    const args = expr.ops;
    const params = args.slice(1).map((x) => x.symbol ?? "_");
    const body = BaseCompiler.compile(args[0].canonical, {
      ...target,
      var: (id) => params.includes(id) ? id : target.var(id)
    });
    return new ComputeEngineFunctionLiteral(
      body,
      params
    );
  }
  if (expr.symbol) {
    const op = target.operators?.(expr.symbol);
    if (op) {
      return new ComputeEngineFunctionLiteral(`a ${op[0]} b`, [
        "a",
        "b"
      ]);
    }
  }
  const js = BaseCompiler.compile(expr, target);
  return new ComputeEngineFunction(
    js,
    target.preamble
  );
}
function compileIntegrate(args, _, target) {
  const { index, lower, upper } = normalizeIndexingSet(args[1]);
  const f = BaseCompiler.compile(args[0], {
    ...target,
    var: (id) => id === index ? id : target.var(id)
  });
  return `_SYS.integrate((${index}) => (${f}), ${lower}, ${upper})`;
}
function isTrulyNamed(func) {
  const source = func.toString();
  if (source.includes("=>")) return false;
  return source.startsWith("function ") && source.includes(func.name);
}

// src/compute-engine/compilation/glsl-target.ts
var GLSL_OPERATORS = {
  Add: ["+", 11],
  Negate: ["-", 14],
  // Unary operator
  Subtract: ["-", 11],
  Multiply: ["*", 12],
  Divide: ["/", 13],
  Equal: ["==", 8],
  NotEqual: ["!=", 8],
  LessEqual: ["<=", 9],
  GreaterEqual: [">=", 9],
  Less: ["<", 9],
  Greater: [">", 9],
  And: ["&&", 4],
  Or: ["||", 3],
  Not: ["!", 14]
  // Unary operator
};
var GLSL_FUNCTIONS = {
  // Basic arithmetic (for when they're called as functions, e.g., with vectors)
  Add: (args, compile) => {
    if (args.length === 0) return "0.0";
    if (args.length === 1) return compile(args[0]);
    return args.map((x) => compile(x)).join(" + ");
  },
  Multiply: (args, compile) => {
    if (args.length === 0) return "1.0";
    if (args.length === 1) return compile(args[0]);
    return args.map((x) => compile(x)).join(" * ");
  },
  Subtract: (args, compile) => {
    if (args.length === 0) return "0.0";
    if (args.length === 1) return compile(args[0]);
    if (args.length === 2) return `${compile(args[0])} - ${compile(args[1])}`;
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `${result} - ${compile(args[i])}`;
    }
    return result;
  },
  Divide: (args, compile) => {
    if (args.length === 0) return "1.0";
    if (args.length === 1) return compile(args[0]);
    if (args.length === 2) return `${compile(args[0])} / ${compile(args[1])}`;
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `${result} / ${compile(args[i])}`;
    }
    return result;
  },
  Abs: "abs",
  Arccos: "acos",
  Arcsin: "asin",
  Arctan: "atan",
  Ceiling: "ceil",
  Clamp: "clamp",
  Cos: "cos",
  Degrees: "degrees",
  Exp: "exp",
  Exp2: "exp2",
  Floor: "floor",
  Fract: "fract",
  Inversesqrt: "inversesqrt",
  Ln: "log",
  // Natural logarithm in GLSL
  Log2: "log2",
  Max: "max",
  Min: "min",
  Mix: "mix",
  Mod: "mod",
  Power: "pow",
  Radians: "radians",
  Round: "round",
  Sign: "sign",
  Sin: "sin",
  Smoothstep: "smoothstep",
  Sqrt: "sqrt",
  Step: "step",
  Tan: "tan",
  // Vector/Matrix operations
  Cross: "cross",
  Distance: "distance",
  Dot: "dot",
  Length: "length",
  Normalize: "normalize",
  Reflect: "reflect",
  Refract: "refract",
  // Common patterns
  List: (args, compile) => {
    if (args.length === 2)
      return `vec2(${args.map((x) => compile(x)).join(", ")})`;
    if (args.length === 3)
      return `vec3(${args.map((x) => compile(x)).join(", ")})`;
    if (args.length === 4)
      return `vec4(${args.map((x) => compile(x)).join(", ")})`;
    return `float[${args.length}](${args.map((x) => compile(x)).join(", ")})`;
  }
};
var GLSLTarget = class {
  getOperators() {
    return GLSL_OPERATORS;
  }
  getFunctions() {
    return GLSL_FUNCTIONS;
  }
  createTarget(options = {}) {
    return {
      language: "glsl",
      operators: (op) => GLSL_OPERATORS[op],
      functions: (id) => GLSL_FUNCTIONS[id],
      var: (id) => {
        const constants = {
          Pi: "3.14159265359",
          ExponentialE: "2.71828182846",
          GoldenRatio: "1.61803398875",
          CatalanConstant: "0.91596559417",
          EulerGamma: "0.57721566490"
        };
        if (id in constants) return constants[id];
        return id;
      },
      string: (str) => JSON.stringify(str),
      number: (n) => {
        const str = n.toString();
        if (!str.includes(".") && !str.includes("e") && !str.includes("E")) {
          return `${str}.0`;
        }
        return str;
      },
      indent: 0,
      ws: (s) => s ?? "",
      preamble: "",
      ...options
    };
  }
  /**
   * Compile to GLSL source code (not executable)
   *
   * GLSL doesn't run in JavaScript, so this returns source code as a string
   * rather than an executable function.
   */
  compileToExecutable(expr, options = {}) {
    const { functions, vars } = options;
    const { BaseCompiler: BaseCompiler2 } = (init_base_compiler(), __toCommonJS(base_compiler_exports));
    const target = this.createTarget({
      functions: (id) => {
        if (functions && id in functions) {
          const fn = functions[id];
          if (typeof fn === "string") return fn;
          if (typeof fn === "function") return fn.name || id;
        }
        return GLSL_FUNCTIONS[id];
      },
      var: (id) => {
        if (vars && id in vars) return vars[id];
        const constants = {
          Pi: "3.14159265359",
          ExponentialE: "2.71828182846",
          GoldenRatio: "1.61803398875",
          CatalanConstant: "0.91596559417",
          EulerGamma: "0.57721566490"
        };
        if (id in constants) return constants[id];
        return id;
      }
    });
    const glslCode = BaseCompiler2.compile(expr, target);
    const result = function() {
      return glslCode;
    };
    Object.defineProperty(result, "toString", {
      value: () => glslCode
    });
    Object.defineProperty(result, "isCompiled", {
      value: true
    });
    return result;
  }
  /**
   * Compile an expression to GLSL source code
   *
   * Returns the GLSL code as a string.
   */
  compile(expr, options = {}) {
    const { BaseCompiler: BaseCompiler2 } = (init_base_compiler(), __toCommonJS(base_compiler_exports));
    const target = this.createTarget();
    return BaseCompiler2.compile(expr, target);
  }
  /**
   * Create a complete GLSL function from an expression
   *
   * @param expr - The expression to compile
   * @param functionName - Name of the GLSL function
   * @param returnType - GLSL return type (e.g., 'float', 'vec3')
   * @param parameters - Parameter declarations (e.g., [['x', 'float'], ['y', 'vec3']])
   */
  compileFunction(expr, functionName, returnType, parameters) {
    const { BaseCompiler: BaseCompiler2 } = (init_base_compiler(), __toCommonJS(base_compiler_exports));
    const target = this.createTarget();
    const body = BaseCompiler2.compile(expr, target);
    const params = parameters.map(([name, type2]) => `${type2} ${name}`).join(", ");
    return `${returnType} ${functionName}(${params}) {
  return ${body};
}`;
  }
  /**
   * Create a complete GLSL shader from expressions
   *
   * @param options - Shader compilation options
   */
  compileShader(options) {
    const {
      type: type2,
      version: version2 = "300 es",
      inputs = [],
      outputs = [],
      uniforms = [],
      body
    } = options;
    let code = `#version ${version2}

`;
    if (type2 === "fragment") {
      code += "precision highp float;\n\n";
    }
    const inputKeyword = version2.startsWith("300") || version2.startsWith("3") ? "in" : type2 === "vertex" ? "attribute" : "varying";
    for (const input of inputs) {
      code += `${inputKeyword} ${input.type} ${input.name};
`;
    }
    if (inputs.length > 0) code += "\n";
    const outputKeyword = version2.startsWith("300") || version2.startsWith("3") ? "out" : "varying";
    for (const output of outputs) {
      code += `${outputKeyword} ${output.type} ${output.name};
`;
    }
    if (outputs.length > 0) code += "\n";
    for (const uniform of uniforms) {
      code += `uniform ${uniform.type} ${uniform.name};
`;
    }
    if (uniforms.length > 0) code += "\n";
    code += "void main() {\n";
    for (const assignment of body) {
      const glsl = this.compile(assignment.expression);
      code += `  ${assignment.variable} = ${glsl};
`;
    }
    code += "}\n";
    return code;
  }
};

// src/compute-engine/compilation/interval-javascript-target.ts
init_base_compiler();

// src/compute-engine/interval/util.ts
function ok(value) {
  return { kind: "interval", value };
}
function point(n) {
  return { lo: n, hi: n };
}
function containsExtremum(x, extremum, period) {
  const n = Math.ceil((x.lo - extremum) / period);
  const candidate = extremum + n * period;
  const EPS = 1e-15;
  return candidate >= x.lo - EPS && candidate <= x.hi + EPS;
}
function unionResults(a, b) {
  if (a.kind === "empty") return b;
  if (b.kind === "empty") return a;
  if (a.kind === "singular" || b.kind === "singular") {
    return { kind: "singular" };
  }
  if (a.kind === "entire" || b.kind === "entire") {
    return { kind: "entire" };
  }
  const aVal = a.value;
  const bVal = b.value;
  const aDomainClip = a.kind === "partial" ? a.domainClipped : null;
  const bDomainClip = b.kind === "partial" ? b.domainClipped : null;
  const value = {
    lo: Math.min(aVal.lo, bVal.lo),
    hi: Math.max(aVal.hi, bVal.hi)
  };
  if (aDomainClip || bDomainClip) {
    const domainClipped = mergeDomainClip(aDomainClip, bDomainClip);
    return { kind: "partial", value, domainClipped };
  }
  return { kind: "interval", value };
}
function mergeDomainClip(a, b) {
  if (a === "both" || b === "both") return "both";
  if (a === null) return b;
  if (b === null) return a;
  if (a === b) return a;
  return "both";
}
function isPoint(x) {
  return x.lo === x.hi;
}
function containsZero(x) {
  return x.lo <= 0 && x.hi >= 0;
}
function isPositive2(x) {
  return x.lo > 0;
}
function isNegative(x) {
  return x.hi < 0;
}
function isNonNegative(x) {
  return x.lo >= 0;
}
function isNonPositive(x) {
  return x.hi <= 0;
}
function width(x) {
  return x.hi - x.lo;
}
function midpoint(x) {
  return (x.lo + x.hi) / 2;
}
function getValue(result) {
  if (result.kind === "interval" || result.kind === "partial") {
    return result.value;
  }
  return void 0;
}
function unwrap(input) {
  if ("kind" in input) {
    if (input.kind === "interval" || input.kind === "partial") {
      return input.value;
    }
    return void 0;
  }
  return input;
}
function unwrapOrPropagate(...inputs) {
  const result = [];
  for (const input of inputs) {
    if ("kind" in input) {
      if (input.kind === "empty") return { kind: "empty" };
      if (input.kind === "entire") return { kind: "entire" };
      if (input.kind === "singular") return input;
      result.push(input.value);
    } else {
      result.push(input);
    }
  }
  return result;
}

// src/compute-engine/interval/arithmetic.ts
function add4(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return ok({ lo: aVal.lo + bVal.lo, hi: aVal.hi + bVal.hi });
}
function sub2(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return ok({ lo: aVal.lo - bVal.hi, hi: aVal.hi - bVal.lo });
}
function negate2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: -xVal.hi, hi: -xVal.lo });
}
function _mul(a, b) {
  const products = [a.lo * b.lo, a.lo * b.hi, a.hi * b.lo, a.hi * b.hi];
  return { lo: Math.min(...products), hi: Math.max(...products) };
}
function mul4(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return ok(_mul(aVal, bVal));
}
function div3(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return _div(aVal, bVal);
}
function _div(a, b) {
  if (b.lo > 0 || b.hi < 0) {
    return ok(_mul(a, { lo: 1 / b.hi, hi: 1 / b.lo }));
  }
  if (b.lo < 0 && b.hi > 0) {
    return { kind: "singular" };
  }
  if (b.lo === 0 && b.hi > 0) {
    if (a.lo >= 0) {
      return {
        kind: "partial",
        value: { lo: a.lo / b.hi, hi: Infinity },
        domainClipped: "hi"
      };
    } else if (a.hi <= 0) {
      return {
        kind: "partial",
        value: { lo: -Infinity, hi: a.hi / b.hi },
        domainClipped: "lo"
      };
    } else {
      return { kind: "entire" };
    }
  }
  if (b.hi === 0 && b.lo < 0) {
    if (a.lo >= 0) {
      return {
        kind: "partial",
        value: { lo: -Infinity, hi: a.lo / b.lo },
        domainClipped: "lo"
      };
    } else if (a.hi <= 0) {
      return {
        kind: "partial",
        value: { lo: a.hi / b.lo, hi: Infinity },
        domainClipped: "hi"
      };
    } else {
      return { kind: "entire" };
    }
  }
  return { kind: "empty" };
}

// src/compute-engine/interval/elementary.ts
function sqrt2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return _sqrt(xVal);
}
function _sqrt(x) {
  if (x.hi < 0) {
    return { kind: "empty" };
  }
  if (x.lo >= 0) {
    return ok({ lo: Math.sqrt(x.lo), hi: Math.sqrt(x.hi) });
  }
  return {
    kind: "partial",
    value: { lo: 0, hi: Math.sqrt(x.hi) },
    domainClipped: "lo"
  };
}
function square(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo >= 0) {
    return ok({ lo: xVal.lo * xVal.lo, hi: xVal.hi * xVal.hi });
  } else if (xVal.hi <= 0) {
    return ok({ lo: xVal.hi * xVal.hi, hi: xVal.lo * xVal.lo });
  } else {
    return ok({ lo: 0, hi: Math.max(xVal.lo * xVal.lo, xVal.hi * xVal.hi) });
  }
}
function intPow2(base, n) {
  if (n === 0) return { lo: 1, hi: 1 };
  if (n === 1) return base;
  if (n % 2 === 0) {
    if (base.lo >= 0) {
      return { lo: Math.pow(base.lo, n), hi: Math.pow(base.hi, n) };
    } else if (base.hi <= 0) {
      return { lo: Math.pow(base.hi, n), hi: Math.pow(base.lo, n) };
    } else {
      return {
        lo: 0,
        hi: Math.max(Math.pow(base.lo, n), Math.pow(base.hi, n))
      };
    }
  }
  return { lo: Math.pow(base.lo, n), hi: Math.pow(base.hi, n) };
}
function pow3(base, exp3) {
  const unwrapped = unwrapOrPropagate(base);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [baseVal] = unwrapped;
  if (Number.isInteger(exp3)) {
    if (exp3 >= 0) {
      return ok(intPow2(baseVal, exp3));
    } else {
      if (containsZero(baseVal)) {
        return { kind: "singular" };
      }
      const denom = intPow2(baseVal, -exp3);
      return ok({ lo: 1 / denom.hi, hi: 1 / denom.lo });
    }
  } else {
    if (isNegative(baseVal)) {
      return { kind: "empty" };
    }
    if (baseVal.lo < 0) {
      const value = exp3 > 0 ? { lo: 0, hi: Math.pow(baseVal.hi, exp3) } : { lo: Math.pow(baseVal.hi, exp3), hi: Infinity };
      return { kind: "partial", value, domainClipped: "lo" };
    }
    if (exp3 > 0) {
      return ok({
        lo: Math.pow(baseVal.lo, exp3),
        hi: Math.pow(baseVal.hi, exp3)
      });
    } else {
      if (baseVal.lo === 0) {
        return {
          kind: "partial",
          value: { lo: Math.pow(baseVal.hi, exp3), hi: Infinity },
          domainClipped: "hi"
        };
      }
      return ok({
        lo: Math.pow(baseVal.hi, exp3),
        hi: Math.pow(baseVal.lo, exp3)
      });
    }
  }
}
function powInterval(base, exp3) {
  const unwrapped = unwrapOrPropagate(base, exp3);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [baseVal, expVal] = unwrapped;
  if (baseVal.hi <= 0) {
    return { kind: "empty" };
  }
  if (baseVal.lo <= 0) {
    const posBase = {
      lo: Math.max(baseVal.lo, Number.EPSILON),
      hi: baseVal.hi
    };
    const corners2 = [
      Math.pow(posBase.lo, expVal.lo),
      Math.pow(posBase.lo, expVal.hi),
      Math.pow(posBase.hi, expVal.lo),
      Math.pow(posBase.hi, expVal.hi)
    ];
    return {
      kind: "partial",
      value: { lo: Math.min(...corners2), hi: Math.max(...corners2) },
      domainClipped: "lo"
    };
  }
  const corners = [
    Math.pow(baseVal.lo, expVal.lo),
    Math.pow(baseVal.lo, expVal.hi),
    Math.pow(baseVal.hi, expVal.lo),
    Math.pow(baseVal.hi, expVal.hi)
  ];
  return ok({ lo: Math.min(...corners), hi: Math.max(...corners) });
}
function exp2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.exp(xVal.lo), hi: Math.exp(xVal.hi) });
}
function ln2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi <= 0) {
    return { kind: "empty" };
  }
  if (xVal.lo > 0) {
    return ok({ lo: Math.log(xVal.lo), hi: Math.log(xVal.hi) });
  }
  return {
    kind: "partial",
    value: { lo: -Infinity, hi: Math.log(xVal.hi) },
    domainClipped: "lo"
  };
}
function log102(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi <= 0) {
    return { kind: "empty" };
  }
  if (xVal.lo > 0) {
    return ok({ lo: Math.log10(xVal.lo), hi: Math.log10(xVal.hi) });
  }
  return {
    kind: "partial",
    value: { lo: -Infinity, hi: Math.log10(xVal.hi) },
    domainClipped: "lo"
  };
}
function log22(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi <= 0) {
    return { kind: "empty" };
  }
  if (xVal.lo > 0) {
    return ok({ lo: Math.log2(xVal.lo), hi: Math.log2(xVal.hi) });
  }
  return {
    kind: "partial",
    value: { lo: -Infinity, hi: Math.log2(xVal.hi) },
    domainClipped: "lo"
  };
}
function abs2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo >= 0) {
    return ok(xVal);
  }
  if (xVal.hi <= 0) {
    return ok({ lo: -xVal.hi, hi: -xVal.lo });
  }
  return ok({ lo: 0, hi: Math.max(-xVal.lo, xVal.hi) });
}
function floor2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.floor(xVal.lo), hi: Math.floor(xVal.hi) });
}
function ceil2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.ceil(xVal.lo), hi: Math.ceil(xVal.hi) });
}
function round2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.round(xVal.lo), hi: Math.round(xVal.hi) });
}
function min2(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return ok({
    lo: Math.min(aVal.lo, bVal.lo),
    hi: Math.min(aVal.hi, bVal.hi)
  });
}
function max2(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  return ok({
    lo: Math.max(aVal.lo, bVal.lo),
    hi: Math.max(aVal.hi, bVal.hi)
  });
}
function mod2(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [aVal, bVal] = unwrapped;
  if (containsZero(bVal)) {
    return { kind: "singular" };
  }
  const bAbs = Math.max(Math.abs(bVal.lo), Math.abs(bVal.hi));
  const aWidth = aVal.hi - aVal.lo;
  if (aWidth >= bAbs) {
    return ok({ lo: 0, hi: bAbs });
  }
  const modLo = (aVal.lo % bAbs + bAbs) % bAbs;
  const modHi = (aVal.hi % bAbs + bAbs) % bAbs;
  if (modLo <= modHi) {
    return ok({ lo: modLo, hi: modHi });
  } else {
    return ok({ lo: 0, hi: bAbs });
  }
}
function sign2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo > 0) return ok({ lo: 1, hi: 1 });
  if (xVal.hi < 0) return ok({ lo: -1, hi: -1 });
  if (xVal.lo === 0 && xVal.hi === 0) return ok({ lo: 0, hi: 0 });
  if (xVal.lo < 0 && xVal.hi > 0) return ok({ lo: -1, hi: 1 });
  if (xVal.lo === 0) return ok({ lo: 0, hi: 1 });
  return ok({ lo: -1, hi: 0 });
}

// src/compute-engine/interval/trigonometric.ts
var TWO_PI = 2 * Math.PI;
var PI2 = Math.PI;
var HALF_PI = Math.PI / 2;
var THREE_HALF_PI = 3 * Math.PI / 2;
function sin2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= TWO_PI) {
    return ok({ lo: -1, hi: 1 });
  }
  const sinLo = Math.sin(xVal.lo);
  const sinHi = Math.sin(xVal.hi);
  let lo = Math.min(sinLo, sinHi);
  let hi = Math.max(sinLo, sinHi);
  if (containsExtremum(xVal, HALF_PI, TWO_PI)) {
    hi = 1;
  }
  if (containsExtremum(xVal, THREE_HALF_PI, TWO_PI)) {
    lo = -1;
  }
  return ok({ lo, hi });
}
function cos2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= TWO_PI) {
    return ok({ lo: -1, hi: 1 });
  }
  const cosLo = Math.cos(xVal.lo);
  const cosHi = Math.cos(xVal.hi);
  let lo = Math.min(cosLo, cosHi);
  let hi = Math.max(cosLo, cosHi);
  if (containsExtremum(xVal, 0, TWO_PI)) {
    hi = 1;
  }
  if (containsExtremum(xVal, PI2, TWO_PI)) {
    lo = -1;
  }
  return ok({ lo, hi });
}
function tan2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= PI2) {
    return { kind: "singular" };
  }
  if (containsExtremum(xVal, HALF_PI, PI2)) {
    const n = Math.ceil((xVal.lo - HALF_PI) / PI2);
    const poleAt = HALF_PI + n * PI2;
    return { kind: "singular", at: poleAt };
  }
  const tanLo = Math.tan(xVal.lo);
  const tanHi = Math.tan(xVal.hi);
  if (tanLo > 1e10 && tanHi < -1e10 || tanLo < -1e10 && tanHi > 1e10) {
    return { kind: "singular" };
  }
  return ok({ lo: tanLo, hi: tanHi });
}
function cot(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= PI2) {
    return { kind: "singular" };
  }
  if (containsExtremum(xVal, 0, PI2)) {
    const n = Math.ceil(xVal.lo / PI2);
    const poleAt = n * PI2;
    return { kind: "singular", at: poleAt };
  }
  const cotLo = 1 / Math.tan(xVal.lo);
  const cotHi = 1 / Math.tan(xVal.hi);
  return ok({ lo: Math.min(cotLo, cotHi), hi: Math.max(cotLo, cotHi) });
}
function sec(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= PI2) {
    return { kind: "singular" };
  }
  if (containsExtremum(xVal, HALF_PI, PI2)) {
    const n = Math.ceil((xVal.lo - HALF_PI) / PI2);
    const poleAt = HALF_PI + n * PI2;
    return { kind: "singular", at: poleAt };
  }
  const secLo = 1 / Math.cos(xVal.lo);
  const secHi = 1 / Math.cos(xVal.hi);
  let lo = Math.min(secLo, secHi);
  let hi = Math.max(secLo, secHi);
  if (containsExtremum(xVal, 0, TWO_PI)) {
    lo = Math.min(lo, 1);
    hi = Math.max(hi, 1);
  }
  if (containsExtremum(xVal, PI2, TWO_PI)) {
    lo = Math.min(lo, -1);
    hi = Math.max(hi, -1);
  }
  return ok({ lo, hi });
}
function csc(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi - xVal.lo >= PI2) {
    return { kind: "singular" };
  }
  if (containsExtremum(xVal, 0, PI2)) {
    const n = Math.ceil(xVal.lo / PI2);
    const poleAt = n * PI2;
    return { kind: "singular", at: poleAt };
  }
  const cscLo = 1 / Math.sin(xVal.lo);
  const cscHi = 1 / Math.sin(xVal.hi);
  let lo = Math.min(cscLo, cscHi);
  let hi = Math.max(cscLo, cscHi);
  if (containsExtremum(xVal, HALF_PI, TWO_PI)) {
    lo = Math.min(lo, 1);
    hi = Math.max(hi, 1);
  }
  if (containsExtremum(xVal, THREE_HALF_PI, TWO_PI)) {
    lo = Math.min(lo, -1);
    hi = Math.max(hi, -1);
  }
  return ok({ lo, hi });
}
function asin2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo > 1 || xVal.hi < -1) {
    return { kind: "empty" };
  }
  if (xVal.lo < -1 || xVal.hi > 1) {
    const clippedLo = Math.max(xVal.lo, -1);
    const clippedHi = Math.min(xVal.hi, 1);
    return {
      kind: "partial",
      value: { lo: Math.asin(clippedLo), hi: Math.asin(clippedHi) },
      domainClipped: xVal.lo < -1 && xVal.hi > 1 ? "both" : xVal.lo < -1 ? "lo" : "hi"
    };
  }
  return ok({ lo: Math.asin(xVal.lo), hi: Math.asin(xVal.hi) });
}
function acos2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo > 1 || xVal.hi < -1) {
    return { kind: "empty" };
  }
  if (xVal.lo < -1 || xVal.hi > 1) {
    const clippedLo = Math.max(xVal.lo, -1);
    const clippedHi = Math.min(xVal.hi, 1);
    return {
      kind: "partial",
      value: { lo: Math.acos(clippedHi), hi: Math.acos(clippedLo) },
      domainClipped: xVal.lo < -1 && xVal.hi > 1 ? "both" : xVal.lo < -1 ? "lo" : "hi"
    };
  }
  return ok({ lo: Math.acos(xVal.hi), hi: Math.acos(xVal.lo) });
}
function atan3(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.atan(xVal.lo), hi: Math.atan(xVal.hi) });
}
function atan22(y, x) {
  const unwrapped = unwrapOrPropagate(y, x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [yVal, xVal] = unwrapped;
  if (yVal.lo === yVal.hi && xVal.lo === xVal.hi) {
    const result = Math.atan2(yVal.lo, xVal.lo);
    return ok({ lo: result, hi: result });
  }
  const angles = [];
  angles.push(Math.atan2(yVal.lo, xVal.lo));
  angles.push(Math.atan2(yVal.lo, xVal.hi));
  angles.push(Math.atan2(yVal.hi, xVal.lo));
  angles.push(Math.atan2(yVal.hi, xVal.hi));
  if (xVal.lo < 0 && yVal.lo < 0 && yVal.hi > 0) {
    return ok({ lo: -PI2, hi: PI2 });
  }
  return ok({ lo: Math.min(...angles), hi: Math.max(...angles) });
}
function sinh3(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.sinh(xVal.lo), hi: Math.sinh(xVal.hi) });
}
function cosh3(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo >= 0) {
    return ok({ lo: Math.cosh(xVal.lo), hi: Math.cosh(xVal.hi) });
  } else if (xVal.hi <= 0) {
    return ok({ lo: Math.cosh(xVal.hi), hi: Math.cosh(xVal.lo) });
  } else {
    return ok({
      lo: 1,
      hi: Math.max(Math.cosh(xVal.lo), Math.cosh(xVal.hi))
    });
  }
}
function tanh2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.tanh(xVal.lo), hi: Math.tanh(xVal.hi) });
}
function asinh2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  return ok({ lo: Math.asinh(xVal.lo), hi: Math.asinh(xVal.hi) });
}
function acosh2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.hi < 1) {
    return { kind: "empty" };
  }
  if (xVal.lo < 1) {
    return {
      kind: "partial",
      value: { lo: 0, hi: Math.acosh(xVal.hi) },
      domainClipped: "lo"
    };
  }
  return ok({ lo: Math.acosh(xVal.lo), hi: Math.acosh(xVal.hi) });
}
function atanh2(x) {
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  if (xVal.lo >= 1 || xVal.hi <= -1) {
    return { kind: "empty" };
  }
  if (xVal.lo <= -1 || xVal.hi >= 1) {
    const clippedLo = Math.max(xVal.lo, -1 + Number.EPSILON);
    const clippedHi = Math.min(xVal.hi, 1 - Number.EPSILON);
    return {
      kind: "partial",
      value: { lo: Math.atanh(clippedLo), hi: Math.atanh(clippedHi) },
      domainClipped: xVal.lo <= -1 && xVal.hi >= 1 ? "both" : xVal.lo <= -1 ? "lo" : "hi"
    };
  }
  return ok({ lo: Math.atanh(xVal.lo), hi: Math.atanh(xVal.hi) });
}

// src/compute-engine/interval/comparison.ts
function less(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return "maybe";
  const [aVal, bVal] = unwrapped;
  if (aVal.hi < bVal.lo) return "true";
  if (aVal.lo >= bVal.hi) return "false";
  return "maybe";
}
function lessEqual(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return "maybe";
  const [aVal, bVal] = unwrapped;
  if (aVal.hi <= bVal.lo) return "true";
  if (aVal.lo > bVal.hi) return "false";
  return "maybe";
}
function greater(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return "maybe";
  const [aVal, bVal] = unwrapped;
  if (aVal.lo > bVal.hi) return "true";
  if (aVal.hi <= bVal.lo) return "false";
  return "maybe";
}
function greaterEqual(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return "maybe";
  const [aVal, bVal] = unwrapped;
  if (aVal.lo >= bVal.hi) return "true";
  if (aVal.hi < bVal.lo) return "false";
  return "maybe";
}
function equal(a, b) {
  const unwrapped = unwrapOrPropagate(a, b);
  if (!Array.isArray(unwrapped)) return "maybe";
  const [aVal, bVal] = unwrapped;
  if (aVal.lo === aVal.hi && bVal.lo === bVal.hi && aVal.lo === bVal.lo)
    return "true";
  if (aVal.hi < bVal.lo || bVal.hi < aVal.lo) return "false";
  return "maybe";
}
function notEqual(a, b) {
  const eq2 = equal(a, b);
  if (eq2 === "true") return "false";
  if (eq2 === "false") return "true";
  return "maybe";
}
function and(a, b) {
  if (a === "false" || b === "false") return "false";
  if (a === "true" && b === "true") return "true";
  return "maybe";
}
function or(a, b) {
  if (a === "true" || b === "true") return "true";
  if (a === "false" && b === "false") return "false";
  return "maybe";
}
function not(a) {
  if (a === "true") return "false";
  if (a === "false") return "true";
  return "maybe";
}
function piecewise(xOrCond, conditionOrTrue, trueOrFalse, falseBranch) {
  if (xOrCond === "true" || xOrCond === "false" || xOrCond === "maybe") {
    const cond2 = xOrCond;
    const trueBranch2 = conditionOrTrue;
    const falseBranchFn2 = trueOrFalse;
    switch (cond2) {
      case "true":
        return trueBranch2();
      case "false":
        return falseBranchFn2();
      case "maybe":
        return unionResults(trueBranch2(), falseBranchFn2());
    }
  }
  const x = xOrCond;
  const condition = conditionOrTrue;
  const trueBranch = trueOrFalse;
  const falseBranchFn = falseBranch;
  const unwrapped = unwrapOrPropagate(x);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal] = unwrapped;
  const cond = condition(xVal);
  switch (cond) {
    case "true":
      return trueBranch(xVal);
    case "false":
      return falseBranchFn(xVal);
    case "maybe":
      const t = trueBranch(xVal);
      const f = falseBranchFn(xVal);
      return unionResults(t, f);
  }
}
function clamp2(x, lo, hi) {
  const unwrapped = unwrapOrPropagate(x, lo, hi);
  if (!Array.isArray(unwrapped)) return unwrapped;
  const [xVal, loVal, hiVal] = unwrapped;
  const resultLo = Math.max(xVal.lo, loVal.lo);
  const resultHi = Math.min(xVal.hi, hiVal.hi);
  if (resultLo > resultHi) {
    return { kind: "empty" };
  }
  return { kind: "interval", value: { lo: resultLo, hi: resultHi } };
}

// src/compute-engine/interval/index.ts
var IntervalArithmetic = {
  // Utilities
  ok,
  point,
  containsExtremum,
  unionResults,
  mergeDomainClip,
  isPoint,
  containsZero,
  isPositive: isPositive2,
  isNegative,
  isNonNegative,
  isNonPositive,
  width,
  midpoint,
  getValue,
  unwrap,
  unwrapOrPropagate,
  // Arithmetic
  add: add4,
  sub: sub2,
  mul: mul4,
  div: div3,
  negate: negate2,
  // Elementary
  sqrt: sqrt2,
  square,
  pow: pow3,
  powInterval,
  exp: exp2,
  ln: ln2,
  log10: log102,
  log2: log22,
  abs: abs2,
  floor: floor2,
  ceil: ceil2,
  round: round2,
  min: min2,
  max: max2,
  mod: mod2,
  sign: sign2,
  // Trigonometric
  sin: sin2,
  cos: cos2,
  tan: tan2,
  cot,
  sec,
  csc,
  asin: asin2,
  acos: acos2,
  atan: atan3,
  atan2: atan22,
  sinh: sinh3,
  cosh: cosh3,
  tanh: tanh2,
  asinh: asinh2,
  acosh: acosh2,
  atanh: atanh2,
  // Comparison
  less,
  lessEqual,
  greater,
  greaterEqual,
  equal,
  notEqual,
  and,
  or,
  not,
  piecewise,
  clamp: clamp2
};

// src/compute-engine/compilation/interval-javascript-target.ts
var INTERVAL_JAVASCRIPT_OPERATORS = {
  // We use high precedence since these become function calls
  Add: ["_IA.add", 20],
  Negate: ["_IA.negate", 20],
  Subtract: ["_IA.sub", 20],
  Multiply: ["_IA.mul", 20],
  Divide: ["_IA.div", 20],
  // Comparisons return BoolInterval
  Equal: ["_IA.equal", 20],
  NotEqual: ["_IA.notEqual", 20],
  LessEqual: ["_IA.lessEqual", 20],
  GreaterEqual: ["_IA.greaterEqual", 20],
  Less: ["_IA.less", 20],
  Greater: ["_IA.greater", 20],
  And: ["_IA.and", 20],
  Or: ["_IA.or", 20],
  Not: ["_IA.not", 20]
};
var INTERVAL_JAVASCRIPT_FUNCTIONS = {
  // Basic arithmetic - using function call syntax
  Add: (args, compile) => {
    if (args.length === 0) return "_IA.point(0)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.add(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Subtract: (args, compile) => {
    if (args.length === 0) return "_IA.point(0)";
    if (args.length === 1) return `_IA.negate(${compile(args[0])})`;
    if (args.length === 2)
      return `_IA.sub(${compile(args[0])}, ${compile(args[1])})`;
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.sub(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Multiply: (args, compile) => {
    if (args.length === 0) return "_IA.point(1)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.mul(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Divide: (args, compile) => {
    if (args.length === 0) return "_IA.point(1)";
    if (args.length === 1) return compile(args[0]);
    if (args.length === 2)
      return `_IA.div(${compile(args[0])}, ${compile(args[1])})`;
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.div(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Negate: (args, compile) => `_IA.negate(${compile(args[0])})`,
  // Elementary functions
  Abs: (args, compile) => `_IA.abs(${compile(args[0])})`,
  Ceiling: (args, compile) => `_IA.ceil(${compile(args[0])})`,
  Exp: (args, compile) => `_IA.exp(${compile(args[0])})`,
  Floor: (args, compile) => `_IA.floor(${compile(args[0])})`,
  Ln: (args, compile) => `_IA.ln(${compile(args[0])})`,
  Log: (args, compile) => {
    if (args.length === 1) return `_IA.log10(${compile(args[0])})`;
    return `_IA.div(_IA.ln(${compile(args[0])}), _IA.ln(${compile(args[1])}))`;
  },
  Lb: (args, compile) => `_IA.log2(${compile(args[0])})`,
  Max: (args, compile) => {
    if (args.length === 0) return "_IA.point(-Infinity)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.max(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Min: (args, compile) => {
    if (args.length === 0) return "_IA.point(Infinity)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `_IA.min(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Power: (args, compile) => {
    const base = args[0];
    const exp3 = args[1];
    if (base === null) throw new Error("Power: no argument");
    if (base.symbol === "ExponentialE") {
      return `_IA.exp(${compile(exp3)})`;
    }
    if (exp3?.isNumberLiteral && exp3.im === 0) {
      const expVal = exp3.re;
      if (expVal === 0.5) return `_IA.sqrt(${compile(base)})`;
      if (expVal === 2) return `_IA.square(${compile(base)})`;
      return `_IA.pow(${compile(base)}, ${expVal})`;
    }
    return `_IA.powInterval(${compile(base)}, ${compile(exp3)})`;
  },
  Root: (args, compile) => {
    const [arg, exp3] = args;
    if (arg === null) throw new Error("Root: no argument");
    if (exp3 === null) return `_IA.sqrt(${compile(arg)})`;
    if (exp3?.re === 2) return `_IA.sqrt(${compile(arg)})`;
    if (exp3?.isNumberLiteral && exp3.im === 0) {
      return `_IA.pow(${compile(arg)}, ${1 / exp3.re})`;
    }
    return `_IA.powInterval(${compile(arg)}, _IA.div(_IA.point(1), ${compile(exp3)}))`;
  },
  Round: (args, compile) => `_IA.round(${compile(args[0])})`,
  Sgn: (args, compile) => `_IA.sign(${compile(args[0])})`,
  Sqrt: (args, compile) => `_IA.sqrt(${compile(args[0])})`,
  Square: (args, compile) => `_IA.square(${compile(args[0])})`,
  // Trigonometric functions
  Sin: (args, compile) => `_IA.sin(${compile(args[0])})`,
  Cos: (args, compile) => `_IA.cos(${compile(args[0])})`,
  Tan: (args, compile) => `_IA.tan(${compile(args[0])})`,
  Cot: (args, compile) => `_IA.cot(${compile(args[0])})`,
  Sec: (args, compile) => `_IA.sec(${compile(args[0])})`,
  Csc: (args, compile) => `_IA.csc(${compile(args[0])})`,
  Arcsin: (args, compile) => `_IA.asin(${compile(args[0])})`,
  Arccos: (args, compile) => `_IA.acos(${compile(args[0])})`,
  Arctan: (args, compile) => `_IA.atan(${compile(args[0])})`,
  // Hyperbolic functions
  Sinh: (args, compile) => `_IA.sinh(${compile(args[0])})`,
  Cosh: (args, compile) => `_IA.cosh(${compile(args[0])})`,
  Tanh: (args, compile) => `_IA.tanh(${compile(args[0])})`,
  Arsinh: (args, compile) => `_IA.asinh(${compile(args[0])})`,
  Arcosh: (args, compile) => `_IA.acosh(${compile(args[0])})`,
  Artanh: (args, compile) => `_IA.atanh(${compile(args[0])})`,
  // Inverse trig (alternative names)
  Asin: (args, compile) => `_IA.asin(${compile(args[0])})`,
  Acos: (args, compile) => `_IA.acos(${compile(args[0])})`,
  Atan: (args, compile) => `_IA.atan(${compile(args[0])})`,
  // Mod
  Mod: (args, compile) => `_IA.mod(${compile(args[0])}, ${compile(args[1])})`,
  // Conditionals
  If: (args, compile) => {
    if (args.length !== 3) throw new Error("If: wrong number of arguments");
    return `_IA.piecewise(
      ${compile(args[0])},
      () => ${compile(args[1])},
      () => ${compile(args[2])}
    )`;
  },
  // Comparisons
  Equal: (args, compile) => `_IA.equal(${compile(args[0])}, ${compile(args[1])})`,
  NotEqual: (args, compile) => `_IA.notEqual(${compile(args[0])}, ${compile(args[1])})`,
  LessEqual: (args, compile) => `_IA.lessEqual(${compile(args[0])}, ${compile(args[1])})`,
  GreaterEqual: (args, compile) => `_IA.greaterEqual(${compile(args[0])}, ${compile(args[1])})`,
  Less: (args, compile) => `_IA.less(${compile(args[0])}, ${compile(args[1])})`,
  Greater: (args, compile) => `_IA.greater(${compile(args[0])}, ${compile(args[1])})`,
  And: (args, compile) => `_IA.and(${compile(args[0])}, ${compile(args[1])})`,
  Or: (args, compile) => `_IA.or(${compile(args[0])}, ${compile(args[1])})`,
  Not: (args, compile) => `_IA.not(${compile(args[0])})`
};
var ComputeEngineIntervalFunction = class extends Function {
  IA = IntervalArithmetic;
  constructor(body, preamble = "") {
    super(
      "_IA",
      "_",
      preamble ? `${preamble};return ${body}` : `return ${body}`
    );
    return new Proxy(this, {
      apply: (target, thisArg, argumentsList) => {
        const processedArgs = argumentsList.map(processInput);
        return super.apply(thisArg, [this.IA, ...processedArgs]);
      },
      get: (target, prop) => {
        if (prop === "toString") return () => body;
        if (prop === "isCompiled") return true;
        return target[prop];
      }
    });
  }
};
function processInput(input) {
  if (input === null || input === void 0) {
    return input;
  }
  if (typeof input === "object" && "lo" in input && "hi" in input) {
    return input;
  }
  if (typeof input === "object") {
    const result = {};
    for (const [key, value] of Object.entries(input)) {
      result[key] = processInput(value);
    }
    return result;
  }
  if (typeof input === "number") {
    return { lo: input, hi: input };
  }
  return input;
}
var IntervalJavaScriptTarget = class {
  getOperators() {
    return INTERVAL_JAVASCRIPT_OPERATORS;
  }
  getFunctions() {
    return INTERVAL_JAVASCRIPT_FUNCTIONS;
  }
  createTarget(options = {}) {
    return {
      language: "interval-javascript",
      // Don't use operators - all arithmetic goes through functions
      // because interval arithmetic returns IntervalResult, not numbers
      operators: () => void 0,
      functions: (id) => INTERVAL_JAVASCRIPT_FUNCTIONS[id],
      var: (id) => {
        const result = {
          Pi: "_IA.point(Math.PI)",
          ExponentialE: "_IA.point(Math.E)",
          NaN: "{ lo: NaN, hi: NaN }",
          ImaginaryUnit: "{ lo: NaN, hi: NaN }",
          Half: "_IA.point(0.5)",
          MachineEpsilon: "_IA.point(Number.EPSILON)",
          GoldenRatio: "_IA.point((1 + Math.sqrt(5)) / 2)",
          CatalanConstant: "_IA.point(0.91596559417721901)",
          EulerGamma: "_IA.point(0.57721566490153286)"
        };
        return result[id];
      },
      string: (str) => JSON.stringify(str),
      number: (n) => `_IA.point(${n})`,
      indent: 0,
      ws: (s) => s ?? "",
      preamble: "",
      ...options
    };
  }
  compileToExecutable(expr, options = {}) {
    const { functions, vars, preamble } = options;
    const unknowns = expr.unknowns;
    const namedFunctions = {};
    let preambleImports = "";
    if (functions) {
      for (const [k, v] of Object.entries(functions)) {
        if (typeof v === "function") {
          preambleImports += `const ${k} = ${v.toString()};
`;
          namedFunctions[k] = k;
        } else if (typeof v === "string") {
          namedFunctions[k] = v;
        }
      }
    }
    const target = this.createTarget({
      functions: (id) => namedFunctions?.[id] ? namedFunctions[id] : INTERVAL_JAVASCRIPT_FUNCTIONS[id],
      var: (id) => {
        if (vars && id in vars) return vars[id];
        const constants = {
          Pi: "_IA.point(Math.PI)",
          ExponentialE: "_IA.point(Math.E)",
          NaN: "{ lo: NaN, hi: NaN }",
          ImaginaryUnit: "{ lo: NaN, hi: NaN }",
          Half: "_IA.point(0.5)",
          MachineEpsilon: "_IA.point(Number.EPSILON)",
          GoldenRatio: "_IA.point((1 + Math.sqrt(5)) / 2)",
          CatalanConstant: "_IA.point(0.91596559417721901)",
          EulerGamma: "_IA.point(0.57721566490153286)"
        };
        if (id in constants) return constants[id];
        if (unknowns.includes(id)) return `_.${id}`;
        return void 0;
      },
      preamble: (preamble ?? "") + preambleImports
    });
    return compileToIntervalTarget(expr, target);
  }
};
function compileToIntervalTarget(expr, target) {
  const js = BaseCompiler.compile(expr, target);
  return new ComputeEngineIntervalFunction(
    js,
    target.preamble
  );
}

// src/compute-engine/compilation/interval-glsl-target.ts
init_base_compiler();
var GLSL_INTERVAL_LIBRARY = `
// Interval Arithmetic Library for GLSL
// Intervals are represented as vec2(lo, hi)
// Results use IntervalResult struct with status flags

// Status constants
const float IA_NORMAL = 0.0;
const float IA_EMPTY = 1.0;
const float IA_ENTIRE = 2.0;
const float IA_SINGULAR = 3.0;
const float IA_PARTIAL_LO = 4.0;
const float IA_PARTIAL_HI = 5.0;
const float IA_PARTIAL_BOTH = 6.0;

// Interval result struct
struct IntervalResult {
  vec2 value;      // (lo, hi)
  float status;    // Status flag
};

// Epsilon for conservative bounds
const float IA_EPS = 1e-6;
const float IA_HUGE = 1e38;

// Create a point interval
vec2 ia_point(float x) {
  return vec2(x, x);
}

// Create interval result
IntervalResult ia_ok(vec2 v) {
  return IntervalResult(v, IA_NORMAL);
}

IntervalResult ia_empty() {
  return IntervalResult(vec2(0.0), IA_EMPTY);
}

IntervalResult ia_entire() {
  return IntervalResult(vec2(-IA_HUGE, IA_HUGE), IA_ENTIRE);
}

IntervalResult ia_singular(float at) {
  return IntervalResult(vec2(at, at), IA_SINGULAR);
}

IntervalResult ia_partial(vec2 v, float clip) {
  return IntervalResult(v, clip);
}

bool ia_is_error(float status) {
  return status == IA_EMPTY || status == IA_ENTIRE || status == IA_SINGULAR;
}

// Addition
IntervalResult ia_add(vec2 a, vec2 b) {
  return ia_ok(vec2(a.x + b.x - IA_EPS, a.y + b.y + IA_EPS));
}

// Subtraction
IntervalResult ia_sub(vec2 a, vec2 b) {
  return ia_ok(vec2(a.x - b.y - IA_EPS, a.y - b.x + IA_EPS));
}

// Negation
IntervalResult ia_negate(vec2 x) {
  return ia_ok(vec2(-x.y, -x.x));
}

// Multiplication helper (returns vec2)
vec2 ia_mul_raw(vec2 a, vec2 b) {
  float p1 = a.x * b.x;
  float p2 = a.x * b.y;
  float p3 = a.y * b.x;
  float p4 = a.y * b.y;
  return vec2(
    min(min(p1, p2), min(p3, p4)) - IA_EPS,
    max(max(p1, p2), max(p3, p4)) + IA_EPS
  );
}

// Multiplication
IntervalResult ia_mul(vec2 a, vec2 b) {
  return ia_ok(ia_mul_raw(a, b));
}

// Division
IntervalResult ia_div(vec2 a, vec2 b) {
  // Case 1: Divisor entirely positive or negative
  if (b.x > 0.0 || b.y < 0.0) {
    return ia_ok(ia_mul_raw(a, vec2(1.0 / b.y, 1.0 / b.x)));
  }

  // Case 2: Divisor strictly contains zero
  if (b.x < 0.0 && b.y > 0.0) {
    return ia_singular(0.0);
  }

  // Case 3: Divisor touches zero at lower bound [0, c]
  if (b.x == 0.0 && b.y > 0.0) {
    if (a.x >= 0.0) {
      return ia_partial(vec2(a.x / b.y, IA_HUGE), IA_PARTIAL_HI);
    } else if (a.y <= 0.0) {
      return ia_partial(vec2(-IA_HUGE, a.y / b.y), IA_PARTIAL_LO);
    } else {
      return ia_entire();
    }
  }

  // Case 4: Divisor touches zero at upper bound [c, 0]
  if (b.y == 0.0 && b.x < 0.0) {
    if (a.x >= 0.0) {
      return ia_partial(vec2(-IA_HUGE, a.x / b.x), IA_PARTIAL_LO);
    } else if (a.y <= 0.0) {
      return ia_partial(vec2(a.y / b.x, IA_HUGE), IA_PARTIAL_HI);
    } else {
      return ia_entire();
    }
  }

  // Case 5: Divisor is [0, 0]
  return ia_empty();
}

// Square root
IntervalResult ia_sqrt(vec2 x) {
  if (x.y < 0.0) {
    return ia_empty();
  }
  if (x.x >= 0.0) {
    return ia_ok(vec2(sqrt(x.x), sqrt(x.y) + IA_EPS));
  }
  return ia_partial(vec2(0.0, sqrt(x.y) + IA_EPS), IA_PARTIAL_LO);
}

// Square
IntervalResult ia_square(vec2 x) {
  if (x.x >= 0.0) {
    return ia_ok(vec2(x.x * x.x - IA_EPS, x.y * x.y + IA_EPS));
  } else if (x.y <= 0.0) {
    return ia_ok(vec2(x.y * x.y - IA_EPS, x.x * x.x + IA_EPS));
  } else {
    float m = max(-x.x, x.y);
    return ia_ok(vec2(0.0, m * m + IA_EPS));
  }
}

// Exponential
IntervalResult ia_exp(vec2 x) {
  return ia_ok(vec2(exp(x.x) - IA_EPS, exp(x.y) + IA_EPS));
}

// Natural logarithm
IntervalResult ia_ln(vec2 x) {
  if (x.y <= 0.0) {
    return ia_empty();
  }
  if (x.x > 0.0) {
    return ia_ok(vec2(log(x.x) - IA_EPS, log(x.y) + IA_EPS));
  }
  return ia_partial(vec2(-IA_HUGE, log(x.y) + IA_EPS), IA_PARTIAL_LO);
}

// Absolute value
IntervalResult ia_abs(vec2 x) {
  if (x.x >= 0.0) {
    return ia_ok(x);
  }
  if (x.y <= 0.0) {
    return ia_ok(vec2(-x.y, -x.x));
  }
  return ia_ok(vec2(0.0, max(-x.x, x.y)));
}

// Sign function
IntervalResult ia_sign(vec2 x) {
  if (x.x > 0.0) return ia_ok(vec2(1.0, 1.0));
  if (x.y < 0.0) return ia_ok(vec2(-1.0, -1.0));
  if (x.x == 0.0 && x.y == 0.0) return ia_ok(vec2(0.0, 0.0));
  if (x.x < 0.0 && x.y > 0.0) return ia_ok(vec2(-1.0, 1.0));
  if (x.x == 0.0) return ia_ok(vec2(0.0, 1.0));
  return ia_ok(vec2(-1.0, 0.0));
}

// Floor
IntervalResult ia_floor(vec2 x) {
  return ia_ok(vec2(floor(x.x), floor(x.y)));
}

// Ceiling
IntervalResult ia_ceil(vec2 x) {
  return ia_ok(vec2(ceil(x.x), ceil(x.y)));
}

// Min of two intervals
IntervalResult ia_min(vec2 a, vec2 b) {
  return ia_ok(vec2(min(a.x, b.x), min(a.y, b.y)));
}

// Max of two intervals
IntervalResult ia_max(vec2 a, vec2 b) {
  return ia_ok(vec2(max(a.x, b.x), max(a.y, b.y)));
}

// Power with constant exponent
IntervalResult ia_pow(vec2 base, float exp) {
  if (exp == 0.0) return ia_ok(vec2(1.0, 1.0));
  if (exp == 1.0) return ia_ok(base);
  if (exp == 2.0) return ia_square(base);
  if (exp == 0.5) return ia_sqrt(base);

  // General case - requires positive base for non-integer exponents
  if (base.y < 0.0) {
    return ia_empty();
  }
  if (base.x < 0.0) {
    // Partial domain
    if (exp > 0.0) {
      return ia_partial(vec2(0.0, pow(base.y, exp) + IA_EPS), IA_PARTIAL_LO);
    } else {
      return ia_partial(vec2(pow(base.y, exp) - IA_EPS, IA_HUGE), IA_PARTIAL_LO);
    }
  }

  // Entirely non-negative
  if (exp > 0.0) {
    return ia_ok(vec2(pow(base.x, exp) - IA_EPS, pow(base.y, exp) + IA_EPS));
  } else {
    if (base.x == 0.0) {
      return ia_partial(vec2(pow(base.y, exp) - IA_EPS, IA_HUGE), IA_PARTIAL_HI);
    }
    return ia_ok(vec2(pow(base.y, exp) - IA_EPS, pow(base.x, exp) + IA_EPS));
  }
}

// Check if interval contains extremum at (extremum + n * period)
bool ia_contains_extremum(vec2 x, float extremum, float period) {
  float n = ceil((x.x - extremum) / period);
  float candidate = extremum + n * period;
  return candidate >= x.x - 1e-7 && candidate <= x.y + 1e-7;
}

// Sine
IntervalResult ia_sin(vec2 x) {
  const float TWO_PI = 6.28318530718;
  const float HALF_PI = 1.57079632679;
  const float THREE_HALF_PI = 4.71238898038;

  if (x.y - x.x >= TWO_PI) {
    return ia_ok(vec2(-1.0, 1.0));
  }

  float sinLo = sin(x.x);
  float sinHi = sin(x.y);
  float lo = min(sinLo, sinHi);
  float hi = max(sinLo, sinHi);

  if (ia_contains_extremum(x, HALF_PI, TWO_PI)) hi = 1.0;
  if (ia_contains_extremum(x, THREE_HALF_PI, TWO_PI)) lo = -1.0;

  return ia_ok(vec2(lo - IA_EPS, hi + IA_EPS));
}

// Cosine
IntervalResult ia_cos(vec2 x) {
  const float TWO_PI = 6.28318530718;
  const float PI = 3.14159265359;

  if (x.y - x.x >= TWO_PI) {
    return ia_ok(vec2(-1.0, 1.0));
  }

  float cosLo = cos(x.x);
  float cosHi = cos(x.y);
  float lo = min(cosLo, cosHi);
  float hi = max(cosLo, cosHi);

  if (ia_contains_extremum(x, 0.0, TWO_PI)) hi = 1.0;
  if (ia_contains_extremum(x, PI, TWO_PI)) lo = -1.0;

  return ia_ok(vec2(lo - IA_EPS, hi + IA_EPS));
}

// Tangent
IntervalResult ia_tan(vec2 x) {
  const float PI = 3.14159265359;
  const float HALF_PI = 1.57079632679;

  if (x.y - x.x >= PI) {
    return ia_singular(0.0);
  }

  if (ia_contains_extremum(x, HALF_PI, PI)) {
    float n = ceil((x.x - HALF_PI) / PI);
    float poleAt = HALF_PI + n * PI;
    return ia_singular(poleAt);
  }

  float tanLo = tan(x.x);
  float tanHi = tan(x.y);

  if ((tanLo > 1e10 && tanHi < -1e10) || (tanLo < -1e10 && tanHi > 1e10)) {
    return ia_singular(0.0);
  }

  return ia_ok(vec2(tanLo - IA_EPS, tanHi + IA_EPS));
}

// Arc sine
IntervalResult ia_asin(vec2 x) {
  if (x.x > 1.0 || x.y < -1.0) {
    return ia_empty();
  }

  vec2 clipped = vec2(max(x.x, -1.0), min(x.y, 1.0));

  if (x.x < -1.0 || x.y > 1.0) {
    float clip = (x.x < -1.0 && x.y > 1.0) ? IA_PARTIAL_BOTH :
                 (x.x < -1.0) ? IA_PARTIAL_LO : IA_PARTIAL_HI;
    return ia_partial(vec2(asin(clipped.x) - IA_EPS, asin(clipped.y) + IA_EPS), clip);
  }

  return ia_ok(vec2(asin(x.x) - IA_EPS, asin(x.y) + IA_EPS));
}

// Arc cosine
IntervalResult ia_acos(vec2 x) {
  if (x.x > 1.0 || x.y < -1.0) {
    return ia_empty();
  }

  vec2 clipped = vec2(max(x.x, -1.0), min(x.y, 1.0));

  if (x.x < -1.0 || x.y > 1.0) {
    float clip = (x.x < -1.0 && x.y > 1.0) ? IA_PARTIAL_BOTH :
                 (x.x < -1.0) ? IA_PARTIAL_LO : IA_PARTIAL_HI;
    // acos is decreasing, so bounds swap
    return ia_partial(vec2(acos(clipped.y) - IA_EPS, acos(clipped.x) + IA_EPS), clip);
  }

  // acos is decreasing
  return ia_ok(vec2(acos(x.y) - IA_EPS, acos(x.x) + IA_EPS));
}

// Arc tangent
IntervalResult ia_atan(vec2 x) {
  return ia_ok(vec2(atan(x.x) - IA_EPS, atan(x.y) + IA_EPS));
}

// Hyperbolic sine
IntervalResult ia_sinh(vec2 x) {
  return ia_ok(vec2(sinh(x.x) - IA_EPS, sinh(x.y) + IA_EPS));
}

// Hyperbolic cosine
IntervalResult ia_cosh(vec2 x) {
  if (x.x >= 0.0) {
    return ia_ok(vec2(cosh(x.x) - IA_EPS, cosh(x.y) + IA_EPS));
  } else if (x.y <= 0.0) {
    return ia_ok(vec2(cosh(x.y) - IA_EPS, cosh(x.x) + IA_EPS));
  } else {
    return ia_ok(vec2(1.0 - IA_EPS, max(cosh(x.x), cosh(x.y)) + IA_EPS));
  }
}

// Hyperbolic tangent
IntervalResult ia_tanh(vec2 x) {
  return ia_ok(vec2(tanh(x.x) - IA_EPS, tanh(x.y) + IA_EPS));
}

// IntervalResult overloads for propagation
IntervalResult ia_add(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_add(a.value, b.value);
}

IntervalResult ia_add(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_add(a.value, b);
}

IntervalResult ia_add(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_add(a, b.value);
}

IntervalResult ia_sub(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_sub(a.value, b.value);
}

IntervalResult ia_sub(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_sub(a.value, b);
}

IntervalResult ia_sub(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_sub(a, b.value);
}

IntervalResult ia_mul(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_mul(a.value, b.value);
}

IntervalResult ia_mul(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_mul(a.value, b);
}

IntervalResult ia_mul(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_mul(a, b.value);
}

IntervalResult ia_div(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_div(a.value, b.value);
}

IntervalResult ia_div(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_div(a.value, b);
}

IntervalResult ia_div(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_div(a, b.value);
}

IntervalResult ia_negate(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_negate(x.value);
}

IntervalResult ia_sqrt(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_sqrt(x.value);
}

IntervalResult ia_square(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_square(x.value);
}

IntervalResult ia_exp(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_exp(x.value);
}

IntervalResult ia_ln(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_ln(x.value);
}

IntervalResult ia_abs(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_abs(x.value);
}

IntervalResult ia_sign(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_sign(x.value);
}

IntervalResult ia_floor(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_floor(x.value);
}

IntervalResult ia_ceil(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_ceil(x.value);
}

IntervalResult ia_min(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_min(a.value, b.value);
}

IntervalResult ia_min(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_min(a.value, b);
}

IntervalResult ia_min(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_min(a, b.value);
}

IntervalResult ia_max(IntervalResult a, IntervalResult b) {
  if (ia_is_error(a.status)) return a;
  if (ia_is_error(b.status)) return b;
  return ia_max(a.value, b.value);
}

IntervalResult ia_max(IntervalResult a, vec2 b) {
  if (ia_is_error(a.status)) return a;
  return ia_max(a.value, b);
}

IntervalResult ia_max(vec2 a, IntervalResult b) {
  if (ia_is_error(b.status)) return b;
  return ia_max(a, b.value);
}

IntervalResult ia_pow(IntervalResult base, float exp) {
  if (ia_is_error(base.status)) return base;
  return ia_pow(base.value, exp);
}

IntervalResult ia_sin(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_sin(x.value);
}

IntervalResult ia_cos(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_cos(x.value);
}

IntervalResult ia_tan(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_tan(x.value);
}

IntervalResult ia_asin(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_asin(x.value);
}

IntervalResult ia_acos(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_acos(x.value);
}

IntervalResult ia_atan(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_atan(x.value);
}

IntervalResult ia_sinh(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_sinh(x.value);
}

IntervalResult ia_cosh(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_cosh(x.value);
}

IntervalResult ia_tanh(IntervalResult x) {
  if (ia_is_error(x.status)) return x;
  return ia_tanh(x.value);
}
`;
var INTERVAL_GLSL_OPERATORS = {
  Add: ["ia_add", 20],
  Negate: ["ia_negate", 20],
  Subtract: ["ia_sub", 20],
  Multiply: ["ia_mul", 20],
  Divide: ["ia_div", 20]
};
var INTERVAL_GLSL_FUNCTIONS = {
  Add: (args, compile) => {
    if (args.length === 0) return "ia_point(0.0)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_add(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Subtract: (args, compile) => {
    if (args.length === 0) return "ia_point(0.0)";
    if (args.length === 1) return `ia_negate(${compile(args[0])})`;
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_sub(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Multiply: (args, compile) => {
    if (args.length === 0) return "ia_point(1.0)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_mul(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Divide: (args, compile) => {
    if (args.length === 0) return "ia_point(1.0)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_div(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Negate: (args, compile) => `ia_negate(${compile(args[0])})`,
  // Elementary functions
  Abs: (args, compile) => `ia_abs(${compile(args[0])})`,
  Ceiling: (args, compile) => `ia_ceil(${compile(args[0])})`,
  Exp: (args, compile) => `ia_exp(${compile(args[0])})`,
  Floor: (args, compile) => `ia_floor(${compile(args[0])})`,
  Ln: (args, compile) => `ia_ln(${compile(args[0])})`,
  Max: (args, compile) => {
    if (args.length === 0) return "ia_point(-1e38)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_max(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Min: (args, compile) => {
    if (args.length === 0) return "ia_point(1e38)";
    if (args.length === 1) return compile(args[0]);
    let result = compile(args[0]);
    for (let i = 1; i < args.length; i++) {
      result = `ia_min(${result}, ${compile(args[i])})`;
    }
    return result;
  },
  Power: (args, compile) => {
    const base = args[0];
    const exp3 = args[1];
    if (base === null) throw new Error("Power: no argument");
    if (base.symbol === "ExponentialE") {
      return `ia_exp(${compile(exp3)})`;
    }
    if (exp3?.isNumberLiteral && exp3.im === 0) {
      const expVal = exp3.re;
      if (expVal === 2) return `ia_square(${compile(base)})`;
      return `ia_pow(${compile(base)}, ${expVal})`;
    }
    throw new Error("Interval GLSL does not support variable exponents");
  },
  Sgn: (args, compile) => `ia_sign(${compile(args[0])})`,
  Sqrt: (args, compile) => `ia_sqrt(${compile(args[0])})`,
  Square: (args, compile) => `ia_square(${compile(args[0])})`,
  // Trigonometric functions
  Sin: (args, compile) => `ia_sin(${compile(args[0])})`,
  Cos: (args, compile) => `ia_cos(${compile(args[0])})`,
  Tan: (args, compile) => `ia_tan(${compile(args[0])})`,
  Arcsin: (args, compile) => `ia_asin(${compile(args[0])})`,
  Arccos: (args, compile) => `ia_acos(${compile(args[0])})`,
  Arctan: (args, compile) => `ia_atan(${compile(args[0])})`,
  // Hyperbolic functions
  Sinh: (args, compile) => `ia_sinh(${compile(args[0])})`,
  Cosh: (args, compile) => `ia_cosh(${compile(args[0])})`,
  Tanh: (args, compile) => `ia_tanh(${compile(args[0])})`
};
var IntervalGLSLTarget = class {
  getOperators() {
    return INTERVAL_GLSL_OPERATORS;
  }
  getFunctions() {
    return INTERVAL_GLSL_FUNCTIONS;
  }
  /**
   * Get the GLSL interval library code.
   *
   * This should be included in shaders that use interval arithmetic.
   */
  getLibrary() {
    return GLSL_INTERVAL_LIBRARY;
  }
  createTarget(options = {}) {
    return {
      language: "interval-glsl",
      // Don't use operators - all arithmetic goes through functions
      // because interval arithmetic returns IntervalResult, not numbers
      operators: () => void 0,
      functions: (id) => INTERVAL_GLSL_FUNCTIONS[id],
      var: (id) => {
        const constants = {
          Pi: "ia_point(3.14159265359)",
          ExponentialE: "ia_point(2.71828182846)",
          GoldenRatio: "ia_point(1.61803398875)",
          CatalanConstant: "ia_point(0.91596559417)",
          EulerGamma: "ia_point(0.57721566490)"
        };
        if (id in constants) return constants[id];
        return id;
      },
      string: (str) => JSON.stringify(str),
      number: (n) => {
        const str = n.toString();
        const numStr = !str.includes(".") && !str.includes("e") && !str.includes("E") ? `${str}.0` : str;
        return `ia_point(${numStr})`;
      },
      indent: 0,
      ws: (s) => s ?? "",
      preamble: "",
      ...options
    };
  }
  compileToExecutable(expr, options = {}) {
    const { functions, vars } = options;
    const target = this.createTarget({
      functions: (id) => {
        if (functions && id in functions) {
          const fn = functions[id];
          if (typeof fn === "string") return fn;
          if (typeof fn === "function") return fn.name || id;
        }
        return INTERVAL_GLSL_FUNCTIONS[id];
      },
      var: (id) => {
        if (vars && id in vars) return vars[id];
        const constants = {
          Pi: "ia_point(3.14159265359)",
          ExponentialE: "ia_point(2.71828182846)",
          GoldenRatio: "ia_point(1.61803398875)",
          CatalanConstant: "ia_point(0.91596559417)",
          EulerGamma: "ia_point(0.57721566490)"
        };
        if (id in constants) return constants[id];
        return id;
      }
    });
    const glslCode = BaseCompiler.compile(expr, target);
    const result = function() {
      return glslCode;
    };
    Object.defineProperty(result, "toString", {
      value: () => glslCode
    });
    Object.defineProperty(result, "isCompiled", {
      value: true
    });
    return result;
  }
  /**
   * Compile an expression to GLSL interval code.
   */
  compile(expr, options = {}) {
    const target = this.createTarget();
    return BaseCompiler.compile(expr, target);
  }
  /**
   * Create a complete GLSL interval function from an expression.
   *
   * @param expr - The expression to compile
   * @param functionName - Name of the GLSL function
   * @param parameters - Parameter names (each becomes a vec2 interval input)
   */
  compileFunction(expr, functionName, parameters) {
    const target = this.createTarget();
    const body = BaseCompiler.compile(expr, target);
    const params = parameters.map((name) => `vec2 ${name}`).join(", ");
    return `IntervalResult ${functionName}(${params}) {
  return ${body};
}`;
  }
  /**
   * Create a complete GLSL fragment shader for interval function plotting.
   *
   * @param expr - The expression to compile
   * @param options - Shader options
   */
  compileShaderFunction(expr, options = {}) {
    const {
      functionName = "evaluateInterval",
      version: version2 = "300 es",
      parameters = ["x"]
    } = options;
    const target = this.createTarget();
    const body = BaseCompiler.compile(expr, target);
    const params = parameters.map((name) => `vec2 ${name}`).join(", ");
    return `#version ${version2}
precision highp float;

${GLSL_INTERVAL_LIBRARY}

IntervalResult ${functionName}(${params}) {
  return ${body};
}
`;
  }
};

// src/compute-engine/index.ts
init_base_compiler();
var ComputeEngine = class _ComputeEngine {
  // Common symbols
  True;
  False;
  Pi;
  E;
  Nothing;
  // Common numbers
  Zero;
  One;
  Half;
  NegativeOne;
  Two;
  I;
  NaN;
  PositiveInfinity;
  NegativeInfinity;
  ComplexInfinity;
  /** The symbol separating the whole part of a number from its fractional
   *  part in a LaTeX string.
   *
   * Commonly a period (`.`) in English, but a comma (`,`) in many European
   * languages. For the comma, use `"{,}"` so that the spacing is correct.
   *
   * Note that this is a LaTeX string and is used when parsing or serializing
   * LaTeX. MathJSON always uses a period.
   *
   * */
  decimalSeparator = ".";
  /** @internal */
  _BIGNUM_NAN;
  /** @internal */
  _BIGNUM_ZERO;
  /** @internal */
  _BIGNUM_ONE;
  /** @internal */
  _BIGNUM_TWO;
  /** @internal */
  _BIGNUM_HALF;
  /** @internal */
  _BIGNUM_PI;
  /** @internal */
  _BIGNUM_NEGATIVE_ONE;
  /** @internal */
  _precision;
  /** @ internal */
  _angularUnit;
  /** @internal */
  _tolerance;
  /** @internal */
  _bignumTolerance;
  _negBignumTolerance;
  /** @internal */
  __cache = {};
  _configurationChangeTracker = new ConfigurationChangeTracker();
  /** @internal */
  _cost;
  /** @internal Registry of compilation targets */
  _compilationTargets = /* @__PURE__ */ new Map();
  /** @internal */
  _commonSymbols = {
    Pi: null,
    True: null,
    False: null,
    All: null,
    Nothing: null,
    None: null,
    Undefined: null,
    ImaginaryUnit: null,
    ExponentialE: null
  };
  /** @internal */
  _commonNumbers = {
    "-5": null,
    "-4": null,
    "-3": null,
    "-2": null,
    2: null,
    3: null,
    4: null,
    5: null,
    6: null,
    7: null,
    8: null,
    9: null,
    10: null,
    11: null,
    12: null,
    36: null
  };
  /**
   * The stack of evaluation contexts.
   *
   * An **evaluation context** contains bindings of symbols to their
   * values, assumptions, and the matching scope.
   *
   */
  _evalContextStack = [];
  /** The current evaluation context */
  get context() {
    return this._evalContextStack[this._evalContextStack.length - 1];
  }
  get contextStack() {
    return [...this._evalContextStack];
  }
  set contextStack(stack) {
    this._evalContextStack = [...stack];
  }
  /** @internal */
  get _typeResolver() {
    const ce = this;
    return {
      get names() {
        const types = [];
        let scope = ce.context.lexicalScope;
        while (scope) {
          if (scope.types) types.push(...Object.keys(scope.types));
          scope = scope.parent;
        }
        return types;
      },
      resolve: (name) => {
        let scope = ce.context.lexicalScope;
        while (scope) {
          if (scope.types?.[name]) return scope.types[name];
          scope = scope.parent;
        }
        return void 0;
      },
      // If no definition was found, but this is a forward lookup, return
      // a new definition
      forward: (name) => {
        const ref = {
          kind: "reference",
          name,
          alias: false,
          def: void 0
        };
        ce.context.lexicalScope.types ??= {};
        ce.context.lexicalScope.types[name] = ref;
        return ref;
      }
    };
  }
  /**
   * Declare a new type in the current scope.
   *
   * By default, types are nominal. To declare a structural type, set
   * `alias` to `true`.
   */
  declareType(name, type2, { alias } = {}) {
    if (!isValidTypeName(name))
      throw Error(`The type name "${name}" is invalid`);
    const scope = this.context.lexicalScope;
    if (scope.types?.[name])
      throw Error(`The type "${name}" is already defined in the current scope`);
    scope.types ??= {};
    alias ??= false;
    scope.types[name] = { kind: "reference", name, alias, def: void 0 };
    const def = type2 instanceof BoxedType ? type2.type : typeof type2 === "string" ? parseType(type2, this._typeResolver) : type2;
    scope.types[name].def = def;
  }
  /**
   * A list of the function calls to the current evaluation context,
   * most recent first.
   */
  get trace() {
    return this._evalContextStack.map((ctx) => ctx.name).filter((x) => x !== void 0).reverse();
  }
  /**
   * The generation is incremented each time the context changes.
   * It is used to invalidate caches.
   * @internal
   */
  _generation = 0;
  /** In strict mode (the default) the Compute Engine performs
   * validation of domains and signature and may report errors.
   *
   * These checks may impact performance
   *
   * When strict mode is off, results may be incorrect or generate JavaScript
   * errors if the input is not valid.
   *
   */
  strict;
  /** Absolute time beyond which evaluation should not proceed.
   * @internal
   */
  deadline;
  /**
   * Return symbol tables suitable for the specified categories, or `"all"`
   * for all categories (`"arithmetic"`, `"algebra"`, etc...).
   *
   * A symbol table defines how to evaluate and manipulate symbols.
   *
   */
  /** @internal */
  _latexDictionaryInput;
  /** @internal */
  __indexedLatexDictionary;
  /** @internal */
  _bignum;
  static getStandardLibrary(categories = "all") {
    return getStandardLibrary(categories);
  }
  /**
   * Return a LaTeX dictionary suitable for the specified category, or `"all"`
   * for all categories (`"arithmetic"`, `"algebra"`, etc...).
   *
   * A LaTeX dictionary is needed to translate between LaTeX and MathJSON.
   *
   * Each entry in the dictionary indicate how a LaTeX token (or string of
   * tokens) should be parsed into a MathJSON expression.
   *
   * For example an entry can define that the `\pi` LaTeX token should map to the
   * symbol `"Pi"`, or that the token `-` should map to the function
   * `["Negate",...]` when in a prefix position and to the function
   * `["Subtract", ...]` when in an infix position.
   *
   * Furthermore, the information in each dictionary entry is used to serialize
   * the LaTeX string corresponding to a MathJSON expression.
   *
   * Use with `ce.latexDictionary` to set the dictionary. You can complement
   * it with your own definitions, for example with:
   *
   * ```ts
   * ce.latexDictionary = [
   *  ...ce.getLatexDictionary("all"),
   *  {
   *    kind: "function",
   *    symbolTrigger: "concat",
   *    parse: "Concatenate"
   *  }
   * ];
   * ```
   */
  static getLatexDictionary(domain = "all") {
    return getLatexDictionary(domain);
  }
  /**
   * Construct a new `ComputeEngine` instance.
   *
   * Symbols tables define functions, constants and variables (in `options.ids`).
   * If no table is provided the MathJSON Standard Library is used (`ComputeEngine.getStandardLibrary()`)
   *
   * The LaTeX syntax dictionary is defined in `options.latexDictionary`.
   *
   * The order of the dictionaries matter: the definitions from the later ones
   * override the definitions from earlier ones. The first dictionary should
   * be the `'core'` dictionary which include basic definitions that are used
   * by later dictionaries.
   *
   *
   * @param options.precision Specific how many digits of precision
   * for the numeric calculations. Default is 300.
   *
   * @param options.tolerance If the absolute value of the difference of two
   * numbers is less than `tolerance`, they are considered equal. Used by
   * `chop()` as well.
   */
  constructor(options) {
    if (options !== void 0 && typeof options !== "object")
      throw Error("Unexpected argument");
    this.strict = true;
    let precision = options?.precision ?? DEFAULT_PRECISION;
    if (precision === "machine") precision = Math.floor(MACHINE_PRECISION);
    this._bignum = Decimal.clone({ precision });
    this._precision = precision;
    this.tolerance = options?.tolerance ?? "auto";
    this._angularUnit = "rad";
    this.Zero = new BoxedNumber(this, 0);
    this.One = new BoxedNumber(this, 1);
    this.Half = new BoxedNumber(this, { rational: [1, 2] });
    this.NegativeOne = new BoxedNumber(this, -1);
    this.Two = new BoxedNumber(this, 2);
    this.NaN = new BoxedNumber(this, Number.NaN);
    this.PositiveInfinity = new BoxedNumber(this, Number.POSITIVE_INFINITY);
    this.NegativeInfinity = new BoxedNumber(this, Number.NEGATIVE_INFINITY);
    this.I = new BoxedNumber(this, { im: 1 });
    this.ComplexInfinity = new BoxedNumber(this, {
      re: Infinity,
      im: Infinity
    });
    this._reset();
    this.pushScope(void 0, "system");
    this.declareType("limits", "expression<Limits>");
    for (const table of _ComputeEngine.getStandardLibrary("domains"))
      setSymbolDefinitions(this, table);
    const tables = options?.ids ?? _ComputeEngine.getStandardLibrary();
    for (const table of tables) setSymbolDefinitions(this, table);
    for (const sym of Object.keys(this._commonSymbols)) {
      this._commonSymbols[sym] = new BoxedSymbol(this, sym, {
        def: this.lookupDefinition(sym)
      });
    }
    this.True = this._commonSymbols.True;
    this.False = this._commonSymbols.False;
    this.Pi = this._commonSymbols.Pi;
    this.E = this._commonSymbols.ExponentialE;
    this.Nothing = this._commonSymbols.Nothing;
    this.pushScope(void 0, "global");
    this._compilationTargets.set("javascript", new JavaScriptTarget());
    this._compilationTargets.set("glsl", new GLSLTarget());
    this._compilationTargets.set(
      "interval-js",
      new IntervalJavaScriptTarget()
    );
    this._compilationTargets.set("interval-glsl", new IntervalGLSLTarget());
    hidePrivateProperties(this);
  }
  toJSON() {
    return "[ComputeEngine]";
  }
  [Symbol.toStringTag] = "ComputeEngine";
  get latexDictionary() {
    return this._latexDictionaryInput ?? _ComputeEngine.getLatexDictionary();
  }
  set latexDictionary(dic) {
    this._latexDictionaryInput = dic;
    this.__indexedLatexDictionary = indexLatexDictionary(dic, (sig) => {
      throw Error(
        typeof sig.message === "string" ? sig.message : sig.message.join(",")
      );
    });
  }
  get _indexedLatexDictionary() {
    this.__indexedLatexDictionary ??= indexLatexDictionary(
      this.latexDictionary,
      (sig) => console.error(sig)
    );
    return this.__indexedLatexDictionary;
  }
  /** After the configuration of the engine has changed, clear the caches
   * so that new values can be recalculated.
   *
   * This needs to happen for example when the numeric precision changes.
   *
   * @internal
   */
  _reset() {
    console.assert(this._bignum);
    this._generation += 1;
    this._BIGNUM_NEGATIVE_ONE = this.bignum(-1);
    this._BIGNUM_NAN = this.bignum(NaN);
    this._BIGNUM_ZERO = this.bignum(0);
    this._BIGNUM_ONE = this.bignum(1);
    this._BIGNUM_TWO = this.bignum(2);
    this._BIGNUM_HALF = this._BIGNUM_ONE.div(this._BIGNUM_TWO);
    this._BIGNUM_PI = this._BIGNUM_NEGATIVE_ONE.acos();
    for (const d of Object.values(this._commonSymbols)) d?.reset();
    for (const k of Object.keys(this.__cache))
      if (this.__cache[k].value) {
        if (!this.__cache[k].purge) delete this.__cache[k];
        else
          this.__cache[k].value = this.__cache[k].purge(this.__cache[k].value);
      }
    this._configurationChangeTracker.notifyNow();
  }
  /** @internal */
  listenToConfigurationChange(tracker) {
    return this._configurationChangeTracker.listen(tracker);
  }
  /**
   * Register a custom compilation target.
   *
   * This allows you to compile mathematical expressions to different target
   * languages beyond the built-in JavaScript and GLSL targets.
   *
   * @param name - The name of the target (e.g., 'python', 'wgsl', 'matlab')
   * @param target - The LanguageTarget implementation
   *
   * @example
   * ```typescript
   * import { ComputeEngine, GLSLTarget } from '@cortex-js/compute-engine';
   *
   * const ce = new ComputeEngine();
   *
   * // Register a custom target
   * class PythonTarget implements LanguageTarget {
   *   // Implementation...
   * }
   *
   * ce.registerCompilationTarget('python', new PythonTarget());
   *
   * // Use the custom target
   * const expr = ce.parse('x^2 + y^2');
   * const code = expr.compile({ to: 'python' });
   * ```
   */
  registerCompilationTarget(name, target) {
    this._compilationTargets.set(name, target);
  }
  /**
   * Get a registered compilation target by name.
   *
   * @param name - The name of the target (e.g., 'javascript', 'glsl')
   * @returns The LanguageTarget implementation, or undefined if not found
   *
   * @internal
   */
  _getCompilationTarget(name) {
    return this._compilationTargets.get(name);
  }
  get precision() {
    return this._precision;
  }
  /** The precision, or number of significant digits, of numeric
   * calculations.
   *
   * To make calculations using more digits, at the cost of expanded memory
   * usage and slower computations, set the `precision` higher.
   *
   * Trigonometric operations are accurate for precision up to 1,000.
   *
   * If the precision is set to `machine`, floating point numbers
   * are represented internally as a 64-bit floating point number (as
   * per IEEE 754-2008), with a 52-bit mantissa, which gives about 15
   * digits of precision.
   *
   * If the precision is set to `auto`, the precision is set to a default value.
   *
   */
  set precision(p) {
    if (p === "machine") p = MACHINE_PRECISION;
    if (p === "auto") p = DEFAULT_PRECISION;
    const currentPrecision = this._precision;
    if (p === currentPrecision) return;
    if (typeof p !== "number" || p <= 0)
      throw Error('Expected "machine" or a positive number');
    this._precision = Math.max(p, MACHINE_PRECISION);
    this._bignum = this._bignum.config({ precision: this._precision });
    this.tolerance = "auto";
    this._reset();
  }
  /**
   * The unit used for unitless angles in trigonometric functions.
   *
   * - `rad`: radian, $2\pi$ radians is a full circle
   * - `deg`: degree, 360 degrees is a full circle
   * - `grad`: gradians, 400 gradians is a full circle
   * - `turn`: turn, 1 turn is a full circle
   *
   * Default is `"rad"` (radians).
   */
  get angularUnit() {
    return this._angularUnit;
  }
  set angularUnit(u) {
    if (u === this._angularUnit) return;
    if (typeof u !== "string") throw Error("Expected a string");
    this._angularUnit = u;
    this._reset();
  }
  /** Throw a `CancellationError` when the duration of an evaluation exceeds
   * the time limit.
   *
   * Time in milliseconds, default 2000 ms = 2 seconds.
   *
   */
  get timeLimit() {
    return this._timeLimit;
  }
  set timeLimit(t) {
    if (t <= 0) t = Number.POSITIVE_INFINITY;
    this._timeLimit = t;
  }
  _timeLimit = 2e3;
  /** The time after which the time limit has been exceeded */
  _deadline = void 0;
  get _timeRemaining() {
    if (this.deadline === void 0) return Number.POSITIVE_INFINITY;
    return this.deadline - Date.now();
  }
  /** Throw `CancellationError` `iteration-limit-exceeded` when the iteration limit
   * in a loop is exceeded. Default: no limits.
   *
   * @experimental
   */
  get iterationLimit() {
    return this._iterationLimit;
  }
  set iterationLimit(t) {
    if (t <= 0) t = Number.POSITIVE_INFINITY;
    this._iterationLimit = t;
  }
  _iterationLimit = 1024;
  /** Signal `recursion-depth-exceeded` when the recursion depth for this
   * scope is exceeded.
   *
   * @experimental
   */
  get recursionLimit() {
    return this._recursionLimit;
  }
  set recursionLimit(t) {
    if (t <= 0) t = Number.POSITIVE_INFINITY;
    this._recursionLimit = t;
  }
  _recursionLimit = 1024;
  /**
   * Flag to prevent infinite recursion in the verify/ask/equality checking cycle.
   *
   * **The Problem:**
   * When verifying equality predicates, a recursion loop can occur:
   * 1. `verify(Equal(x, 0))` evaluates the expression
   * 2. `Equal.evaluate()` calls `eq(x, 0)` to check equality
   * 3. `eq()` calls `ask(['NotEqual', x, 0])` to check assumptions
   * 4. `ask()` calls `verify(NotEqual(x, 0))` as a fallback
   * 5. `verify()` evaluates, calling `eq()` again  infinite loop
   *
   * **The Solution:**
   * - Set `_isVerifying = true` when entering `verify()`
   * - `ask()` skips the `verify()` fallback when `_isVerifying` is true
   * - `Equal/NotEqual` evaluate handlers check this flag to preserve 3-valued
   *   logic in verification mode while still returning False/True in normal mode
   *
   * @see verify() in index.ts
   * @see ask() in index.ts
   * @see eq() in compare.ts
   * @see Equal/NotEqual operators in relational-operator.ts
   */
  _isVerifying = false;
  /**
   * @internal
   * Indicates whether we're currently inside a verify() call.
   * Used to prevent recursion and to enable 3-valued logic in verification mode.
   */
  get isVerifying() {
    return this._isVerifying;
  }
  get tolerance() {
    return this._tolerance;
  }
  /**
   * Values smaller than the tolerance are considered to be zero for the
   * purpose of comparison, i.e. if `|b - a| <= tolerance`, `b` is considered
   * equal to `a`.
   */
  set tolerance(val) {
    if (val === "auto") val = DEFAULT_TOLERANCE;
    if (!Number.isFinite(val) || val < 0)
      val = Math.pow(10, -this._precision + 2);
    this._tolerance = val;
    this._bignumTolerance = this.bignum(val);
    this._negBignumTolerance = this.bignum(-val);
  }
  chop(n) {
    if (typeof n === "number") {
      if (Math.abs(n) <= this._tolerance) return 0;
      return n;
    }
    if (n instanceof Decimal) {
      if (n.isPositive() && n.lte(this._bignumTolerance)) return 0;
      if (n.isNegative() && n.gte(this._negBignumTolerance)) return 0;
      if (n.isZero()) return 0;
      return n;
    }
    if (n instanceof Complex && Math.abs(n.re) <= this._tolerance && Math.abs(n.im) <= this._tolerance)
      return 0;
    return n;
  }
  /** Create an arbitrary precision number. 
     * 
     * The return value is an object with methods to perform arithmetic
     * operations:
     * - `toNumber()`: convert to a JavaScript `number` with potential loss of precision
     * - `add()`
     * - `sub()`
     * - `neg()` (unary minus)
     * - `mul()`
     * - `div()`
     * - `pow()`
     * - `sqrt()` (square root)
     * - `cbrt()` (cube root)
     * - `exp()`  (e^x)
     * - `log()` 
     * - `ln()` (natural logarithm)
     * - `mod()`
  
     * - `abs()`
     * - `ceil()`
     * - `floor()`
     * - `round()`
  
     * - `equals()`
     * - `gt()`
     * - `gte()`
     * - `lt()`
     * - `lte()`
     * 
     * - `cos()`
     * - `sin()`
     * - `tanh()`
     * - `acos()`
     * - `asin()`
     * - `atan()`
     * - `cosh()`
     * - `sinh()`
     * - `acosh()`
     * - `asinh()`
     * - `atanh()`
     * 
     * - `isFinite()`
     * - `isInteger()`
     * - `isNaN()`
     * - `isNegative()`
     * - `isPositive()`
     * - `isZero()`
     * - `sign()` (1, 0 or -1)
     * 
     */
  bignum(a) {
    if (typeof a === "bigint") return new this._bignum(a.toString());
    try {
      return new this._bignum(a);
    } catch (e) {
      console.error(e.message);
    }
    return this._BIGNUM_NAN;
  }
  /** Create a complex number.
     * The return value is an object with methods to perform arithmetic
     * operations:
     * - `re` (real part, as a JavaScript `number`)
     * - `im` (imaginary part, as a JavaScript `number`)
     * - `add()`
     * - `sub()`
     * - `neg()` (unary minus)
     * - `mul()`
     * - `div()`
     * - `pow()`
     * - `sqrt()` (square root)
     * - `exp()`  (e^x)
     * - `log()` 
     * - `ln()` (natural logarithm)
     * - `mod()`
  
     * - `abs()`
     * - `ceil()`
     * - `floor()`
     * - `round()`
  
     * - `arg()` the angle of the complex number
     * - `inverse()` the inverse of the complex number 1/z
     * - `conjugate()` the conjugate of the complex number
  
     * - `equals()`
     * 
     * - `cos()`
     * - `sin()`
     * - `tanh()`
     * - `acos()`
     * - `asin()`
     * - `atan()`
     * - `cosh()`
     * - `sinh()`
     * - `acosh()`
     * - `asinh()`
     * - `atanh()`
     * 
     * - `isFinite()`
     * - `isNaN()`
     * - `isZero()`
     * - `sign()` (1, 0 or -1)
     */
  complex(a, b) {
    if (a instanceof Decimal) a = a.toNumber();
    if (b instanceof Decimal) b = b.toNumber();
    return new Complex(a, b);
  }
  /**
   *
   * Create a Numeric Value.
   *
   * @internal
   */
  _numericValue(value) {
    if (value instanceof NumericValue) return value.asExact ?? value;
    const bignum = (x) => this.bignum(x);
    const makeNumericValue = this._precision > MACHINE_PRECISION ? (x) => new BigNumericValue(x, bignum) : (x) => new MachineNumericValue(x, bignum);
    if (typeof value === "number") {
      if (Number.isInteger(value))
        return new ExactNumericValue(value, makeNumericValue, bignum);
      return makeNumericValue(value);
    }
    if (typeof value === "bigint")
      return new ExactNumericValue(value, makeNumericValue, bignum);
    if (isRational(value))
      return new ExactNumericValue(
        { rational: value },
        makeNumericValue,
        bignum
      );
    if (value instanceof Decimal) {
      if (value.isInteger() && value.e <= MAX_BIGINT_DIGITS) {
        const n = bigint(value.toString());
        if (n !== null)
          return new ExactNumericValue(n, makeNumericValue, bignum);
      }
      return makeNumericValue(value);
    }
    if (value instanceof Complex) {
      if (value.im === 0) return this._numericValue(value.re);
      return makeNumericValue({ re: value.re, im: value.im });
    }
    if ("im" in value || "re" in value) {
      if (value.im !== void 0 && value.im !== 0)
        return makeNumericValue(value);
      if (value.re instanceof Decimal && value.re.isInteger())
        return new ExactNumericValue(
          {
            rational: [bigint(value.re.toString()), BigInt(1)]
            // radical: value.radical,
          },
          makeNumericValue,
          bignum
        );
      if (typeof value.re === "number" && Number.isInteger(value.re))
        return new ExactNumericValue(
          {
            rational: [value.re, 1]
            // radical: value.radical
          },
          makeNumericValue,
          bignum
        );
      return makeNumericValue(value);
    }
    if ("radical" in value || "rational" in value) {
      if (value.radical !== void 0 && (!Number.isInteger(value.radical) || value.radical >= SMALL_INTEGER)) {
        throw Error("Unexpected value for radical part:" + value.radical);
      }
      if (value.rational) {
        if (isMachineRational(value.rational)) {
          if (!Number.isInteger(value.rational[0]) || !Number.isInteger(value.rational[1]))
            return makeNumericValue(value);
        }
      }
      return new ExactNumericValue(value, makeNumericValue, bignum);
    }
    throw Error("Unexpected value");
  }
  /**
   * The cost function is used to determine the "cost" of an expression. For example, when simplifying an expression, the simplification that results in the lowest cost is chosen.
   */
  get costFunction() {
    return this._cost ?? DEFAULT_COST_FUNCTION;
  }
  set costFunction(fn) {
    if (typeof fn !== "function") this._cost = DEFAULT_COST_FUNCTION;
    this._cost = fn;
  }
  /**
   * Return definition matching the symbol, starting with the current
   * lexical scope and going up the scope chain.
   */
  lookupDefinition(id) {
    return lookup(id, this.context.lexicalScope);
  }
  /**
   * Associate a new definition to a symbol in the current context.
   *
   * For internal use. Use `ce.declare()` instead.
   *
   * @internal
   */
  _declareSymbolValue(name, def, scope) {
    scope ??= this.context.lexicalScope;
    scope.bindings.set(name, {
      value: new _BoxedValueDefinition(this, name, {
        type: "unknown",
        inferred: true
      })
    });
    const boxedDef = scope.bindings.get(name);
    updateDef(this, name, boxedDef, def);
    if (scope === this.context.lexicalScope && isValueDef(boxedDef) && boxedDef.value.value && !boxedDef.value.isConstant) {
      this.context.values[name] = boxedDef.value.value;
    }
    this._generation += 1;
    return boxedDef;
  }
  /**
   * Associate a new OperatorDefinition to a function in the current context.
   *
   * For internal use. Use `ce.declare()` instead.
   *
   * @internal
   */
  _declareSymbolOperator(name, def, scope) {
    scope ??= this.context.lexicalScope;
    scope.bindings.set(name, {
      value: new _BoxedValueDefinition(this, name, { type: "function" })
    });
    const boxedDef = scope.bindings.get(name);
    updateDef(this, name, boxedDef, def);
    this._generation += 1;
    return boxedDef;
  }
  /**
   *
   * Create a new lexical scope and matching evaluation context and add it
   * to the evaluation context stack.
   *
   */
  pushScope(scope, name) {
    this._pushEvalContext(
      scope ?? {
        parent: this.context?.lexicalScope,
        bindings: /* @__PURE__ */ new Map()
      },
      name
    );
  }
  /**
   * Remove the most recent scope from the scope stack.
   */
  popScope() {
    this._popEvalContext();
  }
  /** @internal */
  _pushEvalContext(scope, name) {
    if (!name) {
      const l = this._evalContextStack.length;
      if (l === 0) name = "system";
      if (l === 1) name = "global";
      name ??= `anonymous_${l - 1}`;
    }
    const values = {};
    for (const [id, def] of scope.bindings.entries()) {
      if (isValueDef(def) && !def.value.isConstant)
        values[id] = def.value.value;
    }
    this._evalContextStack.push({
      lexicalScope: scope,
      name,
      assumptions: new ExpressionMap(this.context?.assumptions ?? []),
      values
    });
  }
  /** @internal */
  _popEvalContext() {
    this._evalContextStack.pop();
  }
  /** @internal */
  _inScope(scope, f) {
    if (!scope) return f();
    this._evalContextStack.push({
      lexicalScope: scope,
      name: "",
      assumptions: new ExpressionMap([]),
      values: {}
    });
    try {
      return f();
    } finally {
      this._evalContextStack.pop();
    }
  }
  /** @internal */
  _printStack(options) {
    if (options) {
      options = { ...options };
      options.maxDepth ??= 1;
      options.details ??= false;
    } else options = { details: false, maxDepth: -2 };
    if (options.maxDepth !== void 0 && options.maxDepth < 0)
      options.maxDepth = this._evalContextStack.length + options.maxDepth;
    options.maxDepth = Math.min(
      this._evalContextStack.length - 1,
      options.maxDepth
    );
    let depth = 0;
    while (depth <= options.maxDepth) {
      const context = this._evalContextStack[this._evalContextStack.length - 1 - depth];
      if (depth === 0) console.group(`${BOLD}${BLUE}${context.name}${RESET}`);
      else
        console.groupCollapsed(
          `${BOLD}${BLUE}${context.name}${RESET} ${GREY}(${depth})${RESET}`
        );
      const assumptions = [...context.assumptions.entries()].map(
        ([k, v]) => `${k}: ${v}`
      );
      if (assumptions.length > 0) {
        console.groupCollapsed(
          `${BOLD}${assumptions.length} assumptions${RESET}`
        );
        for (const a of assumptions) console.info(a);
        console.groupEnd();
      }
      const bindings = Object.entries(context.values);
      if (bindings.length + context.lexicalScope.bindings.size === 0) {
        console.groupEnd();
        depth += 1;
        continue;
      }
      for (const [k, b] of bindings) {
        if (context.lexicalScope.bindings.has(k)) {
          console.info(
            defToString(k, context.lexicalScope.bindings.get(k), b)
          );
        } else if (b === void 0) {
          console.info(`${CYAN}${k}${RESET}: ${GREY}undefined${RESET}`);
        } else {
          console.info(`${CYAN}${k}${RESET}: ${GREY}${b.toString()}${RESET}`);
        }
      }
      for (const [k, def] of context.lexicalScope.bindings)
        if (!(k in context.values)) console.info(defToString(k, def));
      console.groupEnd();
      depth += 1;
    }
  }
  /**
   * Use `ce.box(name)` instead
   * @internal */
  _getSymbolValue(id) {
    const l = this._evalContextStack.length - 1;
    if (l < 0) return void 0;
    for (let j = l; j >= 0; j--) {
      const frame = this._evalContextStack[j].values;
      if (id in frame) return frame[id];
    }
    return void 0;
  }
  /**
   * For internal use. Use `ce.assign(name, value)` instead.
   * @internal
   */
  _setSymbolValue(id, value) {
    const l = this._evalContextStack.length - 1;
    if (l < 0) throw new Error(`Unknown symbol "${id}"`);
    if (typeof value === "number") value = this.number(value);
    else if (typeof value === "boolean") value = value ? this.True : this.False;
    for (let j = l; j >= 0; j--) {
      const values = this._evalContextStack[j].values;
      if (id in values) {
        values[id] = value;
        this._generation += 1;
        return;
      }
    }
    const ctx = this.lookupContext(id);
    if (!ctx) throw new Error(`Unknown symbol "${id}"`);
    ctx.values[id] = value;
  }
  /**
   * Set a value directly in the current context's values map.
   * This is used for assumptions so that the value is scoped to the current
   * evaluation context and is automatically removed when the scope is popped.
   * @internal
   */
  _setCurrentContextValue(id, value) {
    const l = this._evalContextStack.length - 1;
    if (l < 0) throw new Error(`No evaluation context`);
    if (typeof value === "number") value = this.number(value);
    else if (typeof value === "boolean") value = value ? this.True : this.False;
    this._evalContextStack[l].values[id] = value;
    this._generation += 1;
  }
  declare(arg1, arg2, scope) {
    if (typeof arg1 !== "string") {
      for (const [id2, def2] of Object.entries(arg1)) this.declare(id2, def2);
      return this;
    }
    const id = arg1;
    if (id === "Nothing") return this;
    if (arg2 === void 0 || arg2 === null)
      throw Error(`Expected a definition or type for "${id}"`);
    if (typeof id !== "string" || id.length === 0 || !isValidSymbol(id)) {
      throw new Error(`Invalid symbol "${id}": ${validateSymbol(id)}`);
    }
    scope ??= this.context.lexicalScope;
    const bindings = scope.bindings;
    if (bindings.has(id))
      throw new Error(`The symbol "${id}" is already declared in this scope`);
    const def = arg2;
    if (isValidValueDef(def)) {
      this._declareSymbolValue(id, def, scope);
      return this;
    }
    if (isValidOperatorDef(def)) {
      this._declareSymbolOperator(id, def, scope);
      return this;
    }
    {
      const type2 = parseType(def, this._typeResolver);
      if (!isValidType(type2)) {
        throw Error(
          [
            `Invalid argument for "${id}"`,
            JSON.stringify(def, void 0, 4),
            `Use a type, a \`OperatorDefinition\` or a \`ValueDefinition\``
          ].join("\n|   ")
        );
      }
      this._declareSymbolValue(id, { type: type2 }, scope);
    }
    return this;
  }
  /**
   * Declare a sequence with a recurrence relation.
   *
   * @example
   * ```typescript
   * // Fibonacci sequence
   * ce.declareSequence('F', {
   *   base: { 0: 0, 1: 1 },
   *   recurrence: 'F_{n-1} + F_{n-2}',
   * });
   * ce.parse('F_{10}').evaluate();  //  55
   * ```
   */
  declareSequence(name, def) {
    if (!def.base || Object.keys(def.base).length === 0) {
      throw new Error(`Sequence "${name}" requires at least one base case`);
    }
    if (!def.recurrence) {
      throw new Error(`Sequence "${name}" requires a recurrence relation`);
    }
    this.declare(name, {
      subscriptEvaluate: () => void 0
    });
    const validation = validateSequenceDefinition(this, name, def);
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    const handler = createSequenceHandler(this, name, def);
    const boxedDef = this.lookupDefinition(name);
    if (boxedDef && isValueDef(boxedDef)) {
      boxedDef.value.subscriptEvaluate = handler;
    }
    return this;
  }
  /**
   * Get the status of a sequence definition.
   *
   * @example
   * ```typescript
   * ce.parse('F_0 := 0').evaluate();
   * ce.getSequenceStatus('F');
   * //  { status: 'pending', hasBase: true, hasRecurrence: false, baseIndices: [0] }
   * ```
   */
  getSequenceStatus(name) {
    return getSequenceStatus(this, name);
  }
  /**
   * Get information about a defined sequence.
   * Returns `undefined` if the symbol is not a sequence.
   */
  getSequence(name) {
    return getSequenceInfo(this, name);
  }
  /**
   * List all defined sequences.
   */
  listSequences() {
    return listSequences(this);
  }
  /**
   * Check if a symbol is a defined sequence.
   */
  isSequence(name) {
    return isSequence(this, name);
  }
  /**
   * Clear the memoization cache for a sequence.
   * If no name is provided, clears caches for all sequences.
   */
  clearSequenceCache(name) {
    clearSequenceCache(this, name);
  }
  /**
   * Get the memoization cache for a sequence.
   * Returns a Map of index  value, or `undefined` if not a sequence or memoization is disabled.
   *
   * For single-index sequences, keys are numbers.
   * For multi-index sequences, keys are comma-separated strings (e.g., '5,2').
   */
  getSequenceCache(name) {
    return getSequenceCache(this, name);
  }
  /**
   * Generate a list of sequence terms from start to end (inclusive).
   *
   * @param name - The sequence name
   * @param start - Starting index (inclusive)
   * @param end - Ending index (inclusive)
   * @param step - Step size (default: 1)
   * @returns Array of BoxedExpressions, or undefined if not a sequence
   *
   * @example
   * ```typescript
   * ce.declareSequence('F', { base: { 0: 0, 1: 1 }, recurrence: 'F_{n-1} + F_{n-2}' });
   * ce.getSequenceTerms('F', 0, 10);
   * //  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
   * ```
   */
  getSequenceTerms(name, start, end, step) {
    return generateSequenceTerms(this, name, start, end, step);
  }
  /**
   * Look up sequences in OEIS by their terms.
   *
   * @param terms - Array of sequence terms to search for
   * @param options - Optional configuration (timeout, maxResults)
   * @returns Promise resolving to array of matching sequences
   *
   * @example
   * ```typescript
   * const results = await ce.lookupOEIS([0, 1, 1, 2, 3, 5, 8, 13]);
   * //  [{ id: 'A000045', name: 'Fibonacci numbers', ... }]
   * ```
   */
  lookupOEIS(terms, options) {
    return lookupSequence(this, terms, options);
  }
  /**
   * Check if a defined sequence matches an OEIS sequence.
   *
   * @param name - Name of the defined sequence
   * @param count - Number of terms to check (default: 10)
   * @param options - Optional configuration
   * @returns Promise with match results including OEIS matches and generated terms
   *
   * @example
   * ```typescript
   * ce.declareSequence('F', { base: { 0: 0, 1: 1 }, recurrence: 'F_{n-1} + F_{n-2}' });
   * const result = await ce.checkSequenceOEIS('F', 10);
   * //  { matches: [{ id: 'A000045', name: 'Fibonacci numbers', ... }], terms: [0, 1, 1, ...] }
   * ```
   */
  checkSequenceOEIS(name, count, options) {
    return checkSequence(this, name, count, options);
  }
  /**
   * Return an evaluation context in which the symbol is defined.
   */
  lookupContext(id) {
    if (id.length === 0 || !isValidSymbol(id))
      throw Error(`Invalid symbol "${id}": ${validateSymbol(id)}}`);
    const l = this._evalContextStack.length - 1;
    if (l < 0) return void 0;
    for (let j = l; j >= 0; j--) {
      const context = this._evalContextStack[j];
      if (context.lexicalScope.bindings.has(id)) return context;
    }
    return void 0;
  }
  /**  Find the context in the stack frame, and set the stack frame to
   * it. This is used to evaluate expressions in the context of
   * a different scope.
   */
  _swapContext(context) {
    while (this._evalContextStack.length > 0 && this._evalContextStack[this._evalContextStack.length - 1] !== context)
      this._evalContextStack.pop();
    if (this._evalContextStack.length === 0) this._evalContextStack = [context];
  }
  assign(arg1, arg2) {
    if (typeof arg1 === "object") {
      console.assert(arg2 === void 0);
      for (const [id2, def2] of Object.entries(arg1)) this.assign(id2, def2);
      return this;
    }
    const id = arg1;
    if (id === "Nothing") return this;
    const def = this.lookupDefinition(id);
    if (isOperatorDef(def)) {
      const value2 = assignValueAsValue(this, arg2);
      if (value2) throw Error(`Cannot change the operator "${id}" to a value`);
      const fnDef2 = assignValueAsOperatorDef(this, arg2);
      if (!fnDef2) throw Error(`Cannot change the operator "${id}" to a value`);
      updateDef(this, id, def, fnDef2);
      return this;
    }
    const value = assignValueAsValue(this, arg2);
    if (value !== void 0) {
      if (!def) {
        this._declareSymbolValue(id, { value });
        return this;
      }
      if (def.value.isConstant)
        throw Error(`Cannot assign a value to the constant "${id}"`);
      if (def.value.inferredType)
        def.value.type = this.type(widen(def.value.type.type, value.type.type));
      this._setSymbolValue(id, value);
      return this;
    }
    const fnDef = assignValueAsOperatorDef(this, arg2);
    if (fnDef === void 0)
      throw Error(`Invalid definition for symbol "${id}"`);
    if (def) {
      console.assert(isValueDef(def));
      updateDef(this, id, def, fnDef);
      this._setSymbolValue(id, void 0);
    } else {
      this.declare(id, fnDef);
    }
    return this;
  }
  /**
   * Return false if the execution should stop.
   *
   * This can occur if:
   * - an error has been signaled
   * - the time limit or memory limit has been exceeded
   *
   * @internal
   */
  _shouldContinueExecution() {
    return this.deadline === void 0 || this.deadline >= Date.now();
  }
  /** @internal */
  _checkContinueExecution() {
    if (!this._shouldContinueExecution()) {
      throw new Error("timeout");
    }
  }
  // assert(
  //   condition: boolean,
  //   expr: BoxedExpression,
  //   msg: string,
  //   code?: SignalMessage
  // ) {
  //   if (!condition) this.signal(expr, msg, code);
  // }
  /** @internal */
  _cache(cacheName, build, purge) {
    if (this.__cache[cacheName] === void 0) {
      try {
        this.__cache[cacheName] = { build, purge, value: build() };
      } catch (e) {
        console.error(
          `Fatal error building cache "${cacheName}":
	 ${e.toString()}`
        );
      }
    }
    return this.__cache[cacheName]?.value;
  }
  /** Return a boxed expression from a number, string or semiboxed expression.
   * Calls `ce.function()`, `ce.number()` or `ce.symbol()` as appropriate.
   */
  box(expr, options) {
    return box(this, expr, options);
  }
  function(name, ops, options) {
    return boxFunction(this, name, ops, options);
  }
  /**
   *
   * Shortcut for `this.box(["Error",...])`.
   *
   * The result is canonical.
   */
  error(message, where) {
    let msg;
    if (typeof message === "string") msg = this.string(message);
    else
      msg = this.function(
        "ErrorCode",
        message.map((x) => this.string(x))
      );
    let whereExpr = void 0;
    if (where && isLatexString(where)) {
      whereExpr = this.function("LatexString", [
        this.string(asLatexString(where))
      ]);
    } else if (typeof where === "string" && where.length > 0) {
      whereExpr = this.string(where);
    }
    const ops = [this.box(msg)];
    if (whereExpr) ops.push(whereExpr);
    return this.function("Error", ops);
  }
  typeError(expected, actual, where) {
    if (actual)
      return this.error(
        ["incompatible-type", typeToString(expected), actual.toString()],
        where
      );
    return this.error(["incompatible-type", typeToString(expected)], where);
  }
  /**
   * Add a `["Hold"]` wrapper to `expr`.
   */
  hold(expr) {
    return this._fn("Hold", [this.box(expr, { canonical: false })]);
  }
  tuple(...elements) {
    return new BoxedFunction(
      this,
      "Tuple",
      elements.map(
        (x) => typeof x === "number" ? this.number(x) : x.canonical
      ),
      { canonical: true }
    );
  }
  type(type2) {
    if (type2 instanceof BoxedType) return type2;
    return new BoxedType(type2, this._typeResolver);
  }
  string(s, metadata) {
    return new BoxedString(this, s, metadata);
  }
  /** Create a boxed symbol */
  symbol(name, options) {
    const canonical2 = options?.canonical ?? true;
    const metadata = options?.metadata;
    name = name.normalize();
    const lcName = name.toLowerCase();
    if (lcName === "infinity" || lcName === "+infinity")
      return this.PositiveInfinity;
    if (lcName === "-infinity") return this.NegativeInfinity;
    if (this.strict && !isValidSymbol(name))
      return this.error(["invalid-symbol", validateSymbol(name)], name);
    if (!canonical2) return new BoxedSymbol(this, name, { metadata });
    const result = this._commonSymbols[name];
    if (result) return result;
    let def = this.lookupDefinition(name);
    if (isValueDef(def) && def.value.holdUntil === "never")
      return def.value.value ?? this.Nothing;
    if (def) return new BoxedSymbol(this, name, { metadata, def });
    def = this._declareSymbolValue(name, { type: "unknown", inferred: true });
    return new BoxedSymbol(this, name, { metadata, def });
  }
  /**
   * This function tries to avoid creating a boxed number if `num` corresponds
   * to a common value for which we have a shared instance (-1, 0, NaN, etc...)
   */
  number(value, options) {
    const metadata = options?.metadata;
    let canonical2 = false;
    if (!options || options.canonical === void 0) canonical2 = true;
    else if (options.canonical === "Number" || options.canonical === true)
      canonical2 = true;
    else if (Array.isArray(options.canonical) && options.canonical.includes("Number"))
      canonical2 = true;
    if (!canonical2 && isRational(value)) {
      return this._fn(
        "Rational",
        [this.number(value[0]), this.number(value[1])],
        { ...metadata, canonical: false }
      );
    }
    value = canonicalNumber(this, value);
    if (metadata === void 0) {
      if (typeof value === "number") {
        const n = value;
        if (n === 1) return this.One;
        if (n === 0) return this.Zero;
        if (n === -1) return this.NegativeOne;
        if (n === 2) return this.Two;
        if (Number.isInteger(n) && this._commonNumbers[n] !== void 0) {
          this._commonNumbers[n] ??= new BoxedNumber(this, value);
          return this._commonNumbers[n];
        }
        if (Number.isNaN(n)) return this.NaN;
        if (!Number.isFinite(n))
          return n < 0 ? this.NegativeInfinity : this.PositiveInfinity;
      } else if (value instanceof NumericValue) {
        if (value.isZero) return this.Zero;
        if (value.isOne) return this.One;
        if (value.isNegativeOne) return this.NegativeOne;
        if (value.isNaN) return this.NaN;
        if (value.isNegativeInfinity) return this.NegativeInfinity;
        if (value.isPositiveInfinity) return this.PositiveInfinity;
      }
    }
    return new BoxedNumber(this, value, { metadata });
  }
  rules(rules, options) {
    return boxRules(this, rules, options);
  }
  /**
   * Return a set of built-in rules.
   */
  getRuleSet(id) {
    id ??= "standard-simplification";
    if (id === "standard-simplification")
      return this._cache(
        "standard-simplification-rules",
        () => boxRules(this, SIMPLIFY_RULES, { canonical: true })
      );
    if (id === "solve-univariate")
      return this._cache(
        "univariate-roots-rules",
        () => boxRules(this, UNIVARIATE_ROOTS)
      );
    if (id === "harmonization")
      return this._cache(
        "harmonization-rules",
        () => boxRules(this, HARMONIZATION_RULES)
      );
    return void 0;
  }
  /**
   * Return a function expression, but the caller is responsible for making
   * sure that the arguments are canonical.
   *
   * Unlike `ce.function()`, the operator of the result is the name argument.
   * Calling this function directly is potentially unsafe, as it bypasses
   * the canonicalization of the arguments.
   *
   * For example:
   *
   * - `ce._fn('Multiply', [1, 'x'])` returns `['Multiply', 1, 'x']` as a
   *   canonical expression, even though it doesn't follow the canonical form
   * - `ce.function('Multiply', [1, 'x']` returns `'x'` which is the correct
   *    canonical form
   *
   * @internal */
  _fn(name, ops, options) {
    const canonical2 = options?.canonical ?? true;
    return new BoxedFunction(this, name, ops, { ...options, canonical: canonical2 });
  }
  parse(latex, options) {
    if (latex === null || latex === void 0) return null;
    if (typeof latex !== "string")
      throw Error("ce.parse(): expected a LaTeX string");
    const defaultOptions = {
      imaginaryUnit: "\\imaginaryI",
      positiveInfinity: "\\infty",
      negativeInfinity: "-\\infty",
      notANumber: "\\operatorname{NaN}",
      decimalSeparator: this.decimalSeparator,
      digitGroup: 3,
      digitGroupSeparator: "\\,",
      // for thousands, etc...
      exponentProduct: "\\cdot",
      beginExponentMarker: "10^{",
      // could be 'e'
      endExponentMarker: "}",
      truncationMarker: "\\ldots",
      repeatingDecimal: "auto",
      // auto will accept any notation
      strict: true,
      skipSpace: true,
      parseNumbers: "auto",
      getSymbolType: (id) => {
        const def = this.lookupDefinition(id);
        if (!def) return BoxedType.unknown;
        if (isOperatorDef(def)) return def.operator.signature;
        if (isValueDef(def)) return def.value.type;
        return BoxedType.unknown;
      },
      hasSubscriptEvaluate: (id) => {
        const def = this.lookupDefinition(id);
        if (isValueDef(def) && def.value.subscriptEvaluate) return true;
        return false;
      },
      parseUnexpectedToken: (_lhs, _parser) => null,
      preserveLatex: false,
      quantifierScope: "tight",
      timeDerivativeVariable: "t"
    };
    const result = parse2(
      asLatexString(latex) ?? latex,
      this._indexedLatexDictionary,
      { ...defaultOptions, ...options }
    );
    if (result === null) throw Error("Failed to parse LaTeX string");
    return this.box(result, { canonical: options?.canonical ?? true });
  }
  /**
   * Return a list of all the assumptions that match a pattern.
   *
   * ```js
   *  ce.assume(['Element', 'x', 'PositiveIntegers');
   *  ce.ask(['Greater', 'x', '_val'])
   *  //  -> [{'val': 0}]
   * ```
   */
  ask(pattern) {
    const pat = this.box(pattern, { canonical: false });
    const result = [];
    const patternHasWildcards = (expr) => {
      if (expr.operator?.startsWith("_")) return true;
      if (isWildcard(expr)) return true;
      if (expr.ops) return expr.ops.some(patternHasWildcards);
      return false;
    };
    const pushResult = (m) => {
      const keys = Object.keys(m).sort();
      for (const prev of result) {
        const prevKeys = Object.keys(prev).sort();
        if (prevKeys.length !== keys.length) continue;
        let same2 = true;
        for (let i = 0; i < keys.length; i++) {
          if (prevKeys[i] !== keys[i]) {
            same2 = false;
            break;
          }
          const k = keys[i];
          if (!m[k].isSame(prev[k])) {
            same2 = false;
            break;
          }
        }
        if (same2) return;
      }
      result.push(m);
    };
    const assumptions = this.context.assumptions;
    const candidatesFromAssumptions = () => {
      const candidates = /* @__PURE__ */ new Set();
      for (const [assumption, val] of assumptions) {
        if (val !== true) continue;
        for (const s of assumption.symbols) candidates.add(s);
      }
      return [...candidates];
    };
    const normalizedInequalityPatterns = (expr) => {
      const op = expr.operator;
      if (op !== "Less" && op !== "LessEqual" && op !== "Greater" && op !== "GreaterEqual")
        return [{ pattern: expr }];
      const lhs = op === "Greater" || op === "GreaterEqual" ? expr.op2 : expr.op1;
      const rhs = op === "Greater" || op === "GreaterEqual" ? expr.op1 : expr.op2;
      const normalizedOp = op === "Less" || op === "Greater" ? "Less" : "LessEqual";
      const diff = this.box(["Add", lhs, ["Negate", rhs]], {
        canonical: false
      });
      return [
        { pattern: expr },
        // For the normalized form, disable permutations: for commutative
        // subexpressions (notably Add), allowing permutations can lead to
        // ambiguous wildcard bindings and duplicate, surprising matches.
        {
          pattern: this.box([normalizedOp, diff, 0], { canonical: false }),
          matchPermutations: false
        }
      ];
    };
    if (pat.operator === "Element" && pat.op1?.symbol && isWildcard(pat.op2)) {
      const typeWildcard = wildcardName(pat.op2);
      if (typeWildcard && !typeWildcard.startsWith("__")) {
        const symbolType = this.box(pat.op1.symbol).type;
        if (!symbolType.isUnknown) {
          pushResult({
            [typeWildcard]: this.box(symbolType.toString(), {
              canonical: false
            })
          });
        }
      }
    }
    if ((pat.operator === "Greater" || pat.operator === "GreaterEqual" || pat.operator === "Less" || pat.operator === "LessEqual") && isWildcard(pat.op2)) {
      const boundWildcard = wildcardName(pat.op2);
      if (boundWildcard && !boundWildcard.startsWith("__")) {
        const isLower = pat.operator === "Greater" || pat.operator === "GreaterEqual";
        const isStrict = pat.operator === "Greater" || pat.operator === "Less";
        if (pat.op1?.symbol) {
          const bounds = getInequalityBoundsFromAssumptions(
            this,
            pat.op1.symbol
          );
          const bound = isLower ? bounds.lowerBound : bounds.upperBound;
          const strictOk = isLower ? bounds.lowerStrict : bounds.upperStrict;
          if (bound !== void 0 && (!isStrict || strictOk === true))
            pushResult({ [boundWildcard]: bound });
        }
        if (isWildcard(pat.op1)) {
          const symbolWildcard = wildcardName(pat.op1);
          if (symbolWildcard && !symbolWildcard.startsWith("__")) {
            for (const s of candidatesFromAssumptions()) {
              const bounds = getInequalityBoundsFromAssumptions(this, s);
              const bound = isLower ? bounds.lowerBound : bounds.upperBound;
              const strictOk = isLower ? bounds.lowerStrict : bounds.upperStrict;
              if (bound === void 0 || isStrict && strictOk !== true)
                continue;
              pushResult({
                [symbolWildcard]: this.box(s, { canonical: true }),
                [boundWildcard]: bound
              });
            }
          }
        }
      }
    }
    const patternsToTry = normalizedInequalityPatterns(pat);
    for (const [assumption, val] of assumptions) {
      if (val !== true) continue;
      for (const { pattern: p, matchPermutations } of patternsToTry) {
        const m = assumption.match(p, {
          useVariations: true,
          matchPermutations
        });
        if (m !== null) pushResult(m);
      }
    }
    if (result.length === 0 && !patternHasWildcards(pat) && !this._isVerifying) {
      const verified = this.verify(this.box(pattern, { canonical: true }));
      if (verified === true) pushResult({});
    }
    return result;
  }
  /**
   * Answer a query based on the current assumptions.
   *
   */
  verify(query) {
    if (this._isVerifying) return void 0;
    this._isVerifying = true;
    try {
      const boxed = isLatexString(query) ? this.parse(query, { canonical: false }) : this.box(query, { canonical: false });
      const expr = boxed.evaluate();
      if (expr.symbol === "True") return true;
      if (expr.symbol === "False") return false;
      const op = expr.operator;
      if (op === "Not") {
        const result = this.verify(expr.op1);
        if (result === void 0) return void 0;
        return !result;
      }
      if (op === "And") {
        let hasUnknown = false;
        for (const x of expr.ops ?? []) {
          const r = this.verify(x);
          if (r === false) return false;
          if (r === void 0) hasUnknown = true;
        }
        return hasUnknown ? void 0 : true;
      }
      if (op === "Or") {
        let hasUnknown = false;
        for (const x of expr.ops ?? []) {
          const r = this.verify(x);
          if (r === true) return true;
          if (r === void 0) hasUnknown = true;
        }
        return hasUnknown ? void 0 : false;
      }
      return void 0;
    } finally {
      this._isVerifying = false;
    }
  }
  /**
   * Add an assumption.
   *
   * Note that the assumption is put into canonical form before being added.
   *
   * Returns:
   * - `contradiction` if the new assumption is incompatible with previous
   * ones.
   * - `tautology` if the new assumption is redundant with previous ones.
   * - `ok` if the assumption was successfully added to the assumption set.
   *
   *
   */
  assume(predicate2) {
    try {
      const pred = isLatexString(predicate2) ? this.parse(predicate2, { canonical: false }) : this.box(predicate2, { canonical: false });
      this._generation += 1;
      return assume(pred);
    } catch (e) {
      console.error(e.message.toString());
      throw e;
    }
  }
  /**
   * Remove all assumptions about one or more symbols.
   *
   * `ce.forget()` will remove all assumptions.
   *
   * Note that assumptions are scoped, so when exiting the current lexical
   * scope, the previous assumptions will be restored.
   *
   * */
  forget(symbol2) {
    if (symbol2 === void 0) {
      this.context.assumptions?.clear();
      this._generation += 1;
      return;
    }
    if (Array.isArray(symbol2)) {
      for (const x of symbol2) this.forget(x);
      return;
    }
    if (typeof symbol2 === "string") {
      for (const [assumption, _val] of this.context.assumptions) {
        if (assumption.has(symbol2)) this.context.assumptions.delete(assumption);
      }
      for (const ctx of this._evalContextStack) {
        if (symbol2 in ctx.values) {
          delete ctx.values[symbol2];
        }
      }
    }
    this._generation += 1;
  }
};
function assignValueAsValue(ce, value) {
  if (value === void 0 || value === null) return void 0;
  if (typeof value === "function") return void 0;
  if (typeof value === "boolean") return value ? ce.True : ce.False;
  if (typeof value === "number" || typeof value === "bigint")
    return ce.number(value);
  const expr = ce.box(value);
  if (expr.operator === "Function") return void 0;
  if (expr.unknowns.some((s) => s.startsWith("_"))) {
    return void 0;
  }
  return expr;
}
function assignValueAsOperatorDef(ce, value) {
  if (typeof value === "function")
    return { evaluate: value, signature: "function" };
  if (value === void 0 || value === null) return void 0;
  if (typeof value === "boolean") return void 0;
  const body = canonicalFunctionLiteral(ce.box(value));
  if (body === void 0) return void 0;
  return { evaluate: body };
}
function defToString(name, def, v) {
  let result = "";
  if (isValueDef(def)) {
    const tags = [];
    if (def.value.holdUntil === "never") tags.push("(hold never)");
    if (def.value.holdUntil === "N") tags.push("(hold until N)");
    if (def.value.inferredType) tags.push("inferred");
    const allTags = tags.length > 0 ? ` ${tags.join(" ")}` : "";
    result = `${CYAN}${name}${RESET}:${allTags}`;
    if (def.value.isConstant) {
      result += ` const ${def.value.type.toString()}`;
      if (def.value.value !== void 0)
        result += ` = ${def.value.value?.toString()}`;
      console.assert(v === void 0);
    } else result += ` ${def.value.type.toString()}`;
  } else if (isOperatorDef(def)) {
    const tags = [];
    if (def.operator.inferredSignature) tags.push("(inferred)");
    const allTags = tags.length > 0 ? ` (${tags.join(" ")})` : "";
    result = `${CYAN}${name}${RESET}:${allTags} ${def.operator.signature.toString()}`;
    const details = [];
    if (def.operator.lazy) details.push("lazy");
    if (def.operator.scoped) details.push("scoped");
    if (def.operator.broadcastable) details.push("broadcastable");
    if (def.operator.associative) details.push("associative");
    if (def.operator.commutative) details.push("commutative");
    if (def.operator.idempotent) details.push("idempotent");
    if (def.operator.involution) details.push("involution");
    if (!def.operator.pure) details.push("not pure");
    const allDetails = details.map((x) => `${GREY}${x}${RESET}`).join(" ");
    if (allDetails.length > 0) result += `
   \u2514 ${allDetails}`;
  } else result = "unknown";
  if (v) {
    if (!v.isValid) {
      result += ` = ${INVERSE_RED}${v.toString()}${RESET} (not valid)`;
    } else if (!v.isCanonical) {
      result += ` = ${YELLOW}${v.toString()}${RESET} (not canonical)`;
    } else {
      result += ` = ${GREY}${v.toString()}${RESET}`;
    }
  }
  return result;
}

// src/compute-engine.ts
init_types6();
init_base_compiler();
var version = "0.35.2";
globalThis[Symbol.for("io.cortexjs.compute-engine")] = {
  ComputeEngine: ComputeEngine.prototype.constructor,
  version: "0.35.2"
};
export {
  BaseCompiler,
  BoxedType,
  ComputeEngine,
  GLSLTarget,
  JavaScriptTarget,
  NumericValue,
  version
};
/*! Bundled license information:

complex-esm/dist/src/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
