/* 0.35.2 */import type { Type, NamedElement, TypeReference, TypeResolver, TypeString } from './types';
/**
 * BNF grammar for the type parser:
 *
<type> ::= <union_type>
         | <function_signature>

<union_type> ::= <intersection_type> ( " | " <intersection_type> )*

<intersection_type> ::= <primary_type_with_negation> ( " & " <primary_type_with_negation> )*

<primary_type_with_negation> ::= ( "!" )? <primary_type>

<primary_type> ::= <group>
                 | <list_type>
                 | <tuple_type>
                 | <record_type>
                 | <dictionary_type>
                 | <set_type>
                 | <collection_type>
                 | <expression_type>
                 | <symbol_type>
                 | <numeric_type>
                 | <primitive_type>
                 | <value>
                 | <type_reference>

<group> ::= "(" <type> ")"

(* --- Function Signatures --- *)

<function_signature> ::= <arguments> " -> " <type>

<arguments> ::= "()"
              | "(" <argument_list>? ")"

(* Note: The parser enforces a semantic rule: required arguments must come before optional and variadic arguments. *)
<argument_list> ::= <argument_specifier> ( "," <argument_specifier> )*

<argument_specifier> ::= <named_element> ( "?" | "*" | "+" )?

<named_element> ::= ( <name> ":" )? <type>

<name> ::= <identifier> | <verbatim_string>


(* --- Collection-like Types --- *)

<list_type> ::= "list" ( "<" <type> ( "^" <dimensions> )? ">" )?
              | "vector" ( "<" ( <type> ("^" <dimension_specifier>)? | <dimensions> ) ">" )?
              | "matrix" ( "<" ( <type> ("^" <dimensions>)? | <dimensions> ) ">" )?
              | "tensor" ( "<" <type> ">" )?

<dimensions> ::= <dimension_specifier> ( "x" <dimension_specifier> )*
               | "(" <dimension_specifier> ( "x" <dimension_specifier> )* ")"

<dimension_specifier> ::= <positive_integer_literal> | "?"

<tuple_type> ::= "tuple<" ( <named_element> ( "," <named_element> )* )? ">"

<record_type> ::= "record"
                | "record<" <record_element> ( "," <record_element> )* ">"

<record_element> ::= <key> ":" <type>

<key> ::= <identifier> | <verbatim_string>

<dictionary_type> ::= "dictionary"
                    | "dictionary<" <type> ">"

<set_type> ::= "set"
             | "set<" <type> ">"

<collection_type> ::= ( "collection" | "indexed_collection" ) ( "<" <type> ">" )?


(* --- Other Constructed Types --- *)

<expression_type> ::= "expression<" <identifier> ">"

<symbol_type> ::= "symbol<" <identifier> ">"

<numeric_type> ::= <numeric_primitive> "<" <bound> ".." <bound> ">"

<bound> ::= <number_literal> | "-oo" | "oo" | ""


(* --- Atomic and Primitive Types --- *)

<type_reference> ::= ( "type" )? <identifier>

<value> ::= <string_literal>
          | <number_literal>
          | "true" | "false"
          | "nan" | "infinity" | "+infinity" | "oo" | "∞" | "+oo" | "+∞"
          | "-infinity" | "-oo" | "-∞"

<primitive_type> ::= <numeric_primitive>
                   | "any" | "unknown" | "nothing" | "never" | "error"
                   | "expression" | "symbol" | "function" | "value"
                   | "scalar" | "boolean" | "string"
                   | "collection" | "indexed_collection" | "list" | "tuple"
                   | "set" | "record" | "dictionary"

<numeric_primitive> ::= "number" | "finite_number" | "complex" | "finite_complex"
                      | "imaginary" | "real" | "finite_real" | "rational"
                      | "finite_rational" | "integer" | "finite_integer"
                      | "non_finite_number"


(* --- Terminals (Lexical Tokens) --- *)

<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*

<verbatim_string> ::= "`" ( [^`] | "\`" | "\\" )* "`"

<positive_integer_literal> ::= [1-9][0-9]*

<number_literal> ::= (* As parsed by the valueParser, including integers, decimals, and scientific notation *)

<string_literal> ::= '"' ( [^"] | '\"' )* '"'
 *
 */
declare class TypeParser {
    buffer: string;
    pos: number;
    _valueParser: (parser: TypeParser) => any;
    _typeResolver: TypeResolver;
    constructor(buffer: string, options?: {
        valueParser?: (parser: TypeParser) => any;
        typeResolver?: TypeResolver;
    });
    error(...messages: (string | undefined)[]): never;
    peek(): string;
    consume(): string;
    /** Check if the upcoming tokens match s, return false if not, consume otherwise */
    match(s: string): boolean;
    /** If the next token don't match `>`, error */
    expectClosingBracket(): void;
    /** If a white space is allowed, call before `consume()` or `match()` */
    skipWhitespace(): void;
    isEOF(): boolean;
    parseValue(): Type | null;
    parseTypeReference(): TypeReference | null;
    parsePrimitiveType(): Type | null;
    /**
     * Arguments are `name: type` or `type` separated by commas.
     * Arguments can be optional, i.e. `name: type?` or `type?`.
     * Variadic arguments are `name: type+`, `type+`, `name: type*` or `type*`.
     */
    parseArguments(): [
        required: NamedElement[],
        optional: NamedElement[],
        variadic: NamedElement | undefined,
        variadicMin: 0 | 1 | undefined
    ];
    parseFunctionSignature(): Type | null;
    parsePositiveIntegerLiteral(): number | null;
    parseOptionalDimension(): number | null;
    parseDimensions(): number[] | undefined;
    parseList(): Type | null;
    /**
     * Parse the name of a named element, i.e. an identifier followed by a colon.
     * Does special error handling for optional qualifiers.
     * */
    parseName(): string | null;
    parseVerbatimString(): string | null;
    /**
     * A general purpose identifier, used for expresion<>, symbol<>, type references, record keys, etc.
     *
     * Not used for arguments (they have special error handling with `parseName()`).
     */
    parseIdentifier(): string | null;
    /** Parse:
     * - "<identifier>: <type>"
     * - "<type>"
     *
     * Does not parse variadic arguments, i.e. `type+` or `name: type+`.
     */
    parseNamedElement(): NamedElement | null;
    parseTupleElements(): NamedElement[];
    parseTuple(): Type | null;
    /** Parse a non-optional group, i.e. "(" <type> ")" */
    parseGroup(): Type | null;
    parseSet(): Type | null;
    parseRecordKeyValue(): [string, Type][];
    parseRecord(): Type | null;
    parseDictionary(): Type | null;
    parseCollection(): Type | null;
    parseExpression(): Type | null;
    parseSymbol(): Type | null;
    /** Parse a constructed numeric type with a range */
    parseNumericType(): Type | null;
    parseStringType(): Type | null;
    parsePrimary(): Type;
    parseUnexpectedToken(): string | undefined;
    parseMaybePrimary(): Type | null;
    parseNegationType(): Type | null;
    parseIntersectionType(): Type | null;
    parseUnionType(): Type | null;
    parseType(): Readonly<Type> | null;
    /** Parse a type, but return null if there's a problem instead
     * of throwing.
     */
    parseTypeMaybe(): Readonly<Type> | null;
    parse(): Readonly<Type>;
}
export declare function parseType(s: undefined, typeResolver?: TypeResolver): undefined;
export declare function parseType(s: TypeString | Type, typeResolver?: TypeResolver): Type;
export declare function parseType(s: TypeString | Type | undefined, typeResolver?: TypeResolver): Type | undefined;
export { TypeParser };
