/* 0.35.1 */import type { BoxedExpression, PatternMatchOptions, BoxedSubstitution, ComputeEngine, Metadata, DictionaryInterface, JsonSerializationOptions } from '../global-types';
import { _BoxedExpression } from './abstract-boxed-expression';
import { BoxedType } from '../../common/type/boxed-type';
import { DictionaryValue, Expression } from '../../math-json/types';
/**
 * BoxedDictionary
 *
 */
export declare class BoxedDictionary extends _BoxedExpression implements DictionaryInterface {
    [Symbol.toStringTag]: string;
    private readonly _keyValues;
    private _type;
    /** The input to the constructor is either a ["Dictionary", ["KeyValuePair", ..., ...], ...] expression or a record of key-value pairs */
    constructor(ce: ComputeEngine, keyValues: Record<string, DictionaryValue> | BoxedExpression, options?: {
        metadata?: Metadata;
        canonical?: boolean;
    });
    private _initFromRecord;
    private _initFromExpression;
    get json(): Expression;
    toMathJson(options: Readonly<JsonSerializationOptions>): Expression;
    get hash(): number;
    get operator(): string;
    get type(): BoxedType;
    get isPure(): boolean;
    get isCanonical(): boolean;
    set isCanonical(_va: boolean);
    get value(): BoxedExpression | undefined;
    get complexity(): number;
    get isCollection(): boolean;
    get isIndexedCollection(): boolean;
    get isLazyCollection(): boolean;
    contains(_rhs: BoxedExpression): boolean | undefined;
    get count(): number | undefined;
    get isEmptyCollection(): boolean;
    get isFiniteCollection(): boolean;
    each(): Generator<BoxedExpression>;
    get(key: string): BoxedExpression | undefined;
    has(key: string): boolean;
    get keys(): string[];
    get entries(): [string, BoxedExpression][];
    get values(): BoxedExpression[];
    match(pattern: BoxedExpression, _options?: PatternMatchOptions): BoxedSubstitution | null;
}
