/* 0.30.2 */import type { Expression } from '../../math-json/types';
import type { SimplifyOptions, ReplaceOptions, PatternMatchOptions, BoxedExpression, BoxedBaseDefinition, BoxedOperatorDefinition, BoxedRuleSet, BoxedSubstitution, CanonicalOptions, EvaluateOptions, ComputeEngine, Metadata, Rule, Sign, Substitution, Scope, BoxedValueDefinition } from '../global-types';
import { Type } from '../../common/type/types';
import { BoxedType } from '../../common/type/boxed-type';
import { NumericValue } from '../numeric-value/types';
import { _BoxedExpression } from './abstract-boxed-expression';
/**
 * A boxed function expression represent an expression composed of an operator
 * (the name of the function) and a list of arguments. For example:
 * `["Add", 1, 2]` is a function expression with the operator "Add" and two
 * arguments 1 and 2.
 *
 * If canonical, it has a definition associated with it, based on the operator.
 *
 * The definition contains its signature and its evaluation handler.
 *
 */
export declare class BoxedFunction extends _BoxedExpression {
    private readonly _operator;
    private readonly _ops;
    private _def;
    /** @todo: wrong. If the function is scoped (has its own lexical scope), the captured eval context. This includes the lexical scope for this expression
     */
    private _capturedContext;
    /** If the operator is scoped, the local scope associated with
     * the function expression
     */
    private _localScope;
    private _isPure;
    private _isStructural;
    private _hash;
    private _value;
    private _valueN;
    private _sgn;
    private _type;
    constructor(ce: ComputeEngine, operator: string, ops: ReadonlyArray<BoxedExpression>, options?: {
        metadata?: Metadata;
        canonical?: boolean;
        structural?: boolean;
        scope?: Scope;
    });
    get hash(): number;
    /**
     * For function expressions, `infer()` infers the result type of the function
     * based on the provided type and inference mode.
     */
    infer(t: Type, inferenceMode?: 'narrow' | 'widen'): boolean;
    bind(): void;
    reset(): void;
    get value(): BoxedExpression | undefined;
    get isCanonical(): boolean;
    get isPure(): boolean;
    get isConstant(): boolean;
    get constantValue(): number | boolean | string | object | undefined;
    get json(): Expression;
    get operator(): string;
    get ops(): ReadonlyArray<BoxedExpression>;
    get nops(): number;
    get op1(): BoxedExpression;
    get op2(): BoxedExpression;
    get op3(): BoxedExpression;
    get isScoped(): boolean;
    get localScope(): Scope | undefined;
    get isValid(): boolean;
    /** Note: if the expression is not canonical, this will return a canonical
     * version of the expression in the current lexical scope.
     */
    get canonical(): BoxedExpression;
    get structural(): BoxedExpression;
    get isStructural(): boolean;
    toNumericValue(): [NumericValue, BoxedExpression];
    /**
     * Note: the result is bound to the current scope, not the scope of the
     * original expression.
     * <!-- This may or may not be desirable -->
     */
    subs(sub: Substitution, options?: {
        canonical?: CanonicalOptions;
    }): BoxedExpression;
    replace(rules: BoxedRuleSet | Rule | Rule[], options?: Partial<ReplaceOptions>): BoxedExpression | null;
    match(pattern: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
    has(v: string | string[]): boolean;
    get sgn(): Sign | undefined;
    get isNaN(): boolean | undefined;
    get isInfinity(): boolean | undefined;
    get isFinite(): boolean | undefined;
    get isOne(): boolean | undefined;
    get isNegativeOne(): boolean | undefined;
    get isPositive(): boolean | undefined;
    get isNonNegative(): boolean | undefined;
    get isNegative(): boolean | undefined;
    get isNonPositive(): boolean | undefined;
    get numerator(): BoxedExpression;
    get denominator(): BoxedExpression;
    get numeratorDenominator(): [BoxedExpression, BoxedExpression];
    neg(): BoxedExpression;
    inv(): BoxedExpression;
    abs(): BoxedExpression;
    add(rhs: number | BoxedExpression): BoxedExpression;
    mul(rhs: NumericValue | number | BoxedExpression): BoxedExpression;
    div(rhs: number | BoxedExpression): BoxedExpression;
    pow(exp: number | BoxedExpression): BoxedExpression;
    root(exp: number | BoxedExpression): BoxedExpression;
    sqrt(): BoxedExpression;
    ln(semiBase?: number | BoxedExpression): BoxedExpression;
    get complexity(): number | undefined;
    get baseDefinition(): BoxedBaseDefinition | undefined;
    get operatorDefinition(): BoxedOperatorDefinition | undefined;
    get valueDefinition(): BoxedValueDefinition | undefined;
    get isNumber(): boolean | undefined;
    get isInteger(): boolean | undefined;
    get isRational(): boolean | undefined;
    get isReal(): boolean | undefined;
    get isFunctionExpression(): boolean;
    /** The type of the value of the function */
    get type(): BoxedType;
    simplify(options?: Partial<SimplifyOptions>): BoxedExpression;
    evaluate(options?: Partial<EvaluateOptions>): BoxedExpression;
    evaluateAsync(options?: Partial<EvaluateOptions>): Promise<BoxedExpression>;
    N(): BoxedExpression;
    solve(vars?: Iterable<string> | string | BoxedExpression | Iterable<BoxedExpression>): null | ReadonlyArray<BoxedExpression>;
    get isCollection(): boolean;
    get isIndexedCollection(): boolean;
    get isLazyCollection(): boolean;
    xcontains(rhs: BoxedExpression): boolean | undefined;
    get xsize(): number | undefined;
    get isEmptyCollection(): boolean | undefined;
    get isFiniteCollection(): boolean | undefined;
    each(): Generator<BoxedExpression>;
    at(index: number): BoxedExpression | undefined;
    get(index: BoxedExpression | string): BoxedExpression | undefined;
    indexWhere(predicate: (element: BoxedExpression) => boolean): number | undefined;
    subsetOf(rhs: BoxedExpression, strict: boolean): boolean;
    _computeValue(options?: Partial<EvaluateOptions>): () => BoxedExpression;
    _computeValueAsync(options?: Partial<EvaluateOptions>): () => Promise<BoxedExpression>;
}
