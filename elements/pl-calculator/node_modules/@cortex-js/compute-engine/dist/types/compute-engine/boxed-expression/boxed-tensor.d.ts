/* 0.30.2 */import type { Expression } from '../../math-json/types';
import type { ComputeEngine, TensorDataType, Metadata, BoxedBaseDefinition, BoxedOperatorDefinition, BoxedSubstitution, EvaluateOptions, BoxedExpression, SimplifyOptions, PatternMatchOptions, Tensor } from '../global-types';
import { BoxedType } from '../../common/type/boxed-type';
import { NumericValue } from '../numeric-value/types';
import { _BoxedExpression } from './abstract-boxed-expression';
/**
 * A boxed tensor represents an expression that can be represented by a tensor.
 * This could be a vector, matrix or multi-dimensional array.
 *
 * The object can be created either from a tensor or from an expression that
 * can be represented as a tensor.
 *
 * The structural counterpart (expression if input is tensor, or tensor
 * if input is expression) is created lazily.
 *
 */
export declare class BoxedTensor<T extends TensorDataType> extends _BoxedExpression {
    readonly input: {
        ops: ReadonlyArray<BoxedExpression>;
        shape: number[];
        dtype: T;
    };
    readonly options?: {
        metadata?: Metadata;
    };
    private _tensor;
    private _expression?;
    constructor(ce: ComputeEngine, input: {
        ops: ReadonlyArray<BoxedExpression>;
        shape: number[];
        dtype: T;
    }, options?: {
        metadata?: Metadata;
    });
    get structural(): BoxedExpression;
    /** Create the tensor on demand */
    get tensor(): Tensor<T>;
    get baseDefinition(): BoxedBaseDefinition | undefined;
    get operatorDefinition(): BoxedOperatorDefinition | undefined;
    get hash(): number;
    get canonical(): BoxedExpression;
    get isCanonical(): boolean;
    get isPure(): boolean;
    get isValid(): boolean;
    get complexity(): number;
    get operator(): string;
    get nops(): number;
    get ops(): ReadonlyArray<BoxedExpression>;
    get op1(): BoxedExpression;
    get op2(): BoxedExpression;
    get op3(): BoxedExpression;
    neg(): BoxedExpression;
    inv(): BoxedExpression;
    abs(): BoxedExpression;
    add(rhs: number | BoxedExpression): BoxedExpression;
    sub(rhs: BoxedExpression): BoxedExpression;
    mul(rhs: NumericValue | number | BoxedExpression): BoxedExpression;
    div(rhs: number | BoxedExpression): BoxedExpression;
    pow(exp: number | BoxedExpression): BoxedExpression;
    root(exp: number | BoxedExpression): BoxedExpression;
    sqrt(): BoxedExpression;
    get shape(): number[];
    get rank(): number;
    get type(): BoxedType;
    get json(): Expression;
    /** Mathematical equality */
    isEqual(rhs: number | BoxedExpression): boolean | undefined;
    get isCollection(): boolean;
    get isIndexedCollection(): boolean;
    xcontains(other: BoxedExpression): boolean | undefined;
    get xsize(): number;
    each(): Generator<BoxedExpression>;
    at(index: number): BoxedExpression | undefined;
    match(pattern: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
    evaluate(options?: Partial<EvaluateOptions>): BoxedExpression;
    simplify(options?: Partial<SimplifyOptions>): BoxedExpression;
    N(): BoxedExpression;
}
export declare function isBoxedTensor(val: unknown): val is BoxedTensor<any>;
export declare function expressionTensorInfo(operator: string, rows: ReadonlyArray<BoxedExpression>): {
    shape: number[];
    dtype: TensorDataType;
} | undefined;
