/* 0.35.1 */import type { BoxedSubstitution, PatternMatchOptions, BoxedExpression } from '../global-types';
/**
 * The function attempts to match a subject expression to a
 * [pattern](/compute-engine/guides/patterns-and-rules/).
 *
 * If the match is successful, it returns a `Substitution` indicating how to
 * transform the pattern to become the subject.
 *
 * If the expression does not match the pattern, it returns `null`.
 *
 * ## Canonicalization-Aware Matching
 *
 * The matching handles expressions that have been canonicalized to different
 * but mathematically equivalent forms:
 *
 * - **Rational/Divide**: A `Rational` pattern is treated as equivalent to
 *   `Divide`. Expressions like `['Rational', 'x', 2]` which are canonicalized
 *   to `['Multiply', ['Rational', 1, 2], 'x']` (i.e., `x * 1/2`) will still
 *   match a `['Divide', '_num', '_den']` or `['Rational', '_num', '_den']`
 *   pattern, returning `{_num: x, _den: 2}`.
 *
 * - **BoxedNumber rationals**: Numeric rationals like `['Rational', 3, 2]`
 *   which become `BoxedNumber` values will match `Divide` or `Rational`
 *   patterns by extracting the numerator and denominator.
 *
 * - **Power/Divide**: Expressions like `['Power', 'x', -1]` which are
 *   canonicalized to `['Divide', 1, 'x']` will match a `Power` pattern,
 *   returning `{_base: x, _exp: -1}`.
 *
 * - **Power/Root**: Expressions like `['Root', 'x', 3]` (cube root) will
 *   match a `Power` pattern, returning `{_base: x, _exp: ['Divide', 1, 3]}`.
 *
 * <!--
 * @consider?
 * - pattern 'validation' (not quite the right term in this context) here? In a similar way to the
 * check/condition supplied in 'matchPermutation()'? (i.e. inspect for redundant sequences of
 * wildcard combinations).
 * -->
 *
 */
export declare function match(subject: BoxedExpression, pattern: BoxedExpression, options?: PatternMatchOptions): BoxedSubstitution | null;
