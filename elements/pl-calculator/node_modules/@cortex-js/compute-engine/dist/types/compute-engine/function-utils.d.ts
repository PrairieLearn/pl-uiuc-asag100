/* 0.30.2 */import { MathJsonSymbol } from '../math-json';
import type { BoxedDefinition, BoxedExpression, ComputeEngine, Scope } from './global-types';
/***
 * ### THEORY OF OPERATIONS
 *
 * The body of a `["Function"]` expression is a `["Block"]` expression,
 * which is scoped. The function arguments are declared in that scope as well.
 *
 * Some expressions with anonymous parameters (e.g. `["Add", "_", 1]`)
 * are rewritten to a `["Function"]` expression with anonymous parameters
 * (e.g. `["Function", ["Block", ["Add", "_", 1]], "_"]`).
 *
 *
 * #### DURING BOXING (in makeLambda())
 *
 * During the boxing/canonicalization phase of a function
 * (`["Function"]` expression or operator of expression):
 *
 * 1/ If not a `["Function"]` expression, the expression is rewritten
 *    to a `["Function"]` expression with anonymous parameters
 * 2/ A new scope is created
 * 3/ The function parameters are declared in the scope
 * 4/ The function body is boxed in the context of the scope and the scope
 *    is associated with the function
 *
 *
 * #### DURING EVALUATION (executing the result of makeLambda())
 *
 * 1/ The arguments are evaluated in the current scope
 * 2/ The context is swapped to the function scope
 * 3/ The function parameters are set to the value of the arguments
 * 4/ The function body is evaluated in the context of the function scope
 * 5/ The context is swapped back to the current scope
 * 6/ The result of the function body is returned
 *
 */
/**
 * From an expression, return a predicate function, which can be used to filter.
 */
export declare function predicate(_expr: BoxedExpression): (...args: BoxedExpression[]) => boolean;
/**
 * From an expression, create an ordering function, which can be used to sort.
 */
export declare function order(_expr: BoxedExpression): (a: BoxedExpression, b: BoxedExpression) => -1 | 0 | 1;
/**
 * Given an expression, rewrite it to a symbol or canonical Function form.
 *
 * - symbol (no change):
 *      "Sin"
 *     -> "Sin"
 *
 * - built-in function:
 *      ["BuiltinFunction", "Sin"]
 *     -> "Sin"
 *
 * - parenthesized expression:
 *      ["Delimiter", ["Add", "_", 1], "'()'"]
 *     -> ["Function", ["Block", ["Add", "_", 1]], "_"]
 *
 * - explicit parameters (adding a block to serve as a scope for the arguments):
 *      ["Function", ["Add", "x", 1], "x"]
 *      -> ["Function", ["Block", ["Add", "x", 1]], "x"]
 *
 *
 * - single anonymous parameters:
 *      ["Add", "_", 1]
 *      -> ["Function", ["Block", ["Add", "_", 1]], "_"]
 *
 * - multiple anonymous parameters:
 *      ["Add", "_1", "_2"]
 *      -> ["Function", ["Block", ["Add", "_1", "_2"]], "_1", "_2"]
 *
 *
 */
export declare function canonicalFunctionLiteral(expr: BoxedExpression | undefined): BoxedExpression | undefined;
/** Assuming that ops has the following form:
 * - body
 * - ...params
 * return a canonical function literal (["Function", body, ...params]) where
 * body is potentially wrapped in a Block expression and the arguments are
 * declared in the scope of the body.
 */
export declare function canonicalFunctionLiteralArguments(ce: ComputeEngine, ops: ReadonlyArray<BoxedExpression>): BoxedExpression | undefined;
/**
 * Apply arguments to an expression which is either:
 * - a `["Function"]` expression
 * - the symbol for a function, e.g. `Sin`.
 */
export declare function apply(fn: BoxedExpression, args: ReadonlyArray<BoxedExpression>): BoxedExpression;
/**
 * Return a lambda function, assuming a scoped environment has been
 * created and there is a single numeric argument
 */
export declare function makeLambdaN1(expr: BoxedExpression): ((arg: number) => number) | undefined;
/**
 * Given an expression such as:
 * - ["Function", ["Add", 1, "x"], "x"]
 * - ["Function", ["Divide", "_", 2]]
 * - ["Multiply, "_", 3]
 * - ["Add, "_1", "_2"]
 * - "Sin"
 *
 * return a JS function that can be called with arguments.
 */
export declare function applicable(fn: BoxedExpression): (xs: ReadonlyArray<BoxedExpression>) => BoxedExpression | undefined;
/**
 * Use `applicableN1()` when the function is known to be a function with a
 * single real argument that returns a real value.
 *
 * Unlike `apply()`, `applicableN1()` returns a function that can be called
 * with an argument.
 *
 */
export declare function applicableN1(fn: BoxedExpression): (x: number) => number;
/**
 * Given a string like "f(x,y)" return, ["f", ["x", "y"]]
 */
export declare function parseFunctionSignature(s: string): [id: string, args: string[] | undefined];
/** Lookup a definition matching a symbol in a lexical scope chain */
export declare function lookup(id: MathJsonSymbol, scope: Scope): undefined | BoxedDefinition;
