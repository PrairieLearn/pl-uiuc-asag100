/* 0.30.2 */import { Complex } from 'complex-esm';
import { Decimal } from 'decimal.js';
import { Type, TypeResolver, TypeString } from '../common/type/types';
import { BoxedType } from '../common/type/boxed-type';
import type { OneOf } from '../common/one-of';
import { ConfigurationChangeListener } from '../common/configuration-change';
import type { Expression, MathJsonSymbol, MathJsonNumberObject } from '../math-json/types';
import type { ValueDefinition, OperatorDefinition, AngularUnit, AssignValue, AssumeResult, BoxedExpression, BoxedRule, BoxedRuleSet, BoxedSubstitution, CanonicalOptions, SymbolDefinitions, Metadata, Rule, Scope, EvalContext, SemiBoxedExpression, ComputeEngine as IComputeEngine, BoxedDefinition, SymbolDefinition } from './global-types';
import type { LatexDictionaryEntry, LatexString, LibraryCategory, ParseLatexOptions } from './latex-syntax/types';
import { type IndexedLatexDictionary } from './latex-syntax/dictionary/definitions';
import type { BigNum, Rational } from './numerics/types';
import { ExactNumericValueData, NumericValue, NumericValueData } from './numeric-value/types';
import './boxed-expression/serialize';
export * from './global-types';
/**
 *
 * To use the Compute Engine, create a `ComputeEngine` instance:
 *
 * ```js
 * ce = new ComputeEngine();
 * ```
 *
 * If using a mathfield, use the default Compute Engine instance from the
 * `MathfieldElement` class:
 *
 * ```js
 * ce = MathfieldElement.computeEngine
 * ```
 *
 * Use the instance to create boxed expressions with `ce.parse()` and `ce.box()`.
 *
 * ```js
 * const ce = new ComputeEngine();
 *
 * let expr = ce.parse("e^{i\\pi}");
 * console.log(expr.N().latex);
 * // ➔ "-1"
 *
 * expr = ce.box(["Expand", ["Power", ["Add", "a", "b"], 2]]);
 * console.log(expr.evaluate().latex);
 * // ➔ "a^2 +  2ab + b^2"
 * ```
 *
 * @category Compute Engine
 *
 */
export declare class ComputeEngine implements IComputeEngine {
    readonly True: BoxedExpression;
    readonly False: BoxedExpression;
    readonly Pi: BoxedExpression;
    readonly E: BoxedExpression;
    readonly Nothing: BoxedExpression;
    readonly Zero: BoxedExpression;
    readonly One: BoxedExpression;
    readonly Half: BoxedExpression;
    readonly NegativeOne: BoxedExpression;
    readonly Two: BoxedExpression;
    readonly I: BoxedExpression;
    readonly NaN: BoxedExpression;
    readonly PositiveInfinity: BoxedExpression;
    readonly NegativeInfinity: BoxedExpression;
    readonly ComplexInfinity: BoxedExpression;
    /** The symbol separating the whole part of a number from its fractional
     *  part in a LaTeX string.
     *
     * Commonly a period (`.`) in English, but a comma (`,`) in many European
     * languages. For the comma, use `"{,}"` so that the spacing is correct.
     *
     * Note that this is a LaTeX string and is used when parsing or serializing
     * LaTeX. MathJSON always uses a period.
     *
     * */
    decimalSeparator: LatexString;
    /** @internal */
    _BIGNUM_NAN: Decimal;
    /** @internal */
    _BIGNUM_ZERO: Decimal;
    /** @internal */
    _BIGNUM_ONE: Decimal;
    /** @internal */
    _BIGNUM_TWO: Decimal;
    /** @internal */
    _BIGNUM_HALF: Decimal;
    /** @internal */
    _BIGNUM_PI: Decimal;
    /** @internal */
    _BIGNUM_NEGATIVE_ONE: Decimal;
    /** @internal */
    private _precision;
    /** @ internal */
    private _angularUnit;
    /** @internal */
    private _tolerance;
    /** @internal */
    private _bignumTolerance;
    private _negBignumTolerance;
    /** @internal */
    private __cache;
    private _configurationChangeTracker;
    /** @internal */
    private _cost?;
    /** @internal */
    private _commonSymbols;
    /** @internal */
    private _commonNumbers;
    /**
     * The stack of evaluation contexts.
     *
     * An **evaluation context** contains bindings of symbols to their
     * values, assumptions, and the matching scope.
     *
     */
    _evalContextStack: EvalContext[];
    /** The current evaluation context */
    get context(): EvalContext;
    get contextStack(): ReadonlyArray<EvalContext>;
    set contextStack(stack: ReadonlyArray<EvalContext>);
    /** @internal */
    get _typeResolver(): TypeResolver;
    /**
     * Declare a new type in the current scope.
     *
     * By default, types are nominal. To declare a structural type, set
     * `alias` to `true`.
     */
    declareType(name: string, type: BoxedType | Type | TypeString, { alias }?: {
        alias?: boolean;
    }): void;
    /**
     * A list of the function calls to the current evaluation context,
     * most recent first.
     */
    get trace(): ReadonlyArray<string>;
    /**
     * The generation is incremented each time the context changes.
     * It is used to invalidate caches.
     * @internal
     */
    _generation: number;
    /** In strict mode (the default) the Compute Engine performs
     * validation of domains and signature and may report errors.
     *
     * These checks may impact performance
     *
     * When strict mode is off, results may be incorrect or generate JavaScript
     * errors if the input is not valid.
     *
     */
    strict: boolean;
    /** Absolute time beyond which evaluation should not proceed.
     * @internal
     */
    deadline?: number;
    /**
     * Return symbol tables suitable for the specified categories, or `"all"`
     * for all categories (`"arithmetic"`, `"algebra"`, etc...).
     *
     * A symbol table defines how to evaluate and manipulate symbols.
     *
     */
    /** @internal */
    private _latexDictionaryInput;
    /** @internal */
    __indexedLatexDictionary: IndexedLatexDictionary;
    /** @internal */
    _bignum: Decimal.Constructor;
    static getStandardLibrary(categories?: LibraryCategory[] | LibraryCategory | 'all'): readonly SymbolDefinitions[];
    /**
     * Return a LaTeX dictionary suitable for the specified category, or `"all"`
     * for all categories (`"arithmetic"`, `"algebra"`, etc...).
     *
     * A LaTeX dictionary is needed to translate between LaTeX and MathJSON.
     *
     * Each entry in the dictionary indicate how a LaTeX token (or string of
     * tokens) should be parsed into a MathJSON expression.
     *
     * For example an entry can define that the `\pi` LaTeX token should map to the
     * symbol `"Pi"`, or that the token `-` should map to the function
     * `["Negate",...]` when in a prefix position and to the function
     * `["Subtract", ...]` when in an infix position.
     *
     * Furthermore, the information in each dictionary entry is used to serialize
     * the LaTeX string corresponding to a MathJSON expression.
     *
     * Use with `ce.latexDictionary` to set the dictionary. You can complement
     * it with your own definitions, for example with:
     *
     * ```ts
     * ce.latexDictionary = [
     *  ...ce.getLatexDictionary("all"),
     *  {
     *    kind: "function",
     *    symbolTrigger: "concat",
     *    parse: "Concatenate"
     *  }
     * ];
     * ```
     */
    static getLatexDictionary(domain?: LibraryCategory | 'all'): readonly Readonly<LatexDictionaryEntry>[];
    /**
     * Construct a new `ComputeEngine` instance.
     *
     * Symbols tables define functions, constants and variables (in `options.ids`).
     * If no table is provided the MathJSON Standard Library is used (`ComputeEngine.getStandardLibrary()`)
     *
     * The LaTeX syntax dictionary is defined in `options.latexDictionary`.
     *
     * The order of the dictionaries matter: the definitions from the later ones
     * override the definitions from earlier ones. The first dictionary should
     * be the `'core'` dictionary which include basic definitions that are used
     * by later dictionaries.
     *
     *
     * @param options.precision Specific how many digits of precision
     * for the numeric calculations. Default is 300.
     *
     * @param options.tolerance If the absolute value of the difference of two
     * numbers is less than `tolerance`, they are considered equal. Used by
     * `chop()` as well.
     */
    constructor(options?: {
        ids?: readonly SymbolDefinitions[];
        precision?: number | 'machine';
        tolerance?: number | 'auto';
    });
    toJSON(): string;
    [Symbol.toStringTag]: string;
    get latexDictionary(): Readonly<LatexDictionaryEntry[]>;
    set latexDictionary(dic: Readonly<LatexDictionaryEntry[]>);
    get _indexedLatexDictionary(): IndexedLatexDictionary;
    /** After the configuration of the engine has changed, clear the caches
     * so that new values can be recalculated.
     *
     * This needs to happen for example when the numeric precision changes.
     *
     * @internal
     */
    _reset(): void;
    /** @internal */
    listenToConfigurationChange(tracker: ConfigurationChangeListener): () => void;
    get precision(): number;
    /** The precision, or number of significant digits, of numeric
     * calculations.
     *
     * To make calculations using more digits, at the cost of expanded memory
     * usage and slower computations, set the `precision` higher.
     *
     * Trigonometric operations are accurate for precision up to 1,000.
     *
     * If the precision is set to `machine`, floating point numbers
     * are represented internally as a 64-bit floating point number (as
     * per IEEE 754-2008), with a 52-bit mantissa, which gives about 15
     * digits of precision.
     *
     * If the precision is set to `auto`, the precision is set to a default value.
     *
     */
    set precision(p: number | 'machine' | 'auto');
    /**
     * The unit used for unitless angles in trigonometric functions.
     *
     * - `rad`: radian, $2\pi$ radians is a full circle
     * - `deg`: degree, 360 degrees is a full circle
     * - `grad`: gradians, 400 gradians is a full circle
     * - `turn`: turn, 1 turn is a full circle
     *
     * Default is `"rad"` (radians).
     */
    get angularUnit(): AngularUnit;
    set angularUnit(u: AngularUnit);
    /** Throw a `CancellationError` when the duration of an evaluation exceeds
     * the time limit.
     *
     * Time in milliseconds, default 2000 ms = 2 seconds.
     *
     */
    get timeLimit(): number;
    set timeLimit(t: number);
    private _timeLimit;
    /** The time after which the time limit has been exceeded */
    _deadline: number | undefined;
    get _timeRemaining(): number;
    /** Throw `CancellationError` `iteration-limit-exceeded` when the iteration limit
     * in a loop is exceeded. Default: no limits.
     *
     * @experimental
     */
    get iterationLimit(): number;
    set iterationLimit(t: number);
    private _iterationLimit;
    /** Signal `recursion-depth-exceeded` when the recursion depth for this
     * scope is exceeded.
     *
     * @experimental
     */
    get recursionLimit(): number;
    set recursionLimit(t: number);
    private _recursionLimit;
    get tolerance(): number;
    /**
     * Values smaller than the tolerance are considered to be zero for the
     * purpose of comparison, i.e. if `|b - a| <= tolerance`, `b` is considered
     * equal to `a`.
     */
    set tolerance(val: number | 'auto');
    /** Replace a number that is close to 0 with the exact integer 0.
     *
     * How close to 0 the number has to be to be considered 0 is determined by {@linkcode tolerance}.
     */
    chop(n: number): number;
    chop(n: Decimal): Decimal | 0;
    chop(n: Complex): Complex | 0;
    /** Create an arbitrary precision number.
     *
     * The return value is an object with methods to perform arithmetic
     * operations:
     * - `toNumber()`: convert to a JavaScript `number` with potential loss of precision
     * - `add()`
     * - `sub()`
     * - `neg()` (unary minus)
     * - `mul()`
     * - `div()`
     * - `pow()`
     * - `sqrt()` (square root)
     * - `cbrt()` (cube root)
     * - `exp()`  (e^x)
     * - `log()`
     * - `ln()` (natural logarithm)
     * - `mod()`
  
     * - `abs()`
     * - `ceil()`
     * - `floor()`
     * - `round()`
  
     * - `equals()`
     * - `gt()`
     * - `gte()`
     * - `lt()`
     * - `lte()`
     *
     * - `cos()`
     * - `sin()`
     * - `tanh()`
     * - `acos()`
     * - `asin()`
     * - `atan()`
     * - `cosh()`
     * - `sinh()`
     * - `acosh()`
     * - `asinh()`
     * - `atanh()`
     *
     * - `isFinite()`
     * - `isInteger()`
     * - `isNaN()`
     * - `isNegative()`
     * - `isPositive()`
     * - `isZero()`
     * - `sign()` (1, 0 or -1)
     *
     */
    bignum(a: Decimal.Value | bigint): Decimal;
    /** Create a complex number.
     * The return value is an object with methods to perform arithmetic
     * operations:
     * - `re` (real part, as a JavaScript `number`)
     * - `im` (imaginary part, as a JavaScript `number`)
     * - `add()`
     * - `sub()`
     * - `neg()` (unary minus)
     * - `mul()`
     * - `div()`
     * - `pow()`
     * - `sqrt()` (square root)
     * - `exp()`  (e^x)
     * - `log()`
     * - `ln()` (natural logarithm)
     * - `mod()`
  
     * - `abs()`
     * - `ceil()`
     * - `floor()`
     * - `round()`
  
     * - `arg()` the angle of the complex number
     * - `inverse()` the inverse of the complex number 1/z
     * - `conjugate()` the conjugate of the complex number
  
     * - `equals()`
     *
     * - `cos()`
     * - `sin()`
     * - `tanh()`
     * - `acos()`
     * - `asin()`
     * - `atan()`
     * - `cosh()`
     * - `sinh()`
     * - `acosh()`
     * - `asinh()`
     * - `atanh()`
     *
     * - `isFinite()`
     * - `isNaN()`
     * - `isZero()`
     * - `sign()` (1, 0 or -1)
     */
    complex(a: number | Decimal | Complex, b?: number | Decimal): Complex;
    /**
     *
     * Create a Numeric Value.
     *
     * @internal
     */
    _numericValue(value: number | bigint | Complex | OneOf<[BigNum | NumericValueData | ExactNumericValueData]>): NumericValue;
    /**
     * The cost function is used to determine the "cost" of an expression. For example, when simplifying an expression, the simplification that results in the lowest cost is chosen.
     */
    get costFunction(): (expr: BoxedExpression) => number;
    set costFunction(fn: ((expr: BoxedExpression) => number) | undefined);
    /**
     * Return definition matching the symbol, starting with the current
     * lexical scope and going up the scope chain.
     */
    lookupDefinition(id: MathJsonSymbol): undefined | BoxedDefinition;
    /**
     * Associate a new definition to a symbol in the current context.
     *
     * For internal use. Use `ce.declare()` instead.
     *
     * @internal
     */
    _declareSymbolValue(name: MathJsonSymbol, def: Partial<ValueDefinition>, scope?: Scope): BoxedDefinition;
    /**
     * Associate a new OperatorDefinition to a function in the current context.
     *
     * For internal use. Use `ce.declare()` instead.
     *
     * @internal
     */
    _declareSymbolOperator(name: string, def: OperatorDefinition, scope?: Scope): BoxedDefinition;
    /**
     *
     * Create a new lexical scope and matching evaluation context and add it
     * to the evaluation context stack.
     *
     */
    pushScope(scope?: Scope, name?: string): void;
    /**
     * Remove the most recent scope from the scope stack.
     */
    popScope(): void;
    /** @internal */
    _pushEvalContext(scope: Scope, name?: string): void;
    /** @internal */
    _popEvalContext(): void;
    /** @internal */
    _inScope<T>(scope: Scope | undefined, f: () => T): T;
    /** @internal */
    _printStack(options?: {
        details?: boolean;
        maxDepth?: number;
    }): void;
    /**
     * Use `ce.box(name)` instead
     * @internal */
    _getSymbolValue(id: MathJsonSymbol): BoxedExpression | undefined;
    /**
     * For internal use. Use `ce.assign(name, value)` instead.
     * @internal
     */
    _setSymbolValue(id: MathJsonSymbol, value: BoxedExpression | boolean | number | undefined): void;
    /**
     * Declare a symbol in the current lexical scope: specify their type and
     * other attributes, including optionally a value.
     *
     * Once the type of a symbol has been declared, it cannot be changed.
     * The type information is used to calculate the canonical form of
     * expressions and ensure they are valid. If the type could be changed
     * after the fact, previously valid expressions could become invalid.
     *
     * Set the type to `unknown` if the type is not known yet: it will be
     * inferred based on usage. Use `any` for a very generic type.
     *
     *
     */
    declare(id: string, def: Type | TypeString | Partial<SymbolDefinition>, scope?: Scope): IComputeEngine;
    declare(symbols: {
        [id: string]: Type | TypeString | Partial<SymbolDefinition>;
    }): IComputeEngine;
    /**
     * Return an evaluation context in which the symbol is defined.
     */
    lookupContext(id: MathJsonSymbol): EvalContext | undefined;
    /**  Find the context in the stack frame, and set the stack frame to
     * it. This is used to evaluate expressions in the context of
     * a different scope.
     */
    _swapContext(context: EvalContext): void;
    /**
     * Assign a value to a symbol in the current scope.
     * Use `undefined` to reset the symbol to no value.
     *
     * The symbol should be a valid MathJSON symbol not a LaTeX string.
     *
     * If the symbol was not previously declared, it will be declared as a
     * symbol of a type inferred from its value.
     *
     * To more precisely define the type of the symbol, use `ce.declare()`
     * instead, which allows you to specify the type, value and other
     * attributes of the symbol.
     */
    assign(id: string, value: AssignValue): IComputeEngine;
    assign(ids: {
        [id: string]: AssignValue;
    }): IComputeEngine;
    /**
     * Return false if the execution should stop.
     *
     * This can occur if:
     * - an error has been signaled
     * - the time limit or memory limit has been exceeded
     *
     * @internal
     */
    _shouldContinueExecution(): boolean;
    /** @internal */
    _checkContinueExecution(): void;
    /** @internal */
    _cache<T>(cacheName: string, build: () => T, purge?: (t: T) => T | undefined): T;
    /** Return a boxed expression from a number, string or semiboxed expression.
     * Calls `ce.function()`, `ce.number()` or `ce.symbol()` as appropriate.
     */
    box(expr: NumericValue | SemiBoxedExpression, options?: {
        canonical?: CanonicalOptions;
        structural?: boolean;
        scope?: Scope | undefined;
    }): BoxedExpression;
    function(name: string, ops: ReadonlyArray<BoxedExpression> | ReadonlyArray<Expression>, options?: {
        metadata?: Metadata;
        canonical?: CanonicalOptions;
        structural?: boolean;
        scope?: Scope | undefined;
    }): BoxedExpression;
    /**
     *
     * Shortcut for `this.box(["Error",...])`.
     *
     * The result is canonical.
     */
    error(message: string | string[], where?: string): BoxedExpression;
    typeError(expected: Type, actual: undefined | Type | BoxedType, where?: string): BoxedExpression;
    /**
     * Add a `["Hold"]` wrapper to `expr`.
     */
    hold(expr: SemiBoxedExpression): BoxedExpression;
    /** Shortcut for `this.box(["Tuple", ...])`
     *
     * The result is canonical.
     */
    tuple(...elements: ReadonlyArray<number>): BoxedExpression;
    tuple(...elements: ReadonlyArray<BoxedExpression>): BoxedExpression;
    type(type: Type | TypeString | BoxedType): BoxedType;
    string(s: string, metadata?: Metadata): BoxedExpression;
    /** Create a boxed symbol */
    symbol(name: string, options?: {
        canonical?: CanonicalOptions;
    }): BoxedExpression;
    /**
     * This function tries to avoid creating a boxed number if `num` corresponds
     * to a common value for which we have a shared instance (-1, 0, NaN, etc...)
     */
    number(value: number | bigint | string | NumericValue | MathJsonNumberObject | Decimal | Complex | Rational, options?: {
        metadata: Metadata;
        canonical: CanonicalOptions;
    }): BoxedExpression;
    rules(rules: Rule | ReadonlyArray<Rule | BoxedRule> | BoxedRuleSet | undefined | null, options?: {
        canonical?: boolean;
    }): BoxedRuleSet;
    /**
     * Return a set of built-in rules.
     */
    getRuleSet(id?: string): BoxedRuleSet | undefined;
    /**
     * Return a function expression, but the caller is responsible for making
     * sure that the arguments are canonical.
     *
     * Unlike `ce.function()`, the operator of the result is the name argument.
     * Calling this function directly is potentially unsafe, as it bypasses
     * the canonicalization of the arguments.
     *
     * For example:
     *
     * - `ce._fn('Multiply', [1, 'x'])` returns `['Multiply', 1, 'x']` as a
     *   canonical expression, even though it doesn't follow the canonical form
     * - `ce.function('Multiply', [1, 'x']` returns `'x'` which is the correct
     *    canonical form
     *
     * @internal */
    _fn(name: MathJsonSymbol, ops: ReadonlyArray<BoxedExpression>, options?: {
        metadata?: Metadata;
        canonical?: boolean;
        scope?: Scope;
    }): BoxedExpression;
    /**
     * Parse a string of LaTeX and return a corresponding `BoxedExpression`.
     *
     * If the `canonical` option is set to `true`, the result will be canonical
     *
     */
    parse(latex: null, options?: Partial<ParseLatexOptions> & {
        canonical?: CanonicalOptions;
    }): null;
    parse(latex: LatexString, options?: Partial<ParseLatexOptions> & {
        canonical?: CanonicalOptions;
    }): BoxedExpression;
    /**
     * Return a list of all the assumptions that match a pattern.
     *
     * ```js
     *  ce.assume(['Element', 'x', 'PositiveIntegers');
     *  ce.ask(['Greater', 'x', '_val'])
     *  //  -> [{'val': 0}]
     * ```
     */
    ask(pattern: BoxedExpression): BoxedSubstitution[];
    /**
     * Answer a query based on the current assumptions.
     *
     */
    verify(_query: BoxedExpression): boolean;
    /**
     * Add an assumption.
     *
     * Note that the assumption is put into canonical form before being added.
     *
     * Returns:
     * - `contradiction` if the new assumption is incompatible with previous
     * ones.
     * - `tautology` if the new assumption is redundant with previous ones.
     * - `ok` if the assumption was successfully added to the assumption set.
     *
     *
     */
    assume(predicate: BoxedExpression): AssumeResult;
    /**
     * Remove all assumptions about one or more symbols.
     *
     * `ce.forget()` will remove all assumptions.
     *
     * Note that assumptions are scoped, so when exiting the current lexical
     * scope, the previous assumptions will be restored.
     *
     * */
    forget(symbol: undefined | MathJsonSymbol | MathJsonSymbol[]): void;
}
