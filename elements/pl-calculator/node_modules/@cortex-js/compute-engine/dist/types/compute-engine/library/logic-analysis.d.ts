/* 0.35.2 */import type { BoxedExpression, ComputeEngine } from '../global-types';
/**
 * Quantifier domain helpers and boolean analysis functions.
 * Extracted from logic.ts for better code organization.
 */
/**
 * Result of extracting a finite domain from an Element expression.
 * - `status: 'success'` - Domain was successfully extracted
 * - `status: 'non-enumerable'` - Domain exists but cannot be enumerated (e.g., infinite set, unknown symbol)
 * - `status: 'error'` - Invalid Element expression (missing variable, malformed domain)
 */
export type ExtractDomainResult = {
    status: 'success';
    variable: string;
    values: BoxedExpression[];
} | {
    status: 'non-enumerable';
    variable: string;
    domain: BoxedExpression;
    reason: string;
} | {
    status: 'error';
    reason: string;
};
/**
 * Extract the finite domain from a quantifier's condition.
 * Supports:
 * - ["Element", "x", ["Set", 1, 2, 3]] → [1, 2, 3]
 * - ["Element", "x", ["Range", 1, 5]] → [1, 2, 3, 4, 5]
 * - ["Element", "x", ["Interval", 1, 5]] → [1, 2, 3, 4, 5] (integers only)
 * - ["Element", "x", ["Set", 1, 2, 3], condition] → filtered values (EL-3)
 * Returns detailed result indicating success, non-enumerable domain, or error.
 */
export declare function extractFiniteDomainWithReason(condition: BoxedExpression, ce: ComputeEngine): ExtractDomainResult;
/**
 * Extract the finite domain from a quantifier's condition.
 * Supports:
 * - ["Element", "x", ["Set", 1, 2, 3]] → [1, 2, 3]
 * - ["Element", "x", ["Range", 1, 5]] → [1, 2, 3, 4, 5]
 * - ["Element", "x", ["Interval", 1, 5]] → [1, 2, 3, 4, 5] (integers only)
 * Returns null if the domain is not finite or not recognized.
 * @deprecated Use extractFiniteDomainWithReason for better error handling
 */
export declare function extractFiniteDomain(condition: BoxedExpression, ce: ComputeEngine): {
    variable: string;
    values: BoxedExpression[];
} | null;
/**
 * Check if an expression contains a reference to a specific variable.
 */
export declare function bodyContainsVariable(expr: BoxedExpression, variable: string): boolean;
/**
 * For nested quantifiers like ∀x∈S. ∀y∈T. P(x,y), collect the inner domains.
 * Returns an array of {variable, values} for nested ForAll/Exists with finite domains.
 */
export declare function collectNestedDomains(body: BoxedExpression, ce: ComputeEngine): {
    variable: string;
    values: BoxedExpression[];
}[];
/**
 * Get the innermost body of nested quantifiers.
 */
export declare function getInnermostBody(body: BoxedExpression): BoxedExpression;
/**
 * Evaluate ForAll over a Cartesian product of domains.
 * Returns True if the predicate holds for all combinations.
 */
export declare function evaluateForAllCartesian(domains: {
    variable: string;
    values: BoxedExpression[];
}[], body: BoxedExpression, ce: ComputeEngine): BoxedExpression | undefined;
/**
 * Evaluate Exists over a Cartesian product of domains.
 * Returns True if the predicate holds for at least one combination.
 */
export declare function evaluateExistsCartesian(domains: {
    variable: string;
    values: BoxedExpression[];
}[], body: BoxedExpression, ce: ComputeEngine): BoxedExpression | undefined;
/**
 * Check if a boolean expression is satisfiable.
 *
 * Returns `True` if there exists an assignment of truth values to variables
 * that makes the expression true, `False` if no such assignment exists.
 *
 * ## Algorithm
 *
 * Uses brute-force enumeration of all possible truth assignments.
 * This has **O(2^n) time complexity** where n is the number of variables.
 *
 * ## Performance Characteristics
 *
 * | Variables | Assignments | Approximate Time |
 * |-----------|-------------|------------------|
 * | 10        | 1,024       | < 1ms            |
 * | 15        | 32,768      | ~10ms            |
 * | 20        | 1,048,576   | ~100ms-1s        |
 * | > 20      | (rejected)  | N/A              |
 *
 * ## Limits
 *
 * - **Maximum 20 variables**: Expressions with more than 20 distinct boolean
 *   variables will return the unevaluated `IsSatisfiable` expression rather
 *   than attempting evaluation (to prevent blocking the thread).
 *
 * ## Future Improvements
 *
 * For better performance on larger expressions, a DPLL-based SAT solver
 * could be implemented. The current brute-force approach is suitable for
 * small expressions typically encountered in educational and verification
 * contexts.
 *
 * @param expr - A boolean expression to check for satisfiability
 * @param ce - The ComputeEngine instance
 * @returns `True` if satisfiable, `False` if unsatisfiable, or the
 *          unevaluated expression if the variable limit is exceeded
 */
export declare function isSatisfiable(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Check if a boolean expression is a tautology.
 *
 * Returns `True` if the expression evaluates to true for all possible
 * assignments of truth values to variables, `False` otherwise.
 *
 * ## Algorithm
 *
 * Uses brute-force enumeration of all possible truth assignments.
 * This has **O(2^n) time complexity** where n is the number of variables.
 *
 * ## Performance Characteristics
 *
 * | Variables | Assignments | Approximate Time |
 * |-----------|-------------|------------------|
 * | 10        | 1,024       | < 1ms            |
 * | 15        | 32,768      | ~10ms            |
 * | 20        | 1,048,576   | ~100ms-1s        |
 * | > 20      | (rejected)  | N/A              |
 *
 * ## Limits
 *
 * - **Maximum 20 variables**: Expressions with more than 20 distinct boolean
 *   variables will return the unevaluated `IsTautology` expression rather
 *   than attempting evaluation (to prevent blocking the thread).
 *
 * ## Future Improvements
 *
 * For better performance on larger expressions, a DPLL-based approach
 * (checking unsatisfiability of the negation) could be implemented.
 *
 * @param expr - A boolean expression to check
 * @param ce - The ComputeEngine instance
 * @returns `True` if a tautology, `False` if not, or the unevaluated
 *          expression if the variable limit is exceeded
 */
export declare function isTautology(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Generate a truth table for a boolean expression.
 *
 * Returns a `List` of `List`s where the first row contains column headers
 * (variable names followed by "Result") and subsequent rows contain the
 * truth values for each assignment.
 *
 * ## Algorithm
 *
 * Generates all 2^n possible truth assignments and evaluates the expression
 * for each. This has **O(2^n) time and space complexity**.
 *
 * ## Performance Characteristics
 *
 * | Variables | Rows Generated | Output Size |
 * |-----------|----------------|-------------|
 * | 5         | 32             | ~1 KB       |
 * | 8         | 256            | ~8 KB       |
 * | 10        | 1,024          | ~32 KB      |
 * | > 10      | (rejected)     | N/A         |
 *
 * ## Limits
 *
 * - **Maximum 10 variables**: Expressions with more than 10 distinct boolean
 *   variables will return the unevaluated `TruthTable` expression. This
 *   stricter limit (compared to `IsSatisfiable`/`IsTautology`) accounts for
 *   the memory required to store all rows.
 *
 * @param expr - A boolean expression to generate a truth table for
 * @param ce - The ComputeEngine instance
 * @returns A `List` of `List`s representing the truth table, or the
 *          unevaluated expression if the variable limit is exceeded
 */
export declare function generateTruthTable(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Find all prime implicants using the Quine-McCluskey algorithm.
 *
 * ## Algorithm
 *
 * 1. Generate minterms from the truth table (assignments where expression is true)
 * 2. Group minterms by number of 1s
 * 3. Combine terms differing in exactly one position, marking combined terms
 * 4. Repeat until no more combinations possible
 * 5. Return terms that were never combined (prime implicants)
 *
 * ## Performance Characteristics
 *
 * | Variables | Max Minterms | Approximate Time |
 * |-----------|--------------|------------------|
 * | 5         | 32           | < 1ms            |
 * | 8         | 256          | ~10ms            |
 * | 10        | 1,024        | ~100ms           |
 * | > 12      | (rejected)   | N/A              |
 *
 * ## Limits
 *
 * - **Maximum 12 variables**: Larger expressions return unevaluated.
 *
 * @param expr - A boolean expression
 * @param ce - The ComputeEngine instance
 * @returns A Set of expressions representing prime implicants
 */
export declare function findPrimeImplicants(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression[] | null;
/**
 * Find all prime implicates using the Quine-McCluskey algorithm.
 *
 * Prime implicates are the dual of prime implicants - they are the minimal
 * clauses in CNF. We find them by finding prime implicants of the negation
 * and then negating the result.
 *
 * @param expr - A boolean expression
 * @param ce - The ComputeEngine instance
 * @returns A Set of expressions representing prime implicates (clauses)
 */
export declare function findPrimeImplicates(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression[] | null;
/**
 * Find a minimal DNF (sum of products) using prime implicants.
 *
 * This uses the Quine-McCluskey algorithm followed by a greedy covering
 * algorithm to select a minimal set of prime implicants.
 *
 * @param expr - A boolean expression
 * @param ce - The ComputeEngine instance
 * @returns The minimal DNF, or null if too many variables
 */
export declare function minimalDNF(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression | null;
/**
 * Find a minimal CNF (product of sums) using prime implicates.
 *
 * @param expr - A boolean expression
 * @param ce - The ComputeEngine instance
 * @returns The minimal CNF, or null if too many variables
 */
export declare function minimalCNF(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression | null;
