/* 0.35.1 */import type { BoxedExpression, ComputeEngine } from '../global-types';
export declare function evaluateAnd(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateOr(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateNot(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateEquivalent(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateImplies(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateXor(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateNand(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
export declare function evaluateNor(args: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | undefined;
/**
 * Convert a boolean expression to Negation Normal Form (NNF).
 * In NNF, negations only appear directly before variables (literals).
 * This is a prerequisite for CNF/DNF conversion.
 */
export declare function toNNF(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Convert a boolean expression to Conjunctive Normal Form (CNF).
 */
export declare function toCNF(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Convert a boolean expression to Disjunctive Normal Form (DNF).
 */
export declare function toDNF(expr: BoxedExpression, ce: ComputeEngine): BoxedExpression;
/**
 * Extract all propositional variables from a boolean expression.
 * Returns a sorted array of unique variable names.
 */
export declare function extractVariables(expr: BoxedExpression): string[];
/**
 * Evaluate a boolean expression with a given truth assignment.
 * Returns True, False, or undefined if the expression cannot be evaluated.
 */
export declare function evaluateWithAssignment(expr: BoxedExpression, assignment: Record<string, boolean>, ce: ComputeEngine): BoxedExpression;
/**
 * Generate all possible truth assignments for a list of variables.
 * Each assignment is a Record mapping variable names to boolean values.
 */
export declare function generateAssignments(variables: string[]): Generator<Record<string, boolean>>;
