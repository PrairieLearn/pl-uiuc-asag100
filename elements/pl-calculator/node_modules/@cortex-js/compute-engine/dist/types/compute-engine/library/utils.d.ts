/* 0.35.2 */import type { BoxedExpression, ComputeEngine, Scope } from '../global-types';
/**
 * EL-4: Convert known infinite integer sets to their equivalent Limits bounds.
 * Returns undefined if the set cannot be converted to a Limits form.
 *
 * Mappings:
 * - NonNegativeIntegers (ℕ₀) → [0, ∞)
 * - PositiveIntegers (ℤ⁺) → [1, ∞)
 * - NegativeIntegers (ℤ⁻) → Not supported (would need negative direction)
 * - Integers (ℤ) → Not supported (bidirectional)
 * - Other sets (Reals, Complexes, etc.) → Not supported (non-integer)
 */
export declare function convertInfiniteSetToLimits(domainSymbol: string): {
    lower: number;
    upper: number;
    isFinite: false;
} | undefined;
export type IndexingSet = {
    index: string | undefined;
    lower: number;
    upper: number;
    isFinite: boolean;
};
/**
 * IndexingSet is an expression describing an index variable
 * and a range of values for that variable.
 *
 * Note that when this function is called the indexing set is assumed to be canonical: 'Hold' has been handled, the indexing set is a tuple, and the bounds are canonical.
 *
 * This can take several valid forms:
 * - a symbol, e.g. `n`, the upper and lower bounds are assumed ot be infinity
 * - a tuple, e.g. `["Pair", "n", 1]` or `["Tuple", "n", 1, 10]` with one
 *   or two bounds
 *
 * The result is a normalized version that includes the index, the lower and
 * upper bounds of the range, and a flag indicating whether the range is finite.
 * @param indexingSet
 * @returns
 */
export declare function normalizeIndexingSet(indexingSet: BoxedExpression): IndexingSet;
export declare function normalizeIndexingSets(ops: ReadonlyArray<BoxedExpression>): IndexingSet[];
export declare function indexingSetCartesianProduct(indexingSets: IndexingSet[]): number[][];
/**
 * Calculates the cartesian product of two arrays.
 * ```ts
 * // Example usage
 * const array1 = [1, 2, 3];
 * const array2 = ['a', 'b', 'c'];
 * const result = cartesianProduct(array1, array2);
 * console.log(result);
 * // Output: [[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'b'], [2, 'c'], [3, 'a'], [3, 'b'], [3, 'c']]
 * ```
 * @param array1 - The first array.
 * @param array2 - The second array.
 * @returns The cartesian product as a 2D array.
 */
export declare function cartesianProduct(array1: number[], array2: number[]): number[][];
/** Given a sequence of arguments, return an array of Limits:
 *
 * - ["Range", 1, 10] -> ["Limits", "Unknown", 1, 10]
 * - 1, 10 -> ["Limits", "Nothing", 1, 10]
 * - [Tuple, "x", 1, 10] -> ["Limits", "x", 1, 10]
 *
 */
export declare function canonicalLimitsSequence(ops: ReadonlyArray<BoxedExpression>, options: {
    engine: ComputeEngine;
}): BoxedExpression[];
export declare function canonicalLimits(ops: ReadonlyArray<BoxedExpression>, { engine: ce }: {
    engine: ComputeEngine;
}): BoxedExpression | null;
/** Return a limit/indexing set in canonical form as a `Limits` expression
 * with:
 * - `index` (a symbol), `Nothing` if none is present
 * - `lower` (a number), `Nothing` if none is present
 * - `upper` (a number), `Nothing` if none is present
 *
 * Or, for Element expressions, preserve them in canonical form.
 *
 * Assume we are in the context of a big operator
 * (i.e. `pushScope()` has been called)
 */
export declare function canonicalIndexingSet(expr: BoxedExpression): BoxedExpression | undefined;
export declare function canonicalBigop(bigOp: string, body: BoxedExpression, indexingSets: BoxedExpression[], scope: Scope | undefined): BoxedExpression | null;
/**
 * A special symbol used to signal that a BigOp could not be evaluated
 * because the domain is non-enumerable (e.g., infinite set, unknown symbol).
 * When this is returned, the Sum/Product should keep the expression symbolic
 * rather than returning NaN.
 */
export declare const NON_ENUMERABLE_DOMAIN: unique symbol;
/**
 * Result type for reduceBigOp that includes reason for failure
 */
export type BigOpResult<T> = {
    status: 'success';
    value: T;
} | {
    status: 'non-enumerable';
    reason: string;
    domain?: BoxedExpression;
} | {
    status: 'error';
    reason: string;
};
/**
 * Process an expression of the form
 * - ['Operator', body, ['Tuple', index1, lower, upper]]
 * - ['Operator', body, ['Tuple', index1, lower, upper], ['Tuple', index2, lower, upper], ...]
 * - ['Operator', body, ['Element', index, collection]]
 * - ['Operator', body]
 * - ['Operator', collection]
 *
 * `fn()` is the processing done on each element
 * Apply the function `fn` to the body of a big operator, according to the
 * indexing sets.
 *
 * Returns either the reduced value, or `typeof NON_ENUMERABLE_DOMAIN` if the
 * domain cannot be enumerated (in which case the expression should remain symbolic).
 */
export declare function reduceBigOp<T>(body: BoxedExpression, indexes: ReadonlyArray<BoxedExpression>, fn: (acc: T, x: BoxedExpression) => T | null, initial: T): Generator<T | typeof NON_ENUMERABLE_DOMAIN | undefined>;
/**
 * Result type for reduceElementIndexingSets to distinguish between
 * successful evaluation, non-enumerable domains (keep symbolic), and errors.
 */
export type ReduceElementResult<T> = {
    status: 'success';
    value: T;
} | {
    status: 'non-enumerable';
    reason: string;
    domain?: BoxedExpression;
} | {
    status: 'error';
    reason: string;
};
