/* 0.35.1 *//**
 * Utilities for declarative sequence definitions.
 *
 * This module provides functions to create subscriptEvaluate handlers
 * from sequence definitions (base cases + recurrence relation).
 */
import type { BoxedExpression, ComputeEngine, SequenceDefinition, SequenceStatus, SequenceInfo } from './global-types';
/**
 * Create a subscriptEvaluate handler from a sequence definition.
 *
 * The handler evaluates expressions like `F_{10}` or `P_{5,2}` by:
 * 1. Checking base cases first (with pattern matching for multi-index)
 * 2. Looking up memoized values
 * 3. Recursively evaluating the recurrence relation
 *
 * Supports both single-index and multi-index sequences:
 * - Single-index: `F_{10}` with subscript as a number
 * - Multi-index: `P_{5,2}` with subscript as `Sequence(5, 2)`
 */
export declare function createSequenceHandler(ce: ComputeEngine, name: string, def: SequenceDefinition): (subscript: BoxedExpression, options: {
    engine: ComputeEngine;
    numericApproximation?: boolean;
}) => BoxedExpression | undefined;
/**
 * Validate a sequence definition.
 */
export declare function validateSequenceDefinition(ce: ComputeEngine, name: string, def: SequenceDefinition): {
    valid: boolean;
    error?: string;
};
/**
 * Add a base case for a single-index sequence definition.
 * e.g., from `L_0 := 1`
 */
export declare function addSequenceBaseCase(ce: ComputeEngine, name: string, index: number, value: BoxedExpression): void;
/**
 * Add a base case for a multi-index sequence definition.
 * e.g., from `P_{0,0} := 1` or `P_{n,0} := 1`
 *
 * @param key - The base case key, e.g., '0,0' for exact or 'n,0' for pattern
 */
export declare function addMultiIndexBaseCase(ce: ComputeEngine, name: string, key: string, value: BoxedExpression): void;
/**
 * Add a recurrence relation for a single-index sequence definition.
 * e.g., from `L_n := L_{n-1} + 1`
 *
 * We store the recurrence as a LaTeX string rather than a BoxedExpression
 * because the expression may have been parsed before the symbol was declared
 * with subscriptEvaluate. Storing as LaTeX allows us to re-parse fresh when
 * creating the handler, ensuring proper binding.
 */
export declare function addSequenceRecurrence(ce: ComputeEngine, name: string, variable: string, expr: BoxedExpression): void;
/**
 * Add a recurrence relation for a multi-index sequence definition.
 * e.g., from `P_{n,k} := P_{n-1,k-1} + P_{n-1,k}`
 *
 * @param variables - The index variable names, e.g., ['n', 'k']
 */
export declare function addMultiIndexRecurrence(ce: ComputeEngine, name: string, variables: string[], expr: BoxedExpression): void;
/**
 * Check if expression contains self-reference to sequence name.
 * e.g., `a_{n-1}` when defining sequence 'a'
 */
export declare function containsSelfReference(expr: BoxedExpression, seqName: string): boolean;
/**
 * Extract the index variable from a subscript expression.
 * e.g., from `n-1` extract 'n', from `2*k` extract 'k'
 */
export declare function extractIndexVariable(subscript: BoxedExpression): string | undefined;
/**
 * Get the status of a sequence definition.
 *
 * Returns information about whether a sequence is complete, pending, or not defined.
 * Supports both single-index and multi-index sequences.
 */
export declare function getSequenceStatus(ce: ComputeEngine, name: string): SequenceStatus;
/**
 * Get information about a defined sequence.
 * Returns `undefined` if the symbol is not a complete sequence.
 * Supports both single-index and multi-index sequences.
 */
export declare function getSequenceInfo(ce: ComputeEngine, name: string): SequenceInfo | undefined;
/**
 * List all defined sequences.
 */
export declare function listSequences(ce: ComputeEngine): string[];
/**
 * Check if a symbol is a defined sequence.
 */
export declare function isSequence(ce: ComputeEngine, name: string): boolean;
/**
 * Clear the memoization cache for a sequence or all sequences.
 */
export declare function clearSequenceCache(ce: ComputeEngine, name?: string): void;
/**
 * Get the memoization cache for a sequence.
 * Returns a copy of the cache Map, or `undefined` if not a sequence or memoization is disabled.
 *
 * For single-index sequences, keys are numbers.
 * For multi-index sequences, keys are comma-separated strings (e.g., '5,2').
 */
export declare function getSequenceCache(ce: ComputeEngine, name: string): Map<number | string, BoxedExpression> | undefined;
/**
 * Generate a list of sequence terms from start to end (inclusive).
 *
 * @param ce - The compute engine
 * @param name - The sequence name
 * @param start - Starting index (inclusive)
 * @param end - Ending index (inclusive)
 * @param step - Step size (default: 1)
 * @returns Array of BoxedExpressions for each term, or undefined if not a sequence
 *
 * @example
 * ```typescript
 * // For Fibonacci sequence F
 * generateSequenceTerms(ce, 'F', 0, 10);
 * // â†’ [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
 * ```
 */
export declare function generateSequenceTerms(ce: ComputeEngine, name: string, start: number, end: number, step?: number): BoxedExpression[] | undefined;
